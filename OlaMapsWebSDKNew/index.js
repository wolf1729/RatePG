(function(){"use strict";try{if(typeof document<"u"){var l=document.createElement("style");l.appendChild(document.createTextNode(`.maplibregl-map{font:12px/20px Helvetica Neue,Arial,Helvetica,sans-serif;overflow:hidden;position:relative;-webkit-tap-highlight-color:rgb(0 0 0/0)}.maplibregl-canvas{left:0;position:absolute;top:0}.maplibregl-map:fullscreen{height:100%;width:100%}.maplibregl-ctrl-group button.maplibregl-ctrl-compass{touch-action:none}.maplibregl-canvas-container.maplibregl-interactive,.maplibregl-ctrl-group button.maplibregl-ctrl-compass{cursor:grab;-webkit-user-select:none;-moz-user-select:none;user-select:none}.maplibregl-canvas-container.maplibregl-interactive.maplibregl-track-pointer{cursor:pointer}.maplibregl-canvas-container.maplibregl-interactive:active,.maplibregl-ctrl-group button.maplibregl-ctrl-compass:active{cursor:grabbing}.maplibregl-canvas-container.maplibregl-touch-zoom-rotate,.maplibregl-canvas-container.maplibregl-touch-zoom-rotate .maplibregl-canvas{touch-action:pan-x pan-y}.maplibregl-canvas-container.maplibregl-touch-drag-pan,.maplibregl-canvas-container.maplibregl-touch-drag-pan .maplibregl-canvas{touch-action:pinch-zoom}.maplibregl-canvas-container.maplibregl-touch-zoom-rotate.maplibregl-touch-drag-pan,.maplibregl-canvas-container.maplibregl-touch-zoom-rotate.maplibregl-touch-drag-pan .maplibregl-canvas{touch-action:none}.maplibregl-canvas-container.maplibregl-touch-drag-pan.maplibregl-cooperative-gestures,.maplibregl-canvas-container.maplibregl-touch-drag-pan.maplibregl-cooperative-gestures .maplibregl-canvas{touch-action:pan-x pan-y}.maplibregl-ctrl-bottom-left,.maplibregl-ctrl-bottom-right,.maplibregl-ctrl-top-left,.maplibregl-ctrl-top-right{pointer-events:none;position:absolute;z-index:2}.maplibregl-ctrl-top-left{left:0;top:0}.maplibregl-ctrl-top-right{right:0;top:0}.maplibregl-ctrl-bottom-left{bottom:0;left:0}.maplibregl-ctrl-bottom-right{bottom:0;right:0}.maplibregl-ctrl{clear:both;pointer-events:auto;transform:translate(0)}.maplibregl-ctrl-top-left .maplibregl-ctrl{float:left;margin:10px 0 0 10px}.maplibregl-ctrl-top-right .maplibregl-ctrl{float:right;margin:10px 10px 0 0}.maplibregl-ctrl-bottom-left .maplibregl-ctrl{float:left;margin:0 0 10px 10px}.maplibregl-ctrl-bottom-right .maplibregl-ctrl{float:right;margin:0 10px 10px 0}.maplibregl-ctrl-group{background:#fff;border-radius:4px}.maplibregl-ctrl-group:not(:empty){box-shadow:0 0 0 2px #0000001a}@media (forced-colors:active){.maplibregl-ctrl-group:not(:empty){box-shadow:0 0 0 2px ButtonText}}.maplibregl-ctrl-group button{background-color:transparent;border:0;box-sizing:border-box;cursor:pointer;display:block;height:29px;outline:none;padding:0;width:29px}.maplibregl-ctrl-group button+button{border-top:1px solid #ddd}.maplibregl-ctrl button .maplibregl-ctrl-icon{background-position:50%;background-repeat:no-repeat;display:block;height:100%;width:100%}@media (forced-colors:active){.maplibregl-ctrl-icon{background-color:transparent}.maplibregl-ctrl-group button+button{border-top:1px solid ButtonText}}.maplibregl-ctrl button::-moz-focus-inner{border:0;padding:0}.maplibregl-ctrl-attrib-button:focus,.maplibregl-ctrl-group button:focus{box-shadow:0 0 2px 2px #0096ff}.maplibregl-ctrl button:disabled{cursor:not-allowed}.maplibregl-ctrl button:disabled .maplibregl-ctrl-icon{opacity:.25}.maplibregl-ctrl button:not(:disabled):hover{background-color:#0000000d}.maplibregl-ctrl-group button:focus:focus-visible{box-shadow:0 0 2px 2px #0096ff}.maplibregl-ctrl-group button:focus:not(:focus-visible){box-shadow:none}.maplibregl-ctrl-group button:focus:first-child{border-radius:4px 4px 0 0}.maplibregl-ctrl-group button:focus:last-child{border-radius:0 0 4px 4px}.maplibregl-ctrl-group button:focus:only-child{border-radius:inherit}.maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5'/%3E%3C/svg%3E")}@media (forced-colors:active){.maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5'/%3E%3C/svg%3E")}}@media (forced-colors:active) and (prefers-color-scheme:light){.maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5'/%3E%3C/svg%3E")}}.maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1z'/%3E%3C/svg%3E")}@media (forced-colors:active){.maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1z'/%3E%3C/svg%3E")}}@media (forced-colors:active) and (prefers-color-scheme:light){.maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1z'/%3E%3C/svg%3E")}}.maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='m10.5 14 4-8 4 8z'/%3E%3Cpath fill='%23ccc' d='m10.5 16 4 8 4-8z'/%3E%3C/svg%3E")}@media (forced-colors:active){.maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='m10.5 14 4-8 4 8z'/%3E%3Cpath fill='%23ccc' d='m10.5 16 4 8 4-8z'/%3E%3C/svg%3E")}}@media (forced-colors:active) and (prefers-color-scheme:light){.maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='m10.5 14 4-8 4 8z'/%3E%3Cpath fill='%23ccc' d='m10.5 16 4 8 4-8z'/%3E%3C/svg%3E")}}.maplibregl-ctrl button.maplibregl-ctrl-terrain .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' fill='%23333' viewBox='0 0 22 22'%3E%3Cpath d='m1.754 13.406 4.453-4.851 3.09 3.09 3.281 3.277.969-.969-3.309-3.312 3.844-4.121 6.148 6.886h1.082v-.855l-7.207-8.07-4.84 5.187L6.169 6.57l-5.48 5.965v.871ZM.688 16.844h20.625v1.375H.688Zm0 0'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-terrain-enabled .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' fill='%2333b5e5' viewBox='0 0 22 22'%3E%3Cpath d='m1.754 13.406 4.453-4.851 3.09 3.09 3.281 3.277.969-.969-3.309-3.312 3.844-4.121 6.148 6.886h1.082v-.855l-7.207-8.07-4.84 5.187L6.169 6.57l-5.48 5.965v.871ZM.688 16.844h20.625v1.375H.688Zm0 0'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23aaa' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath fill='red' d='m14 5 1 1-9 9-1-1z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active-error .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e58978' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background-error .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e54e33' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-waiting .maplibregl-ctrl-icon{animation:maplibregl-spin 2s linear infinite}@media (forced-colors:active){.maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23999' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath fill='red' d='m14 5 1 1-9 9-1-1z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active-error .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e58978' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background-error .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e54e33' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3C/svg%3E")}}@media (forced-colors:active) and (prefers-color-scheme:light){.maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23666' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath fill='red' d='m14 5 1 1-9 9-1-1z'/%3E%3C/svg%3E")}}@keyframes maplibregl-spin{0%{transform:rotate(0)}to{transform:rotate(1turn)}}a.maplibregl-ctrl-logo{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='88' height='23' fill='none'%3E%3Cpath fill='%23000' fill-opacity='.4' fill-rule='evenodd' d='M17.408 16.796h-1.827l2.501-12.095h.198l3.324 6.533.988 2.19.988-2.19 3.258-6.533h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.929 5.644h-.098l-2.914-5.644-.757-1.71-.345 1.71zm1.958-3.42-.726 3.663a1.255 1.255 0 0 1-1.232 1.011h-1.827a1.255 1.255 0 0 1-1.229-1.509l2.501-12.095a1.255 1.255 0 0 1 1.23-1.001h.197a1.25 1.25 0 0 1 1.12.685l3.19 6.273 3.125-6.263a1.25 1.25 0 0 1 1.123-.695h.181a1.255 1.255 0 0 1 1.227.991l1.443 6.71a5 5 0 0 1 .314-.787l.009-.016a4.6 4.6 0 0 1 1.777-1.887c.782-.46 1.668-.667 2.611-.667a4.6 4.6 0 0 1 1.7.32l.306.134c.21-.16.474-.256.759-.256h1.694a1.255 1.255 0 0 1 1.212.925 1.255 1.255 0 0 1 1.212-.925h1.711c.284 0 .545.094.755.252.613-.3 1.312-.45 2.075-.45 1.356 0 2.557.445 3.482 1.4q.47.48.763 1.064V4.701a1.255 1.255 0 0 1 1.255-1.255h1.86A1.255 1.255 0 0 1 54.44 4.7v9.194h2.217c.19 0 .37.043.532.118v-4.77c0-.356.147-.678.385-.906a2.42 2.42 0 0 1-.682-1.71c0-.665.267-1.253.735-1.7a2.45 2.45 0 0 1 1.722-.674 2.43 2.43 0 0 1 1.705.675q.318.302.504.683V4.7a1.255 1.255 0 0 1 1.255-1.255h1.744A1.255 1.255 0 0 1 65.812 4.7v3.335a4.8 4.8 0 0 1 1.526-.246c.938 0 1.817.214 2.59.69a4.47 4.47 0 0 1 1.67 1.743v-.98a1.255 1.255 0 0 1 1.256-1.256h1.777c.233 0 .451.064.639.174a3.4 3.4 0 0 1 1.567-.372c.346 0 .861.02 1.285.232a1.25 1.25 0 0 1 .689 1.004 4.7 4.7 0 0 1 .853-.588c.795-.44 1.675-.647 2.61-.647 1.385 0 2.65.39 3.525 1.396.836.938 1.168 2.173 1.168 3.528q-.001.515-.056 1.051a1.255 1.255 0 0 1-.947 1.09l.408.952a1.255 1.255 0 0 1-.477 1.552c-.418.268-.92.463-1.458.612-.613.171-1.304.244-2.049.244-1.06 0-2.043-.207-2.886-.698l-.015-.008c-.798-.48-1.419-1.135-1.818-1.963l-.004-.008a5.8 5.8 0 0 1-.548-2.512q0-.429.053-.843a1.3 1.3 0 0 1-.333-.086l-.166-.004c-.223 0-.426.062-.643.228-.03.024-.142.139-.142.59v3.883a1.255 1.255 0 0 1-1.256 1.256h-1.777a1.255 1.255 0 0 1-1.256-1.256V15.69l-.032.057a4.8 4.8 0 0 1-1.86 1.833 5.04 5.04 0 0 1-2.484.634 4.5 4.5 0 0 1-1.935-.424 1.25 1.25 0 0 1-.764.258h-1.71a1.255 1.255 0 0 1-1.256-1.255V7.687a2.4 2.4 0 0 1-.428.625c.253.23.412.561.412.93v7.553a1.255 1.255 0 0 1-1.256 1.255h-1.843a1.25 1.25 0 0 1-.894-.373c-.228.23-.544.373-.894.373H51.32a1.255 1.255 0 0 1-1.256-1.255v-1.251l-.061.117a4.7 4.7 0 0 1-1.782 1.884 4.77 4.77 0 0 1-2.485.67 5.6 5.6 0 0 1-1.485-.188l.009 2.764a1.255 1.255 0 0 1-1.255 1.259h-1.729a1.255 1.255 0 0 1-1.255-1.255v-3.537a1.255 1.255 0 0 1-1.167.793h-1.679a1.25 1.25 0 0 1-.77-.263 4.5 4.5 0 0 1-1.945.429c-.885 0-1.724-.21-2.495-.632l-.017-.01a5 5 0 0 1-1.081-.836 1.255 1.255 0 0 1-1.254 1.312h-1.81a1.255 1.255 0 0 1-1.228-.99l-.782-3.625-2.044 3.939a1.25 1.25 0 0 1-1.115.676h-.098a1.25 1.25 0 0 1-1.116-.68l-2.061-3.994zM35.92 16.63l.207-.114.223-.15q.493-.356.735-.785l.061-.118.033 1.332h1.678V9.242h-1.694l-.033 1.267q-.133-.329-.526-.658l-.032-.028a3.2 3.2 0 0 0-.668-.428l-.27-.12a3.3 3.3 0 0 0-1.235-.23q-1.136-.001-1.974.493a3.36 3.36 0 0 0-1.3 1.382q-.445.89-.444 2.074 0 1.2.51 2.107a3.8 3.8 0 0 0 1.382 1.381 3.9 3.9 0 0 0 1.893.477q.795 0 1.455-.33zm-2.789-5.38q-.576.675-.575 1.762 0 1.102.559 1.794.576.675 1.645.675a2.25 2.25 0 0 0 .934-.19 2.2 2.2 0 0 0 .468-.29l.178-.161a2.2 2.2 0 0 0 .397-.561q.244-.5.244-1.15v-.115q0-.708-.296-1.267l-.043-.077a2.2 2.2 0 0 0-.633-.709l-.13-.086-.047-.028a2.1 2.1 0 0 0-1.073-.285q-1.052 0-1.629.692zm2.316 2.706c.163-.17.28-.407.28-.83v-.114c0-.292-.06-.508-.15-.68a.96.96 0 0 0-.353-.389.85.85 0 0 0-.464-.127c-.4 0-.56.114-.664.239l-.01.012c-.148.174-.275.45-.275.945 0 .506.122.801.27.99.097.11.266.224.68.224.303 0 .504-.09.687-.269zm7.545 1.705a2.6 2.6 0 0 0 .331.423q.319.33.755.548l.173.074q.65.255 1.49.255 1.02 0 1.844-.493a3.45 3.45 0 0 0 1.316-1.4q.493-.904.493-2.089 0-1.909-.988-2.913-.988-1.02-2.584-1.02-.898 0-1.575.347a3 3 0 0 0-.415.262l-.199.166a3.4 3.4 0 0 0-.64.82V9.242h-1.712v11.553h1.729l-.017-5.134zm.53-1.138q.206.29.48.5l.155.11.053.034q.51.296 1.119.297 1.07 0 1.645-.675.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.435 0-.835.16a2 2 0 0 0-.284.136 2 2 0 0 0-.363.254 2.2 2.2 0 0 0-.46.569l-.082.162a2.6 2.6 0 0 0-.213 1.072v.115q0 .707.296 1.267l.135.211zm.964-.818a1.1 1.1 0 0 0 .367.385.94.94 0 0 0 .476.118c.423 0 .59-.117.687-.23.159-.194.28-.478.28-.95 0-.53-.133-.8-.266-.952l-.021-.025c-.078-.094-.231-.221-.68-.221a1 1 0 0 0-.503.135l-.012.007a.86.86 0 0 0-.335.343c-.073.133-.132.324-.132.614v.115a1.4 1.4 0 0 0 .14.66zm15.7-6.222q.347-.346.346-.856a1.05 1.05 0 0 0-.345-.79 1.18 1.18 0 0 0-.84-.329q-.51 0-.855.33a1.05 1.05 0 0 0-.346.79q0 .51.346.855.345.346.856.346.51 0 .839-.346zm4.337 9.314.033-1.332q.191.403.59.747l.098.081a4 4 0 0 0 .316.224l.223.122a3.2 3.2 0 0 0 1.44.322 3.8 3.8 0 0 0 1.875-.477 3.5 3.5 0 0 0 1.382-1.366q.527-.89.526-2.09 0-1.184-.444-2.073a3.24 3.24 0 0 0-1.283-1.399q-.823-.51-1.942-.51a3.5 3.5 0 0 0-1.527.344l-.086.043-.165.09a3 3 0 0 0-.33.214q-.432.315-.656.707a2 2 0 0 0-.099.198l.082-1.283V4.701h-1.744v12.095zm.473-2.509a2.5 2.5 0 0 0 .566.7q.117.098.245.18l.144.08a2.1 2.1 0 0 0 .975.232q1.07 0 1.645-.675.576-.69.576-1.778 0-1.102-.576-1.777-.56-.691-1.645-.692a2.2 2.2 0 0 0-1.015.235q-.22.113-.415.282l-.15.142a2.1 2.1 0 0 0-.42.594q-.223.479-.223 1.1v.115q0 .705.293 1.26zm2.616-.293c.157-.191.28-.479.28-.967 0-.51-.13-.79-.276-.961l-.021-.026c-.082-.1-.232-.225-.67-.225a.87.87 0 0 0-.681.279l-.012.011c-.154.155-.274.38-.274.807v.115c0 .285.057.499.144.669a1.1 1.1 0 0 0 .367.405c.137.082.28.123.455.123.423 0 .59-.118.686-.23zm8.266-3.013q.345-.13.724-.14l.069-.002q.493 0 .642.099l.247-1.794q-.196-.099-.717-.099a2.3 2.3 0 0 0-.545.063 2 2 0 0 0-.411.148 2.2 2.2 0 0 0-.4.249 2.5 2.5 0 0 0-.485.499 2.7 2.7 0 0 0-.32.581l-.05.137v-1.48h-1.778v7.553h1.777v-3.884q0-.546.159-.943a1.5 1.5 0 0 1 .466-.636 2.5 2.5 0 0 1 .399-.253 2 2 0 0 1 .224-.099zm9.784 2.656.05-.922q0-1.743-.856-2.698-.838-.97-2.584-.97-1.119-.001-2.007.493a3.46 3.46 0 0 0-1.4 1.382q-.493.906-.493 2.106 0 1.07.428 1.975.428.89 1.332 1.432.906.526 2.255.526.973 0 1.668-.185l.044-.012.135-.04q.613-.184.984-.421l-.542-1.267q-.3.162-.642.274l-.297.087q-.51.131-1.3.131-.954 0-1.497-.444a1.6 1.6 0 0 1-.192-.193q-.366-.44-.512-1.234l-.004-.021zm-5.427-1.256-.003.022h3.752v-.138q-.011-.727-.288-1.118a1 1 0 0 0-.156-.176q-.46-.428-1.316-.428-.986 0-1.494.604-.379.45-.494 1.234zm-27.053 2.77V4.7h-1.86v12.095h5.333V15.15zm7.103-5.908v7.553h-1.843V9.242h1.843z'/%3E%3Cpath fill='%23fff' d='m19.63 11.151-.757-1.71-.345 1.71-1.12 5.644h-1.827L18.083 4.7h.197l3.325 6.533.988 2.19.988-2.19L26.839 4.7h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.93 5.644h-.098l-2.913-5.644zm14.836 5.81q-1.02 0-1.893-.478a3.8 3.8 0 0 1-1.381-1.382q-.51-.906-.51-2.106 0-1.185.444-2.074a3.36 3.36 0 0 1 1.3-1.382q.839-.494 1.974-.494a3.3 3.3 0 0 1 1.234.231 3.3 3.3 0 0 1 .97.575q.396.33.527.659l.033-1.267h1.694v7.553H37.18l-.033-1.332q-.279.593-1.02 1.053a3.17 3.17 0 0 1-1.662.444zm.296-1.482q.938 0 1.58-.642.642-.66.642-1.711v-.115q0-.708-.296-1.267a2.2 2.2 0 0 0-.807-.872 2.1 2.1 0 0 0-1.119-.313q-1.053 0-1.629.692-.575.675-.575 1.76 0 1.103.559 1.795.577.675 1.645.675zm6.521-6.237h1.711v1.4q.906-1.597 2.83-1.597 1.596 0 2.584 1.02.988 1.005.988 2.914 0 1.185-.493 2.09a3.46 3.46 0 0 1-1.316 1.399 3.5 3.5 0 0 1-1.844.493q-.954 0-1.662-.329a2.67 2.67 0 0 1-1.086-.97l.017 5.134h-1.728zm4.048 6.22q1.07 0 1.645-.674.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.592 0-1.12.296-.51.28-.822.823-.296.527-.296 1.234v.115q0 .708.296 1.267.313.543.823.855.51.296 1.119.297z'/%3E%3Cpath fill='%23e1e3e9' d='M51.325 4.7h1.86v10.45h3.473v1.646h-5.333zm7.12 4.542h1.843v7.553h-1.843zm.905-1.415a1.16 1.16 0 0 1-.856-.346 1.17 1.17 0 0 1-.346-.856 1.05 1.05 0 0 1 .346-.79q.346-.329.856-.329.494 0 .839.33a1.05 1.05 0 0 1 .345.79 1.16 1.16 0 0 1-.345.855q-.33.346-.84.346zm7.875 9.133a3.17 3.17 0 0 1-1.662-.444q-.723-.46-1.004-1.053l-.033 1.332h-1.71V4.701h1.743v4.657l-.082 1.283q.279-.658 1.086-1.119a3.5 3.5 0 0 1 1.778-.477q1.119 0 1.942.51a3.24 3.24 0 0 1 1.283 1.4q.445.888.444 2.072 0 1.201-.526 2.09a3.5 3.5 0 0 1-1.382 1.366 3.8 3.8 0 0 1-1.876.477zm-.296-1.481q1.069 0 1.645-.675.577-.69.577-1.778 0-1.102-.577-1.776-.56-.691-1.645-.692a2.12 2.12 0 0 0-1.58.659q-.642.641-.642 1.694v.115q0 .71.296 1.267a2.4 2.4 0 0 0 .807.872 2.1 2.1 0 0 0 1.119.313zm5.927-6.237h1.777v1.481q.263-.757.856-1.217a2.14 2.14 0 0 1 1.349-.46q.527 0 .724.098l-.247 1.794q-.149-.099-.642-.099-.774 0-1.416.494-.626.493-.626 1.58v3.883h-1.777V9.242zm9.534 7.718q-1.35 0-2.255-.526-.904-.543-1.332-1.432a4.6 4.6 0 0 1-.428-1.975q0-1.2.493-2.106a3.46 3.46 0 0 1 1.4-1.382q.889-.495 2.007-.494 1.744 0 2.584.97.855.956.856 2.7 0 .444-.05.92h-5.43q.18 1.005.708 1.45.542.443 1.497.443.79 0 1.3-.131a4 4 0 0 0 .938-.362l.542 1.267q-.411.263-1.119.46-.708.198-1.711.197zm1.596-4.558q.016-1.02-.444-1.432-.46-.428-1.316-.428-1.728 0-1.991 1.86z'/%3E%3Cpath d='M5.074 15.948a.484.657 0 0 0-.486.659v1.84a.484.657 0 0 0 .486.659h4.101a.484.657 0 0 0 .486-.659v-1.84a.484.657 0 0 0-.486-.659zm3.56 1.16H5.617v.838h3.017z' style='fill:%23fff;fill-rule:evenodd;stroke-width:1.03600001'/%3E%3Cg style='stroke-width:1.12603545'%3E%3Cpath d='M-9.408-1.416c-3.833-.025-7.056 2.912-7.08 6.615-.02 3.08 1.653 4.832 3.107 6.268.903.892 1.721 1.74 2.32 2.902l-.525-.004c-.543-.003-.992.304-1.24.639a1.87 1.87 0 0 0-.362 1.121l-.011 1.877c-.003.402.104.787.347 1.125.244.338.688.653 1.23.656l4.142.028c.542.003.99-.306 1.238-.641a1.87 1.87 0 0 0 .363-1.121l.012-1.875a1.87 1.87 0 0 0-.348-1.127c-.243-.338-.688-.653-1.23-.656l-.518-.004c.597-1.145 1.425-1.983 2.348-2.87 1.473-1.414 3.18-3.149 3.2-6.226-.016-3.59-2.923-6.684-6.993-6.707m-.006 1.1v.002c3.274.02 5.92 2.532 5.9 5.6-.017 2.706-1.39 4.026-2.863 5.44-1.034.994-2.118 2.033-2.814 3.633-.018.041-.052.055-.075.065q-.013.004-.02.01a.34.34 0 0 1-.226.084.34.34 0 0 1-.224-.086l-.092-.077c-.699-1.615-1.768-2.669-2.781-3.67-1.454-1.435-2.797-2.762-2.78-5.478.02-3.067 2.7-5.545 5.975-5.523m-.02 2.826c-1.62-.01-2.944 1.315-2.955 2.96-.01 1.646 1.295 2.988 2.916 2.999h.002c1.621.01 2.943-1.316 2.953-2.961.011-1.646-1.294-2.988-2.916-2.998m-.005 1.1c1.017.006 1.829.83 1.822 1.89s-.83 1.874-1.848 1.867c-1.018-.006-1.829-.83-1.822-1.89s.83-1.874 1.848-1.868m-2.155 11.857 4.14.025c.271.002.49.305.487.676l-.013 1.875c-.003.37-.224.67-.495.668l-4.14-.025c-.27-.002-.487-.306-.485-.676l.012-1.875c.003-.37.224-.67.494-.668' style='color:%23000;font-style:normal;font-variant:normal;font-weight:400;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:%23000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;clip-rule:evenodd;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:%23000;solid-opacity:1;vector-effect:none;fill:%23000;fill-opacity:.4;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-9.415-.316C-12.69-.338-15.37 2.14-15.39 5.207c-.017 2.716 1.326 4.041 2.78 5.477 1.013 1 2.081 2.055 2.78 3.67l.092.076a.34.34 0 0 0 .225.086.34.34 0 0 0 .227-.083l.019-.01c.022-.009.057-.024.074-.064.697-1.6 1.78-2.64 2.814-3.634 1.473-1.414 2.847-2.733 2.864-5.44.02-3.067-2.627-5.58-5.901-5.601m-.057 8.784c1.621.011 2.944-1.315 2.955-2.96.01-1.646-1.295-2.988-2.916-2.999-1.622-.01-2.945 1.315-2.955 2.96s1.295 2.989 2.916 3' style='clip-rule:evenodd;fill:%23e1e3e9;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-11.594 15.465c-.27-.002-.492.297-.494.668l-.012 1.876c-.003.371.214.673.485.675l4.14.027c.271.002.492-.298.495-.668l.012-1.877c.003-.37-.215-.672-.485-.674z' style='clip-rule:evenodd;fill:%23fff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3C/g%3E%3C/svg%3E");background-repeat:no-repeat;cursor:pointer;display:block;height:23px;margin:0 0 -4px -4px;overflow:hidden;width:88px}a.maplibregl-ctrl-logo.maplibregl-compact{width:14px}@media (forced-colors:active){a.maplibregl-ctrl-logo{background-color:transparent;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='88' height='23' fill='none'%3E%3Cpath fill='%23000' fill-opacity='.4' fill-rule='evenodd' d='M17.408 16.796h-1.827l2.501-12.095h.198l3.324 6.533.988 2.19.988-2.19 3.258-6.533h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.929 5.644h-.098l-2.914-5.644-.757-1.71-.345 1.71zm1.958-3.42-.726 3.663a1.255 1.255 0 0 1-1.232 1.011h-1.827a1.255 1.255 0 0 1-1.229-1.509l2.501-12.095a1.255 1.255 0 0 1 1.23-1.001h.197a1.25 1.25 0 0 1 1.12.685l3.19 6.273 3.125-6.263a1.25 1.25 0 0 1 1.123-.695h.181a1.255 1.255 0 0 1 1.227.991l1.443 6.71a5 5 0 0 1 .314-.787l.009-.016a4.6 4.6 0 0 1 1.777-1.887c.782-.46 1.668-.667 2.611-.667a4.6 4.6 0 0 1 1.7.32l.306.134c.21-.16.474-.256.759-.256h1.694a1.255 1.255 0 0 1 1.212.925 1.255 1.255 0 0 1 1.212-.925h1.711c.284 0 .545.094.755.252.613-.3 1.312-.45 2.075-.45 1.356 0 2.557.445 3.482 1.4q.47.48.763 1.064V4.701a1.255 1.255 0 0 1 1.255-1.255h1.86A1.255 1.255 0 0 1 54.44 4.7v9.194h2.217c.19 0 .37.043.532.118v-4.77c0-.356.147-.678.385-.906a2.42 2.42 0 0 1-.682-1.71c0-.665.267-1.253.735-1.7a2.45 2.45 0 0 1 1.722-.674 2.43 2.43 0 0 1 1.705.675q.318.302.504.683V4.7a1.255 1.255 0 0 1 1.255-1.255h1.744A1.255 1.255 0 0 1 65.812 4.7v3.335a4.8 4.8 0 0 1 1.526-.246c.938 0 1.817.214 2.59.69a4.47 4.47 0 0 1 1.67 1.743v-.98a1.255 1.255 0 0 1 1.256-1.256h1.777c.233 0 .451.064.639.174a3.4 3.4 0 0 1 1.567-.372c.346 0 .861.02 1.285.232a1.25 1.25 0 0 1 .689 1.004 4.7 4.7 0 0 1 .853-.588c.795-.44 1.675-.647 2.61-.647 1.385 0 2.65.39 3.525 1.396.836.938 1.168 2.173 1.168 3.528q-.001.515-.056 1.051a1.255 1.255 0 0 1-.947 1.09l.408.952a1.255 1.255 0 0 1-.477 1.552c-.418.268-.92.463-1.458.612-.613.171-1.304.244-2.049.244-1.06 0-2.043-.207-2.886-.698l-.015-.008c-.798-.48-1.419-1.135-1.818-1.963l-.004-.008a5.8 5.8 0 0 1-.548-2.512q0-.429.053-.843a1.3 1.3 0 0 1-.333-.086l-.166-.004c-.223 0-.426.062-.643.228-.03.024-.142.139-.142.59v3.883a1.255 1.255 0 0 1-1.256 1.256h-1.777a1.255 1.255 0 0 1-1.256-1.256V15.69l-.032.057a4.8 4.8 0 0 1-1.86 1.833 5.04 5.04 0 0 1-2.484.634 4.5 4.5 0 0 1-1.935-.424 1.25 1.25 0 0 1-.764.258h-1.71a1.255 1.255 0 0 1-1.256-1.255V7.687a2.4 2.4 0 0 1-.428.625c.253.23.412.561.412.93v7.553a1.255 1.255 0 0 1-1.256 1.255h-1.843a1.25 1.25 0 0 1-.894-.373c-.228.23-.544.373-.894.373H51.32a1.255 1.255 0 0 1-1.256-1.255v-1.251l-.061.117a4.7 4.7 0 0 1-1.782 1.884 4.77 4.77 0 0 1-2.485.67 5.6 5.6 0 0 1-1.485-.188l.009 2.764a1.255 1.255 0 0 1-1.255 1.259h-1.729a1.255 1.255 0 0 1-1.255-1.255v-3.537a1.255 1.255 0 0 1-1.167.793h-1.679a1.25 1.25 0 0 1-.77-.263 4.5 4.5 0 0 1-1.945.429c-.885 0-1.724-.21-2.495-.632l-.017-.01a5 5 0 0 1-1.081-.836 1.255 1.255 0 0 1-1.254 1.312h-1.81a1.255 1.255 0 0 1-1.228-.99l-.782-3.625-2.044 3.939a1.25 1.25 0 0 1-1.115.676h-.098a1.25 1.25 0 0 1-1.116-.68l-2.061-3.994zM35.92 16.63l.207-.114.223-.15q.493-.356.735-.785l.061-.118.033 1.332h1.678V9.242h-1.694l-.033 1.267q-.133-.329-.526-.658l-.032-.028a3.2 3.2 0 0 0-.668-.428l-.27-.12a3.3 3.3 0 0 0-1.235-.23q-1.136-.001-1.974.493a3.36 3.36 0 0 0-1.3 1.382q-.445.89-.444 2.074 0 1.2.51 2.107a3.8 3.8 0 0 0 1.382 1.381 3.9 3.9 0 0 0 1.893.477q.795 0 1.455-.33zm-2.789-5.38q-.576.675-.575 1.762 0 1.102.559 1.794.576.675 1.645.675a2.25 2.25 0 0 0 .934-.19 2.2 2.2 0 0 0 .468-.29l.178-.161a2.2 2.2 0 0 0 .397-.561q.244-.5.244-1.15v-.115q0-.708-.296-1.267l-.043-.077a2.2 2.2 0 0 0-.633-.709l-.13-.086-.047-.028a2.1 2.1 0 0 0-1.073-.285q-1.052 0-1.629.692zm2.316 2.706c.163-.17.28-.407.28-.83v-.114c0-.292-.06-.508-.15-.68a.96.96 0 0 0-.353-.389.85.85 0 0 0-.464-.127c-.4 0-.56.114-.664.239l-.01.012c-.148.174-.275.45-.275.945 0 .506.122.801.27.99.097.11.266.224.68.224.303 0 .504-.09.687-.269zm7.545 1.705a2.6 2.6 0 0 0 .331.423q.319.33.755.548l.173.074q.65.255 1.49.255 1.02 0 1.844-.493a3.45 3.45 0 0 0 1.316-1.4q.493-.904.493-2.089 0-1.909-.988-2.913-.988-1.02-2.584-1.02-.898 0-1.575.347a3 3 0 0 0-.415.262l-.199.166a3.4 3.4 0 0 0-.64.82V9.242h-1.712v11.553h1.729l-.017-5.134zm.53-1.138q.206.29.48.5l.155.11.053.034q.51.296 1.119.297 1.07 0 1.645-.675.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.435 0-.835.16a2 2 0 0 0-.284.136 2 2 0 0 0-.363.254 2.2 2.2 0 0 0-.46.569l-.082.162a2.6 2.6 0 0 0-.213 1.072v.115q0 .707.296 1.267l.135.211zm.964-.818a1.1 1.1 0 0 0 .367.385.94.94 0 0 0 .476.118c.423 0 .59-.117.687-.23.159-.194.28-.478.28-.95 0-.53-.133-.8-.266-.952l-.021-.025c-.078-.094-.231-.221-.68-.221a1 1 0 0 0-.503.135l-.012.007a.86.86 0 0 0-.335.343c-.073.133-.132.324-.132.614v.115a1.4 1.4 0 0 0 .14.66zm15.7-6.222q.347-.346.346-.856a1.05 1.05 0 0 0-.345-.79 1.18 1.18 0 0 0-.84-.329q-.51 0-.855.33a1.05 1.05 0 0 0-.346.79q0 .51.346.855.345.346.856.346.51 0 .839-.346zm4.337 9.314.033-1.332q.191.403.59.747l.098.081a4 4 0 0 0 .316.224l.223.122a3.2 3.2 0 0 0 1.44.322 3.8 3.8 0 0 0 1.875-.477 3.5 3.5 0 0 0 1.382-1.366q.527-.89.526-2.09 0-1.184-.444-2.073a3.24 3.24 0 0 0-1.283-1.399q-.823-.51-1.942-.51a3.5 3.5 0 0 0-1.527.344l-.086.043-.165.09a3 3 0 0 0-.33.214q-.432.315-.656.707a2 2 0 0 0-.099.198l.082-1.283V4.701h-1.744v12.095zm.473-2.509a2.5 2.5 0 0 0 .566.7q.117.098.245.18l.144.08a2.1 2.1 0 0 0 .975.232q1.07 0 1.645-.675.576-.69.576-1.778 0-1.102-.576-1.777-.56-.691-1.645-.692a2.2 2.2 0 0 0-1.015.235q-.22.113-.415.282l-.15.142a2.1 2.1 0 0 0-.42.594q-.223.479-.223 1.1v.115q0 .705.293 1.26zm2.616-.293c.157-.191.28-.479.28-.967 0-.51-.13-.79-.276-.961l-.021-.026c-.082-.1-.232-.225-.67-.225a.87.87 0 0 0-.681.279l-.012.011c-.154.155-.274.38-.274.807v.115c0 .285.057.499.144.669a1.1 1.1 0 0 0 .367.405c.137.082.28.123.455.123.423 0 .59-.118.686-.23zm8.266-3.013q.345-.13.724-.14l.069-.002q.493 0 .642.099l.247-1.794q-.196-.099-.717-.099a2.3 2.3 0 0 0-.545.063 2 2 0 0 0-.411.148 2.2 2.2 0 0 0-.4.249 2.5 2.5 0 0 0-.485.499 2.7 2.7 0 0 0-.32.581l-.05.137v-1.48h-1.778v7.553h1.777v-3.884q0-.546.159-.943a1.5 1.5 0 0 1 .466-.636 2.5 2.5 0 0 1 .399-.253 2 2 0 0 1 .224-.099zm9.784 2.656.05-.922q0-1.743-.856-2.698-.838-.97-2.584-.97-1.119-.001-2.007.493a3.46 3.46 0 0 0-1.4 1.382q-.493.906-.493 2.106 0 1.07.428 1.975.428.89 1.332 1.432.906.526 2.255.526.973 0 1.668-.185l.044-.012.135-.04q.613-.184.984-.421l-.542-1.267q-.3.162-.642.274l-.297.087q-.51.131-1.3.131-.954 0-1.497-.444a1.6 1.6 0 0 1-.192-.193q-.366-.44-.512-1.234l-.004-.021zm-5.427-1.256-.003.022h3.752v-.138q-.011-.727-.288-1.118a1 1 0 0 0-.156-.176q-.46-.428-1.316-.428-.986 0-1.494.604-.379.45-.494 1.234zm-27.053 2.77V4.7h-1.86v12.095h5.333V15.15zm7.103-5.908v7.553h-1.843V9.242h1.843z'/%3E%3Cpath fill='%23fff' d='m19.63 11.151-.757-1.71-.345 1.71-1.12 5.644h-1.827L18.083 4.7h.197l3.325 6.533.988 2.19.988-2.19L26.839 4.7h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.93 5.644h-.098l-2.913-5.644zm14.836 5.81q-1.02 0-1.893-.478a3.8 3.8 0 0 1-1.381-1.382q-.51-.906-.51-2.106 0-1.185.444-2.074a3.36 3.36 0 0 1 1.3-1.382q.839-.494 1.974-.494a3.3 3.3 0 0 1 1.234.231 3.3 3.3 0 0 1 .97.575q.396.33.527.659l.033-1.267h1.694v7.553H37.18l-.033-1.332q-.279.593-1.02 1.053a3.17 3.17 0 0 1-1.662.444zm.296-1.482q.938 0 1.58-.642.642-.66.642-1.711v-.115q0-.708-.296-1.267a2.2 2.2 0 0 0-.807-.872 2.1 2.1 0 0 0-1.119-.313q-1.053 0-1.629.692-.575.675-.575 1.76 0 1.103.559 1.795.577.675 1.645.675zm6.521-6.237h1.711v1.4q.906-1.597 2.83-1.597 1.596 0 2.584 1.02.988 1.005.988 2.914 0 1.185-.493 2.09a3.46 3.46 0 0 1-1.316 1.399 3.5 3.5 0 0 1-1.844.493q-.954 0-1.662-.329a2.67 2.67 0 0 1-1.086-.97l.017 5.134h-1.728zm4.048 6.22q1.07 0 1.645-.674.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.592 0-1.12.296-.51.28-.822.823-.296.527-.296 1.234v.115q0 .708.296 1.267.313.543.823.855.51.296 1.119.297z'/%3E%3Cpath fill='%23e1e3e9' d='M51.325 4.7h1.86v10.45h3.473v1.646h-5.333zm7.12 4.542h1.843v7.553h-1.843zm.905-1.415a1.16 1.16 0 0 1-.856-.346 1.17 1.17 0 0 1-.346-.856 1.05 1.05 0 0 1 .346-.79q.346-.329.856-.329.494 0 .839.33a1.05 1.05 0 0 1 .345.79 1.16 1.16 0 0 1-.345.855q-.33.346-.84.346zm7.875 9.133a3.17 3.17 0 0 1-1.662-.444q-.723-.46-1.004-1.053l-.033 1.332h-1.71V4.701h1.743v4.657l-.082 1.283q.279-.658 1.086-1.119a3.5 3.5 0 0 1 1.778-.477q1.119 0 1.942.51a3.24 3.24 0 0 1 1.283 1.4q.445.888.444 2.072 0 1.201-.526 2.09a3.5 3.5 0 0 1-1.382 1.366 3.8 3.8 0 0 1-1.876.477zm-.296-1.481q1.069 0 1.645-.675.577-.69.577-1.778 0-1.102-.577-1.776-.56-.691-1.645-.692a2.12 2.12 0 0 0-1.58.659q-.642.641-.642 1.694v.115q0 .71.296 1.267a2.4 2.4 0 0 0 .807.872 2.1 2.1 0 0 0 1.119.313zm5.927-6.237h1.777v1.481q.263-.757.856-1.217a2.14 2.14 0 0 1 1.349-.46q.527 0 .724.098l-.247 1.794q-.149-.099-.642-.099-.774 0-1.416.494-.626.493-.626 1.58v3.883h-1.777V9.242zm9.534 7.718q-1.35 0-2.255-.526-.904-.543-1.332-1.432a4.6 4.6 0 0 1-.428-1.975q0-1.2.493-2.106a3.46 3.46 0 0 1 1.4-1.382q.889-.495 2.007-.494 1.744 0 2.584.97.855.956.856 2.7 0 .444-.05.92h-5.43q.18 1.005.708 1.45.542.443 1.497.443.79 0 1.3-.131a4 4 0 0 0 .938-.362l.542 1.267q-.411.263-1.119.46-.708.198-1.711.197zm1.596-4.558q.016-1.02-.444-1.432-.46-.428-1.316-.428-1.728 0-1.991 1.86z'/%3E%3Cpath d='M5.074 15.948a.484.657 0 0 0-.486.659v1.84a.484.657 0 0 0 .486.659h4.101a.484.657 0 0 0 .486-.659v-1.84a.484.657 0 0 0-.486-.659zm3.56 1.16H5.617v.838h3.017z' style='fill:%23fff;fill-rule:evenodd;stroke-width:1.03600001'/%3E%3Cg style='stroke-width:1.12603545'%3E%3Cpath d='M-9.408-1.416c-3.833-.025-7.056 2.912-7.08 6.615-.02 3.08 1.653 4.832 3.107 6.268.903.892 1.721 1.74 2.32 2.902l-.525-.004c-.543-.003-.992.304-1.24.639a1.87 1.87 0 0 0-.362 1.121l-.011 1.877c-.003.402.104.787.347 1.125.244.338.688.653 1.23.656l4.142.028c.542.003.99-.306 1.238-.641a1.87 1.87 0 0 0 .363-1.121l.012-1.875a1.87 1.87 0 0 0-.348-1.127c-.243-.338-.688-.653-1.23-.656l-.518-.004c.597-1.145 1.425-1.983 2.348-2.87 1.473-1.414 3.18-3.149 3.2-6.226-.016-3.59-2.923-6.684-6.993-6.707m-.006 1.1v.002c3.274.02 5.92 2.532 5.9 5.6-.017 2.706-1.39 4.026-2.863 5.44-1.034.994-2.118 2.033-2.814 3.633-.018.041-.052.055-.075.065q-.013.004-.02.01a.34.34 0 0 1-.226.084.34.34 0 0 1-.224-.086l-.092-.077c-.699-1.615-1.768-2.669-2.781-3.67-1.454-1.435-2.797-2.762-2.78-5.478.02-3.067 2.7-5.545 5.975-5.523m-.02 2.826c-1.62-.01-2.944 1.315-2.955 2.96-.01 1.646 1.295 2.988 2.916 2.999h.002c1.621.01 2.943-1.316 2.953-2.961.011-1.646-1.294-2.988-2.916-2.998m-.005 1.1c1.017.006 1.829.83 1.822 1.89s-.83 1.874-1.848 1.867c-1.018-.006-1.829-.83-1.822-1.89s.83-1.874 1.848-1.868m-2.155 11.857 4.14.025c.271.002.49.305.487.676l-.013 1.875c-.003.37-.224.67-.495.668l-4.14-.025c-.27-.002-.487-.306-.485-.676l.012-1.875c.003-.37.224-.67.494-.668' style='color:%23000;font-style:normal;font-variant:normal;font-weight:400;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:%23000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;clip-rule:evenodd;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:%23000;solid-opacity:1;vector-effect:none;fill:%23000;fill-opacity:.4;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-9.415-.316C-12.69-.338-15.37 2.14-15.39 5.207c-.017 2.716 1.326 4.041 2.78 5.477 1.013 1 2.081 2.055 2.78 3.67l.092.076a.34.34 0 0 0 .225.086.34.34 0 0 0 .227-.083l.019-.01c.022-.009.057-.024.074-.064.697-1.6 1.78-2.64 2.814-3.634 1.473-1.414 2.847-2.733 2.864-5.44.02-3.067-2.627-5.58-5.901-5.601m-.057 8.784c1.621.011 2.944-1.315 2.955-2.96.01-1.646-1.295-2.988-2.916-2.999-1.622-.01-2.945 1.315-2.955 2.96s1.295 2.989 2.916 3' style='clip-rule:evenodd;fill:%23e1e3e9;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-11.594 15.465c-.27-.002-.492.297-.494.668l-.012 1.876c-.003.371.214.673.485.675l4.14.027c.271.002.492-.298.495-.668l.012-1.877c.003-.37-.215-.672-.485-.674z' style='clip-rule:evenodd;fill:%23fff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3C/g%3E%3C/svg%3E")}}@media (forced-colors:active) and (prefers-color-scheme:light){a.maplibregl-ctrl-logo{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='88' height='23' fill='none'%3E%3Cpath fill='%23000' fill-opacity='.4' fill-rule='evenodd' d='M17.408 16.796h-1.827l2.501-12.095h.198l3.324 6.533.988 2.19.988-2.19 3.258-6.533h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.929 5.644h-.098l-2.914-5.644-.757-1.71-.345 1.71zm1.958-3.42-.726 3.663a1.255 1.255 0 0 1-1.232 1.011h-1.827a1.255 1.255 0 0 1-1.229-1.509l2.501-12.095a1.255 1.255 0 0 1 1.23-1.001h.197a1.25 1.25 0 0 1 1.12.685l3.19 6.273 3.125-6.263a1.25 1.25 0 0 1 1.123-.695h.181a1.255 1.255 0 0 1 1.227.991l1.443 6.71a5 5 0 0 1 .314-.787l.009-.016a4.6 4.6 0 0 1 1.777-1.887c.782-.46 1.668-.667 2.611-.667a4.6 4.6 0 0 1 1.7.32l.306.134c.21-.16.474-.256.759-.256h1.694a1.255 1.255 0 0 1 1.212.925 1.255 1.255 0 0 1 1.212-.925h1.711c.284 0 .545.094.755.252.613-.3 1.312-.45 2.075-.45 1.356 0 2.557.445 3.482 1.4q.47.48.763 1.064V4.701a1.255 1.255 0 0 1 1.255-1.255h1.86A1.255 1.255 0 0 1 54.44 4.7v9.194h2.217c.19 0 .37.043.532.118v-4.77c0-.356.147-.678.385-.906a2.42 2.42 0 0 1-.682-1.71c0-.665.267-1.253.735-1.7a2.45 2.45 0 0 1 1.722-.674 2.43 2.43 0 0 1 1.705.675q.318.302.504.683V4.7a1.255 1.255 0 0 1 1.255-1.255h1.744A1.255 1.255 0 0 1 65.812 4.7v3.335a4.8 4.8 0 0 1 1.526-.246c.938 0 1.817.214 2.59.69a4.47 4.47 0 0 1 1.67 1.743v-.98a1.255 1.255 0 0 1 1.256-1.256h1.777c.233 0 .451.064.639.174a3.4 3.4 0 0 1 1.567-.372c.346 0 .861.02 1.285.232a1.25 1.25 0 0 1 .689 1.004 4.7 4.7 0 0 1 .853-.588c.795-.44 1.675-.647 2.61-.647 1.385 0 2.65.39 3.525 1.396.836.938 1.168 2.173 1.168 3.528q-.001.515-.056 1.051a1.255 1.255 0 0 1-.947 1.09l.408.952a1.255 1.255 0 0 1-.477 1.552c-.418.268-.92.463-1.458.612-.613.171-1.304.244-2.049.244-1.06 0-2.043-.207-2.886-.698l-.015-.008c-.798-.48-1.419-1.135-1.818-1.963l-.004-.008a5.8 5.8 0 0 1-.548-2.512q0-.429.053-.843a1.3 1.3 0 0 1-.333-.086l-.166-.004c-.223 0-.426.062-.643.228-.03.024-.142.139-.142.59v3.883a1.255 1.255 0 0 1-1.256 1.256h-1.777a1.255 1.255 0 0 1-1.256-1.256V15.69l-.032.057a4.8 4.8 0 0 1-1.86 1.833 5.04 5.04 0 0 1-2.484.634 4.5 4.5 0 0 1-1.935-.424 1.25 1.25 0 0 1-.764.258h-1.71a1.255 1.255 0 0 1-1.256-1.255V7.687a2.4 2.4 0 0 1-.428.625c.253.23.412.561.412.93v7.553a1.255 1.255 0 0 1-1.256 1.255h-1.843a1.25 1.25 0 0 1-.894-.373c-.228.23-.544.373-.894.373H51.32a1.255 1.255 0 0 1-1.256-1.255v-1.251l-.061.117a4.7 4.7 0 0 1-1.782 1.884 4.77 4.77 0 0 1-2.485.67 5.6 5.6 0 0 1-1.485-.188l.009 2.764a1.255 1.255 0 0 1-1.255 1.259h-1.729a1.255 1.255 0 0 1-1.255-1.255v-3.537a1.255 1.255 0 0 1-1.167.793h-1.679a1.25 1.25 0 0 1-.77-.263 4.5 4.5 0 0 1-1.945.429c-.885 0-1.724-.21-2.495-.632l-.017-.01a5 5 0 0 1-1.081-.836 1.255 1.255 0 0 1-1.254 1.312h-1.81a1.255 1.255 0 0 1-1.228-.99l-.782-3.625-2.044 3.939a1.25 1.25 0 0 1-1.115.676h-.098a1.25 1.25 0 0 1-1.116-.68l-2.061-3.994zM35.92 16.63l.207-.114.223-.15q.493-.356.735-.785l.061-.118.033 1.332h1.678V9.242h-1.694l-.033 1.267q-.133-.329-.526-.658l-.032-.028a3.2 3.2 0 0 0-.668-.428l-.27-.12a3.3 3.3 0 0 0-1.235-.23q-1.136-.001-1.974.493a3.36 3.36 0 0 0-1.3 1.382q-.445.89-.444 2.074 0 1.2.51 2.107a3.8 3.8 0 0 0 1.382 1.381 3.9 3.9 0 0 0 1.893.477q.795 0 1.455-.33zm-2.789-5.38q-.576.675-.575 1.762 0 1.102.559 1.794.576.675 1.645.675a2.25 2.25 0 0 0 .934-.19 2.2 2.2 0 0 0 .468-.29l.178-.161a2.2 2.2 0 0 0 .397-.561q.244-.5.244-1.15v-.115q0-.708-.296-1.267l-.043-.077a2.2 2.2 0 0 0-.633-.709l-.13-.086-.047-.028a2.1 2.1 0 0 0-1.073-.285q-1.052 0-1.629.692zm2.316 2.706c.163-.17.28-.407.28-.83v-.114c0-.292-.06-.508-.15-.68a.96.96 0 0 0-.353-.389.85.85 0 0 0-.464-.127c-.4 0-.56.114-.664.239l-.01.012c-.148.174-.275.45-.275.945 0 .506.122.801.27.99.097.11.266.224.68.224.303 0 .504-.09.687-.269zm7.545 1.705a2.6 2.6 0 0 0 .331.423q.319.33.755.548l.173.074q.65.255 1.49.255 1.02 0 1.844-.493a3.45 3.45 0 0 0 1.316-1.4q.493-.904.493-2.089 0-1.909-.988-2.913-.988-1.02-2.584-1.02-.898 0-1.575.347a3 3 0 0 0-.415.262l-.199.166a3.4 3.4 0 0 0-.64.82V9.242h-1.712v11.553h1.729l-.017-5.134zm.53-1.138q.206.29.48.5l.155.11.053.034q.51.296 1.119.297 1.07 0 1.645-.675.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.435 0-.835.16a2 2 0 0 0-.284.136 2 2 0 0 0-.363.254 2.2 2.2 0 0 0-.46.569l-.082.162a2.6 2.6 0 0 0-.213 1.072v.115q0 .707.296 1.267l.135.211zm.964-.818a1.1 1.1 0 0 0 .367.385.94.94 0 0 0 .476.118c.423 0 .59-.117.687-.23.159-.194.28-.478.28-.95 0-.53-.133-.8-.266-.952l-.021-.025c-.078-.094-.231-.221-.68-.221a1 1 0 0 0-.503.135l-.012.007a.86.86 0 0 0-.335.343c-.073.133-.132.324-.132.614v.115a1.4 1.4 0 0 0 .14.66zm15.7-6.222q.347-.346.346-.856a1.05 1.05 0 0 0-.345-.79 1.18 1.18 0 0 0-.84-.329q-.51 0-.855.33a1.05 1.05 0 0 0-.346.79q0 .51.346.855.345.346.856.346.51 0 .839-.346zm4.337 9.314.033-1.332q.191.403.59.747l.098.081a4 4 0 0 0 .316.224l.223.122a3.2 3.2 0 0 0 1.44.322 3.8 3.8 0 0 0 1.875-.477 3.5 3.5 0 0 0 1.382-1.366q.527-.89.526-2.09 0-1.184-.444-2.073a3.24 3.24 0 0 0-1.283-1.399q-.823-.51-1.942-.51a3.5 3.5 0 0 0-1.527.344l-.086.043-.165.09a3 3 0 0 0-.33.214q-.432.315-.656.707a2 2 0 0 0-.099.198l.082-1.283V4.701h-1.744v12.095zm.473-2.509a2.5 2.5 0 0 0 .566.7q.117.098.245.18l.144.08a2.1 2.1 0 0 0 .975.232q1.07 0 1.645-.675.576-.69.576-1.778 0-1.102-.576-1.777-.56-.691-1.645-.692a2.2 2.2 0 0 0-1.015.235q-.22.113-.415.282l-.15.142a2.1 2.1 0 0 0-.42.594q-.223.479-.223 1.1v.115q0 .705.293 1.26zm2.616-.293c.157-.191.28-.479.28-.967 0-.51-.13-.79-.276-.961l-.021-.026c-.082-.1-.232-.225-.67-.225a.87.87 0 0 0-.681.279l-.012.011c-.154.155-.274.38-.274.807v.115c0 .285.057.499.144.669a1.1 1.1 0 0 0 .367.405c.137.082.28.123.455.123.423 0 .59-.118.686-.23zm8.266-3.013q.345-.13.724-.14l.069-.002q.493 0 .642.099l.247-1.794q-.196-.099-.717-.099a2.3 2.3 0 0 0-.545.063 2 2 0 0 0-.411.148 2.2 2.2 0 0 0-.4.249 2.5 2.5 0 0 0-.485.499 2.7 2.7 0 0 0-.32.581l-.05.137v-1.48h-1.778v7.553h1.777v-3.884q0-.546.159-.943a1.5 1.5 0 0 1 .466-.636 2.5 2.5 0 0 1 .399-.253 2 2 0 0 1 .224-.099zm9.784 2.656.05-.922q0-1.743-.856-2.698-.838-.97-2.584-.97-1.119-.001-2.007.493a3.46 3.46 0 0 0-1.4 1.382q-.493.906-.493 2.106 0 1.07.428 1.975.428.89 1.332 1.432.906.526 2.255.526.973 0 1.668-.185l.044-.012.135-.04q.613-.184.984-.421l-.542-1.267q-.3.162-.642.274l-.297.087q-.51.131-1.3.131-.954 0-1.497-.444a1.6 1.6 0 0 1-.192-.193q-.366-.44-.512-1.234l-.004-.021zm-5.427-1.256-.003.022h3.752v-.138q-.011-.727-.288-1.118a1 1 0 0 0-.156-.176q-.46-.428-1.316-.428-.986 0-1.494.604-.379.45-.494 1.234zm-27.053 2.77V4.7h-1.86v12.095h5.333V15.15zm7.103-5.908v7.553h-1.843V9.242h1.843z'/%3E%3Cpath fill='%23fff' d='m19.63 11.151-.757-1.71-.345 1.71-1.12 5.644h-1.827L18.083 4.7h.197l3.325 6.533.988 2.19.988-2.19L26.839 4.7h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.93 5.644h-.098l-2.913-5.644zm14.836 5.81q-1.02 0-1.893-.478a3.8 3.8 0 0 1-1.381-1.382q-.51-.906-.51-2.106 0-1.185.444-2.074a3.36 3.36 0 0 1 1.3-1.382q.839-.494 1.974-.494a3.3 3.3 0 0 1 1.234.231 3.3 3.3 0 0 1 .97.575q.396.33.527.659l.033-1.267h1.694v7.553H37.18l-.033-1.332q-.279.593-1.02 1.053a3.17 3.17 0 0 1-1.662.444zm.296-1.482q.938 0 1.58-.642.642-.66.642-1.711v-.115q0-.708-.296-1.267a2.2 2.2 0 0 0-.807-.872 2.1 2.1 0 0 0-1.119-.313q-1.053 0-1.629.692-.575.675-.575 1.76 0 1.103.559 1.795.577.675 1.645.675zm6.521-6.237h1.711v1.4q.906-1.597 2.83-1.597 1.596 0 2.584 1.02.988 1.005.988 2.914 0 1.185-.493 2.09a3.46 3.46 0 0 1-1.316 1.399 3.5 3.5 0 0 1-1.844.493q-.954 0-1.662-.329a2.67 2.67 0 0 1-1.086-.97l.017 5.134h-1.728zm4.048 6.22q1.07 0 1.645-.674.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.592 0-1.12.296-.51.28-.822.823-.296.527-.296 1.234v.115q0 .708.296 1.267.313.543.823.855.51.296 1.119.297z'/%3E%3Cpath fill='%23e1e3e9' d='M51.325 4.7h1.86v10.45h3.473v1.646h-5.333zm7.12 4.542h1.843v7.553h-1.843zm.905-1.415a1.16 1.16 0 0 1-.856-.346 1.17 1.17 0 0 1-.346-.856 1.05 1.05 0 0 1 .346-.79q.346-.329.856-.329.494 0 .839.33a1.05 1.05 0 0 1 .345.79 1.16 1.16 0 0 1-.345.855q-.33.346-.84.346zm7.875 9.133a3.17 3.17 0 0 1-1.662-.444q-.723-.46-1.004-1.053l-.033 1.332h-1.71V4.701h1.743v4.657l-.082 1.283q.279-.658 1.086-1.119a3.5 3.5 0 0 1 1.778-.477q1.119 0 1.942.51a3.24 3.24 0 0 1 1.283 1.4q.445.888.444 2.072 0 1.201-.526 2.09a3.5 3.5 0 0 1-1.382 1.366 3.8 3.8 0 0 1-1.876.477zm-.296-1.481q1.069 0 1.645-.675.577-.69.577-1.778 0-1.102-.577-1.776-.56-.691-1.645-.692a2.12 2.12 0 0 0-1.58.659q-.642.641-.642 1.694v.115q0 .71.296 1.267a2.4 2.4 0 0 0 .807.872 2.1 2.1 0 0 0 1.119.313zm5.927-6.237h1.777v1.481q.263-.757.856-1.217a2.14 2.14 0 0 1 1.349-.46q.527 0 .724.098l-.247 1.794q-.149-.099-.642-.099-.774 0-1.416.494-.626.493-.626 1.58v3.883h-1.777V9.242zm9.534 7.718q-1.35 0-2.255-.526-.904-.543-1.332-1.432a4.6 4.6 0 0 1-.428-1.975q0-1.2.493-2.106a3.46 3.46 0 0 1 1.4-1.382q.889-.495 2.007-.494 1.744 0 2.584.97.855.956.856 2.7 0 .444-.05.92h-5.43q.18 1.005.708 1.45.542.443 1.497.443.79 0 1.3-.131a4 4 0 0 0 .938-.362l.542 1.267q-.411.263-1.119.46-.708.198-1.711.197zm1.596-4.558q.016-1.02-.444-1.432-.46-.428-1.316-.428-1.728 0-1.991 1.86z'/%3E%3Cpath d='M5.074 15.948a.484.657 0 0 0-.486.659v1.84a.484.657 0 0 0 .486.659h4.101a.484.657 0 0 0 .486-.659v-1.84a.484.657 0 0 0-.486-.659zm3.56 1.16H5.617v.838h3.017z' style='fill:%23fff;fill-rule:evenodd;stroke-width:1.03600001'/%3E%3Cg style='stroke-width:1.12603545'%3E%3Cpath d='M-9.408-1.416c-3.833-.025-7.056 2.912-7.08 6.615-.02 3.08 1.653 4.832 3.107 6.268.903.892 1.721 1.74 2.32 2.902l-.525-.004c-.543-.003-.992.304-1.24.639a1.87 1.87 0 0 0-.362 1.121l-.011 1.877c-.003.402.104.787.347 1.125.244.338.688.653 1.23.656l4.142.028c.542.003.99-.306 1.238-.641a1.87 1.87 0 0 0 .363-1.121l.012-1.875a1.87 1.87 0 0 0-.348-1.127c-.243-.338-.688-.653-1.23-.656l-.518-.004c.597-1.145 1.425-1.983 2.348-2.87 1.473-1.414 3.18-3.149 3.2-6.226-.016-3.59-2.923-6.684-6.993-6.707m-.006 1.1v.002c3.274.02 5.92 2.532 5.9 5.6-.017 2.706-1.39 4.026-2.863 5.44-1.034.994-2.118 2.033-2.814 3.633-.018.041-.052.055-.075.065q-.013.004-.02.01a.34.34 0 0 1-.226.084.34.34 0 0 1-.224-.086l-.092-.077c-.699-1.615-1.768-2.669-2.781-3.67-1.454-1.435-2.797-2.762-2.78-5.478.02-3.067 2.7-5.545 5.975-5.523m-.02 2.826c-1.62-.01-2.944 1.315-2.955 2.96-.01 1.646 1.295 2.988 2.916 2.999h.002c1.621.01 2.943-1.316 2.953-2.961.011-1.646-1.294-2.988-2.916-2.998m-.005 1.1c1.017.006 1.829.83 1.822 1.89s-.83 1.874-1.848 1.867c-1.018-.006-1.829-.83-1.822-1.89s.83-1.874 1.848-1.868m-2.155 11.857 4.14.025c.271.002.49.305.487.676l-.013 1.875c-.003.37-.224.67-.495.668l-4.14-.025c-.27-.002-.487-.306-.485-.676l.012-1.875c.003-.37.224-.67.494-.668' style='color:%23000;font-style:normal;font-variant:normal;font-weight:400;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:%23000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;clip-rule:evenodd;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:%23000;solid-opacity:1;vector-effect:none;fill:%23000;fill-opacity:.4;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-9.415-.316C-12.69-.338-15.37 2.14-15.39 5.207c-.017 2.716 1.326 4.041 2.78 5.477 1.013 1 2.081 2.055 2.78 3.67l.092.076a.34.34 0 0 0 .225.086.34.34 0 0 0 .227-.083l.019-.01c.022-.009.057-.024.074-.064.697-1.6 1.78-2.64 2.814-3.634 1.473-1.414 2.847-2.733 2.864-5.44.02-3.067-2.627-5.58-5.901-5.601m-.057 8.784c1.621.011 2.944-1.315 2.955-2.96.01-1.646-1.295-2.988-2.916-2.999-1.622-.01-2.945 1.315-2.955 2.96s1.295 2.989 2.916 3' style='clip-rule:evenodd;fill:%23e1e3e9;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-11.594 15.465c-.27-.002-.492.297-.494.668l-.012 1.876c-.003.371.214.673.485.675l4.14.027c.271.002.492-.298.495-.668l.012-1.877c.003-.37-.215-.672-.485-.674z' style='clip-rule:evenodd;fill:%23fff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3C/g%3E%3C/svg%3E")}}.maplibregl-ctrl.maplibregl-ctrl-attrib{background-color:#ffffff80;margin:0;padding:0 5px}@media screen{.maplibregl-ctrl-attrib.maplibregl-compact{background-color:#fff;border-radius:12px;box-sizing:content-box;color:#000;margin:10px;min-height:20px;padding:2px 24px 2px 0;position:relative}.maplibregl-ctrl-attrib.maplibregl-compact-show{padding:2px 28px 2px 8px;visibility:visible}.maplibregl-ctrl-bottom-left>.maplibregl-ctrl-attrib.maplibregl-compact-show,.maplibregl-ctrl-top-left>.maplibregl-ctrl-attrib.maplibregl-compact-show{border-radius:12px;padding:2px 8px 2px 28px}.maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-inner{display:none}.maplibregl-ctrl-attrib-button{background-color:#ffffff80;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill-rule='evenodd' viewBox='0 0 20 20'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E");border:0;border-radius:12px;box-sizing:border-box;cursor:pointer;display:none;height:24px;outline:none;position:absolute;right:0;top:0;width:24px}.maplibregl-ctrl-attrib summary.maplibregl-ctrl-attrib-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;list-style:none}.maplibregl-ctrl-attrib summary.maplibregl-ctrl-attrib-button::-webkit-details-marker{display:none}.maplibregl-ctrl-bottom-left .maplibregl-ctrl-attrib-button,.maplibregl-ctrl-top-left .maplibregl-ctrl-attrib-button{left:0}.maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-button,.maplibregl-ctrl-attrib.maplibregl-compact-show .maplibregl-ctrl-attrib-inner{display:block}.maplibregl-ctrl-attrib.maplibregl-compact-show .maplibregl-ctrl-attrib-button{background-color:#0000000d}.maplibregl-ctrl-bottom-right>.maplibregl-ctrl-attrib.maplibregl-compact:after{bottom:0;right:0}.maplibregl-ctrl-top-right>.maplibregl-ctrl-attrib.maplibregl-compact:after{right:0;top:0}.maplibregl-ctrl-top-left>.maplibregl-ctrl-attrib.maplibregl-compact:after{left:0;top:0}.maplibregl-ctrl-bottom-left>.maplibregl-ctrl-attrib.maplibregl-compact:after{bottom:0;left:0}}@media screen and (forced-colors:active){.maplibregl-ctrl-attrib.maplibregl-compact:after{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='%23fff' fill-rule='evenodd' viewBox='0 0 20 20'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E")}}@media screen and (forced-colors:active) and (prefers-color-scheme:light){.maplibregl-ctrl-attrib.maplibregl-compact:after{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill-rule='evenodd' viewBox='0 0 20 20'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E")}}.maplibregl-ctrl-attrib a{color:#000000bf;text-decoration:none}.maplibregl-ctrl-attrib a:hover{color:inherit;text-decoration:underline}.maplibregl-attrib-empty{display:none}.maplibregl-ctrl-scale{background-color:#ffffffbf;border:2px solid #333;border-top:#333;box-sizing:border-box;color:#333;font-size:10px;padding:0 5px}.maplibregl-popup{display:flex;left:0;pointer-events:none;position:absolute;top:0;will-change:transform}.maplibregl-popup-anchor-top,.maplibregl-popup-anchor-top-left,.maplibregl-popup-anchor-top-right{flex-direction:column}.maplibregl-popup-anchor-bottom,.maplibregl-popup-anchor-bottom-left,.maplibregl-popup-anchor-bottom-right{flex-direction:column-reverse}.maplibregl-popup-anchor-left{flex-direction:row}.maplibregl-popup-anchor-right{flex-direction:row-reverse}.maplibregl-popup-tip{border:10px solid transparent;height:0;width:0;z-index:1}.maplibregl-popup-anchor-top .maplibregl-popup-tip{align-self:center;border-bottom-color:#fff;border-top:none}.maplibregl-popup-anchor-top-left .maplibregl-popup-tip{align-self:flex-start;border-bottom-color:#fff;border-left:none;border-top:none}.maplibregl-popup-anchor-top-right .maplibregl-popup-tip{align-self:flex-end;border-bottom-color:#fff;border-right:none;border-top:none}.maplibregl-popup-anchor-bottom .maplibregl-popup-tip{align-self:center;border-bottom:none;border-top-color:#fff}.maplibregl-popup-anchor-bottom-left .maplibregl-popup-tip{align-self:flex-start;border-bottom:none;border-left:none;border-top-color:#fff}.maplibregl-popup-anchor-bottom-right .maplibregl-popup-tip{align-self:flex-end;border-bottom:none;border-right:none;border-top-color:#fff}.maplibregl-popup-anchor-left .maplibregl-popup-tip{align-self:center;border-left:none;border-right-color:#fff}.maplibregl-popup-anchor-right .maplibregl-popup-tip{align-self:center;border-left-color:#fff;border-right:none}.maplibregl-popup-close-button{background-color:transparent;border:0;border-radius:0 3px 0 0;cursor:pointer;position:absolute;right:0;top:0}.maplibregl-popup-close-button:hover{background-color:#0000000d}.maplibregl-popup-content{background:#fff;border-radius:3px;box-shadow:0 1px 2px #0000001a;padding:15px 10px;pointer-events:auto;position:relative}.maplibregl-popup-anchor-top-left .maplibregl-popup-content{border-top-left-radius:0}.maplibregl-popup-anchor-top-right .maplibregl-popup-content{border-top-right-radius:0}.maplibregl-popup-anchor-bottom-left .maplibregl-popup-content{border-bottom-left-radius:0}.maplibregl-popup-anchor-bottom-right .maplibregl-popup-content{border-bottom-right-radius:0}.maplibregl-popup-track-pointer{display:none}.maplibregl-popup-track-pointer *{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.maplibregl-map:hover .maplibregl-popup-track-pointer{display:flex}.maplibregl-map:active .maplibregl-popup-track-pointer{display:none}.maplibregl-marker{left:0;position:absolute;top:0;transition:opacity .2s;will-change:transform}.maplibregl-user-location-dot,.maplibregl-user-location-dot:before{background-color:#1da1f2;border-radius:50%;height:15px;width:15px}.maplibregl-user-location-dot:before{animation:maplibregl-user-location-dot-pulse 2s infinite;content:"";position:absolute}.maplibregl-user-location-dot:after{border:2px solid #fff;border-radius:50%;box-shadow:0 0 3px #00000059;box-sizing:border-box;content:"";height:19px;left:-2px;position:absolute;top:-2px;width:19px}@keyframes maplibregl-user-location-dot-pulse{0%{opacity:1;transform:scale(1)}70%{opacity:0;transform:scale(3)}to{opacity:0;transform:scale(1)}}.maplibregl-user-location-dot-stale{background-color:#aaa}.maplibregl-user-location-dot-stale:after{display:none}.maplibregl-user-location-accuracy-circle{background-color:#1da1f233;border-radius:100%;height:1px;width:1px}.maplibregl-crosshair,.maplibregl-crosshair .maplibregl-interactive,.maplibregl-crosshair .maplibregl-interactive:active{cursor:crosshair}.maplibregl-boxzoom{background:#fff;border:2px dotted #202020;height:0;left:0;opacity:.5;position:absolute;top:0;width:0}.maplibregl-cooperative-gesture-screen{align-items:center;background:#0006;color:#fff;display:flex;font-size:1.4em;top:0;right:0;bottom:0;left:0;justify-content:center;line-height:1.2;opacity:0;padding:1rem;pointer-events:none;position:absolute;transition:opacity 1s ease 1s;z-index:99999}.maplibregl-cooperative-gesture-screen.maplibregl-show{opacity:1;transition:opacity .05s}.maplibregl-cooperative-gesture-screen .maplibregl-mobile-message{display:none}@media (hover:none),(width <= 480px){.maplibregl-cooperative-gesture-screen .maplibregl-desktop-message{display:none}.maplibregl-cooperative-gesture-screen .maplibregl-mobile-message{display:block}}.maplibregl-pseudo-fullscreen{height:100%!important;left:0!important;position:fixed!important;top:0!important;width:100%!important;z-index:99999}.psv-navbar{display:none!important}`)),document.head.appendChild(l)}}catch(a){console.error("vite-plugin-css-injected-by-js",a)}})();
var KS = Object.defineProperty;
var JS = (t, e, i) => e in t ? KS(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i;
var O = (t, e, i) => JS(t, typeof e != "symbol" ? e + "" : e, i);
function U1(t, e) {
  for (var i = 0; i < e.length; i++) {
    const s = e[i];
    if (typeof s != "string" && !Array.isArray(s)) {
      for (const o in s)
        if (o !== "default" && !(o in t)) {
          const l = Object.getOwnPropertyDescriptor(s, o);
          l && Object.defineProperty(t, o, l.get ? l : {
            enumerable: !0,
            get: () => s[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
var YS = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function z1(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var V1 = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v4.7.1/LICENSE.txt
 */
(function(t, e) {
  (function(i, s) {
    t.exports = s();
  })(YS, function() {
    var i = {}, s = {};
    function o(u, c, x) {
      if (s[u] = x, u === "index") {
        var w = "var sharedModule = {}; (" + s.shared + ")(sharedModule); (" + s.worker + ")(sharedModule);", C = {};
        return s.shared(C), s.index(i, C), typeof window < "u" && i.setWorkerUrl(window.URL.createObjectURL(new Blob([w], { type: "text/javascript" }))), i;
      }
    }
    o("shared", ["exports"], function(u) {
      function c(a, n, h, f) {
        return new (h || (h = Promise))(function(m, b) {
          function v(R) {
            try {
              E(f.next(R));
            } catch (B) {
              b(B);
            }
          }
          function A(R) {
            try {
              E(f.throw(R));
            } catch (B) {
              b(B);
            }
          }
          function E(R) {
            var B;
            R.done ? m(R.value) : (B = R.value, B instanceof h ? B : new h(function(F) {
              F(B);
            })).then(v, A);
          }
          E((f = f.apply(a, n || [])).next());
        });
      }
      function x(a) {
        return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
      }
      typeof SuppressedError == "function" && SuppressedError;
      var w = C;
      function C(a, n) {
        this.x = a, this.y = n;
      }
      C.prototype = { clone: function() {
        return new C(this.x, this.y);
      }, add: function(a) {
        return this.clone()._add(a);
      }, sub: function(a) {
        return this.clone()._sub(a);
      }, multByPoint: function(a) {
        return this.clone()._multByPoint(a);
      }, divByPoint: function(a) {
        return this.clone()._divByPoint(a);
      }, mult: function(a) {
        return this.clone()._mult(a);
      }, div: function(a) {
        return this.clone()._div(a);
      }, rotate: function(a) {
        return this.clone()._rotate(a);
      }, rotateAround: function(a, n) {
        return this.clone()._rotateAround(a, n);
      }, matMult: function(a) {
        return this.clone()._matMult(a);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(a) {
        return this.x === a.x && this.y === a.y;
      }, dist: function(a) {
        return Math.sqrt(this.distSqr(a));
      }, distSqr: function(a) {
        var n = a.x - this.x, h = a.y - this.y;
        return n * n + h * h;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(a) {
        return Math.atan2(this.y - a.y, this.x - a.x);
      }, angleWith: function(a) {
        return this.angleWithSep(a.x, a.y);
      }, angleWithSep: function(a, n) {
        return Math.atan2(this.x * n - this.y * a, this.x * a + this.y * n);
      }, _matMult: function(a) {
        var n = a[2] * this.x + a[3] * this.y;
        return this.x = a[0] * this.x + a[1] * this.y, this.y = n, this;
      }, _add: function(a) {
        return this.x += a.x, this.y += a.y, this;
      }, _sub: function(a) {
        return this.x -= a.x, this.y -= a.y, this;
      }, _mult: function(a) {
        return this.x *= a, this.y *= a, this;
      }, _div: function(a) {
        return this.x /= a, this.y /= a, this;
      }, _multByPoint: function(a) {
        return this.x *= a.x, this.y *= a.y, this;
      }, _divByPoint: function(a) {
        return this.x /= a.x, this.y /= a.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var a = this.y;
        return this.y = this.x, this.x = -a, this;
      }, _rotate: function(a) {
        var n = Math.cos(a), h = Math.sin(a), f = h * this.x + n * this.y;
        return this.x = n * this.x - h * this.y, this.y = f, this;
      }, _rotateAround: function(a, n) {
        var h = Math.cos(a), f = Math.sin(a), m = n.y + f * (this.x - n.x) + h * (this.y - n.y);
        return this.x = n.x + h * (this.x - n.x) - f * (this.y - n.y), this.y = m, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, C.convert = function(a) {
        return a instanceof C ? a : Array.isArray(a) ? new C(a[0], a[1]) : a;
      };
      var M = x(w), P = j;
      function j(a, n, h, f) {
        this.cx = 3 * a, this.bx = 3 * (h - a) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (f - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = a, this.p1y = n, this.p2x = h, this.p2y = f;
      }
      j.prototype = { sampleCurveX: function(a) {
        return ((this.ax * a + this.bx) * a + this.cx) * a;
      }, sampleCurveY: function(a) {
        return ((this.ay * a + this.by) * a + this.cy) * a;
      }, sampleCurveDerivativeX: function(a) {
        return (3 * this.ax * a + 2 * this.bx) * a + this.cx;
      }, solveCurveX: function(a, n) {
        if (n === void 0 && (n = 1e-6), a < 0) return 0;
        if (a > 1) return 1;
        for (var h = a, f = 0; f < 8; f++) {
          var m = this.sampleCurveX(h) - a;
          if (Math.abs(m) < n) return h;
          var b = this.sampleCurveDerivativeX(h);
          if (Math.abs(b) < 1e-6) break;
          h -= m / b;
        }
        var v = 0, A = 1;
        for (h = a, f = 0; f < 20 && (m = this.sampleCurveX(h), !(Math.abs(m - a) < n)); f++) a > m ? v = h : A = h, h = 0.5 * (A - v) + v;
        return h;
      }, solve: function(a, n) {
        return this.sampleCurveY(this.solveCurveX(a, n));
      } };
      var Y = x(P);
      let Q, _e;
      function me() {
        return Q == null && (Q = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), Q;
      }
      function we() {
        if (_e == null && (_e = !1, me())) {
          const n = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
          if (n) {
            for (let f = 0; f < 5 * 5; f++) {
              const m = 4 * f;
              n.fillStyle = `rgb(${m},${m + 1},${m + 2})`, n.fillRect(f % 5, Math.floor(f / 5), 1, 1);
            }
            const h = n.getImageData(0, 0, 5, 5).data;
            for (let f = 0; f < 5 * 5 * 4; f++) if (f % 4 != 3 && h[f] !== f) {
              _e = !0;
              break;
            }
          }
        }
        return _e || !1;
      }
      function Ee(a, n, h, f) {
        const m = new Y(a, n, h, f);
        return (b) => m.solve(b);
      }
      const Oe = Ee(0.25, 0.1, 0.25, 1);
      function Ne(a, n, h) {
        return Math.min(h, Math.max(n, a));
      }
      function ze(a, n, h) {
        const f = h - n, m = ((a - n) % f + f) % f + n;
        return m === n ? h : m;
      }
      function nt(a, ...n) {
        for (const h of n) for (const f in h) a[f] = h[f];
        return a;
      }
      let mt = 1;
      function We(a, n, h) {
        const f = {};
        for (const m in a) f[m] = n.call(this, a[m], m, a);
        return f;
      }
      function at(a, n, h) {
        const f = {};
        for (const m in a) n.call(this, a[m], m, a) && (f[m] = a[m]);
        return f;
      }
      function it(a) {
        return Array.isArray(a) ? a.map(it) : typeof a == "object" && a ? We(a, it) : a;
      }
      const Ut = {};
      function Rt(a) {
        Ut[a] || (typeof console < "u" && console.warn(a), Ut[a] = !0);
      }
      function yt(a, n, h) {
        return (h.y - a.y) * (n.x - a.x) > (n.y - a.y) * (h.x - a.x);
      }
      function di(a) {
        return typeof WorkerGlobalScope < "u" && a !== void 0 && a instanceof WorkerGlobalScope;
      }
      let Fs = null;
      function Hi(a) {
        return typeof ImageBitmap < "u" && a instanceof ImageBitmap;
      }
      const An = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function Js(a, n, h, f, m) {
        return c(this, void 0, void 0, function* () {
          if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
          const b = new VideoFrame(a, { timestamp: 0 });
          try {
            const v = b == null ? void 0 : b.format;
            if (!v || !v.startsWith("BGR") && !v.startsWith("RGB")) throw new Error(`Unrecognized format ${v}`);
            const A = v.startsWith("BGR"), E = new Uint8ClampedArray(f * m * 4);
            if (yield b.copyTo(E, function(R, B, F, L, V) {
              const $ = 4 * Math.max(-B, 0), X = (Math.max(0, F) - F) * L * 4 + $, ie = 4 * L, ne = Math.max(0, B), Ae = Math.max(0, F);
              return { rect: { x: ne, y: Ae, width: Math.min(R.width, B + L) - ne, height: Math.min(R.height, F + V) - Ae }, layout: [{ offset: X, stride: ie }] };
            }(a, n, h, f, m)), A) for (let R = 0; R < E.length; R += 4) {
              const B = E[R];
              E[R] = E[R + 2], E[R + 2] = B;
            }
            return E;
          } finally {
            b.close();
          }
        });
      }
      let ji, Li;
      const Pi = "AbortError";
      function Tn() {
        return new Error(Pi);
      }
      const or = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
      function ar(a) {
        return or.REGISTERED_PROTOCOLS[a.substring(0, a.indexOf("://"))];
      }
      const En = "global-dispatcher";
      class Qt extends Error {
        constructor(n, h, f, m) {
          super(`AJAXError: ${h} (${n}): ${f}`), this.status = n, this.statusText = h, this.url = f, this.body = m;
        }
      }
      const Zi = () => di(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, ni = function(a, n) {
        if (/:\/\//.test(a.url) && !/^https?:|^file:/.test(a.url)) {
          const f = ar(a.url);
          if (f) return f(a, n);
          if (di(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: a, targetMapId: En }, n);
        }
        if (!(/^file:/.test(h = a.url) || /^file:/.test(Zi()) && !/^\w+:/.test(h))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(f, m) {
            return c(this, void 0, void 0, function* () {
              const b = new Request(f.url, { method: f.method || "GET", body: f.body, credentials: f.credentials, headers: f.headers, cache: f.cache, referrer: Zi(), signal: m.signal });
              f.type !== "json" || b.headers.has("Accept") || b.headers.set("Accept", "application/json");
              const v = yield fetch(b);
              if (!v.ok) {
                const R = yield v.blob();
                throw new Qt(v.status, v.statusText, f.url, R);
              }
              let A;
              A = f.type === "arrayBuffer" || f.type === "image" ? v.arrayBuffer() : f.type === "json" ? v.json() : v.text();
              const E = yield A;
              if (m.signal.aborted) throw Tn();
              return { data: E, cacheControl: v.headers.get("Cache-Control"), expires: v.headers.get("Expires") };
            });
          }(a, n);
          if (di(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: a, mustQueue: !0, targetMapId: En }, n);
        }
        var h;
        return function(f, m) {
          return new Promise((b, v) => {
            var A;
            const E = new XMLHttpRequest();
            E.open(f.method || "GET", f.url, !0), f.type !== "arrayBuffer" && f.type !== "image" || (E.responseType = "arraybuffer");
            for (const R in f.headers) E.setRequestHeader(R, f.headers[R]);
            f.type === "json" && (E.responseType = "text", !((A = f.headers) === null || A === void 0) && A.Accept || E.setRequestHeader("Accept", "application/json")), E.withCredentials = f.credentials === "include", E.onerror = () => {
              v(new Error(E.statusText));
            }, E.onload = () => {
              if (!m.signal.aborted) if ((E.status >= 200 && E.status < 300 || E.status === 0) && E.response !== null) {
                let R = E.response;
                if (f.type === "json") try {
                  R = JSON.parse(E.response);
                } catch (B) {
                  return void v(B);
                }
                b({ data: R, cacheControl: E.getResponseHeader("Cache-Control"), expires: E.getResponseHeader("Expires") });
              } else {
                const R = new Blob([E.response], { type: E.getResponseHeader("Content-Type") });
                v(new Qt(E.status, E.statusText, f.url, R));
              }
            }, m.signal.addEventListener("abort", () => {
              E.abort(), v(Tn());
            }), E.send(f.body);
          });
        }(a, n);
      };
      function Bi(a) {
        if (!a || a.indexOf("://") <= 0 || a.indexOf("data:image/") === 0 || a.indexOf("blob:") === 0) return !0;
        const n = new URL(a), h = window.location;
        return n.protocol === h.protocol && n.host === h.host;
      }
      function Vr(a, n, h) {
        h[a] && h[a].indexOf(n) !== -1 || (h[a] = h[a] || [], h[a].push(n));
      }
      function Ss(a, n, h) {
        if (h && h[a]) {
          const f = h[a].indexOf(n);
          f !== -1 && h[a].splice(f, 1);
        }
      }
      class ks {
        constructor(n, h = {}) {
          nt(this, h), this.type = n;
        }
      }
      class Ns extends ks {
        constructor(n, h = {}) {
          super("error", nt({ error: n }, h));
        }
      }
      class lr {
        on(n, h) {
          return this._listeners = this._listeners || {}, Vr(n, h, this._listeners), this;
        }
        off(n, h) {
          return Ss(n, h, this._listeners), Ss(n, h, this._oneTimeListeners), this;
        }
        once(n, h) {
          return h ? (this._oneTimeListeners = this._oneTimeListeners || {}, Vr(n, h, this._oneTimeListeners), this) : new Promise((f) => this.once(n, f));
        }
        fire(n, h) {
          typeof n == "string" && (n = new ks(n, h || {}));
          const f = n.type;
          if (this.listens(f)) {
            n.target = this;
            const m = this._listeners && this._listeners[f] ? this._listeners[f].slice() : [];
            for (const A of m) A.call(this, n);
            const b = this._oneTimeListeners && this._oneTimeListeners[f] ? this._oneTimeListeners[f].slice() : [];
            for (const A of b) Ss(f, A, this._oneTimeListeners), A.call(this, n);
            const v = this._eventedParent;
            v && (nt(n, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), v.fire(n));
          } else n instanceof Ns && console.error(n.error);
          return this;
        }
        listens(n) {
          return this._listeners && this._listeners[n] && this._listeners[n].length > 0 || this._oneTimeListeners && this._oneTimeListeners[n] && this._oneTimeListeners[n].length > 0 || this._eventedParent && this._eventedParent.listens(n);
        }
        setEventedParent(n, h) {
          return this._eventedParent = n, this._eventedParentData = h, this;
        }
      }
      var Ie = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "enum", default: "mercator", values: { mercator: {}, globe: {} } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      const Cs = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function Sn(a, n) {
        const h = {};
        for (const f in a) f !== "ref" && (h[f] = a[f]);
        return Cs.forEach((f) => {
          f in n && (h[f] = n[f]);
        }), h;
      }
      function zt(a, n) {
        if (Array.isArray(a)) {
          if (!Array.isArray(n) || a.length !== n.length) return !1;
          for (let h = 0; h < a.length; h++) if (!zt(a[h], n[h])) return !1;
          return !0;
        }
        if (typeof a == "object" && a !== null && n !== null) {
          if (typeof n != "object" || Object.keys(a).length !== Object.keys(n).length) return !1;
          for (const h in a) if (!zt(a[h], n[h])) return !1;
          return !0;
        }
        return a === n;
      }
      function oi(a, n) {
        a.push(n);
      }
      function Ji(a, n, h) {
        oi(h, { command: "addSource", args: [a, n[a]] });
      }
      function Hr(a, n, h) {
        oi(n, { command: "removeSource", args: [a] }), h[a] = !0;
      }
      function Ar(a, n, h, f) {
        Hr(a, h, f), Ji(a, n, h);
      }
      function Cn(a, n, h) {
        let f;
        for (f in a[h]) if (Object.prototype.hasOwnProperty.call(a[h], f) && f !== "data" && !zt(a[h][f], n[h][f])) return !1;
        for (f in n[h]) if (Object.prototype.hasOwnProperty.call(n[h], f) && f !== "data" && !zt(a[h][f], n[h][f])) return !1;
        return !0;
      }
      function Ls(a, n, h, f, m, b) {
        a = a || {}, n = n || {};
        for (const v in a) Object.prototype.hasOwnProperty.call(a, v) && (zt(a[v], n[v]) || h.push({ command: b, args: [f, v, n[v], m] }));
        for (const v in n) Object.prototype.hasOwnProperty.call(n, v) && !Object.prototype.hasOwnProperty.call(a, v) && (zt(a[v], n[v]) || h.push({ command: b, args: [f, v, n[v], m] }));
      }
      function Jn(a) {
        return a.id;
      }
      function In(a, n) {
        return a[n.id] = n, a;
      }
      class He {
        constructor(n, h, f, m) {
          this.message = (n ? `${n}: ` : "") + f, m && (this.identifier = m), h != null && h.__line__ && (this.line = h.__line__);
        }
      }
      function Ys(a, ...n) {
        for (const h of n) for (const f in h) a[f] = h[f];
        return a;
      }
      class Yi extends Error {
        constructor(n, h) {
          super(h), this.message = h, this.key = n;
        }
      }
      class Is {
        constructor(n, h = []) {
          this.parent = n, this.bindings = {};
          for (const [f, m] of h) this.bindings[f] = m;
        }
        concat(n) {
          return new Is(this, n);
        }
        get(n) {
          if (this.bindings[n]) return this.bindings[n];
          if (this.parent) return this.parent.get(n);
          throw new Error(`${n} not found in scope.`);
        }
        has(n) {
          return !!this.bindings[n] || !!this.parent && this.parent.has(n);
        }
      }
      const cr = { kind: "null" }, qe = { kind: "number" }, It = { kind: "string" }, xt = { kind: "boolean" }, ds = { kind: "color" }, Qs = { kind: "object" }, wt = { kind: "value" }, hr = { kind: "collator" }, Tr = { kind: "formatted" }, Er = { kind: "padding" }, er = { kind: "resolvedImage" }, re = { kind: "variableAnchorOffsetCollection" };
      function z(a, n) {
        return { kind: "array", itemType: a, N: n };
      }
      function U(a) {
        if (a.kind === "array") {
          const n = U(a.itemType);
          return typeof a.N == "number" ? `array<${n}, ${a.N}>` : a.itemType.kind === "value" ? "array" : `array<${n}>`;
        }
        return a.kind;
      }
      const W = [cr, qe, It, xt, ds, Tr, Qs, z(wt), Er, er, re];
      function ee(a, n) {
        if (n.kind === "error") return null;
        if (a.kind === "array") {
          if (n.kind === "array" && (n.N === 0 && n.itemType.kind === "value" || !ee(a.itemType, n.itemType)) && (typeof a.N != "number" || a.N === n.N)) return null;
        } else {
          if (a.kind === n.kind) return null;
          if (a.kind === "value") {
            for (const h of W) if (!ee(h, n)) return null;
          }
        }
        return `Expected ${U(a)} but found ${U(n)} instead.`;
      }
      function ue(a, n) {
        return n.some((h) => h.kind === a.kind);
      }
      function pe(a, n) {
        return n.some((h) => h === "null" ? a === null : h === "array" ? Array.isArray(a) : h === "object" ? a && !Array.isArray(a) && typeof a == "object" : h === typeof a);
      }
      function xe(a, n) {
        return a.kind === "array" && n.kind === "array" ? a.itemType.kind === n.itemType.kind && typeof a.N == "number" : a.kind === n.kind;
      }
      const le = 0.96422, Be = 0.82521, ke = 4 / 29, Re = 6 / 29, je = 3 * Re * Re, pt = Re * Re * Re, gt = Math.PI / 180, Lt = 180 / Math.PI;
      function St(a) {
        return (a %= 360) < 0 && (a += 360), a;
      }
      function Ft([a, n, h, f]) {
        let m, b;
        const v = Ei((0.2225045 * (a = Pt(a)) + 0.7168786 * (n = Pt(n)) + 0.0606169 * (h = Pt(h))) / 1);
        a === n && n === h ? m = b = v : (m = Ei((0.4360747 * a + 0.3850649 * n + 0.1430804 * h) / le), b = Ei((0.0139322 * a + 0.0971045 * n + 0.7141733 * h) / Be));
        const A = 116 * v - 16;
        return [A < 0 ? 0 : A, 500 * (m - v), 200 * (v - b), f];
      }
      function Pt(a) {
        return a <= 0.04045 ? a / 12.92 : Math.pow((a + 0.055) / 1.055, 2.4);
      }
      function Ei(a) {
        return a > pt ? Math.pow(a, 1 / 3) : a / je + ke;
      }
      function li([a, n, h, f]) {
        let m = (a + 16) / 116, b = isNaN(n) ? m : m + n / 500, v = isNaN(h) ? m : m - h / 200;
        return m = 1 * Vt(m), b = le * Vt(b), v = Be * Vt(v), [Ct(3.1338561 * b - 1.6168667 * m - 0.4906146 * v), Ct(-0.9787684 * b + 1.9161415 * m + 0.033454 * v), Ct(0.0719453 * b - 0.2289914 * m + 1.4052427 * v), f];
      }
      function Ct(a) {
        return (a = a <= 304e-5 ? 12.92 * a : 1.055 * Math.pow(a, 1 / 2.4) - 0.055) < 0 ? 0 : a > 1 ? 1 : a;
      }
      function Vt(a) {
        return a > Re ? a * a * a : je * (a - ke);
      }
      function Zt(a) {
        return parseInt(a.padEnd(2, a), 16) / 255;
      }
      function Si(a, n) {
        return Ui(n ? a / 100 : a, 0, 1);
      }
      function Ui(a, n, h) {
        return Math.min(Math.max(n, a), h);
      }
      function ns(a) {
        return !a.some(Number.isNaN);
      }
      const Rn = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      class jt {
        constructor(n, h, f, m = 1, b = !0) {
          this.r = n, this.g = h, this.b = f, this.a = m, b || (this.r *= m, this.g *= m, this.b *= m, m || this.overwriteGetter("rgb", [n, h, f, m]));
        }
        static parse(n) {
          if (n instanceof jt) return n;
          if (typeof n != "string") return;
          const h = function(f) {
            if ((f = f.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
            const m = Rn[f];
            if (m) {
              const [v, A, E] = m;
              return [v / 255, A / 255, E / 255, 1];
            }
            if (f.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(f)) {
              const v = f.length < 6 ? 1 : 2;
              let A = 1;
              return [Zt(f.slice(A, A += v)), Zt(f.slice(A, A += v)), Zt(f.slice(A, A += v)), Zt(f.slice(A, A + v) || "ff")];
            }
            if (f.startsWith("rgb")) {
              const v = f.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (v) {
                const [A, E, R, B, F, L, V, $, X, ie, ne, Ae] = v, de = [B || " ", V || " ", ie].join("");
                if (de === "  " || de === "  /" || de === ",," || de === ",,,") {
                  const ye = [R, L, X].join(""), Pe = ye === "%%%" ? 100 : ye === "" ? 255 : 0;
                  if (Pe) {
                    const Le = [Ui(+E / Pe, 0, 1), Ui(+F / Pe, 0, 1), Ui(+$ / Pe, 0, 1), ne ? Si(+ne, Ae) : 1];
                    if (ns(Le)) return Le;
                  }
                }
                return;
              }
            }
            const b = f.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (b) {
              const [v, A, E, R, B, F, L, V, $] = b, X = [E || " ", B || " ", L].join("");
              if (X === "  " || X === "  /" || X === ",," || X === ",,,") {
                const ie = [+A, Ui(+R, 0, 100), Ui(+F, 0, 100), V ? Si(+V, $) : 1];
                if (ns(ie)) return function([ne, Ae, de, ye]) {
                  function Pe(Le) {
                    const tt = (Le + ne / 30) % 12, bt = Ae * Math.min(de, 1 - de);
                    return de - bt * Math.max(-1, Math.min(tt - 3, 9 - tt, 1));
                  }
                  return ne = St(ne), Ae /= 100, de /= 100, [Pe(0), Pe(8), Pe(4), ye];
                }(ie);
              }
            }
          }(n);
          return h ? new jt(...h, !1) : void 0;
        }
        get rgb() {
          const { r: n, g: h, b: f, a: m } = this, b = m || 1 / 0;
          return this.overwriteGetter("rgb", [n / b, h / b, f / b, m]);
        }
        get hcl() {
          return this.overwriteGetter("hcl", function(n) {
            const [h, f, m, b] = Ft(n), v = Math.sqrt(f * f + m * m);
            return [Math.round(1e4 * v) ? St(Math.atan2(m, f) * Lt) : NaN, v, h, b];
          }(this.rgb));
        }
        get lab() {
          return this.overwriteGetter("lab", Ft(this.rgb));
        }
        overwriteGetter(n, h) {
          return Object.defineProperty(this, n, { value: h }), h;
        }
        toString() {
          const [n, h, f, m] = this.rgb;
          return `rgba(${[n, h, f].map((b) => Math.round(255 * b)).join(",")},${m})`;
        }
      }
      jt.black = new jt(0, 0, 0, 1), jt.white = new jt(1, 1, 1, 1), jt.transparent = new jt(0, 0, 0, 0), jt.red = new jt(1, 0, 0, 1);
      class fs {
        constructor(n, h, f) {
          this.sensitivity = n ? h ? "variant" : "case" : h ? "accent" : "base", this.locale = f, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(n, h) {
          return this.collator.compare(n, h);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class jr {
        constructor(n, h, f, m, b) {
          this.text = n, this.image = h, this.scale = f, this.fontStack = m, this.textColor = b;
        }
      }
      class Di {
        constructor(n) {
          this.sections = n;
        }
        static fromString(n) {
          return new Di([new jr(n, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((n) => n.text.length !== 0 || n.image && n.image.name.length !== 0);
        }
        static factory(n) {
          return n instanceof Di ? n : Di.fromString(n);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((n) => n.text).join("");
        }
      }
      class Ci {
        constructor(n) {
          this.values = n.slice();
        }
        static parse(n) {
          if (n instanceof Ci) return n;
          if (typeof n == "number") return new Ci([n, n, n, n]);
          if (Array.isArray(n) && !(n.length < 1 || n.length > 4)) {
            for (const h of n) if (typeof h != "number") return;
            switch (n.length) {
              case 1:
                n = [n[0], n[0], n[0], n[0]];
                break;
              case 2:
                n = [n[0], n[1], n[0], n[1]];
                break;
              case 3:
                n = [n[0], n[1], n[2], n[1]];
            }
            return new Ci(n);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      const Yn = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
      class Ii {
        constructor(n) {
          this.values = n.slice();
        }
        static parse(n) {
          if (n instanceof Ii) return n;
          if (Array.isArray(n) && !(n.length < 1) && n.length % 2 == 0) {
            for (let h = 0; h < n.length; h += 2) {
              const f = n[h], m = n[h + 1];
              if (typeof f != "string" || !Yn.has(f) || !Array.isArray(m) || m.length !== 2 || typeof m[0] != "number" || typeof m[1] != "number") return;
            }
            return new Ii(n);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      class Ri {
        constructor(n) {
          this.name = n.name, this.available = n.available;
        }
        toString() {
          return this.name;
        }
        static fromString(n) {
          return n ? new Ri({ name: n, available: !1 }) : null;
        }
      }
      function on(a, n, h, f) {
        return typeof a == "number" && a >= 0 && a <= 255 && typeof n == "number" && n >= 0 && n <= 255 && typeof h == "number" && h >= 0 && h <= 255 ? f === void 0 || typeof f == "number" && f >= 0 && f <= 1 ? null : `Invalid rgba value [${[a, n, h, f].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof f == "number" ? [a, n, h, f] : [a, n, h]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function $r(a) {
        if (a === null || typeof a == "string" || typeof a == "boolean" || typeof a == "number" || a instanceof jt || a instanceof fs || a instanceof Di || a instanceof Ci || a instanceof Ii || a instanceof Ri) return !0;
        if (Array.isArray(a)) {
          for (const n of a) if (!$r(n)) return !1;
          return !0;
        }
        if (typeof a == "object") {
          for (const n in a) if (!$r(a[n])) return !1;
          return !0;
        }
        return !1;
      }
      function xi(a) {
        if (a === null) return cr;
        if (typeof a == "string") return It;
        if (typeof a == "boolean") return xt;
        if (typeof a == "number") return qe;
        if (a instanceof jt) return ds;
        if (a instanceof fs) return hr;
        if (a instanceof Di) return Tr;
        if (a instanceof Ci) return Er;
        if (a instanceof Ii) return re;
        if (a instanceof Ri) return er;
        if (Array.isArray(a)) {
          const n = a.length;
          let h;
          for (const f of a) {
            const m = xi(f);
            if (h) {
              if (h === m) continue;
              h = wt;
              break;
            }
            h = m;
          }
          return z(h || wt, n);
        }
        return Qs;
      }
      function os(a) {
        const n = typeof a;
        return a === null ? "" : n === "string" || n === "number" || n === "boolean" ? String(a) : a instanceof jt || a instanceof Di || a instanceof Ci || a instanceof Ii || a instanceof Ri ? a.toString() : JSON.stringify(a);
      }
      class ps {
        constructor(n, h) {
          this.type = n, this.value = h;
        }
        static parse(n, h) {
          if (n.length !== 2) return h.error(`'literal' expression requires exactly one argument, but found ${n.length - 1} instead.`);
          if (!$r(n[1])) return h.error("invalid value");
          const f = n[1];
          let m = xi(f);
          const b = h.expectedType;
          return m.kind !== "array" || m.N !== 0 || !b || b.kind !== "array" || typeof b.N == "number" && b.N !== 0 || (m = b), new ps(m, f);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      class wi {
        constructor(n) {
          this.name = "ExpressionEvaluationError", this.message = n;
        }
        toJSON() {
          return this.message;
        }
      }
      const Mn = { string: It, number: qe, boolean: xt, object: Qs };
      class Rs {
        constructor(n, h) {
          this.type = n, this.args = h;
        }
        static parse(n, h) {
          if (n.length < 2) return h.error("Expected at least one argument.");
          let f, m = 1;
          const b = n[0];
          if (b === "array") {
            let A, E;
            if (n.length > 2) {
              const R = n[1];
              if (typeof R != "string" || !(R in Mn) || R === "object") return h.error('The item type argument of "array" must be one of string, number, boolean', 1);
              A = Mn[R], m++;
            } else A = wt;
            if (n.length > 3) {
              if (n[2] !== null && (typeof n[2] != "number" || n[2] < 0 || n[2] !== Math.floor(n[2]))) return h.error('The length argument to "array" must be a positive integer literal', 2);
              E = n[2], m++;
            }
            f = z(A, E);
          } else {
            if (!Mn[b]) throw new Error(`Types doesn't contain name = ${b}`);
            f = Mn[b];
          }
          const v = [];
          for (; m < n.length; m++) {
            const A = h.parse(n[m], m, wt);
            if (!A) return null;
            v.push(A);
          }
          return new Rs(f, v);
        }
        evaluate(n) {
          for (let h = 0; h < this.args.length; h++) {
            const f = this.args[h].evaluate(n);
            if (!ee(this.type, xi(f))) return f;
            if (h === this.args.length - 1) throw new wi(`Expected value to be of type ${U(this.type)}, but found ${U(xi(f))} instead.`);
          }
          throw new Error();
        }
        eachChild(n) {
          this.args.forEach(n);
        }
        outputDefined() {
          return this.args.every((n) => n.outputDefined());
        }
      }
      const Qn = { "to-boolean": xt, "to-color": ds, "to-number": qe, "to-string": It };
      class _s {
        constructor(n, h) {
          this.type = n, this.args = h;
        }
        static parse(n, h) {
          if (n.length < 2) return h.error("Expected at least one argument.");
          const f = n[0];
          if (!Qn[f]) throw new Error(`Can't parse ${f} as it is not part of the known types`);
          if ((f === "to-boolean" || f === "to-string") && n.length !== 2) return h.error("Expected one argument.");
          const m = Qn[f], b = [];
          for (let v = 1; v < n.length; v++) {
            const A = h.parse(n[v], v, wt);
            if (!A) return null;
            b.push(A);
          }
          return new _s(m, b);
        }
        evaluate(n) {
          switch (this.type.kind) {
            case "boolean":
              return !!this.args[0].evaluate(n);
            case "color": {
              let h, f;
              for (const m of this.args) {
                if (h = m.evaluate(n), f = null, h instanceof jt) return h;
                if (typeof h == "string") {
                  const b = n.parseColor(h);
                  if (b) return b;
                } else if (Array.isArray(h) && (f = h.length < 3 || h.length > 4 ? `Invalid rbga value ${JSON.stringify(h)}: expected an array containing either three or four numeric values.` : on(h[0], h[1], h[2], h[3]), !f)) return new jt(h[0] / 255, h[1] / 255, h[2] / 255, h[3]);
              }
              throw new wi(f || `Could not parse color from value '${typeof h == "string" ? h : JSON.stringify(h)}'`);
            }
            case "padding": {
              let h;
              for (const f of this.args) {
                h = f.evaluate(n);
                const m = Ci.parse(h);
                if (m) return m;
              }
              throw new wi(`Could not parse padding from value '${typeof h == "string" ? h : JSON.stringify(h)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let h;
              for (const f of this.args) {
                h = f.evaluate(n);
                const m = Ii.parse(h);
                if (m) return m;
              }
              throw new wi(`Could not parse variableAnchorOffsetCollection from value '${typeof h == "string" ? h : JSON.stringify(h)}'`);
            }
            case "number": {
              let h = null;
              for (const f of this.args) {
                if (h = f.evaluate(n), h === null) return 0;
                const m = Number(h);
                if (!isNaN(m)) return m;
              }
              throw new wi(`Could not convert ${JSON.stringify(h)} to number.`);
            }
            case "formatted":
              return Di.fromString(os(this.args[0].evaluate(n)));
            case "resolvedImage":
              return Ri.fromString(os(this.args[0].evaluate(n)));
            default:
              return os(this.args[0].evaluate(n));
          }
        }
        eachChild(n) {
          this.args.forEach(n);
        }
        outputDefined() {
          return this.args.every((n) => n.outputDefined());
        }
      }
      const Gr = ["Unknown", "Point", "LineString", "Polygon"];
      class Eo {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? Gr[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(n) {
          let h = this._parseColorCache[n];
          return h || (h = this._parseColorCache[n] = jt.parse(n)), h;
        }
      }
      class Xr {
        constructor(n, h, f = [], m, b = new Is(), v = []) {
          this.registry = n, this.path = f, this.key = f.map((A) => `[${A}]`).join(""), this.scope = b, this.errors = v, this.expectedType = m, this._isConstant = h;
        }
        parse(n, h, f, m, b = {}) {
          return h ? this.concat(h, f, m)._parse(n, b) : this._parse(n, b);
        }
        _parse(n, h) {
          function f(m, b, v) {
            return v === "assert" ? new Rs(b, [m]) : v === "coerce" ? new _s(b, [m]) : m;
          }
          if (n !== null && typeof n != "string" && typeof n != "boolean" && typeof n != "number" || (n = ["literal", n]), Array.isArray(n)) {
            if (n.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const m = n[0];
            if (typeof m != "string") return this.error(`Expression name must be a string, but found ${typeof m} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const b = this.registry[m];
            if (b) {
              let v = b.parse(n, this);
              if (!v) return null;
              if (this.expectedType) {
                const A = this.expectedType, E = v.type;
                if (A.kind !== "string" && A.kind !== "number" && A.kind !== "boolean" && A.kind !== "object" && A.kind !== "array" || E.kind !== "value") if (A.kind !== "color" && A.kind !== "formatted" && A.kind !== "resolvedImage" || E.kind !== "value" && E.kind !== "string") if (A.kind !== "padding" || E.kind !== "value" && E.kind !== "number" && E.kind !== "array") if (A.kind !== "variableAnchorOffsetCollection" || E.kind !== "value" && E.kind !== "array") {
                  if (this.checkSubtype(A, E)) return null;
                } else v = f(v, A, h.typeAnnotation || "coerce");
                else v = f(v, A, h.typeAnnotation || "coerce");
                else v = f(v, A, h.typeAnnotation || "coerce");
                else v = f(v, A, h.typeAnnotation || "assert");
              }
              if (!(v instanceof ps) && v.type.kind !== "resolvedImage" && this._isConstant(v)) {
                const A = new Eo();
                try {
                  v = new ps(v.type, v.evaluate(A));
                } catch (E) {
                  return this.error(E.message), null;
                }
              }
              return v;
            }
            return this.error(`Unknown expression "${m}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(n === void 0 ? "'undefined' value invalid. Use null instead." : typeof n == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof n} instead.`);
        }
        concat(n, h, f) {
          const m = typeof n == "number" ? this.path.concat(n) : this.path, b = f ? this.scope.concat(f) : this.scope;
          return new Xr(this.registry, this._isConstant, m, h || null, b, this.errors);
        }
        error(n, ...h) {
          const f = `${this.key}${h.map((m) => `[${m}]`).join("")}`;
          this.errors.push(new Yi(f, n));
        }
        checkSubtype(n, h) {
          const f = ee(n, h);
          return f && this.error(f), f;
        }
      }
      class ur {
        constructor(n, h) {
          this.type = h.type, this.bindings = [].concat(n), this.result = h;
        }
        evaluate(n) {
          return this.result.evaluate(n);
        }
        eachChild(n) {
          for (const h of this.bindings) n(h[1]);
          n(this.result);
        }
        static parse(n, h) {
          if (n.length < 4) return h.error(`Expected at least 3 arguments, but found ${n.length - 1} instead.`);
          const f = [];
          for (let b = 1; b < n.length - 1; b += 2) {
            const v = n[b];
            if (typeof v != "string") return h.error(`Expected string, but found ${typeof v} instead.`, b);
            if (/[^a-zA-Z0-9_]/.test(v)) return h.error("Variable names must contain only alphanumeric characters or '_'.", b);
            const A = h.parse(n[b + 1], b + 1);
            if (!A) return null;
            f.push([v, A]);
          }
          const m = h.parse(n[n.length - 1], n.length - 1, h.expectedType, f);
          return m ? new ur(f, m) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class Ht {
        constructor(n, h) {
          this.type = h.type, this.name = n, this.boundExpression = h;
        }
        static parse(n, h) {
          if (n.length !== 2 || typeof n[1] != "string") return h.error("'var' expression requires exactly one string literal argument.");
          const f = n[1];
          return h.scope.has(f) ? new Ht(f, h.scope.get(f)) : h.error(`Unknown variable "${f}". Make sure "${f}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(n) {
          return this.boundExpression.evaluate(n);
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
      }
      class va {
        constructor(n, h, f) {
          this.type = n, this.index = h, this.input = f;
        }
        static parse(n, h) {
          if (n.length !== 3) return h.error(`Expected 2 arguments, but found ${n.length - 1} instead.`);
          const f = h.parse(n[1], 1, qe), m = h.parse(n[2], 2, z(h.expectedType || wt));
          return f && m ? new va(m.type.itemType, f, m) : null;
        }
        evaluate(n) {
          const h = this.index.evaluate(n), f = this.input.evaluate(n);
          if (h < 0) throw new wi(`Array index out of bounds: ${h} < 0.`);
          if (h >= f.length) throw new wi(`Array index out of bounds: ${h} > ${f.length - 1}.`);
          if (h !== Math.floor(h)) throw new wi(`Array index must be an integer, but found ${h} instead.`);
          return f[h];
        }
        eachChild(n) {
          n(this.index), n(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class xa {
        constructor(n, h) {
          this.type = xt, this.needle = n, this.haystack = h;
        }
        static parse(n, h) {
          if (n.length !== 3) return h.error(`Expected 2 arguments, but found ${n.length - 1} instead.`);
          const f = h.parse(n[1], 1, wt), m = h.parse(n[2], 2, wt);
          return f && m ? ue(f.type, [xt, It, qe, cr, wt]) ? new xa(f, m) : h.error(`Expected first argument to be of type boolean, string, number or null, but found ${U(f.type)} instead`) : null;
        }
        evaluate(n) {
          const h = this.needle.evaluate(n), f = this.haystack.evaluate(n);
          if (!f) return !1;
          if (!pe(h, ["boolean", "string", "number", "null"])) throw new wi(`Expected first argument to be of type boolean, string, number or null, but found ${U(xi(h))} instead.`);
          if (!pe(f, ["string", "array"])) throw new wi(`Expected second argument to be of type array or string, but found ${U(xi(f))} instead.`);
          return f.indexOf(h) >= 0;
        }
        eachChild(n) {
          n(this.needle), n(this.haystack);
        }
        outputDefined() {
          return !0;
        }
      }
      class G {
        constructor(n, h, f) {
          this.type = qe, this.needle = n, this.haystack = h, this.fromIndex = f;
        }
        static parse(n, h) {
          if (n.length <= 2 || n.length >= 5) return h.error(`Expected 3 or 4 arguments, but found ${n.length - 1} instead.`);
          const f = h.parse(n[1], 1, wt), m = h.parse(n[2], 2, wt);
          if (!f || !m) return null;
          if (!ue(f.type, [xt, It, qe, cr, wt])) return h.error(`Expected first argument to be of type boolean, string, number or null, but found ${U(f.type)} instead`);
          if (n.length === 4) {
            const b = h.parse(n[3], 3, qe);
            return b ? new G(f, m, b) : null;
          }
          return new G(f, m);
        }
        evaluate(n) {
          const h = this.needle.evaluate(n), f = this.haystack.evaluate(n);
          if (!pe(h, ["boolean", "string", "number", "null"])) throw new wi(`Expected first argument to be of type boolean, string, number or null, but found ${U(xi(h))} instead.`);
          let m;
          if (this.fromIndex && (m = this.fromIndex.evaluate(n)), pe(f, ["string"])) {
            const b = f.indexOf(h, m);
            return b === -1 ? -1 : [...f.slice(0, b)].length;
          }
          if (pe(f, ["array"])) return f.indexOf(h, m);
          throw new wi(`Expected second argument to be of type array or string, but found ${U(xi(f))} instead.`);
        }
        eachChild(n) {
          n(this.needle), n(this.haystack), this.fromIndex && n(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      class Z {
        constructor(n, h, f, m, b, v) {
          this.inputType = n, this.type = h, this.input = f, this.cases = m, this.outputs = b, this.otherwise = v;
        }
        static parse(n, h) {
          if (n.length < 5) return h.error(`Expected at least 4 arguments, but found only ${n.length - 1}.`);
          if (n.length % 2 != 1) return h.error("Expected an even number of arguments.");
          let f, m;
          h.expectedType && h.expectedType.kind !== "value" && (m = h.expectedType);
          const b = {}, v = [];
          for (let R = 2; R < n.length - 1; R += 2) {
            let B = n[R];
            const F = n[R + 1];
            Array.isArray(B) || (B = [B]);
            const L = h.concat(R);
            if (B.length === 0) return L.error("Expected at least one branch label.");
            for (const $ of B) {
              if (typeof $ != "number" && typeof $ != "string") return L.error("Branch labels must be numbers or strings.");
              if (typeof $ == "number" && Math.abs($) > Number.MAX_SAFE_INTEGER) return L.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof $ == "number" && Math.floor($) !== $) return L.error("Numeric branch labels must be integer values.");
              if (f) {
                if (L.checkSubtype(f, xi($))) return null;
              } else f = xi($);
              if (b[String($)] !== void 0) return L.error("Branch labels must be unique.");
              b[String($)] = v.length;
            }
            const V = h.parse(F, R, m);
            if (!V) return null;
            m = m || V.type, v.push(V);
          }
          const A = h.parse(n[1], 1, wt);
          if (!A) return null;
          const E = h.parse(n[n.length - 1], n.length - 1, m);
          return E ? A.type.kind !== "value" && h.concat(1).checkSubtype(f, A.type) ? null : new Z(f, m, A, b, v, E) : null;
        }
        evaluate(n) {
          const h = this.input.evaluate(n);
          return (xi(h) === this.inputType && this.outputs[this.cases[h]] || this.otherwise).evaluate(n);
        }
        eachChild(n) {
          n(this.input), this.outputs.forEach(n), n(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((n) => n.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class ce {
        constructor(n, h, f) {
          this.type = n, this.branches = h, this.otherwise = f;
        }
        static parse(n, h) {
          if (n.length < 4) return h.error(`Expected at least 3 arguments, but found only ${n.length - 1}.`);
          if (n.length % 2 != 0) return h.error("Expected an odd number of arguments.");
          let f;
          h.expectedType && h.expectedType.kind !== "value" && (f = h.expectedType);
          const m = [];
          for (let v = 1; v < n.length - 1; v += 2) {
            const A = h.parse(n[v], v, xt);
            if (!A) return null;
            const E = h.parse(n[v + 1], v + 1, f);
            if (!E) return null;
            m.push([A, E]), f = f || E.type;
          }
          const b = h.parse(n[n.length - 1], n.length - 1, f);
          if (!b) return null;
          if (!f) throw new Error("Can't infer output type");
          return new ce(f, m, b);
        }
        evaluate(n) {
          for (const [h, f] of this.branches) if (h.evaluate(n)) return f.evaluate(n);
          return this.otherwise.evaluate(n);
        }
        eachChild(n) {
          for (const [h, f] of this.branches) n(h), n(f);
          n(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([n, h]) => h.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class Me {
        constructor(n, h, f, m) {
          this.type = n, this.input = h, this.beginIndex = f, this.endIndex = m;
        }
        static parse(n, h) {
          if (n.length <= 2 || n.length >= 5) return h.error(`Expected 3 or 4 arguments, but found ${n.length - 1} instead.`);
          const f = h.parse(n[1], 1, wt), m = h.parse(n[2], 2, qe);
          if (!f || !m) return null;
          if (!ue(f.type, [z(wt), It, wt])) return h.error(`Expected first argument to be of type array or string, but found ${U(f.type)} instead`);
          if (n.length === 4) {
            const b = h.parse(n[3], 3, qe);
            return b ? new Me(f.type, f, m, b) : null;
          }
          return new Me(f.type, f, m);
        }
        evaluate(n) {
          const h = this.input.evaluate(n), f = this.beginIndex.evaluate(n);
          let m;
          if (this.endIndex && (m = this.endIndex.evaluate(n)), pe(h, ["string"])) return [...h].slice(f, m).join("");
          if (pe(h, ["array"])) return h.slice(f, m);
          throw new wi(`Expected first argument to be of type array or string, but found ${U(xi(h))} instead.`);
        }
        eachChild(n) {
          n(this.input), n(this.beginIndex), this.endIndex && n(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      function Ue(a, n) {
        const h = a.length - 1;
        let f, m, b = 0, v = h, A = 0;
        for (; b <= v; ) if (A = Math.floor((b + v) / 2), f = a[A], m = a[A + 1], f <= n) {
          if (A === h || n < m) return A;
          b = A + 1;
        } else {
          if (!(f > n)) throw new wi("Input is not a number.");
          v = A - 1;
        }
        return 0;
      }
      class lt {
        constructor(n, h, f) {
          this.type = n, this.input = h, this.labels = [], this.outputs = [];
          for (const [m, b] of f) this.labels.push(m), this.outputs.push(b);
        }
        static parse(n, h) {
          if (n.length - 1 < 4) return h.error(`Expected at least 4 arguments, but found only ${n.length - 1}.`);
          if ((n.length - 1) % 2 != 0) return h.error("Expected an even number of arguments.");
          const f = h.parse(n[1], 1, qe);
          if (!f) return null;
          const m = [];
          let b = null;
          h.expectedType && h.expectedType.kind !== "value" && (b = h.expectedType);
          for (let v = 1; v < n.length; v += 2) {
            const A = v === 1 ? -1 / 0 : n[v], E = n[v + 1], R = v, B = v + 1;
            if (typeof A != "number") return h.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', R);
            if (m.length && m[m.length - 1][0] >= A) return h.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', R);
            const F = h.parse(E, B, b);
            if (!F) return null;
            b = b || F.type, m.push([A, F]);
          }
          return new lt(b, f, m);
        }
        evaluate(n) {
          const h = this.labels, f = this.outputs;
          if (h.length === 1) return f[0].evaluate(n);
          const m = this.input.evaluate(n);
          if (m <= h[0]) return f[0].evaluate(n);
          const b = h.length;
          return m >= h[b - 1] ? f[b - 1].evaluate(n) : f[Ue(h, m)].evaluate(n);
        }
        eachChild(n) {
          n(this.input);
          for (const h of this.outputs) n(h);
        }
        outputDefined() {
          return this.outputs.every((n) => n.outputDefined());
        }
      }
      function Dt(a) {
        return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
      }
      var $i = Gi;
      function Gi(a, n, h, f) {
        this.cx = 3 * a, this.bx = 3 * (h - a) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (f - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = a, this.p1y = n, this.p2x = h, this.p2y = f;
      }
      Gi.prototype = { sampleCurveX: function(a) {
        return ((this.ax * a + this.bx) * a + this.cx) * a;
      }, sampleCurveY: function(a) {
        return ((this.ay * a + this.by) * a + this.cy) * a;
      }, sampleCurveDerivativeX: function(a) {
        return (3 * this.ax * a + 2 * this.bx) * a + this.cx;
      }, solveCurveX: function(a, n) {
        if (n === void 0 && (n = 1e-6), a < 0) return 0;
        if (a > 1) return 1;
        for (var h = a, f = 0; f < 8; f++) {
          var m = this.sampleCurveX(h) - a;
          if (Math.abs(m) < n) return h;
          var b = this.sampleCurveDerivativeX(h);
          if (Math.abs(b) < 1e-6) break;
          h -= m / b;
        }
        var v = 0, A = 1;
        for (h = a, f = 0; f < 20 && (m = this.sampleCurveX(h), !(Math.abs(m - a) < n)); f++) a > m ? v = h : A = h, h = 0.5 * (A - v) + v;
        return h;
      }, solve: function(a, n) {
        return this.sampleCurveY(this.solveCurveX(a, n));
      } };
      var as = Dt($i);
      function Qi(a, n, h) {
        return a + h * (n - a);
      }
      function wa(a, n, h) {
        return a.map((f, m) => Qi(f, n[m], h));
      }
      const Us = { number: Qi, color: function(a, n, h, f = "rgb") {
        switch (f) {
          case "rgb": {
            const [m, b, v, A] = wa(a.rgb, n.rgb, h);
            return new jt(m, b, v, A, !1);
          }
          case "hcl": {
            const [m, b, v, A] = a.hcl, [E, R, B, F] = n.hcl;
            let L, V;
            if (isNaN(m) || isNaN(E)) isNaN(m) ? isNaN(E) ? L = NaN : (L = E, v !== 1 && v !== 0 || (V = R)) : (L = m, B !== 1 && B !== 0 || (V = b));
            else {
              let Ae = E - m;
              E > m && Ae > 180 ? Ae -= 360 : E < m && m - E > 180 && (Ae += 360), L = m + h * Ae;
            }
            const [$, X, ie, ne] = function([Ae, de, ye, Pe]) {
              return Ae = isNaN(Ae) ? 0 : Ae * gt, li([ye, Math.cos(Ae) * de, Math.sin(Ae) * de, Pe]);
            }([L, V ?? Qi(b, R, h), Qi(v, B, h), Qi(A, F, h)]);
            return new jt($, X, ie, ne, !1);
          }
          case "lab": {
            const [m, b, v, A] = li(wa(a.lab, n.lab, h));
            return new jt(m, b, v, A, !1);
          }
        }
      }, array: wa, padding: function(a, n, h) {
        return new Ci(wa(a.values, n.values, h));
      }, variableAnchorOffsetCollection: function(a, n, h) {
        const f = a.values, m = n.values;
        if (f.length !== m.length) throw new wi(`Cannot interpolate values of different length. from: ${a.toString()}, to: ${n.toString()}`);
        const b = [];
        for (let v = 0; v < f.length; v += 2) {
          if (f[v] !== m[v]) throw new wi(`Cannot interpolate values containing mismatched anchors. from[${v}]: ${f[v]}, to[${v}]: ${m[v]}`);
          b.push(f[v]);
          const [A, E] = f[v + 1], [R, B] = m[v + 1];
          b.push([Qi(A, R, h), Qi(E, B, h)]);
        }
        return new Ii(b);
      } };
      class zs {
        constructor(n, h, f, m, b) {
          this.type = n, this.operator = h, this.interpolation = f, this.input = m, this.labels = [], this.outputs = [];
          for (const [v, A] of b) this.labels.push(v), this.outputs.push(A);
        }
        static interpolationFactor(n, h, f, m) {
          let b = 0;
          if (n.name === "exponential") b = pl(h, n.base, f, m);
          else if (n.name === "linear") b = pl(h, 1, f, m);
          else if (n.name === "cubic-bezier") {
            const v = n.controlPoints;
            b = new as(v[0], v[1], v[2], v[3]).solve(pl(h, 1, f, m));
          }
          return b;
        }
        static parse(n, h) {
          let [f, m, b, ...v] = n;
          if (!Array.isArray(m) || m.length === 0) return h.error("Expected an interpolation type expression.", 1);
          if (m[0] === "linear") m = { name: "linear" };
          else if (m[0] === "exponential") {
            const R = m[1];
            if (typeof R != "number") return h.error("Exponential interpolation requires a numeric base.", 1, 1);
            m = { name: "exponential", base: R };
          } else {
            if (m[0] !== "cubic-bezier") return h.error(`Unknown interpolation type ${String(m[0])}`, 1, 0);
            {
              const R = m.slice(1);
              if (R.length !== 4 || R.some((B) => typeof B != "number" || B < 0 || B > 1)) return h.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              m = { name: "cubic-bezier", controlPoints: R };
            }
          }
          if (n.length - 1 < 4) return h.error(`Expected at least 4 arguments, but found only ${n.length - 1}.`);
          if ((n.length - 1) % 2 != 0) return h.error("Expected an even number of arguments.");
          if (b = h.parse(b, 2, qe), !b) return null;
          const A = [];
          let E = null;
          f === "interpolate-hcl" || f === "interpolate-lab" ? E = ds : h.expectedType && h.expectedType.kind !== "value" && (E = h.expectedType);
          for (let R = 0; R < v.length; R += 2) {
            const B = v[R], F = v[R + 1], L = R + 3, V = R + 4;
            if (typeof B != "number") return h.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', L);
            if (A.length && A[A.length - 1][0] >= B) return h.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', L);
            const $ = h.parse(F, V, E);
            if (!$) return null;
            E = E || $.type, A.push([B, $]);
          }
          return xe(E, qe) || xe(E, ds) || xe(E, Er) || xe(E, re) || xe(E, z(qe)) ? new zs(E, f, m, b, A) : h.error(`Type ${U(E)} is not interpolatable.`);
        }
        evaluate(n) {
          const h = this.labels, f = this.outputs;
          if (h.length === 1) return f[0].evaluate(n);
          const m = this.input.evaluate(n);
          if (m <= h[0]) return f[0].evaluate(n);
          const b = h.length;
          if (m >= h[b - 1]) return f[b - 1].evaluate(n);
          const v = Ue(h, m), A = zs.interpolationFactor(this.interpolation, m, h[v], h[v + 1]), E = f[v].evaluate(n), R = f[v + 1].evaluate(n);
          switch (this.operator) {
            case "interpolate":
              return Us[this.type.kind](E, R, A);
            case "interpolate-hcl":
              return Us.color(E, R, A, "hcl");
            case "interpolate-lab":
              return Us.color(E, R, A, "lab");
          }
        }
        eachChild(n) {
          n(this.input);
          for (const h of this.outputs) n(h);
        }
        outputDefined() {
          return this.outputs.every((n) => n.outputDefined());
        }
      }
      function pl(a, n, h, f) {
        const m = f - h, b = a - h;
        return m === 0 ? 0 : n === 1 ? b / m : (Math.pow(n, b) - 1) / (Math.pow(n, m) - 1);
      }
      class _l {
        constructor(n, h) {
          this.type = n, this.args = h;
        }
        static parse(n, h) {
          if (n.length < 2) return h.error("Expectected at least one argument.");
          let f = null;
          const m = h.expectedType;
          m && m.kind !== "value" && (f = m);
          const b = [];
          for (const A of n.slice(1)) {
            const E = h.parse(A, 1 + b.length, f, void 0, { typeAnnotation: "omit" });
            if (!E) return null;
            f = f || E.type, b.push(E);
          }
          if (!f) throw new Error("No output type");
          const v = m && b.some((A) => ee(m, A.type));
          return new _l(v ? wt : f, b);
        }
        evaluate(n) {
          let h, f = null, m = 0;
          for (const b of this.args) if (m++, f = b.evaluate(n), f && f instanceof Ri && !f.available && (h || (h = f.name), f = null, m === this.args.length && (f = h)), f !== null) break;
          return f;
        }
        eachChild(n) {
          this.args.forEach(n);
        }
        outputDefined() {
          return this.args.every((n) => n.outputDefined());
        }
      }
      function ml(a, n) {
        return a === "==" || a === "!=" ? n.kind === "boolean" || n.kind === "string" || n.kind === "number" || n.kind === "null" || n.kind === "value" : n.kind === "string" || n.kind === "number" || n.kind === "value";
      }
      function Hu(a, n, h, f) {
        return f.compare(n, h) === 0;
      }
      function So(a, n, h) {
        const f = a !== "==" && a !== "!=";
        return class H1 {
          constructor(b, v, A) {
            this.type = xt, this.lhs = b, this.rhs = v, this.collator = A, this.hasUntypedArgument = b.type.kind === "value" || v.type.kind === "value";
          }
          static parse(b, v) {
            if (b.length !== 3 && b.length !== 4) return v.error("Expected two or three arguments.");
            const A = b[0];
            let E = v.parse(b[1], 1, wt);
            if (!E) return null;
            if (!ml(A, E.type)) return v.concat(1).error(`"${A}" comparisons are not supported for type '${U(E.type)}'.`);
            let R = v.parse(b[2], 2, wt);
            if (!R) return null;
            if (!ml(A, R.type)) return v.concat(2).error(`"${A}" comparisons are not supported for type '${U(R.type)}'.`);
            if (E.type.kind !== R.type.kind && E.type.kind !== "value" && R.type.kind !== "value") return v.error(`Cannot compare types '${U(E.type)}' and '${U(R.type)}'.`);
            f && (E.type.kind === "value" && R.type.kind !== "value" ? E = new Rs(R.type, [E]) : E.type.kind !== "value" && R.type.kind === "value" && (R = new Rs(E.type, [R])));
            let B = null;
            if (b.length === 4) {
              if (E.type.kind !== "string" && R.type.kind !== "string" && E.type.kind !== "value" && R.type.kind !== "value") return v.error("Cannot use collator to compare non-string types.");
              if (B = v.parse(b[3], 3, hr), !B) return null;
            }
            return new H1(E, R, B);
          }
          evaluate(b) {
            const v = this.lhs.evaluate(b), A = this.rhs.evaluate(b);
            if (f && this.hasUntypedArgument) {
              const E = xi(v), R = xi(A);
              if (E.kind !== R.kind || E.kind !== "string" && E.kind !== "number") throw new wi(`Expected arguments for "${a}" to be (string, string) or (number, number), but found (${E.kind}, ${R.kind}) instead.`);
            }
            if (this.collator && !f && this.hasUntypedArgument) {
              const E = xi(v), R = xi(A);
              if (E.kind !== "string" || R.kind !== "string") return n(b, v, A);
            }
            return this.collator ? h(b, v, A, this.collator.evaluate(b)) : n(b, v, A);
          }
          eachChild(b) {
            b(this.lhs), b(this.rhs), this.collator && b(this.collator);
          }
          outputDefined() {
            return !0;
          }
        };
      }
      const Rp = So("==", function(a, n, h) {
        return n === h;
      }, Hu), ju = So("!=", function(a, n, h) {
        return n !== h;
      }, function(a, n, h, f) {
        return !Hu(0, n, h, f);
      }), $u = So("<", function(a, n, h) {
        return n < h;
      }, function(a, n, h, f) {
        return f.compare(n, h) < 0;
      }), Mp = So(">", function(a, n, h) {
        return n > h;
      }, function(a, n, h, f) {
        return f.compare(n, h) > 0;
      }), Pp = So("<=", function(a, n, h) {
        return n <= h;
      }, function(a, n, h, f) {
        return f.compare(n, h) <= 0;
      }), Gu = So(">=", function(a, n, h) {
        return n >= h;
      }, function(a, n, h, f) {
        return f.compare(n, h) >= 0;
      });
      class Aa {
        constructor(n, h, f) {
          this.type = hr, this.locale = f, this.caseSensitive = n, this.diacriticSensitive = h;
        }
        static parse(n, h) {
          if (n.length !== 2) return h.error("Expected one argument.");
          const f = n[1];
          if (typeof f != "object" || Array.isArray(f)) return h.error("Collator options argument must be an object.");
          const m = h.parse(f["case-sensitive"] !== void 0 && f["case-sensitive"], 1, xt);
          if (!m) return null;
          const b = h.parse(f["diacritic-sensitive"] !== void 0 && f["diacritic-sensitive"], 1, xt);
          if (!b) return null;
          let v = null;
          return f.locale && (v = h.parse(f.locale, 1, It), !v) ? null : new Aa(m, b, v);
        }
        evaluate(n) {
          return new fs(this.caseSensitive.evaluate(n), this.diacriticSensitive.evaluate(n), this.locale ? this.locale.evaluate(n) : null);
        }
        eachChild(n) {
          n(this.caseSensitive), n(this.diacriticSensitive), this.locale && n(this.locale);
        }
        outputDefined() {
          return !1;
        }
      }
      class Xc {
        constructor(n, h, f, m, b) {
          this.type = It, this.number = n, this.locale = h, this.currency = f, this.minFractionDigits = m, this.maxFractionDigits = b;
        }
        static parse(n, h) {
          if (n.length !== 3) return h.error("Expected two arguments.");
          const f = h.parse(n[1], 1, qe);
          if (!f) return null;
          const m = n[2];
          if (typeof m != "object" || Array.isArray(m)) return h.error("NumberFormat options argument must be an object.");
          let b = null;
          if (m.locale && (b = h.parse(m.locale, 1, It), !b)) return null;
          let v = null;
          if (m.currency && (v = h.parse(m.currency, 1, It), !v)) return null;
          let A = null;
          if (m["min-fraction-digits"] && (A = h.parse(m["min-fraction-digits"], 1, qe), !A)) return null;
          let E = null;
          return m["max-fraction-digits"] && (E = h.parse(m["max-fraction-digits"], 1, qe), !E) ? null : new Xc(f, b, v, A, E);
        }
        evaluate(n) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(n) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(n) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(n) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(n) : void 0 }).format(this.number.evaluate(n));
        }
        eachChild(n) {
          n(this.number), this.locale && n(this.locale), this.currency && n(this.currency), this.minFractionDigits && n(this.minFractionDigits), this.maxFractionDigits && n(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
      }
      class gl {
        constructor(n) {
          this.type = Tr, this.sections = n;
        }
        static parse(n, h) {
          if (n.length < 2) return h.error("Expected at least one argument.");
          const f = n[1];
          if (!Array.isArray(f) && typeof f == "object") return h.error("First argument must be an image or text section.");
          const m = [];
          let b = !1;
          for (let v = 1; v <= n.length - 1; ++v) {
            const A = n[v];
            if (b && typeof A == "object" && !Array.isArray(A)) {
              b = !1;
              let E = null;
              if (A["font-scale"] && (E = h.parse(A["font-scale"], 1, qe), !E)) return null;
              let R = null;
              if (A["text-font"] && (R = h.parse(A["text-font"], 1, z(It)), !R)) return null;
              let B = null;
              if (A["text-color"] && (B = h.parse(A["text-color"], 1, ds), !B)) return null;
              const F = m[m.length - 1];
              F.scale = E, F.font = R, F.textColor = B;
            } else {
              const E = h.parse(n[v], 1, wt);
              if (!E) return null;
              const R = E.type.kind;
              if (R !== "string" && R !== "value" && R !== "null" && R !== "resolvedImage") return h.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              b = !0, m.push({ content: E, scale: null, font: null, textColor: null });
            }
          }
          return new gl(m);
        }
        evaluate(n) {
          return new Di(this.sections.map((h) => {
            const f = h.content.evaluate(n);
            return xi(f) === er ? new jr("", f, null, null, null) : new jr(os(f), null, h.scale ? h.scale.evaluate(n) : null, h.font ? h.font.evaluate(n).join(",") : null, h.textColor ? h.textColor.evaluate(n) : null);
          }));
        }
        eachChild(n) {
          for (const h of this.sections) n(h.content), h.scale && n(h.scale), h.font && n(h.font), h.textColor && n(h.textColor);
        }
        outputDefined() {
          return !1;
        }
      }
      class Wc {
        constructor(n) {
          this.type = er, this.input = n;
        }
        static parse(n, h) {
          if (n.length !== 2) return h.error("Expected two arguments.");
          const f = h.parse(n[1], 1, It);
          return f ? new Wc(f) : h.error("No image name provided.");
        }
        evaluate(n) {
          const h = this.input.evaluate(n), f = Ri.fromString(h);
          return f && n.availableImages && (f.available = n.availableImages.indexOf(h) > -1), f;
        }
        eachChild(n) {
          n(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class qc {
        constructor(n) {
          this.type = qe, this.input = n;
        }
        static parse(n, h) {
          if (n.length !== 2) return h.error(`Expected 1 argument, but found ${n.length - 1} instead.`);
          const f = h.parse(n[1], 1);
          return f ? f.type.kind !== "array" && f.type.kind !== "string" && f.type.kind !== "value" ? h.error(`Expected argument of type string or array, but found ${U(f.type)} instead.`) : new qc(f) : null;
        }
        evaluate(n) {
          const h = this.input.evaluate(n);
          if (typeof h == "string") return [...h].length;
          if (Array.isArray(h)) return h.length;
          throw new wi(`Expected value to be of type string or array, but found ${U(xi(h))} instead.`);
        }
        eachChild(n) {
          n(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      const Wr = 8192;
      function Bp(a, n) {
        const h = (180 + a[0]) / 360, f = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a[1] * Math.PI / 360))) / 360, m = Math.pow(2, n.z);
        return [Math.round(h * m * Wr), Math.round(f * m * Wr)];
      }
      function Zc(a, n) {
        const h = Math.pow(2, n.z);
        return [(m = (a[0] / Wr + n.x) / h, 360 * m - 180), (f = (a[1] / Wr + n.y) / h, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * f) * Math.PI / 180)) - 90)];
        var f, m;
      }
      function eo(a, n) {
        a[0] = Math.min(a[0], n[0]), a[1] = Math.min(a[1], n[1]), a[2] = Math.max(a[2], n[0]), a[3] = Math.max(a[3], n[1]);
      }
      function Pn(a, n) {
        return !(a[0] <= n[0] || a[2] >= n[2] || a[1] <= n[1] || a[3] >= n[3]);
      }
      function qt(a, n, h) {
        const f = a[0] - n[0], m = a[1] - n[1], b = a[0] - h[0], v = a[1] - h[1];
        return f * v - b * m == 0 && f * b <= 0 && m * v <= 0;
      }
      function yl(a, n, h, f) {
        return (m = [f[0] - h[0], f[1] - h[1]])[0] * (b = [n[0] - a[0], n[1] - a[1]])[1] - m[1] * b[0] != 0 && !(!Wu(a, n, h, f) || !Wu(h, f, a, n));
        var m, b;
      }
      function Dp(a, n, h) {
        for (const f of h) for (let m = 0; m < f.length - 1; ++m) if (yl(a, n, f[m], f[m + 1])) return !0;
        return !1;
      }
      function Co(a, n, h = !1) {
        let f = !1;
        for (const A of n) for (let E = 0; E < A.length - 1; E++) {
          if (qt(a, A[E], A[E + 1])) return h;
          (b = A[E])[1] > (m = a)[1] != (v = A[E + 1])[1] > m[1] && m[0] < (v[0] - b[0]) * (m[1] - b[1]) / (v[1] - b[1]) + b[0] && (f = !f);
        }
        var m, b, v;
        return f;
      }
      function Op(a, n) {
        for (const h of n) if (Co(a, h)) return !0;
        return !1;
      }
      function Xu(a, n) {
        for (const h of a) if (!Co(h, n)) return !1;
        for (let h = 0; h < a.length - 1; ++h) if (Dp(a[h], a[h + 1], n)) return !1;
        return !0;
      }
      function Fp(a, n) {
        for (const h of n) if (Xu(a, h)) return !0;
        return !1;
      }
      function Wu(a, n, h, f) {
        const m = f[0] - h[0], b = f[1] - h[1], v = (a[0] - h[0]) * b - m * (a[1] - h[1]), A = (n[0] - h[0]) * b - m * (n[1] - h[1]);
        return v > 0 && A < 0 || v < 0 && A > 0;
      }
      function Kc(a, n, h) {
        const f = [];
        for (let m = 0; m < a.length; m++) {
          const b = [];
          for (let v = 0; v < a[m].length; v++) {
            const A = Bp(a[m][v], h);
            eo(n, A), b.push(A);
          }
          f.push(b);
        }
        return f;
      }
      function qu(a, n, h) {
        const f = [];
        for (let m = 0; m < a.length; m++) {
          const b = Kc(a[m], n, h);
          f.push(b);
        }
        return f;
      }
      function Zu(a, n, h, f) {
        if (a[0] < h[0] || a[0] > h[2]) {
          const m = 0.5 * f;
          let b = a[0] - h[0] > m ? -f : h[0] - a[0] > m ? f : 0;
          b === 0 && (b = a[0] - h[2] > m ? -f : h[2] - a[0] > m ? f : 0), a[0] += b;
        }
        eo(n, a);
      }
      function Ku(a, n, h, f) {
        const m = Math.pow(2, f.z) * Wr, b = [f.x * Wr, f.y * Wr], v = [];
        for (const A of a) for (const E of A) {
          const R = [E.x + b[0], E.y + b[1]];
          Zu(R, n, h, m), v.push(R);
        }
        return v;
      }
      function Ju(a, n, h, f) {
        const m = Math.pow(2, f.z) * Wr, b = [f.x * Wr, f.y * Wr], v = [];
        for (const E of a) {
          const R = [];
          for (const B of E) {
            const F = [B.x + b[0], B.y + b[1]];
            eo(n, F), R.push(F);
          }
          v.push(R);
        }
        if (n[2] - n[0] <= m / 2) {
          (A = n)[0] = A[1] = 1 / 0, A[2] = A[3] = -1 / 0;
          for (const E of v) for (const R of E) Zu(R, n, h, m);
        }
        var A;
        return v;
      }
      class to {
        constructor(n, h) {
          this.type = xt, this.geojson = n, this.geometries = h;
        }
        static parse(n, h) {
          if (n.length !== 2) return h.error(`'within' expression requires exactly one argument, but found ${n.length - 1} instead.`);
          if ($r(n[1])) {
            const f = n[1];
            if (f.type === "FeatureCollection") {
              const m = [];
              for (const b of f.features) {
                const { type: v, coordinates: A } = b.geometry;
                v === "Polygon" && m.push(A), v === "MultiPolygon" && m.push(...A);
              }
              if (m.length) return new to(f, { type: "MultiPolygon", coordinates: m });
            } else if (f.type === "Feature") {
              const m = f.geometry.type;
              if (m === "Polygon" || m === "MultiPolygon") return new to(f, f.geometry);
            } else if (f.type === "Polygon" || f.type === "MultiPolygon") return new to(f, f);
          }
          return h.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(n) {
          if (n.geometry() != null && n.canonicalID() != null) {
            if (n.geometryType() === "Point") return function(h, f) {
              const m = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = h.canonicalID();
              if (f.type === "Polygon") {
                const A = Kc(f.coordinates, b, v), E = Ku(h.geometry(), m, b, v);
                if (!Pn(m, b)) return !1;
                for (const R of E) if (!Co(R, A)) return !1;
              }
              if (f.type === "MultiPolygon") {
                const A = qu(f.coordinates, b, v), E = Ku(h.geometry(), m, b, v);
                if (!Pn(m, b)) return !1;
                for (const R of E) if (!Op(R, A)) return !1;
              }
              return !0;
            }(n, this.geometries);
            if (n.geometryType() === "LineString") return function(h, f) {
              const m = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = h.canonicalID();
              if (f.type === "Polygon") {
                const A = Kc(f.coordinates, b, v), E = Ju(h.geometry(), m, b, v);
                if (!Pn(m, b)) return !1;
                for (const R of E) if (!Xu(R, A)) return !1;
              }
              if (f.type === "MultiPolygon") {
                const A = qu(f.coordinates, b, v), E = Ju(h.geometry(), m, b, v);
                if (!Pn(m, b)) return !1;
                for (const R of E) if (!Fp(R, A)) return !1;
              }
              return !0;
            }(n, this.geometries);
          }
          return !1;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      let Yu = class {
        constructor(a = [], n = (h, f) => h < f ? -1 : h > f ? 1 : 0) {
          if (this.data = a, this.length = this.data.length, this.compare = n, this.length > 0) for (let h = (this.length >> 1) - 1; h >= 0; h--) this._down(h);
        }
        push(a) {
          this.data.push(a), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const a = this.data[0], n = this.data.pop();
          return --this.length > 0 && (this.data[0] = n, this._down(0)), a;
        }
        peek() {
          return this.data[0];
        }
        _up(a) {
          const { data: n, compare: h } = this, f = n[a];
          for (; a > 0; ) {
            const m = a - 1 >> 1, b = n[m];
            if (h(f, b) >= 0) break;
            n[a] = b, a = m;
          }
          n[a] = f;
        }
        _down(a) {
          const { data: n, compare: h } = this, f = this.length >> 1, m = n[a];
          for (; a < f; ) {
            let b = 1 + (a << 1);
            const v = b + 1;
            if (v < this.length && h(n[v], n[b]) < 0 && (b = v), h(n[b], m) >= 0) break;
            n[a] = n[b], a = b;
          }
          n[a] = m;
        }
      };
      function kp(a, n, h, f, m) {
        Qu(a, n, h, f || a.length - 1, m || Np);
      }
      function Qu(a, n, h, f, m) {
        for (; f > h; ) {
          if (f - h > 600) {
            var b = f - h + 1, v = n - h + 1, A = Math.log(b), E = 0.5 * Math.exp(2 * A / 3), R = 0.5 * Math.sqrt(A * E * (b - E) / b) * (v - b / 2 < 0 ? -1 : 1);
            Qu(a, n, Math.max(h, Math.floor(n - v * E / b + R)), Math.min(f, Math.floor(n + (b - v) * E / b + R)), m);
          }
          var B = a[n], F = h, L = f;
          for (Ta(a, h, n), m(a[f], B) > 0 && Ta(a, h, f); F < L; ) {
            for (Ta(a, F, L), F++, L--; m(a[F], B) < 0; ) F++;
            for (; m(a[L], B) > 0; ) L--;
          }
          m(a[h], B) === 0 ? Ta(a, h, L) : Ta(a, ++L, f), L <= n && (h = L + 1), n <= L && (f = L - 1);
        }
      }
      function Ta(a, n, h) {
        var f = a[n];
        a[n] = a[h], a[h] = f;
      }
      function Np(a, n) {
        return a < n ? -1 : a > n ? 1 : 0;
      }
      function bl(a, n) {
        if (a.length <= 1) return [a];
        const h = [];
        let f, m;
        for (const b of a) {
          const v = Up(b);
          v !== 0 && (b.area = Math.abs(v), m === void 0 && (m = v < 0), m === v < 0 ? (f && h.push(f), f = [b]) : f.push(b));
        }
        if (f && h.push(f), n > 1) for (let b = 0; b < h.length; b++) h[b].length <= n || (kp(h[b], n, 1, h[b].length - 1, Lp), h[b] = h[b].slice(0, n));
        return h;
      }
      function Lp(a, n) {
        return n.area - a.area;
      }
      function Up(a) {
        let n = 0;
        for (let h, f, m = 0, b = a.length, v = b - 1; m < b; v = m++) h = a[m], f = a[v], n += (f.x - h.x) * (h.y + f.y);
        return n;
      }
      const ed = 1 / 298.257223563, td = ed * (2 - ed), id = Math.PI / 180;
      class Jc {
        constructor(n) {
          const h = 6378.137 * id * 1e3, f = Math.cos(n * id), m = 1 / (1 - td * (1 - f * f)), b = Math.sqrt(m);
          this.kx = h * b * f, this.ky = h * b * m * (1 - td);
        }
        distance(n, h) {
          const f = this.wrap(n[0] - h[0]) * this.kx, m = (n[1] - h[1]) * this.ky;
          return Math.sqrt(f * f + m * m);
        }
        pointOnLine(n, h) {
          let f, m, b, v, A = 1 / 0;
          for (let E = 0; E < n.length - 1; E++) {
            let R = n[E][0], B = n[E][1], F = this.wrap(n[E + 1][0] - R) * this.kx, L = (n[E + 1][1] - B) * this.ky, V = 0;
            F === 0 && L === 0 || (V = (this.wrap(h[0] - R) * this.kx * F + (h[1] - B) * this.ky * L) / (F * F + L * L), V > 1 ? (R = n[E + 1][0], B = n[E + 1][1]) : V > 0 && (R += F / this.kx * V, B += L / this.ky * V)), F = this.wrap(h[0] - R) * this.kx, L = (h[1] - B) * this.ky;
            const $ = F * F + L * L;
            $ < A && (A = $, f = R, m = B, b = E, v = V);
          }
          return { point: [f, m], index: b, t: Math.max(0, Math.min(1, v)) };
        }
        wrap(n) {
          for (; n < -180; ) n += 360;
          for (; n > 180; ) n -= 360;
          return n;
        }
      }
      function sd(a, n) {
        return n[0] - a[0];
      }
      function vl(a) {
        return a[1] - a[0] + 1;
      }
      function an(a, n) {
        return a[1] >= a[0] && a[1] < n;
      }
      function Yc(a, n) {
        if (a[0] > a[1]) return [null, null];
        const h = vl(a);
        if (n) {
          if (h === 2) return [a, null];
          const m = Math.floor(h / 2);
          return [[a[0], a[0] + m], [a[0] + m, a[1]]];
        }
        if (h === 1) return [a, null];
        const f = Math.floor(h / 2) - 1;
        return [[a[0], a[0] + f], [a[0] + f + 1, a[1]]];
      }
      function Qc(a, n) {
        if (!an(n, a.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let f = n[0]; f <= n[1]; ++f) eo(h, a[f]);
        return h;
      }
      function eh(a) {
        const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const h of a) for (const f of h) eo(n, f);
        return n;
      }
      function xl(a) {
        return a[0] !== -1 / 0 && a[1] !== -1 / 0 && a[2] !== 1 / 0 && a[3] !== 1 / 0;
      }
      function th(a, n, h) {
        if (!xl(a) || !xl(n)) return NaN;
        let f = 0, m = 0;
        return a[2] < n[0] && (f = n[0] - a[2]), a[0] > n[2] && (f = a[0] - n[2]), a[1] > n[3] && (m = a[1] - n[3]), a[3] < n[1] && (m = n[1] - a[3]), h.distance([0, 0], [f, m]);
      }
      function io(a, n, h) {
        const f = h.pointOnLine(n, a);
        return h.distance(a, f.point);
      }
      function ih(a, n, h, f, m) {
        const b = Math.min(io(a, [h, f], m), io(n, [h, f], m)), v = Math.min(io(h, [a, n], m), io(f, [a, n], m));
        return Math.min(b, v);
      }
      function zp(a, n, h, f, m) {
        if (!an(n, a.length) || !an(f, h.length)) return 1 / 0;
        let b = 1 / 0;
        for (let v = n[0]; v < n[1]; ++v) {
          const A = a[v], E = a[v + 1];
          for (let R = f[0]; R < f[1]; ++R) {
            const B = h[R], F = h[R + 1];
            if (yl(A, E, B, F)) return 0;
            b = Math.min(b, ih(A, E, B, F, m));
          }
        }
        return b;
      }
      function Oi(a, n, h, f, m) {
        if (!an(n, a.length) || !an(f, h.length)) return NaN;
        let b = 1 / 0;
        for (let v = n[0]; v <= n[1]; ++v) for (let A = f[0]; A <= f[1]; ++A) if (b = Math.min(b, m.distance(a[v], h[A])), b === 0) return b;
        return b;
      }
      function Vp(a, n, h) {
        if (Co(a, n, !0)) return 0;
        let f = 1 / 0;
        for (const m of n) {
          const b = m[0], v = m[m.length - 1];
          if (b !== v && (f = Math.min(f, io(a, [v, b], h)), f === 0)) return f;
          const A = h.pointOnLine(m, a);
          if (f = Math.min(f, h.distance(a, A.point)), f === 0) return f;
        }
        return f;
      }
      function Bt(a, n, h, f) {
        if (!an(n, a.length)) return NaN;
        for (let b = n[0]; b <= n[1]; ++b) if (Co(a[b], h, !0)) return 0;
        let m = 1 / 0;
        for (let b = n[0]; b < n[1]; ++b) {
          const v = a[b], A = a[b + 1];
          for (const E of h) for (let R = 0, B = E.length, F = B - 1; R < B; F = R++) {
            const L = E[F], V = E[R];
            if (yl(v, A, L, V)) return 0;
            m = Math.min(m, ih(v, A, L, V, f));
          }
        }
        return m;
      }
      function wl(a, n) {
        for (const h of a) for (const f of h) if (Co(f, n, !0)) return !0;
        return !1;
      }
      function ci(a, n, h, f = 1 / 0) {
        const m = eh(a), b = eh(n);
        if (f !== 1 / 0 && th(m, b, h) >= f) return f;
        if (Pn(m, b)) {
          if (wl(a, n)) return 0;
        } else if (wl(n, a)) return 0;
        let v = 1 / 0;
        for (const A of a) for (let E = 0, R = A.length, B = R - 1; E < R; B = E++) {
          const F = A[B], L = A[E];
          for (const V of n) for (let $ = 0, X = V.length, ie = X - 1; $ < X; ie = $++) {
            const ne = V[ie], Ae = V[$];
            if (yl(F, L, ne, Ae)) return 0;
            v = Math.min(v, ih(F, L, ne, Ae, h));
          }
        }
        return v;
      }
      function ei(a, n, h, f, m, b) {
        if (!b) return;
        const v = th(Qc(f, b), m, h);
        v < n && a.push([v, b, [0, 0]]);
      }
      function so(a, n, h, f, m, b, v) {
        if (!b || !v) return;
        const A = th(Qc(f, b), Qc(m, v), h);
        A < n && a.push([A, b, v]);
      }
      function Ea(a, n, h, f, m = 1 / 0) {
        let b = Math.min(f.distance(a[0], h[0][0]), m);
        if (b === 0) return b;
        const v = new Yu([[0, [0, a.length - 1], [0, 0]]], sd), A = eh(h);
        for (; v.length > 0; ) {
          const E = v.pop();
          if (E[0] >= b) continue;
          const R = E[1], B = n ? 50 : 100;
          if (vl(R) <= B) {
            if (!an(R, a.length)) return NaN;
            if (n) {
              const F = Bt(a, R, h, f);
              if (isNaN(F) || F === 0) return F;
              b = Math.min(b, F);
            } else for (let F = R[0]; F <= R[1]; ++F) {
              const L = Vp(a[F], h, f);
              if (b = Math.min(b, L), b === 0) return 0;
            }
          } else {
            const F = Yc(R, n);
            ei(v, b, f, a, A, F[0]), ei(v, b, f, a, A, F[1]);
          }
        }
        return b;
      }
      function Sa(a, n, h, f, m, b = 1 / 0) {
        let v = Math.min(b, m.distance(a[0], h[0]));
        if (v === 0) return v;
        const A = new Yu([[0, [0, a.length - 1], [0, h.length - 1]]], sd);
        for (; A.length > 0; ) {
          const E = A.pop();
          if (E[0] >= v) continue;
          const R = E[1], B = E[2], F = n ? 50 : 100, L = f ? 50 : 100;
          if (vl(R) <= F && vl(B) <= L) {
            if (!an(R, a.length) && an(B, h.length)) return NaN;
            let V;
            if (n && f) V = zp(a, R, h, B, m), v = Math.min(v, V);
            else if (n && !f) {
              const $ = a.slice(R[0], R[1] + 1);
              for (let X = B[0]; X <= B[1]; ++X) if (V = io(h[X], $, m), v = Math.min(v, V), v === 0) return v;
            } else if (!n && f) {
              const $ = h.slice(B[0], B[1] + 1);
              for (let X = R[0]; X <= R[1]; ++X) if (V = io(a[X], $, m), v = Math.min(v, V), v === 0) return v;
            } else V = Oi(a, R, h, B, m), v = Math.min(v, V);
          } else {
            const V = Yc(R, n), $ = Yc(B, f);
            so(A, v, m, a, h, V[0], $[0]), so(A, v, m, a, h, V[0], $[1]), so(A, v, m, a, h, V[1], $[0]), so(A, v, m, a, h, V[1], $[1]);
          }
        }
        return v;
      }
      function sh(a) {
        return a.type === "MultiPolygon" ? a.coordinates.map((n) => ({ type: "Polygon", coordinates: n })) : a.type === "MultiLineString" ? a.coordinates.map((n) => ({ type: "LineString", coordinates: n })) : a.type === "MultiPoint" ? a.coordinates.map((n) => ({ type: "Point", coordinates: n })) : [a];
      }
      class ro {
        constructor(n, h) {
          this.type = qe, this.geojson = n, this.geometries = h;
        }
        static parse(n, h) {
          if (n.length !== 2) return h.error(`'distance' expression requires exactly one argument, but found ${n.length - 1} instead.`);
          if ($r(n[1])) {
            const f = n[1];
            if (f.type === "FeatureCollection") return new ro(f, f.features.map((m) => sh(m.geometry)).flat());
            if (f.type === "Feature") return new ro(f, sh(f.geometry));
            if ("type" in f && "coordinates" in f) return new ro(f, sh(f));
          }
          return h.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(n) {
          if (n.geometry() != null && n.canonicalID() != null) {
            if (n.geometryType() === "Point") return function(h, f) {
              const m = h.geometry(), b = m.flat().map((E) => Zc([E.x, E.y], h.canonical));
              if (m.length === 0) return NaN;
              const v = new Jc(b[0][1]);
              let A = 1 / 0;
              for (const E of f) {
                switch (E.type) {
                  case "Point":
                    A = Math.min(A, Sa(b, !1, [E.coordinates], !1, v, A));
                    break;
                  case "LineString":
                    A = Math.min(A, Sa(b, !1, E.coordinates, !0, v, A));
                    break;
                  case "Polygon":
                    A = Math.min(A, Ea(b, !1, E.coordinates, v, A));
                }
                if (A === 0) return A;
              }
              return A;
            }(n, this.geometries);
            if (n.geometryType() === "LineString") return function(h, f) {
              const m = h.geometry(), b = m.flat().map((E) => Zc([E.x, E.y], h.canonical));
              if (m.length === 0) return NaN;
              const v = new Jc(b[0][1]);
              let A = 1 / 0;
              for (const E of f) {
                switch (E.type) {
                  case "Point":
                    A = Math.min(A, Sa(b, !0, [E.coordinates], !1, v, A));
                    break;
                  case "LineString":
                    A = Math.min(A, Sa(b, !0, E.coordinates, !0, v, A));
                    break;
                  case "Polygon":
                    A = Math.min(A, Ea(b, !0, E.coordinates, v, A));
                }
                if (A === 0) return A;
              }
              return A;
            }(n, this.geometries);
            if (n.geometryType() === "Polygon") return function(h, f) {
              const m = h.geometry();
              if (m.length === 0 || m[0].length === 0) return NaN;
              const b = bl(m, 0).map((E) => E.map((R) => R.map((B) => Zc([B.x, B.y], h.canonical)))), v = new Jc(b[0][0][0][1]);
              let A = 1 / 0;
              for (const E of f) for (const R of b) {
                switch (E.type) {
                  case "Point":
                    A = Math.min(A, Ea([E.coordinates], !1, R, v, A));
                    break;
                  case "LineString":
                    A = Math.min(A, Ea(E.coordinates, !0, R, v, A));
                    break;
                  case "Polygon":
                    A = Math.min(A, ci(R, E.coordinates, v, A));
                }
                if (A === 0) return A;
              }
              return A;
            }(n, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      const Io = { "==": Rp, "!=": ju, ">": Mp, "<": $u, ">=": Gu, "<=": Pp, array: Rs, at: va, boolean: Rs, case: ce, coalesce: _l, collator: Aa, format: gl, image: Wc, in: xa, "index-of": G, interpolate: zs, "interpolate-hcl": zs, "interpolate-lab": zs, length: qc, let: ur, literal: ps, match: Z, number: Rs, "number-format": Xc, object: Rs, slice: Me, step: lt, string: Rs, "to-boolean": _s, "to-color": _s, "to-number": _s, "to-string": _s, var: Ht, within: to, distance: ro };
      class dr {
        constructor(n, h, f, m) {
          this.name = n, this.type = h, this._evaluate = f, this.args = m;
        }
        evaluate(n) {
          return this._evaluate(n, this.args);
        }
        eachChild(n) {
          this.args.forEach(n);
        }
        outputDefined() {
          return !1;
        }
        static parse(n, h) {
          const f = n[0], m = dr.definitions[f];
          if (!m) return h.error(`Unknown expression "${f}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const b = Array.isArray(m) ? m[0] : m.type, v = Array.isArray(m) ? [[m[1], m[2]]] : m.overloads, A = v.filter(([R]) => !Array.isArray(R) || R.length === n.length - 1);
          let E = null;
          for (const [R, B] of A) {
            E = new Xr(h.registry, Ca, h.path, null, h.scope);
            const F = [];
            let L = !1;
            for (let V = 1; V < n.length; V++) {
              const $ = n[V], X = Array.isArray(R) ? R[V - 1] : R.type, ie = E.parse($, 1 + F.length, X);
              if (!ie) {
                L = !0;
                break;
              }
              F.push(ie);
            }
            if (!L) if (Array.isArray(R) && R.length !== F.length) E.error(`Expected ${R.length} arguments, but found ${F.length} instead.`);
            else {
              for (let V = 0; V < F.length; V++) {
                const $ = Array.isArray(R) ? R[V] : R.type, X = F[V];
                E.concat(V + 1).checkSubtype($, X.type);
              }
              if (E.errors.length === 0) return new dr(f, b, B, F);
            }
          }
          if (A.length === 1) h.errors.push(...E.errors);
          else {
            const R = (A.length ? A : v).map(([F]) => {
              return L = F, Array.isArray(L) ? `(${L.map(U).join(", ")})` : `(${U(L.type)}...)`;
              var L;
            }).join(" | "), B = [];
            for (let F = 1; F < n.length; F++) {
              const L = h.parse(n[F], 1 + B.length);
              if (!L) return null;
              B.push(U(L.type));
            }
            h.error(`Expected arguments of type ${R}, but found (${B.join(", ")}) instead.`);
          }
          return null;
        }
        static register(n, h) {
          dr.definitions = h;
          for (const f in h) n[f] = dr;
        }
      }
      function rh(a, [n, h, f, m]) {
        n = n.evaluate(a), h = h.evaluate(a), f = f.evaluate(a);
        const b = m ? m.evaluate(a) : 1, v = on(n, h, f, b);
        if (v) throw new wi(v);
        return new jt(n / 255, h / 255, f / 255, b, !1);
      }
      function nh(a, n) {
        return a in n;
      }
      function oh(a, n) {
        const h = n[a];
        return h === void 0 ? null : h;
      }
      function no(a) {
        return { type: a };
      }
      function Ca(a) {
        if (a instanceof Ht) return Ca(a.boundExpression);
        if (a instanceof dr && a.name === "error" || a instanceof Aa || a instanceof to || a instanceof ro) return !1;
        const n = a instanceof _s || a instanceof Rs;
        let h = !0;
        return a.eachChild((f) => {
          h = n ? h && Ca(f) : h && f instanceof ps;
        }), !!h && Ia(a) && Ra(a, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
      }
      function Ia(a) {
        if (a instanceof dr && (a.name === "get" && a.args.length === 1 || a.name === "feature-state" || a.name === "has" && a.args.length === 1 || a.name === "properties" || a.name === "geometry-type" || a.name === "id" || /^filter-/.test(a.name)) || a instanceof to || a instanceof ro) return !1;
        let n = !0;
        return a.eachChild((h) => {
          n && !Ia(h) && (n = !1);
        }), n;
      }
      function Ro(a) {
        if (a instanceof dr && a.name === "feature-state") return !1;
        let n = !0;
        return a.eachChild((h) => {
          n && !Ro(h) && (n = !1);
        }), n;
      }
      function Ra(a, n) {
        if (a instanceof dr && n.indexOf(a.name) >= 0) return !1;
        let h = !0;
        return a.eachChild((f) => {
          h && !Ra(f, n) && (h = !1);
        }), h;
      }
      function Al(a) {
        return { result: "success", value: a };
      }
      function Mo(a) {
        return { result: "error", value: a };
      }
      function Po(a) {
        return a["property-type"] === "data-driven" || a["property-type"] === "cross-faded-data-driven";
      }
      function rd(a) {
        return !!a.expression && a.expression.parameters.indexOf("zoom") > -1;
      }
      function ah(a) {
        return !!a.expression && a.expression.interpolated;
      }
      function $t(a) {
        return a instanceof Number ? "number" : a instanceof String ? "string" : a instanceof Boolean ? "boolean" : Array.isArray(a) ? "array" : a === null ? "null" : typeof a;
      }
      function Tl(a) {
        return typeof a == "object" && a !== null && !Array.isArray(a);
      }
      function Hp(a) {
        return a;
      }
      function nd(a, n) {
        const h = n.type === "color", f = a.stops && typeof a.stops[0][0] == "object", m = f || !(f || a.property !== void 0), b = a.type || (ah(n) ? "exponential" : "interval");
        if (h || n.type === "padding") {
          const B = h ? jt.parse : Ci.parse;
          (a = Ys({}, a)).stops && (a.stops = a.stops.map((F) => [F[0], B(F[1])])), a.default = B(a.default ? a.default : n.default);
        }
        if (a.colorSpace && (v = a.colorSpace) !== "rgb" && v !== "hcl" && v !== "lab") throw new Error(`Unknown color space: "${a.colorSpace}"`);
        var v;
        let A, E, R;
        if (b === "exponential") A = ad;
        else if (b === "interval") A = El;
        else if (b === "categorical") {
          A = od, E = /* @__PURE__ */ Object.create(null);
          for (const B of a.stops) E[B[0]] = B[1];
          R = typeof a.stops[0][0];
        } else {
          if (b !== "identity") throw new Error(`Unknown function type "${b}"`);
          A = ld;
        }
        if (f) {
          const B = {}, F = [];
          for (let $ = 0; $ < a.stops.length; $++) {
            const X = a.stops[$], ie = X[0].zoom;
            B[ie] === void 0 && (B[ie] = { zoom: ie, type: a.type, property: a.property, default: a.default, stops: [] }, F.push(ie)), B[ie].stops.push([X[0].value, X[1]]);
          }
          const L = [];
          for (const $ of F) L.push([B[$].zoom, nd(B[$], n)]);
          const V = { name: "linear" };
          return { kind: "composite", interpolationType: V, interpolationFactor: zs.interpolationFactor.bind(void 0, V), zoomStops: L.map(($) => $[0]), evaluate: ({ zoom: $ }, X) => ad({ stops: L, base: a.base }, n, $).evaluate($, X) };
        }
        if (m) {
          const B = b === "exponential" ? { name: "exponential", base: a.base !== void 0 ? a.base : 1 } : null;
          return { kind: "camera", interpolationType: B, interpolationFactor: zs.interpolationFactor.bind(void 0, B), zoomStops: a.stops.map((F) => F[0]), evaluate: ({ zoom: F }) => A(a, n, F, E, R) };
        }
        return { kind: "source", evaluate(B, F) {
          const L = F && F.properties ? F.properties[a.property] : void 0;
          return L === void 0 ? Bo(a.default, n.default) : A(a, n, L, E, R);
        } };
      }
      function Bo(a, n, h) {
        return a !== void 0 ? a : n !== void 0 ? n : h !== void 0 ? h : void 0;
      }
      function od(a, n, h, f, m) {
        return Bo(typeof h === m ? f[h] : void 0, a.default, n.default);
      }
      function El(a, n, h) {
        if ($t(h) !== "number") return Bo(a.default, n.default);
        const f = a.stops.length;
        if (f === 1 || h <= a.stops[0][0]) return a.stops[0][1];
        if (h >= a.stops[f - 1][0]) return a.stops[f - 1][1];
        const m = Ue(a.stops.map((b) => b[0]), h);
        return a.stops[m][1];
      }
      function ad(a, n, h) {
        const f = a.base !== void 0 ? a.base : 1;
        if ($t(h) !== "number") return Bo(a.default, n.default);
        const m = a.stops.length;
        if (m === 1 || h <= a.stops[0][0]) return a.stops[0][1];
        if (h >= a.stops[m - 1][0]) return a.stops[m - 1][1];
        const b = Ue(a.stops.map((B) => B[0]), h), v = function(B, F, L, V) {
          const $ = V - L, X = B - L;
          return $ === 0 ? 0 : F === 1 ? X / $ : (Math.pow(F, X) - 1) / (Math.pow(F, $) - 1);
        }(h, f, a.stops[b][0], a.stops[b + 1][0]), A = a.stops[b][1], E = a.stops[b + 1][1], R = Us[n.type] || Hp;
        return typeof A.evaluate == "function" ? { evaluate(...B) {
          const F = A.evaluate.apply(void 0, B), L = E.evaluate.apply(void 0, B);
          if (F !== void 0 && L !== void 0) return R(F, L, v, a.colorSpace);
        } } : R(A, E, v, a.colorSpace);
      }
      function ld(a, n, h) {
        switch (n.type) {
          case "color":
            h = jt.parse(h);
            break;
          case "formatted":
            h = Di.fromString(h.toString());
            break;
          case "resolvedImage":
            h = Ri.fromString(h.toString());
            break;
          case "padding":
            h = Ci.parse(h);
            break;
          default:
            $t(h) === n.type || n.type === "enum" && n.values[h] || (h = void 0);
        }
        return Bo(h, a.default, n.default);
      }
      dr.register(Io, { error: [{ kind: "error" }, [It], (a, [n]) => {
        throw new wi(n.evaluate(a));
      }], typeof: [It, [wt], (a, [n]) => U(xi(n.evaluate(a)))], "to-rgba": [z(qe, 4), [ds], (a, [n]) => {
        const [h, f, m, b] = n.evaluate(a).rgb;
        return [255 * h, 255 * f, 255 * m, b];
      }], rgb: [ds, [qe, qe, qe], rh], rgba: [ds, [qe, qe, qe, qe], rh], has: { type: xt, overloads: [[[It], (a, [n]) => nh(n.evaluate(a), a.properties())], [[It, Qs], (a, [n, h]) => nh(n.evaluate(a), h.evaluate(a))]] }, get: { type: wt, overloads: [[[It], (a, [n]) => oh(n.evaluate(a), a.properties())], [[It, Qs], (a, [n, h]) => oh(n.evaluate(a), h.evaluate(a))]] }, "feature-state": [wt, [It], (a, [n]) => oh(n.evaluate(a), a.featureState || {})], properties: [Qs, [], (a) => a.properties()], "geometry-type": [It, [], (a) => a.geometryType()], id: [wt, [], (a) => a.id()], zoom: [qe, [], (a) => a.globals.zoom], "heatmap-density": [qe, [], (a) => a.globals.heatmapDensity || 0], "line-progress": [qe, [], (a) => a.globals.lineProgress || 0], accumulated: [wt, [], (a) => a.globals.accumulated === void 0 ? null : a.globals.accumulated], "+": [qe, no(qe), (a, n) => {
        let h = 0;
        for (const f of n) h += f.evaluate(a);
        return h;
      }], "*": [qe, no(qe), (a, n) => {
        let h = 1;
        for (const f of n) h *= f.evaluate(a);
        return h;
      }], "-": { type: qe, overloads: [[[qe, qe], (a, [n, h]) => n.evaluate(a) - h.evaluate(a)], [[qe], (a, [n]) => -n.evaluate(a)]] }, "/": [qe, [qe, qe], (a, [n, h]) => n.evaluate(a) / h.evaluate(a)], "%": [qe, [qe, qe], (a, [n, h]) => n.evaluate(a) % h.evaluate(a)], ln2: [qe, [], () => Math.LN2], pi: [qe, [], () => Math.PI], e: [qe, [], () => Math.E], "^": [qe, [qe, qe], (a, [n, h]) => Math.pow(n.evaluate(a), h.evaluate(a))], sqrt: [qe, [qe], (a, [n]) => Math.sqrt(n.evaluate(a))], log10: [qe, [qe], (a, [n]) => Math.log(n.evaluate(a)) / Math.LN10], ln: [qe, [qe], (a, [n]) => Math.log(n.evaluate(a))], log2: [qe, [qe], (a, [n]) => Math.log(n.evaluate(a)) / Math.LN2], sin: [qe, [qe], (a, [n]) => Math.sin(n.evaluate(a))], cos: [qe, [qe], (a, [n]) => Math.cos(n.evaluate(a))], tan: [qe, [qe], (a, [n]) => Math.tan(n.evaluate(a))], asin: [qe, [qe], (a, [n]) => Math.asin(n.evaluate(a))], acos: [qe, [qe], (a, [n]) => Math.acos(n.evaluate(a))], atan: [qe, [qe], (a, [n]) => Math.atan(n.evaluate(a))], min: [qe, no(qe), (a, n) => Math.min(...n.map((h) => h.evaluate(a)))], max: [qe, no(qe), (a, n) => Math.max(...n.map((h) => h.evaluate(a)))], abs: [qe, [qe], (a, [n]) => Math.abs(n.evaluate(a))], round: [qe, [qe], (a, [n]) => {
        const h = n.evaluate(a);
        return h < 0 ? -Math.round(-h) : Math.round(h);
      }], floor: [qe, [qe], (a, [n]) => Math.floor(n.evaluate(a))], ceil: [qe, [qe], (a, [n]) => Math.ceil(n.evaluate(a))], "filter-==": [xt, [It, wt], (a, [n, h]) => a.properties()[n.value] === h.value], "filter-id-==": [xt, [wt], (a, [n]) => a.id() === n.value], "filter-type-==": [xt, [It], (a, [n]) => a.geometryType() === n.value], "filter-<": [xt, [It, wt], (a, [n, h]) => {
        const f = a.properties()[n.value], m = h.value;
        return typeof f == typeof m && f < m;
      }], "filter-id-<": [xt, [wt], (a, [n]) => {
        const h = a.id(), f = n.value;
        return typeof h == typeof f && h < f;
      }], "filter->": [xt, [It, wt], (a, [n, h]) => {
        const f = a.properties()[n.value], m = h.value;
        return typeof f == typeof m && f > m;
      }], "filter-id->": [xt, [wt], (a, [n]) => {
        const h = a.id(), f = n.value;
        return typeof h == typeof f && h > f;
      }], "filter-<=": [xt, [It, wt], (a, [n, h]) => {
        const f = a.properties()[n.value], m = h.value;
        return typeof f == typeof m && f <= m;
      }], "filter-id-<=": [xt, [wt], (a, [n]) => {
        const h = a.id(), f = n.value;
        return typeof h == typeof f && h <= f;
      }], "filter->=": [xt, [It, wt], (a, [n, h]) => {
        const f = a.properties()[n.value], m = h.value;
        return typeof f == typeof m && f >= m;
      }], "filter-id->=": [xt, [wt], (a, [n]) => {
        const h = a.id(), f = n.value;
        return typeof h == typeof f && h >= f;
      }], "filter-has": [xt, [wt], (a, [n]) => n.value in a.properties()], "filter-has-id": [xt, [], (a) => a.id() !== null && a.id() !== void 0], "filter-type-in": [xt, [z(It)], (a, [n]) => n.value.indexOf(a.geometryType()) >= 0], "filter-id-in": [xt, [z(wt)], (a, [n]) => n.value.indexOf(a.id()) >= 0], "filter-in-small": [xt, [It, z(wt)], (a, [n, h]) => h.value.indexOf(a.properties()[n.value]) >= 0], "filter-in-large": [xt, [It, z(wt)], (a, [n, h]) => function(f, m, b, v) {
        for (; b <= v; ) {
          const A = b + v >> 1;
          if (m[A] === f) return !0;
          m[A] > f ? v = A - 1 : b = A + 1;
        }
        return !1;
      }(a.properties()[n.value], h.value, 0, h.value.length - 1)], all: { type: xt, overloads: [[[xt, xt], (a, [n, h]) => n.evaluate(a) && h.evaluate(a)], [no(xt), (a, n) => {
        for (const h of n) if (!h.evaluate(a)) return !1;
        return !0;
      }]] }, any: { type: xt, overloads: [[[xt, xt], (a, [n, h]) => n.evaluate(a) || h.evaluate(a)], [no(xt), (a, n) => {
        for (const h of n) if (h.evaluate(a)) return !0;
        return !1;
      }]] }, "!": [xt, [xt], (a, [n]) => !n.evaluate(a)], "is-supported-script": [xt, [It], (a, [n]) => {
        const h = a.globals && a.globals.isSupportedScript;
        return !h || h(n.evaluate(a));
      }], upcase: [It, [It], (a, [n]) => n.evaluate(a).toUpperCase()], downcase: [It, [It], (a, [n]) => n.evaluate(a).toLowerCase()], concat: [It, no(wt), (a, n) => n.map((h) => os(h.evaluate(a))).join("")], "resolved-locale": [It, [hr], (a, [n]) => n.evaluate(a).resolvedLocale()] });
      class Sl {
        constructor(n, h) {
          var f;
          this.expression = n, this._warningHistory = {}, this._evaluator = new Eo(), this._defaultValue = h ? (f = h).type === "color" && Tl(f.default) ? new jt(0, 0, 0, 0) : f.type === "color" ? jt.parse(f.default) || null : f.type === "padding" ? Ci.parse(f.default) || null : f.type === "variableAnchorOffsetCollection" ? Ii.parse(f.default) || null : f.default === void 0 ? null : f.default : null, this._enumValues = h && h.type === "enum" ? h.values : null;
        }
        evaluateWithoutErrorHandling(n, h, f, m, b, v) {
          return this._evaluator.globals = n, this._evaluator.feature = h, this._evaluator.featureState = f, this._evaluator.canonical = m, this._evaluator.availableImages = b || null, this._evaluator.formattedSection = v, this.expression.evaluate(this._evaluator);
        }
        evaluate(n, h, f, m, b, v) {
          this._evaluator.globals = n, this._evaluator.feature = h || null, this._evaluator.featureState = f || null, this._evaluator.canonical = m, this._evaluator.availableImages = b || null, this._evaluator.formattedSection = v || null;
          try {
            const A = this.expression.evaluate(this._evaluator);
            if (A == null || typeof A == "number" && A != A) return this._defaultValue;
            if (this._enumValues && !(A in this._enumValues)) throw new wi(`Expected value to be one of ${Object.keys(this._enumValues).map((E) => JSON.stringify(E)).join(", ")}, but found ${JSON.stringify(A)} instead.`);
            return A;
          } catch (A) {
            return this._warningHistory[A.message] || (this._warningHistory[A.message] = !0, typeof console < "u" && console.warn(A.message)), this._defaultValue;
          }
        }
      }
      function Cl(a) {
        return Array.isArray(a) && a.length > 0 && typeof a[0] == "string" && a[0] in Io;
      }
      function Do(a, n) {
        const h = new Xr(Io, Ca, [], n ? function(m) {
          const b = { color: ds, string: It, number: qe, enum: It, boolean: xt, formatted: Tr, padding: Er, resolvedImage: er, variableAnchorOffsetCollection: re };
          return m.type === "array" ? z(b[m.value] || wt, m.length) : b[m.type];
        }(n) : void 0), f = h.parse(a, void 0, void 0, void 0, n && n.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return f ? Al(new Sl(f, n)) : Mo(h.errors);
      }
      class Oo {
        constructor(n, h) {
          this.kind = n, this._styleExpression = h, this.isStateDependent = n !== "constant" && !Ro(h.expression);
        }
        evaluateWithoutErrorHandling(n, h, f, m, b, v) {
          return this._styleExpression.evaluateWithoutErrorHandling(n, h, f, m, b, v);
        }
        evaluate(n, h, f, m, b, v) {
          return this._styleExpression.evaluate(n, h, f, m, b, v);
        }
      }
      class Fo {
        constructor(n, h, f, m) {
          this.kind = n, this.zoomStops = f, this._styleExpression = h, this.isStateDependent = n !== "camera" && !Ro(h.expression), this.interpolationType = m;
        }
        evaluateWithoutErrorHandling(n, h, f, m, b, v) {
          return this._styleExpression.evaluateWithoutErrorHandling(n, h, f, m, b, v);
        }
        evaluate(n, h, f, m, b, v) {
          return this._styleExpression.evaluate(n, h, f, m, b, v);
        }
        interpolationFactor(n, h, f) {
          return this.interpolationType ? zs.interpolationFactor(this.interpolationType, n, h, f) : 0;
        }
      }
      function lh(a, n) {
        const h = Do(a, n);
        if (h.result === "error") return h;
        const f = h.value.expression, m = Ia(f);
        if (!m && !Po(n)) return Mo([new Yi("", "data expressions not supported")]);
        const b = Ra(f, ["zoom"]);
        if (!b && !rd(n)) return Mo([new Yi("", "zoom expressions not supported")]);
        const v = Ma(f);
        return v || b ? v instanceof Yi ? Mo([v]) : v instanceof zs && !ah(n) ? Mo([new Yi("", '"interpolate" expressions cannot be used with this property')]) : Al(v ? new Fo(m ? "camera" : "composite", h.value, v.labels, v instanceof zs ? v.interpolation : void 0) : new Oo(m ? "constant" : "source", h.value)) : Mo([new Yi("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class ko {
        constructor(n, h) {
          this._parameters = n, this._specification = h, Ys(this, nd(this._parameters, this._specification));
        }
        static deserialize(n) {
          return new ko(n._parameters, n._specification);
        }
        static serialize(n) {
          return { _parameters: n._parameters, _specification: n._specification };
        }
      }
      function Ma(a) {
        let n = null;
        if (a instanceof ur) n = Ma(a.result);
        else if (a instanceof _l) {
          for (const h of a.args) if (n = Ma(h), n) break;
        } else (a instanceof lt || a instanceof zs) && a.input instanceof dr && a.input.name === "zoom" && (n = a);
        return n instanceof Yi || a.eachChild((h) => {
          const f = Ma(h);
          f instanceof Yi ? n = f : !n && f ? n = new Yi("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : n && f && n !== f && (n = new Yi("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), n;
      }
      function Il(a) {
        if (a === !0 || a === !1) return !0;
        if (!Array.isArray(a) || a.length === 0) return !1;
        switch (a[0]) {
          case "has":
            return a.length >= 2 && a[1] !== "$id" && a[1] !== "$type";
          case "in":
            return a.length >= 3 && (typeof a[1] != "string" || Array.isArray(a[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return a.length !== 3 || Array.isArray(a[1]) || Array.isArray(a[2]);
          case "any":
          case "all":
            for (const n of a.slice(1)) if (!Il(n) && typeof n != "boolean") return !1;
            return !0;
          default:
            return !0;
        }
      }
      const Rl = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function ch(a) {
        if (a == null) return { filter: () => !0, needGeometry: !1 };
        Il(a) || (a = Ml(a));
        const n = Do(a, Rl);
        if (n.result === "error") throw new Error(n.value.map((h) => `${h.key}: ${h.message}`).join(", "));
        return { filter: (h, f, m) => n.value.evaluate(h, f, {}, m), needGeometry: cd(a) };
      }
      function jp(a, n) {
        return a < n ? -1 : a > n ? 1 : 0;
      }
      function cd(a) {
        if (!Array.isArray(a)) return !1;
        if (a[0] === "within" || a[0] === "distance") return !0;
        for (let n = 1; n < a.length; n++) if (cd(a[n])) return !0;
        return !1;
      }
      function Ml(a) {
        if (!a) return !0;
        const n = a[0];
        return a.length <= 1 ? n !== "any" : n === "==" ? hh(a[1], a[2], "==") : n === "!=" ? ms(hh(a[1], a[2], "==")) : n === "<" || n === ">" || n === "<=" || n === ">=" ? hh(a[1], a[2], n) : n === "any" ? (h = a.slice(1), ["any"].concat(h.map(Ml))) : n === "all" ? ["all"].concat(a.slice(1).map(Ml)) : n === "none" ? ["all"].concat(a.slice(1).map(Ml).map(ms)) : n === "in" ? Pa(a[1], a.slice(2)) : n === "!in" ? ms(Pa(a[1], a.slice(2))) : n === "has" ? Ba(a[1]) : n !== "!has" || ms(Ba(a[1]));
        var h;
      }
      function hh(a, n, h) {
        switch (a) {
          case "$type":
            return [`filter-type-${h}`, n];
          case "$id":
            return [`filter-id-${h}`, n];
          default:
            return [`filter-${h}`, a, n];
        }
      }
      function Pa(a, n) {
        if (n.length === 0) return !1;
        switch (a) {
          case "$type":
            return ["filter-type-in", ["literal", n]];
          case "$id":
            return ["filter-id-in", ["literal", n]];
          default:
            return n.length > 200 && !n.some((h) => typeof h != typeof n[0]) ? ["filter-in-large", a, ["literal", n.sort(jp)]] : ["filter-in-small", a, ["literal", n]];
        }
      }
      function Ba(a) {
        switch (a) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", a];
        }
      }
      function ms(a) {
        return ["!", a];
      }
      function oo(a) {
        const n = typeof a;
        if (n === "number" || n === "boolean" || n === "string" || a == null) return JSON.stringify(a);
        if (Array.isArray(a)) {
          let m = "[";
          for (const b of a) m += `${oo(b)},`;
          return `${m}]`;
        }
        const h = Object.keys(a).sort();
        let f = "{";
        for (let m = 0; m < h.length; m++) f += `${JSON.stringify(h[m])}:${oo(a[h[m]])},`;
        return `${f}}`;
      }
      function hd(a) {
        let n = "";
        for (const h of Cs) n += `/${oo(a[h])}`;
        return n;
      }
      function ud(a) {
        const n = a.value;
        return n ? [new He(a.key, n, "constants have been deprecated as of v8")] : [];
      }
      function Fi(a) {
        return a instanceof Number || a instanceof String || a instanceof Boolean ? a.valueOf() : a;
      }
      function Sr(a) {
        if (Array.isArray(a)) return a.map(Sr);
        if (a instanceof Object && !(a instanceof Number || a instanceof String || a instanceof Boolean)) {
          const n = {};
          for (const h in a) n[h] = Sr(a[h]);
          return n;
        }
        return Fi(a);
      }
      function tr(a) {
        const n = a.key, h = a.value, f = a.valueSpec || {}, m = a.objectElementValidators || {}, b = a.style, v = a.styleSpec, A = a.validateSpec;
        let E = [];
        const R = $t(h);
        if (R !== "object") return [new He(n, h, `object expected, ${R} found`)];
        for (const B in h) {
          const F = B.split(".")[0], L = f[F] || f["*"];
          let V;
          if (m[F]) V = m[F];
          else if (f[F]) V = A;
          else if (m["*"]) V = m["*"];
          else {
            if (!f["*"]) {
              E.push(new He(n, h[B], `unknown property "${B}"`));
              continue;
            }
            V = A;
          }
          E = E.concat(V({ key: (n && `${n}.`) + B, value: h[B], valueSpec: L, style: b, styleSpec: v, object: h, objectKey: B, validateSpec: A }, h));
        }
        for (const B in f) m[B] || f[B].required && f[B].default === void 0 && h[B] === void 0 && E.push(new He(n, h, `missing required property "${B}"`));
        return E;
      }
      function Da(a) {
        const n = a.value, h = a.valueSpec, f = a.style, m = a.styleSpec, b = a.key, v = a.arrayElementValidator || a.validateSpec;
        if ($t(n) !== "array") return [new He(b, n, `array expected, ${$t(n)} found`)];
        if (h.length && n.length !== h.length) return [new He(b, n, `array length ${h.length} expected, length ${n.length} found`)];
        if (h["min-length"] && n.length < h["min-length"]) return [new He(b, n, `array length at least ${h["min-length"]} expected, length ${n.length} found`)];
        let A = { type: h.value, values: h.values };
        m.$version < 7 && (A.function = h.function), $t(h.value) === "object" && (A = h.value);
        let E = [];
        for (let R = 0; R < n.length; R++) E = E.concat(v({ array: n, arrayIndex: R, value: n[R], valueSpec: A, validateSpec: a.validateSpec, style: f, styleSpec: m, key: `${b}[${R}]` }));
        return E;
      }
      function uh(a) {
        const n = a.key, h = a.value, f = a.valueSpec;
        let m = $t(h);
        return m === "number" && h != h && (m = "NaN"), m !== "number" ? [new He(n, h, `number expected, ${m} found`)] : "minimum" in f && h < f.minimum ? [new He(n, h, `${h} is less than the minimum value ${f.minimum}`)] : "maximum" in f && h > f.maximum ? [new He(n, h, `${h} is greater than the maximum value ${f.maximum}`)] : [];
      }
      function Pl(a) {
        const n = a.valueSpec, h = Fi(a.value.type);
        let f, m, b, v = {};
        const A = h !== "categorical" && a.value.property === void 0, E = !A, R = $t(a.value.stops) === "array" && $t(a.value.stops[0]) === "array" && $t(a.value.stops[0][0]) === "object", B = tr({ key: a.key, value: a.value, valueSpec: a.styleSpec.function, validateSpec: a.validateSpec, style: a.style, styleSpec: a.styleSpec, objectElementValidators: { stops: function(V) {
          if (h === "identity") return [new He(V.key, V.value, 'identity function may not have a "stops" property')];
          let $ = [];
          const X = V.value;
          return $ = $.concat(Da({ key: V.key, value: X, valueSpec: V.valueSpec, validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec, arrayElementValidator: F })), $t(X) === "array" && X.length === 0 && $.push(new He(V.key, X, "array must have at least one stop")), $;
        }, default: function(V) {
          return V.validateSpec({ key: V.key, value: V.value, valueSpec: n, validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec });
        } } });
        return h === "identity" && A && B.push(new He(a.key, a.value, 'missing required property "property"')), h === "identity" || a.value.stops || B.push(new He(a.key, a.value, 'missing required property "stops"')), h === "exponential" && a.valueSpec.expression && !ah(a.valueSpec) && B.push(new He(a.key, a.value, "exponential functions not supported")), a.styleSpec.$version >= 8 && (E && !Po(a.valueSpec) ? B.push(new He(a.key, a.value, "property functions not supported")) : A && !rd(a.valueSpec) && B.push(new He(a.key, a.value, "zoom functions not supported"))), h !== "categorical" && !R || a.value.property !== void 0 || B.push(new He(a.key, a.value, '"property" property is required')), B;
        function F(V) {
          let $ = [];
          const X = V.value, ie = V.key;
          if ($t(X) !== "array") return [new He(ie, X, `array expected, ${$t(X)} found`)];
          if (X.length !== 2) return [new He(ie, X, `array length 2 expected, length ${X.length} found`)];
          if (R) {
            if ($t(X[0]) !== "object") return [new He(ie, X, `object expected, ${$t(X[0])} found`)];
            if (X[0].zoom === void 0) return [new He(ie, X, "object stop key must have zoom")];
            if (X[0].value === void 0) return [new He(ie, X, "object stop key must have value")];
            if (b && b > Fi(X[0].zoom)) return [new He(ie, X[0].zoom, "stop zoom values must appear in ascending order")];
            Fi(X[0].zoom) !== b && (b = Fi(X[0].zoom), m = void 0, v = {}), $ = $.concat(tr({ key: `${ie}[0]`, value: X[0], valueSpec: { zoom: {} }, validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec, objectElementValidators: { zoom: uh, value: L } }));
          } else $ = $.concat(L({ key: `${ie}[0]`, value: X[0], valueSpec: {}, validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec }, X));
          return Cl(Sr(X[1])) ? $.concat([new He(`${ie}[1]`, X[1], "expressions are not allowed in function stops.")]) : $.concat(V.validateSpec({ key: `${ie}[1]`, value: X[1], valueSpec: n, validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec }));
        }
        function L(V, $) {
          const X = $t(V.value), ie = Fi(V.value), ne = V.value !== null ? V.value : $;
          if (f) {
            if (X !== f) return [new He(V.key, ne, `${X} stop domain type must match previous stop domain type ${f}`)];
          } else f = X;
          if (X !== "number" && X !== "string" && X !== "boolean") return [new He(V.key, ne, "stop domain value must be a number, string, or boolean")];
          if (X !== "number" && h !== "categorical") {
            let Ae = `number expected, ${X} found`;
            return Po(n) && h === void 0 && (Ae += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new He(V.key, ne, Ae)];
          }
          return h !== "categorical" || X !== "number" || isFinite(ie) && Math.floor(ie) === ie ? h !== "categorical" && X === "number" && m !== void 0 && ie < m ? [new He(V.key, ne, "stop domain values must appear in ascending order")] : (m = ie, h === "categorical" && ie in v ? [new He(V.key, ne, "stop domain values must be unique")] : (v[ie] = !0, [])) : [new He(V.key, ne, `integer expected, found ${ie}`)];
        }
      }
      function No(a) {
        const n = (a.expressionContext === "property" ? lh : Do)(Sr(a.value), a.valueSpec);
        if (n.result === "error") return n.value.map((f) => new He(`${a.key}${f.key}`, a.value, f.message));
        const h = n.value.expression || n.value._styleExpression.expression;
        if (a.expressionContext === "property" && a.propertyKey === "text-font" && !h.outputDefined()) return [new He(a.key, a.value, `Invalid data expression for "${a.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (a.expressionContext === "property" && a.propertyType === "layout" && !Ro(h)) return [new He(a.key, a.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (a.expressionContext === "filter" && !Ro(h)) return [new He(a.key, a.value, '"feature-state" data expressions are not supported with filters.')];
        if (a.expressionContext && a.expressionContext.indexOf("cluster") === 0) {
          if (!Ra(h, ["zoom", "feature-state"])) return [new He(a.key, a.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (a.expressionContext === "cluster-initial" && !Ia(h)) return [new He(a.key, a.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function ln(a) {
        const n = a.key, h = a.value, f = a.valueSpec, m = [];
        return Array.isArray(f.values) ? f.values.indexOf(Fi(h)) === -1 && m.push(new He(n, h, `expected one of [${f.values.join(", ")}], ${JSON.stringify(h)} found`)) : Object.keys(f.values).indexOf(Fi(h)) === -1 && m.push(new He(n, h, `expected one of [${Object.keys(f.values).join(", ")}], ${JSON.stringify(h)} found`)), m;
      }
      function dh(a) {
        return Il(Sr(a.value)) ? No(Ys({}, a, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Bl(a);
      }
      function Bl(a) {
        const n = a.value, h = a.key;
        if ($t(n) !== "array") return [new He(h, n, `array expected, ${$t(n)} found`)];
        const f = a.styleSpec;
        let m, b = [];
        if (n.length < 1) return [new He(h, n, "filter array must have at least 1 element")];
        switch (b = b.concat(ln({ key: `${h}[0]`, value: n[0], valueSpec: f.filter_operator, style: a.style, styleSpec: a.styleSpec })), Fi(n[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            n.length >= 2 && Fi(n[1]) === "$type" && b.push(new He(h, n, `"$type" cannot be use with operator "${n[0]}"`));
          case "==":
          case "!=":
            n.length !== 3 && b.push(new He(h, n, `filter array for operator "${n[0]}" must have 3 elements`));
          case "in":
          case "!in":
            n.length >= 2 && (m = $t(n[1]), m !== "string" && b.push(new He(`${h}[1]`, n[1], `string expected, ${m} found`)));
            for (let v = 2; v < n.length; v++) m = $t(n[v]), Fi(n[1]) === "$type" ? b = b.concat(ln({ key: `${h}[${v}]`, value: n[v], valueSpec: f.geometry_type, style: a.style, styleSpec: a.styleSpec })) : m !== "string" && m !== "number" && m !== "boolean" && b.push(new He(`${h}[${v}]`, n[v], `string, number, or boolean expected, ${m} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let v = 1; v < n.length; v++) b = b.concat(Bl({ key: `${h}[${v}]`, value: n[v], style: a.style, styleSpec: a.styleSpec }));
            break;
          case "has":
          case "!has":
            m = $t(n[1]), n.length !== 2 ? b.push(new He(h, n, `filter array for "${n[0]}" operator must have 2 elements`)) : m !== "string" && b.push(new He(`${h}[1]`, n[1], `string expected, ${m} found`));
        }
        return b;
      }
      function fh(a, n) {
        const h = a.key, f = a.validateSpec, m = a.style, b = a.styleSpec, v = a.value, A = a.objectKey, E = b[`${n}_${a.layerType}`];
        if (!E) return [];
        const R = A.match(/^(.*)-transition$/);
        if (n === "paint" && R && E[R[1]] && E[R[1]].transition) return f({ key: h, value: v, valueSpec: b.transition, style: m, styleSpec: b });
        const B = a.valueSpec || E[A];
        if (!B) return [new He(h, v, `unknown property "${A}"`)];
        let F;
        if ($t(v) === "string" && Po(B) && !B.tokens && (F = /^{([^}]+)}$/.exec(v))) return [new He(h, v, `"${A}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(F[1])} }\`.`)];
        const L = [];
        return a.layerType === "symbol" && (A === "text-field" && m && !m.glyphs && L.push(new He(h, v, 'use of "text-field" requires a style "glyphs" property')), A === "text-font" && Tl(Sr(v)) && Fi(v.type) === "identity" && L.push(new He(h, v, '"text-font" does not support identity functions'))), L.concat(f({ key: a.key, value: v, valueSpec: B, style: m, styleSpec: b, expressionContext: "property", propertyType: n, propertyKey: A }));
      }
      function Dl(a) {
        return fh(a, "paint");
      }
      function ph(a) {
        return fh(a, "layout");
      }
      function _h(a) {
        let n = [];
        const h = a.value, f = a.key, m = a.style, b = a.styleSpec;
        h.type || h.ref || n.push(new He(f, h, 'either "type" or "ref" is required'));
        let v = Fi(h.type);
        const A = Fi(h.ref);
        if (h.id) {
          const E = Fi(h.id);
          for (let R = 0; R < a.arrayIndex; R++) {
            const B = m.layers[R];
            Fi(B.id) === E && n.push(new He(f, h.id, `duplicate layer id "${h.id}", previously used at line ${B.id.__line__}`));
          }
        }
        if ("ref" in h) {
          let E;
          ["type", "source", "source-layer", "filter", "layout"].forEach((R) => {
            R in h && n.push(new He(f, h[R], `"${R}" is prohibited for ref layers`));
          }), m.layers.forEach((R) => {
            Fi(R.id) === A && (E = R);
          }), E ? E.ref ? n.push(new He(f, h.ref, "ref cannot reference another ref layer")) : v = Fi(E.type) : n.push(new He(f, h.ref, `ref layer "${A}" not found`));
        } else if (v !== "background") if (h.source) {
          const E = m.sources && m.sources[h.source], R = E && Fi(E.type);
          E ? R === "vector" && v === "raster" ? n.push(new He(f, h.source, `layer "${h.id}" requires a raster source`)) : R !== "raster-dem" && v === "hillshade" ? n.push(new He(f, h.source, `layer "${h.id}" requires a raster-dem source`)) : R === "raster" && v !== "raster" ? n.push(new He(f, h.source, `layer "${h.id}" requires a vector source`)) : R !== "vector" || h["source-layer"] ? R === "raster-dem" && v !== "hillshade" ? n.push(new He(f, h.source, "raster-dem source can only be used with layer type 'hillshade'.")) : v !== "line" || !h.paint || !h.paint["line-gradient"] || R === "geojson" && E.lineMetrics || n.push(new He(f, h, `layer "${h.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : n.push(new He(f, h, `layer "${h.id}" must specify a "source-layer"`)) : n.push(new He(f, h.source, `source "${h.source}" not found`));
        } else n.push(new He(f, h, 'missing required property "source"'));
        return n = n.concat(tr({ key: f, value: h, valueSpec: b.layer, style: a.style, styleSpec: a.styleSpec, validateSpec: a.validateSpec, objectElementValidators: { "*": () => [], type: () => a.validateSpec({ key: `${f}.type`, value: h.type, valueSpec: b.layer.type, style: a.style, styleSpec: a.styleSpec, validateSpec: a.validateSpec, object: h, objectKey: "type" }), filter: dh, layout: (E) => tr({ layer: h, key: E.key, value: E.value, style: E.style, styleSpec: E.styleSpec, validateSpec: E.validateSpec, objectElementValidators: { "*": (R) => ph(Ys({ layerType: v }, R)) } }), paint: (E) => tr({ layer: h, key: E.key, value: E.value, style: E.style, styleSpec: E.styleSpec, validateSpec: E.validateSpec, objectElementValidators: { "*": (R) => Dl(Ys({ layerType: v }, R)) } }) } })), n;
      }
      function ao(a) {
        const n = a.value, h = a.key, f = $t(n);
        return f !== "string" ? [new He(h, n, `string expected, ${f} found`)] : [];
      }
      const Ol = { promoteId: function({ key: a, value: n }) {
        if ($t(n) === "string") return ao({ key: a, value: n });
        {
          const h = [];
          for (const f in n) h.push(...ao({ key: `${a}.${f}`, value: n[f] }));
          return h;
        }
      } };
      function Oa(a) {
        const n = a.value, h = a.key, f = a.styleSpec, m = a.style, b = a.validateSpec;
        if (!n.type) return [new He(h, n, '"type" is required')];
        const v = Fi(n.type);
        let A;
        switch (v) {
          case "vector":
          case "raster":
            return A = tr({ key: h, value: n, valueSpec: f[`source_${v.replace("-", "_")}`], style: a.style, styleSpec: f, objectElementValidators: Ol, validateSpec: b }), A;
          case "raster-dem":
            return A = function(E) {
              var R;
              const B = (R = E.sourceName) !== null && R !== void 0 ? R : "", F = E.value, L = E.styleSpec, V = L.source_raster_dem, $ = E.style;
              let X = [];
              const ie = $t(F);
              if (F === void 0) return X;
              if (ie !== "object") return X.push(new He("source_raster_dem", F, `object expected, ${ie} found`)), X;
              const ne = Fi(F.encoding) === "custom", Ae = ["redFactor", "greenFactor", "blueFactor", "baseShift"], de = E.value.encoding ? `"${E.value.encoding}"` : "Default";
              for (const ye in F) !ne && Ae.includes(ye) ? X.push(new He(ye, F[ye], `In "${B}": "${ye}" is only valid when "encoding" is set to "custom". ${de} encoding found`)) : V[ye] ? X = X.concat(E.validateSpec({ key: ye, value: F[ye], valueSpec: V[ye], validateSpec: E.validateSpec, style: $, styleSpec: L })) : X.push(new He(ye, F[ye], `unknown property "${ye}"`));
              return X;
            }({ sourceName: h, value: n, style: a.style, styleSpec: f, validateSpec: b }), A;
          case "geojson":
            if (A = tr({ key: h, value: n, valueSpec: f.source_geojson, style: m, styleSpec: f, validateSpec: b, objectElementValidators: Ol }), n.cluster) for (const E in n.clusterProperties) {
              const [R, B] = n.clusterProperties[E], F = typeof R == "string" ? [R, ["accumulated"], ["get", E]] : R;
              A.push(...No({ key: `${h}.${E}.map`, value: B, validateSpec: b, expressionContext: "cluster-map" })), A.push(...No({ key: `${h}.${E}.reduce`, value: F, validateSpec: b, expressionContext: "cluster-reduce" }));
            }
            return A;
          case "video":
            return tr({ key: h, value: n, valueSpec: f.source_video, style: m, validateSpec: b, styleSpec: f });
          case "image":
            return tr({ key: h, value: n, valueSpec: f.source_image, style: m, validateSpec: b, styleSpec: f });
          case "canvas":
            return [new He(h, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return ln({ key: `${h}.type`, value: n.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: m, validateSpec: b, styleSpec: f });
        }
      }
      function mh(a) {
        const n = a.value, h = a.styleSpec, f = h.light, m = a.style;
        let b = [];
        const v = $t(n);
        if (n === void 0) return b;
        if (v !== "object") return b = b.concat([new He("light", n, `object expected, ${v} found`)]), b;
        for (const A in n) {
          const E = A.match(/^(.*)-transition$/);
          b = b.concat(E && f[E[1]] && f[E[1]].transition ? a.validateSpec({ key: A, value: n[A], valueSpec: h.transition, validateSpec: a.validateSpec, style: m, styleSpec: h }) : f[A] ? a.validateSpec({ key: A, value: n[A], valueSpec: f[A], validateSpec: a.validateSpec, style: m, styleSpec: h }) : [new He(A, n[A], `unknown property "${A}"`)]);
        }
        return b;
      }
      function gh(a) {
        const n = a.value, h = a.styleSpec, f = h.sky, m = a.style, b = $t(n);
        if (n === void 0) return [];
        if (b !== "object") return [new He("sky", n, `object expected, ${b} found`)];
        let v = [];
        for (const A in n) v = v.concat(f[A] ? a.validateSpec({ key: A, value: n[A], valueSpec: f[A], style: m, styleSpec: h }) : [new He(A, n[A], `unknown property "${A}"`)]);
        return v;
      }
      function yh(a) {
        const n = a.value, h = a.styleSpec, f = h.terrain, m = a.style;
        let b = [];
        const v = $t(n);
        if (n === void 0) return b;
        if (v !== "object") return b = b.concat([new He("terrain", n, `object expected, ${v} found`)]), b;
        for (const A in n) b = b.concat(f[A] ? a.validateSpec({ key: A, value: n[A], valueSpec: f[A], validateSpec: a.validateSpec, style: m, styleSpec: h }) : [new He(A, n[A], `unknown property "${A}"`)]);
        return b;
      }
      function bh(a) {
        let n = [];
        const h = a.value, f = a.key;
        if (Array.isArray(h)) {
          const m = [], b = [];
          for (const v in h) h[v].id && m.includes(h[v].id) && n.push(new He(f, h, `all the sprites' ids must be unique, but ${h[v].id} is duplicated`)), m.push(h[v].id), h[v].url && b.includes(h[v].url) && n.push(new He(f, h, `all the sprites' URLs must be unique, but ${h[v].url} is duplicated`)), b.push(h[v].url), n = n.concat(tr({ key: `${f}[${v}]`, value: h[v], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: a.validateSpec }));
          return n;
        }
        return ao({ key: f, value: h });
      }
      const Fl = { "*": () => [], array: Da, boolean: function(a) {
        const n = a.value, h = a.key, f = $t(n);
        return f !== "boolean" ? [new He(h, n, `boolean expected, ${f} found`)] : [];
      }, number: uh, color: function(a) {
        const n = a.key, h = a.value, f = $t(h);
        return f !== "string" ? [new He(n, h, `color expected, ${f} found`)] : jt.parse(String(h)) ? [] : [new He(n, h, `color expected, "${h}" found`)];
      }, constants: ud, enum: ln, filter: dh, function: Pl, layer: _h, object: tr, source: Oa, light: mh, sky: gh, terrain: yh, projection: function(a) {
        const n = a.value, h = a.styleSpec, f = h.projection, m = a.style, b = $t(n);
        if (n === void 0) return [];
        if (b !== "object") return [new He("projection", n, `object expected, ${b} found`)];
        let v = [];
        for (const A in n) v = v.concat(f[A] ? a.validateSpec({ key: A, value: n[A], valueSpec: f[A], style: m, styleSpec: h }) : [new He(A, n[A], `unknown property "${A}"`)]);
        return v;
      }, string: ao, formatted: function(a) {
        return ao(a).length === 0 ? [] : No(a);
      }, resolvedImage: function(a) {
        return ao(a).length === 0 ? [] : No(a);
      }, padding: function(a) {
        const n = a.key, h = a.value;
        if ($t(h) === "array") {
          if (h.length < 1 || h.length > 4) return [new He(n, h, `padding requires 1 to 4 values; ${h.length} values found`)];
          const f = { type: "number" };
          let m = [];
          for (let b = 0; b < h.length; b++) m = m.concat(a.validateSpec({ key: `${n}[${b}]`, value: h[b], validateSpec: a.validateSpec, valueSpec: f }));
          return m;
        }
        return uh({ key: n, value: h, valueSpec: {} });
      }, variableAnchorOffsetCollection: function(a) {
        const n = a.key, h = a.value, f = $t(h), m = a.styleSpec;
        if (f !== "array" || h.length < 1 || h.length % 2 != 0) return [new He(n, h, "variableAnchorOffsetCollection requires a non-empty array of even length")];
        let b = [];
        for (let v = 0; v < h.length; v += 2) b = b.concat(ln({ key: `${n}[${v}]`, value: h[v], valueSpec: m.layout_symbol["text-anchor"] })), b = b.concat(Da({ key: `${n}[${v + 1}]`, value: h[v + 1], valueSpec: { length: 2, value: "number" }, validateSpec: a.validateSpec, style: a.style, styleSpec: m }));
        return b;
      }, sprite: bh };
      function Lo(a) {
        const n = a.value, h = a.valueSpec, f = a.styleSpec;
        return a.validateSpec = Lo, h.expression && Tl(Fi(n)) ? Pl(a) : h.expression && Cl(Sr(n)) ? No(a) : h.type && Fl[h.type] ? Fl[h.type](a) : tr(Ys({}, a, { valueSpec: h.type ? f[h.type] : h }));
      }
      function dd(a) {
        const n = a.value, h = a.key, f = ao(a);
        return f.length || (n.indexOf("{fontstack}") === -1 && f.push(new He(h, n, '"glyphs" url must include a "{fontstack}" token')), n.indexOf("{range}") === -1 && f.push(new He(h, n, '"glyphs" url must include a "{range}" token'))), f;
      }
      function fr(a, n = Ie) {
        let h = [];
        return h = h.concat(Lo({ key: "", value: a, valueSpec: n.$root, styleSpec: n, style: a, validateSpec: Lo, objectElementValidators: { glyphs: dd, "*": () => [] } })), a.constants && (h = h.concat(ud({ key: "constants", value: a.constants, style: a, styleSpec: n, validateSpec: Lo }))), vh(h);
      }
      function qr(a) {
        return function(n) {
          return a({ ...n, validateSpec: Lo });
        };
      }
      function vh(a) {
        return [].concat(a).sort((n, h) => n.line - h.line);
      }
      function Cr(a) {
        return function(...n) {
          return vh(a.apply(this, n));
        };
      }
      fr.source = Cr(qr(Oa)), fr.sprite = Cr(qr(bh)), fr.glyphs = Cr(qr(dd)), fr.light = Cr(qr(mh)), fr.sky = Cr(qr(gh)), fr.terrain = Cr(qr(yh)), fr.layer = Cr(qr(_h)), fr.filter = Cr(qr(dh)), fr.paintProperty = Cr(qr(Dl)), fr.layoutProperty = Cr(qr(ph));
      const lo = fr, $p = lo.light, Gp = lo.sky, fd = lo.paintProperty, pd = lo.layoutProperty;
      function xh(a, n) {
        let h = !1;
        if (n && n.length) for (const f of n) a.fire(new Ns(new Error(f.message))), h = !0;
        return h;
      }
      class Uo {
        constructor(n, h, f) {
          const m = this.cells = [];
          if (n instanceof ArrayBuffer) {
            this.arrayBuffer = n;
            const v = new Int32Array(this.arrayBuffer);
            n = v[0], this.d = (h = v[1]) + 2 * (f = v[2]);
            for (let E = 0; E < this.d * this.d; E++) {
              const R = v[3 + E], B = v[3 + E + 1];
              m.push(R === B ? null : v.subarray(R, B));
            }
            const A = v[3 + m.length + 1];
            this.keys = v.subarray(v[3 + m.length], A), this.bboxes = v.subarray(A), this.insert = this._insertReadonly;
          } else {
            this.d = h + 2 * f;
            for (let v = 0; v < this.d * this.d; v++) m.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = h, this.extent = n, this.padding = f, this.scale = h / n, this.uid = 0;
          const b = f / h * n;
          this.min = -b, this.max = n + b;
        }
        insert(n, h, f, m, b) {
          this._forEachCell(h, f, m, b, this._insertCell, this.uid++, void 0, void 0), this.keys.push(n), this.bboxes.push(h), this.bboxes.push(f), this.bboxes.push(m), this.bboxes.push(b);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(n, h, f, m, b, v) {
          this.cells[b].push(v);
        }
        query(n, h, f, m, b) {
          const v = this.min, A = this.max;
          if (n <= v && h <= v && A <= f && A <= m && !b) return Array.prototype.slice.call(this.keys);
          {
            const E = [];
            return this._forEachCell(n, h, f, m, this._queryCell, E, {}, b), E;
          }
        }
        _queryCell(n, h, f, m, b, v, A, E) {
          const R = this.cells[b];
          if (R !== null) {
            const B = this.keys, F = this.bboxes;
            for (let L = 0; L < R.length; L++) {
              const V = R[L];
              if (A[V] === void 0) {
                const $ = 4 * V;
                (E ? E(F[$ + 0], F[$ + 1], F[$ + 2], F[$ + 3]) : n <= F[$ + 2] && h <= F[$ + 3] && f >= F[$ + 0] && m >= F[$ + 1]) ? (A[V] = !0, v.push(B[V])) : A[V] = !1;
              }
            }
          }
        }
        _forEachCell(n, h, f, m, b, v, A, E) {
          const R = this._convertToCellCoord(n), B = this._convertToCellCoord(h), F = this._convertToCellCoord(f), L = this._convertToCellCoord(m);
          for (let V = R; V <= F; V++) for (let $ = B; $ <= L; $++) {
            const X = this.d * $ + V;
            if ((!E || E(this._convertFromCellCoord(V), this._convertFromCellCoord($), this._convertFromCellCoord(V + 1), this._convertFromCellCoord($ + 1))) && b.call(this, n, h, f, m, X, v, A, E)) return;
          }
        }
        _convertFromCellCoord(n) {
          return (n - this.padding) / this.scale;
        }
        _convertToCellCoord(n) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(n * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer) return this.arrayBuffer;
          const n = this.cells, h = 3 + this.cells.length + 1 + 1;
          let f = 0;
          for (let v = 0; v < this.cells.length; v++) f += this.cells[v].length;
          const m = new Int32Array(h + f + this.keys.length + this.bboxes.length);
          m[0] = this.extent, m[1] = this.n, m[2] = this.padding;
          let b = h;
          for (let v = 0; v < n.length; v++) {
            const A = n[v];
            m[3 + v] = b, m.set(A, b), b += A.length;
          }
          return m[3 + n.length] = b, m.set(this.keys, b), b += this.keys.length, m[3 + n.length + 1] = b, m.set(this.bboxes, b), b += this.bboxes.length, m.buffer;
        }
        static serialize(n, h) {
          const f = n.toArrayBuffer();
          return h && h.push(f), { buffer: f };
        }
        static deserialize(n) {
          return new Uo(n.buffer);
        }
      }
      const pr = {};
      function ot(a, n, h = {}) {
        if (pr[a]) throw new Error(`${a} is already registered.`);
        Object.defineProperty(n, "_classRegistryKey", { value: a, writeable: !1 }), pr[a] = { klass: n, omit: h.omit || [], shallow: h.shallow || [] };
      }
      ot("Object", Object), ot("TransferableGridIndex", Uo), ot("Color", jt), ot("Error", Error), ot("AJAXError", Qt), ot("ResolvedImage", Ri), ot("StylePropertyFunction", ko), ot("StyleExpression", Sl, { omit: ["_evaluator"] }), ot("ZoomDependentExpression", Fo), ot("ZoomConstantExpression", Oo), ot("CompoundExpression", dr, { omit: ["_evaluate"] });
      for (const a in Io) Io[a]._classRegistryKey || ot(`Expression_${a}`, Io[a]);
      function kl(a) {
        return a && typeof ArrayBuffer < "u" && (a instanceof ArrayBuffer || a.constructor && a.constructor.name === "ArrayBuffer");
      }
      function wh(a) {
        return a.$name || a.constructor._classRegistryKey;
      }
      function _d(a) {
        return !function(n) {
          if (n === null || typeof n != "object") return !1;
          const h = wh(n);
          return !(!h || h === "Object");
        }(a) && (a == null || typeof a == "boolean" || typeof a == "number" || typeof a == "string" || a instanceof Boolean || a instanceof Number || a instanceof String || a instanceof Date || a instanceof RegExp || a instanceof Blob || a instanceof Error || kl(a) || Hi(a) || ArrayBuffer.isView(a) || a instanceof ImageData);
      }
      function zo(a, n) {
        if (_d(a)) return (kl(a) || Hi(a)) && n && n.push(a), ArrayBuffer.isView(a) && n && n.push(a.buffer), a instanceof ImageData && n && n.push(a.data.buffer), a;
        if (Array.isArray(a)) {
          const b = [];
          for (const v of a) b.push(zo(v, n));
          return b;
        }
        if (typeof a != "object") throw new Error("can't serialize object of type " + typeof a);
        const h = wh(a);
        if (!h) throw new Error(`can't serialize object of unregistered class ${a.constructor.name}`);
        if (!pr[h]) throw new Error(`${h} is not registered.`);
        const { klass: f } = pr[h], m = f.serialize ? f.serialize(a, n) : {};
        if (f.serialize) {
          if (n && m === n[n.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
        } else {
          for (const b in a) {
            if (!a.hasOwnProperty(b) || pr[h].omit.indexOf(b) >= 0) continue;
            const v = a[b];
            m[b] = pr[h].shallow.indexOf(b) >= 0 ? v : zo(v, n);
          }
          a instanceof Error && (m.message = a.message);
        }
        if (m.$name) throw new Error("$name property is reserved for worker serialization logic.");
        return h !== "Object" && (m.$name = h), m;
      }
      function Vo(a) {
        if (_d(a)) return a;
        if (Array.isArray(a)) return a.map(Vo);
        if (typeof a != "object") throw new Error("can't deserialize object of type " + typeof a);
        const n = wh(a) || "Object";
        if (!pr[n]) throw new Error(`can't deserialize unregistered class ${n}`);
        const { klass: h } = pr[n];
        if (!h) throw new Error(`can't deserialize unregistered class ${n}`);
        if (h.deserialize) return h.deserialize(a);
        const f = Object.create(h.prototype);
        for (const m of Object.keys(a)) {
          if (m === "$name") continue;
          const b = a[m];
          f[m] = pr[n].shallow.indexOf(m) >= 0 ? b : Vo(b);
        }
        return f;
      }
      class Ah {
        constructor() {
          this.first = !0;
        }
        update(n, h) {
          const f = Math.floor(n);
          return this.first ? (this.first = !1, this.lastIntegerZoom = f, this.lastIntegerZoomTime = 0, this.lastZoom = n, this.lastFloorZoom = f, !0) : (this.lastFloorZoom > f ? (this.lastIntegerZoom = f + 1, this.lastIntegerZoomTime = h) : this.lastFloorZoom < f && (this.lastIntegerZoom = f, this.lastIntegerZoomTime = h), n !== this.lastZoom && (this.lastZoom = n, this.lastFloorZoom = f, !0));
        }
      }
      const kt = { "Latin-1 Supplement": (a) => a >= 128 && a <= 255, "Hangul Jamo": (a) => a >= 4352 && a <= 4607, Khmer: (a) => a >= 6016 && a <= 6143, "General Punctuation": (a) => a >= 8192 && a <= 8303, "Letterlike Symbols": (a) => a >= 8448 && a <= 8527, "Number Forms": (a) => a >= 8528 && a <= 8591, "Miscellaneous Technical": (a) => a >= 8960 && a <= 9215, "Control Pictures": (a) => a >= 9216 && a <= 9279, "Optical Character Recognition": (a) => a >= 9280 && a <= 9311, "Enclosed Alphanumerics": (a) => a >= 9312 && a <= 9471, "Geometric Shapes": (a) => a >= 9632 && a <= 9727, "Miscellaneous Symbols": (a) => a >= 9728 && a <= 9983, "Miscellaneous Symbols and Arrows": (a) => a >= 11008 && a <= 11263, "Ideographic Description Characters": (a) => a >= 12272 && a <= 12287, "CJK Symbols and Punctuation": (a) => a >= 12288 && a <= 12351, Katakana: (a) => a >= 12448 && a <= 12543, Kanbun: (a) => a >= 12688 && a <= 12703, "CJK Strokes": (a) => a >= 12736 && a <= 12783, "Enclosed CJK Letters and Months": (a) => a >= 12800 && a <= 13055, "CJK Compatibility": (a) => a >= 13056 && a <= 13311, "Yijing Hexagram Symbols": (a) => a >= 19904 && a <= 19967, "Private Use Area": (a) => a >= 57344 && a <= 63743, "Vertical Forms": (a) => a >= 65040 && a <= 65055, "CJK Compatibility Forms": (a) => a >= 65072 && a <= 65103, "Small Form Variants": (a) => a >= 65104 && a <= 65135, "Halfwidth and Fullwidth Forms": (a) => a >= 65280 && a <= 65519 };
      function Th(a) {
        for (const n of a) if (Sh(n.charCodeAt(0))) return !0;
        return !1;
      }
      function Xp(a) {
        for (const n of a) if (!Ho(n.charCodeAt(0))) return !1;
        return !0;
      }
      function Eh(a) {
        const n = a.map((h) => {
          try {
            return new RegExp(`\\p{sc=${h}}`, "u").source;
          } catch {
            return null;
          }
        }).filter((h) => h);
        return new RegExp(n.join("|"), "u");
      }
      const Wp = Eh(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
      function Ho(a) {
        return !Wp.test(String.fromCodePoint(a));
      }
      const md = Eh(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
      function Sh(a) {
        return !(a !== 746 && a !== 747 && (a < 4352 || !(kt["CJK Compatibility Forms"](a) && !(a >= 65097 && a <= 65103) || kt["CJK Compatibility"](a) || kt["CJK Strokes"](a) || !(!kt["CJK Symbols and Punctuation"](a) || a >= 12296 && a <= 12305 || a >= 12308 && a <= 12319 || a === 12336) || kt["Enclosed CJK Letters and Months"](a) || kt["Ideographic Description Characters"](a) || kt.Kanbun(a) || kt.Katakana(a) && a !== 12540 || !(!kt["Halfwidth and Fullwidth Forms"](a) || a === 65288 || a === 65289 || a === 65293 || a >= 65306 && a <= 65310 || a === 65339 || a === 65341 || a === 65343 || a >= 65371 && a <= 65503 || a === 65507 || a >= 65512 && a <= 65519) || !(!kt["Small Form Variants"](a) || a >= 65112 && a <= 65118 || a >= 65123 && a <= 65126) || kt["Vertical Forms"](a) || kt["Yijing Hexagram Symbols"](a) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(a)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(a)) || md.test(String.fromCodePoint(a)))));
      }
      function gd(a) {
        return !(Sh(a) || function(n) {
          return !!(kt["Latin-1 Supplement"](n) && (n === 167 || n === 169 || n === 174 || n === 177 || n === 188 || n === 189 || n === 190 || n === 215 || n === 247) || kt["General Punctuation"](n) && (n === 8214 || n === 8224 || n === 8225 || n === 8240 || n === 8241 || n === 8251 || n === 8252 || n === 8258 || n === 8263 || n === 8264 || n === 8265 || n === 8273) || kt["Letterlike Symbols"](n) || kt["Number Forms"](n) || kt["Miscellaneous Technical"](n) && (n >= 8960 && n <= 8967 || n >= 8972 && n <= 8991 || n >= 8996 && n <= 9e3 || n === 9003 || n >= 9085 && n <= 9114 || n >= 9150 && n <= 9165 || n === 9167 || n >= 9169 && n <= 9179 || n >= 9186 && n <= 9215) || kt["Control Pictures"](n) && n !== 9251 || kt["Optical Character Recognition"](n) || kt["Enclosed Alphanumerics"](n) || kt["Geometric Shapes"](n) || kt["Miscellaneous Symbols"](n) && !(n >= 9754 && n <= 9759) || kt["Miscellaneous Symbols and Arrows"](n) && (n >= 11026 && n <= 11055 || n >= 11088 && n <= 11097 || n >= 11192 && n <= 11243) || kt["CJK Symbols and Punctuation"](n) || kt.Katakana(n) || kt["Private Use Area"](n) || kt["CJK Compatibility Forms"](n) || kt["Small Form Variants"](n) || kt["Halfwidth and Fullwidth Forms"](n) || n === 8734 || n === 8756 || n === 8757 || n >= 9984 && n <= 10087 || n >= 10102 && n <= 10131 || n === 65532 || n === 65533);
        }(a));
      }
      const qp = Eh(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
      function Ch(a) {
        return qp.test(String.fromCodePoint(a));
      }
      function Zp(a, n) {
        return !(!n && Ch(a) || a >= 2304 && a <= 3583 || a >= 3840 && a <= 4255 || kt.Khmer(a));
      }
      function Kp(a) {
        for (const n of a) if (Ch(n.charCodeAt(0))) return !0;
        return !1;
      }
      const ir = new class {
        constructor() {
          this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null;
        }
        setState(a) {
          this.pluginStatus = a.pluginStatus, this.pluginURL = a.pluginURL;
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(a) {
          this.applyArabicShaping = a.applyArabicShaping, this.processBidirectionalText = a.processBidirectionalText, this.processStyledBidirectionalText = a.processStyledBidirectionalText;
        }
        isParsed() {
          return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
        }
        getPluginURL() {
          return this.pluginURL;
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
      }();
      class fi {
        constructor(n, h) {
          this.zoom = n, h ? (this.now = h.now, this.fadeDuration = h.fadeDuration, this.zoomHistory = h.zoomHistory, this.transition = h.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Ah(), this.transition = {});
        }
        isSupportedScript(n) {
          return function(h, f) {
            for (const m of h) if (!Zp(m.charCodeAt(0), f)) return !1;
            return !0;
          }(n, ir.getRTLTextPluginStatus() === "loaded");
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const n = this.zoom, h = n - Math.floor(n), f = this.crossFadingFactor();
          return n > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: h + (1 - h) * f } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - f) * h };
        }
      }
      class jo {
        constructor(n, h) {
          this.property = n, this.value = h, this.expression = function(f, m) {
            if (Tl(f)) return new ko(f, m);
            if (Cl(f)) {
              const b = lh(f, m);
              if (b.result === "error") throw new Error(b.value.map((v) => `${v.key}: ${v.message}`).join(", "));
              return b.value;
            }
            {
              let b = f;
              return m.type === "color" && typeof f == "string" ? b = jt.parse(f) : m.type !== "padding" || typeof f != "number" && !Array.isArray(f) ? m.type === "variableAnchorOffsetCollection" && Array.isArray(f) && (b = Ii.parse(f)) : b = Ci.parse(f), { kind: "constant", evaluate: () => b };
            }
          }(h === void 0 ? n.specification.default : h, n.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(n, h, f) {
          return this.property.possiblyEvaluate(this, n, h, f);
        }
      }
      class Nl {
        constructor(n) {
          this.property = n, this.value = new jo(n, void 0);
        }
        transitioned(n, h) {
          return new yd(this.property, this.value, h, nt({}, n.transition, this.transition), n.now);
        }
        untransitioned() {
          return new yd(this.property, this.value, null, {}, 0);
        }
      }
      class Ll {
        constructor(n) {
          this._properties = n, this._values = Object.create(n.defaultTransitionablePropertyValues);
        }
        getValue(n) {
          return it(this._values[n].value.value);
        }
        setValue(n, h) {
          Object.prototype.hasOwnProperty.call(this._values, n) || (this._values[n] = new Nl(this._values[n].property)), this._values[n].value = new jo(this._values[n].property, h === null ? void 0 : it(h));
        }
        getTransition(n) {
          return it(this._values[n].transition);
        }
        setTransition(n, h) {
          Object.prototype.hasOwnProperty.call(this._values, n) || (this._values[n] = new Nl(this._values[n].property)), this._values[n].transition = it(h) || void 0;
        }
        serialize() {
          const n = {};
          for (const h of Object.keys(this._values)) {
            const f = this.getValue(h);
            f !== void 0 && (n[h] = f);
            const m = this.getTransition(h);
            m !== void 0 && (n[`${h}-transition`] = m);
          }
          return n;
        }
        transitioned(n, h) {
          const f = new Fa(this._properties);
          for (const m of Object.keys(this._values)) f._values[m] = this._values[m].transitioned(n, h._values[m]);
          return f;
        }
        untransitioned() {
          const n = new Fa(this._properties);
          for (const h of Object.keys(this._values)) n._values[h] = this._values[h].untransitioned();
          return n;
        }
      }
      class yd {
        constructor(n, h, f, m, b) {
          this.property = n, this.value = h, this.begin = b + m.delay || 0, this.end = this.begin + m.duration || 0, n.specification.transition && (m.delay || m.duration) && (this.prior = f);
        }
        possiblyEvaluate(n, h, f) {
          const m = n.now || 0, b = this.value.possiblyEvaluate(n, h, f), v = this.prior;
          if (v) {
            if (m > this.end) return this.prior = null, b;
            if (this.value.isDataDriven()) return this.prior = null, b;
            if (m < this.begin) return v.possiblyEvaluate(n, h, f);
            {
              const A = (m - this.begin) / (this.end - this.begin);
              return this.property.interpolate(v.possiblyEvaluate(n, h, f), b, function(E) {
                if (E <= 0) return 0;
                if (E >= 1) return 1;
                const R = E * E, B = R * E;
                return 4 * (E < 0.5 ? B : 3 * (E - R) + B - 0.75);
              }(A));
            }
          }
          return b;
        }
      }
      class Fa {
        constructor(n) {
          this._properties = n, this._values = Object.create(n.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(n, h, f) {
          const m = new Na(this._properties);
          for (const b of Object.keys(this._values)) m._values[b] = this._values[b].possiblyEvaluate(n, h, f);
          return m;
        }
        hasTransition() {
          for (const n of Object.keys(this._values)) if (this._values[n].prior) return !0;
          return !1;
        }
      }
      class ka {
        constructor(n) {
          this._properties = n, this._values = Object.create(n.defaultPropertyValues);
        }
        hasValue(n) {
          return this._values[n].value !== void 0;
        }
        getValue(n) {
          return it(this._values[n].value);
        }
        setValue(n, h) {
          this._values[n] = new jo(this._values[n].property, h === null ? void 0 : it(h));
        }
        serialize() {
          const n = {};
          for (const h of Object.keys(this._values)) {
            const f = this.getValue(h);
            f !== void 0 && (n[h] = f);
          }
          return n;
        }
        possiblyEvaluate(n, h, f) {
          const m = new Na(this._properties);
          for (const b of Object.keys(this._values)) m._values[b] = this._values[b].possiblyEvaluate(n, h, f);
          return m;
        }
      }
      class Zr {
        constructor(n, h, f) {
          this.property = n, this.value = h, this.parameters = f;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(n) {
          return this.value.kind === "constant" ? this.value.value : n;
        }
        evaluate(n, h, f, m) {
          return this.property.evaluate(this.value, this.parameters, n, h, f, m);
        }
      }
      class Na {
        constructor(n) {
          this._properties = n, this._values = Object.create(n.defaultPossiblyEvaluatedValues);
        }
        get(n) {
          return this._values[n];
        }
      }
      class ht {
        constructor(n) {
          this.specification = n;
        }
        possiblyEvaluate(n, h) {
          if (n.isDataDriven()) throw new Error("Value should not be data driven");
          return n.expression.evaluate(h);
        }
        interpolate(n, h, f) {
          const m = Us[this.specification.type];
          return m ? m(n, h, f) : n;
        }
      }
      class vt {
        constructor(n, h) {
          this.specification = n, this.overrides = h;
        }
        possiblyEvaluate(n, h, f, m) {
          return new Zr(this, n.expression.kind === "constant" || n.expression.kind === "camera" ? { kind: "constant", value: n.expression.evaluate(h, null, {}, f, m) } : n.expression, h);
        }
        interpolate(n, h, f) {
          if (n.value.kind !== "constant" || h.value.kind !== "constant") return n;
          if (n.value.value === void 0 || h.value.value === void 0) return new Zr(this, { kind: "constant", value: void 0 }, n.parameters);
          const m = Us[this.specification.type];
          if (m) {
            const b = m(n.value.value, h.value.value, f);
            return new Zr(this, { kind: "constant", value: b }, n.parameters);
          }
          return n;
        }
        evaluate(n, h, f, m, b, v) {
          return n.kind === "constant" ? n.value : n.evaluate(h, f, m, b, v);
        }
      }
      class Ul extends vt {
        possiblyEvaluate(n, h, f, m) {
          if (n.value === void 0) return new Zr(this, { kind: "constant", value: void 0 }, h);
          if (n.expression.kind === "constant") {
            const b = n.expression.evaluate(h, null, {}, f, m), v = n.property.specification.type === "resolvedImage" && typeof b != "string" ? b.name : b, A = this._calculate(v, v, v, h);
            return new Zr(this, { kind: "constant", value: A }, h);
          }
          if (n.expression.kind === "camera") {
            const b = this._calculate(n.expression.evaluate({ zoom: h.zoom - 1 }), n.expression.evaluate({ zoom: h.zoom }), n.expression.evaluate({ zoom: h.zoom + 1 }), h);
            return new Zr(this, { kind: "constant", value: b }, h);
          }
          return new Zr(this, n.expression, h);
        }
        evaluate(n, h, f, m, b, v) {
          if (n.kind === "source") {
            const A = n.evaluate(h, f, m, b, v);
            return this._calculate(A, A, A, h);
          }
          return n.kind === "composite" ? this._calculate(n.evaluate({ zoom: Math.floor(h.zoom) - 1 }, f, m), n.evaluate({ zoom: Math.floor(h.zoom) }, f, m), n.evaluate({ zoom: Math.floor(h.zoom) + 1 }, f, m), h) : n.value;
        }
        _calculate(n, h, f, m) {
          return m.zoom > m.zoomHistory.lastIntegerZoom ? { from: n, to: h } : { from: f, to: h };
        }
        interpolate(n) {
          return n;
        }
      }
      class zl {
        constructor(n) {
          this.specification = n;
        }
        possiblyEvaluate(n, h, f, m) {
          if (n.value !== void 0) {
            if (n.expression.kind === "constant") {
              const b = n.expression.evaluate(h, null, {}, f, m);
              return this._calculate(b, b, b, h);
            }
            return this._calculate(n.expression.evaluate(new fi(Math.floor(h.zoom - 1), h)), n.expression.evaluate(new fi(Math.floor(h.zoom), h)), n.expression.evaluate(new fi(Math.floor(h.zoom + 1), h)), h);
          }
        }
        _calculate(n, h, f, m) {
          return m.zoom > m.zoomHistory.lastIntegerZoom ? { from: n, to: h } : { from: f, to: h };
        }
        interpolate(n) {
          return n;
        }
      }
      class Ih {
        constructor(n) {
          this.specification = n;
        }
        possiblyEvaluate(n, h, f, m) {
          return !!n.expression.evaluate(h, null, {}, f, m);
        }
        interpolate() {
          return !1;
        }
      }
      class y {
        constructor(n) {
          this.properties = n, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const h in n) {
            const f = n[h];
            f.specification.overridable && this.overridableProperties.push(h);
            const m = this.defaultPropertyValues[h] = new jo(f, void 0), b = this.defaultTransitionablePropertyValues[h] = new Nl(f);
            this.defaultTransitioningPropertyValues[h] = b.untransitioned(), this.defaultPossiblyEvaluatedValues[h] = m.possiblyEvaluate({});
          }
        }
      }
      ot("DataDrivenProperty", vt), ot("DataConstantProperty", ht), ot("CrossFadedDataDrivenProperty", Ul), ot("CrossFadedProperty", zl), ot("ColorRampProperty", Ih);
      const r = "-transition";
      class d extends lr {
        constructor(n, h) {
          if (super(), this.id = n.id, this.type = n.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, n.type !== "custom" && (this.metadata = n.metadata, this.minzoom = n.minzoom, this.maxzoom = n.maxzoom, n.type !== "background" && (this.source = n.source, this.sourceLayer = n["source-layer"], this.filter = n.filter), h.layout && (this._unevaluatedLayout = new ka(h.layout)), h.paint)) {
            this._transitionablePaint = new Ll(h.paint);
            for (const f in n.paint) this.setPaintProperty(f, n.paint[f], { validate: !1 });
            for (const f in n.layout) this.setLayoutProperty(f, n.layout[f], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Na(h.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(n) {
          return n === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(n);
        }
        setLayoutProperty(n, h, f = {}) {
          h != null && this._validate(pd, `layers.${this.id}.layout.${n}`, n, h, f) || (n !== "visibility" ? this._unevaluatedLayout.setValue(n, h) : this.visibility = h);
        }
        getPaintProperty(n) {
          return n.endsWith(r) ? this._transitionablePaint.getTransition(n.slice(0, -11)) : this._transitionablePaint.getValue(n);
        }
        setPaintProperty(n, h, f = {}) {
          if (h != null && this._validate(fd, `layers.${this.id}.paint.${n}`, n, h, f)) return !1;
          if (n.endsWith(r)) return this._transitionablePaint.setTransition(n.slice(0, -11), h || void 0), !1;
          {
            const m = this._transitionablePaint._values[n], b = m.property.specification["property-type"] === "cross-faded-data-driven", v = m.value.isDataDriven(), A = m.value;
            this._transitionablePaint.setValue(n, h), this._handleSpecialPaintPropertyUpdate(n);
            const E = this._transitionablePaint._values[n].value;
            return E.isDataDriven() || v || b || this._handleOverridablePaintPropertyUpdate(n, A, E);
          }
        }
        _handleSpecialPaintPropertyUpdate(n) {
        }
        _handleOverridablePaintPropertyUpdate(n, h, f) {
          return !1;
        }
        isHidden(n) {
          return !!(this.minzoom && n < this.minzoom) || !!(this.maxzoom && n >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(n) {
          this._transitioningPaint = this._transitionablePaint.transitioned(n, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(n, h) {
          n.getCrossfadeParameters && (this._crossfadeParameters = n.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(n, void 0, h)), this.paint = this._transitioningPaint.possiblyEvaluate(n, void 0, h);
        }
        serialize() {
          const n = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (n.layout = n.layout || {}, n.layout.visibility = this.visibility), at(n, (h, f) => !(h === void 0 || f === "layout" && !Object.keys(h).length || f === "paint" && !Object.keys(h).length));
        }
        _validate(n, h, f, m, b = {}) {
          return (!b || b.validate !== !1) && xh(this, n.call(lo, { key: h, layerType: this.type, objectKey: f, value: m, styleSpec: Ie, style: { glyphs: !0, sprite: !0 } }));
        }
        is3D() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        resize() {
        }
        isStateDependent() {
          for (const n in this.paint._values) {
            const h = this.paint.get(n);
            if (h instanceof Zr && Po(h.property.specification) && (h.value.kind === "source" || h.value.kind === "composite") && h.value.isStateDependent) return !0;
          }
          return !1;
        }
      }
      const p = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class _ {
        constructor(n, h) {
          this._structArray = n, this._pos1 = h * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class g {
        constructor() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        }
        static serialize(n, h) {
          return n._trim(), h && (n.isTransferred = !0, h.push(n.arrayBuffer)), { length: n.length, arrayBuffer: n.arrayBuffer };
        }
        static deserialize(n) {
          const h = Object.create(this.prototype);
          return h.arrayBuffer = n.arrayBuffer, h.length = n.length, h.capacity = n.arrayBuffer.byteLength / h.bytesPerElement, h._refreshViews(), h;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(n) {
          this.reserve(n), this.length = n;
        }
        reserve(n) {
          if (n > this.capacity) {
            this.capacity = Math.max(n, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const h = this.uint8;
            this._refreshViews(), h && this.uint8.set(h);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function T(a, n = 1) {
        let h = 0, f = 0;
        return { members: a.map((m) => {
          const b = p[m.type].BYTES_PER_ELEMENT, v = h = S(h, Math.max(n, b)), A = m.components || 1;
          return f = Math.max(f, b), h += b * A, { name: m.name, type: m.type, components: A, offset: v };
        }), size: S(h, Math.max(f, n)), alignment: n };
      }
      function S(a, n) {
        return Math.ceil(a / n) * n;
      }
      class I extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(n, h) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, n, h);
        }
        emplace(n, h, f) {
          const m = 2 * n;
          return this.int16[m + 0] = h, this.int16[m + 1] = f, n;
        }
      }
      I.prototype.bytesPerElement = 4, ot("StructArrayLayout2i4", I);
      class D extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f) {
          const m = this.length;
          return this.resize(m + 1), this.emplace(m, n, h, f);
        }
        emplace(n, h, f, m) {
          const b = 3 * n;
          return this.int16[b + 0] = h, this.int16[b + 1] = f, this.int16[b + 2] = m, n;
        }
      }
      D.prototype.bytesPerElement = 6, ot("StructArrayLayout3i6", D);
      class k extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f, m) {
          const b = this.length;
          return this.resize(b + 1), this.emplace(b, n, h, f, m);
        }
        emplace(n, h, f, m, b) {
          const v = 4 * n;
          return this.int16[v + 0] = h, this.int16[v + 1] = f, this.int16[v + 2] = m, this.int16[v + 3] = b, n;
        }
      }
      k.prototype.bytesPerElement = 8, ot("StructArrayLayout4i8", k);
      class N extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f, m, b, v) {
          const A = this.length;
          return this.resize(A + 1), this.emplace(A, n, h, f, m, b, v);
        }
        emplace(n, h, f, m, b, v, A) {
          const E = 6 * n;
          return this.int16[E + 0] = h, this.int16[E + 1] = f, this.int16[E + 2] = m, this.int16[E + 3] = b, this.int16[E + 4] = v, this.int16[E + 5] = A, n;
        }
      }
      N.prototype.bytesPerElement = 12, ot("StructArrayLayout2i4i12", N);
      class H extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f, m, b, v) {
          const A = this.length;
          return this.resize(A + 1), this.emplace(A, n, h, f, m, b, v);
        }
        emplace(n, h, f, m, b, v, A) {
          const E = 4 * n, R = 8 * n;
          return this.int16[E + 0] = h, this.int16[E + 1] = f, this.uint8[R + 4] = m, this.uint8[R + 5] = b, this.uint8[R + 6] = v, this.uint8[R + 7] = A, n;
        }
      }
      H.prototype.bytesPerElement = 8, ot("StructArrayLayout2i4ub8", H);
      class q extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(n, h) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, n, h);
        }
        emplace(n, h, f) {
          const m = 2 * n;
          return this.float32[m + 0] = h, this.float32[m + 1] = f, n;
        }
      }
      q.prototype.bytesPerElement = 8, ot("StructArrayLayout2f8", q);
      class K extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f, m, b, v, A, E, R, B) {
          const F = this.length;
          return this.resize(F + 1), this.emplace(F, n, h, f, m, b, v, A, E, R, B);
        }
        emplace(n, h, f, m, b, v, A, E, R, B, F) {
          const L = 10 * n;
          return this.uint16[L + 0] = h, this.uint16[L + 1] = f, this.uint16[L + 2] = m, this.uint16[L + 3] = b, this.uint16[L + 4] = v, this.uint16[L + 5] = A, this.uint16[L + 6] = E, this.uint16[L + 7] = R, this.uint16[L + 8] = B, this.uint16[L + 9] = F, n;
        }
      }
      K.prototype.bytesPerElement = 20, ot("StructArrayLayout10ui20", K);
      class se extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f, m, b, v, A, E, R, B, F, L) {
          const V = this.length;
          return this.resize(V + 1), this.emplace(V, n, h, f, m, b, v, A, E, R, B, F, L);
        }
        emplace(n, h, f, m, b, v, A, E, R, B, F, L, V) {
          const $ = 12 * n;
          return this.int16[$ + 0] = h, this.int16[$ + 1] = f, this.int16[$ + 2] = m, this.int16[$ + 3] = b, this.uint16[$ + 4] = v, this.uint16[$ + 5] = A, this.uint16[$ + 6] = E, this.uint16[$ + 7] = R, this.int16[$ + 8] = B, this.int16[$ + 9] = F, this.int16[$ + 10] = L, this.int16[$ + 11] = V, n;
        }
      }
      se.prototype.bytesPerElement = 24, ot("StructArrayLayout4i4ui4i24", se);
      class oe extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f) {
          const m = this.length;
          return this.resize(m + 1), this.emplace(m, n, h, f);
        }
        emplace(n, h, f, m) {
          const b = 3 * n;
          return this.float32[b + 0] = h, this.float32[b + 1] = f, this.float32[b + 2] = m, n;
        }
      }
      oe.prototype.bytesPerElement = 12, ot("StructArrayLayout3f12", oe);
      class ae extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(n) {
          const h = this.length;
          return this.resize(h + 1), this.emplace(h, n);
        }
        emplace(n, h) {
          return this.uint32[1 * n + 0] = h, n;
        }
      }
      ae.prototype.bytesPerElement = 4, ot("StructArrayLayout1ul4", ae);
      class he extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f, m, b, v, A, E, R) {
          const B = this.length;
          return this.resize(B + 1), this.emplace(B, n, h, f, m, b, v, A, E, R);
        }
        emplace(n, h, f, m, b, v, A, E, R, B) {
          const F = 10 * n, L = 5 * n;
          return this.int16[F + 0] = h, this.int16[F + 1] = f, this.int16[F + 2] = m, this.int16[F + 3] = b, this.int16[F + 4] = v, this.int16[F + 5] = A, this.uint32[L + 3] = E, this.uint16[F + 8] = R, this.uint16[F + 9] = B, n;
        }
      }
      he.prototype.bytesPerElement = 20, ot("StructArrayLayout6i1ul2ui20", he);
      class te extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f, m, b, v) {
          const A = this.length;
          return this.resize(A + 1), this.emplace(A, n, h, f, m, b, v);
        }
        emplace(n, h, f, m, b, v, A) {
          const E = 6 * n;
          return this.int16[E + 0] = h, this.int16[E + 1] = f, this.int16[E + 2] = m, this.int16[E + 3] = b, this.int16[E + 4] = v, this.int16[E + 5] = A, n;
        }
      }
      te.prototype.bytesPerElement = 12, ot("StructArrayLayout2i2i2i12", te);
      class fe extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f, m, b) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, n, h, f, m, b);
        }
        emplace(n, h, f, m, b, v) {
          const A = 4 * n, E = 8 * n;
          return this.float32[A + 0] = h, this.float32[A + 1] = f, this.float32[A + 2] = m, this.int16[E + 6] = b, this.int16[E + 7] = v, n;
        }
      }
      fe.prototype.bytesPerElement = 16, ot("StructArrayLayout2f1f2i16", fe);
      class ge extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f, m, b, v) {
          const A = this.length;
          return this.resize(A + 1), this.emplace(A, n, h, f, m, b, v);
        }
        emplace(n, h, f, m, b, v, A) {
          const E = 16 * n, R = 4 * n, B = 8 * n;
          return this.uint8[E + 0] = h, this.uint8[E + 1] = f, this.float32[R + 1] = m, this.float32[R + 2] = b, this.int16[B + 6] = v, this.int16[B + 7] = A, n;
        }
      }
      ge.prototype.bytesPerElement = 16, ot("StructArrayLayout2ub2f2i16", ge);
      class Te extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f) {
          const m = this.length;
          return this.resize(m + 1), this.emplace(m, n, h, f);
        }
        emplace(n, h, f, m) {
          const b = 3 * n;
          return this.uint16[b + 0] = h, this.uint16[b + 1] = f, this.uint16[b + 2] = m, n;
        }
      }
      Te.prototype.bytesPerElement = 6, ot("StructArrayLayout3ui6", Te);
      class Fe extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f, m, b, v, A, E, R, B, F, L, V, $, X, ie, ne) {
          const Ae = this.length;
          return this.resize(Ae + 1), this.emplace(Ae, n, h, f, m, b, v, A, E, R, B, F, L, V, $, X, ie, ne);
        }
        emplace(n, h, f, m, b, v, A, E, R, B, F, L, V, $, X, ie, ne, Ae) {
          const de = 24 * n, ye = 12 * n, Pe = 48 * n;
          return this.int16[de + 0] = h, this.int16[de + 1] = f, this.uint16[de + 2] = m, this.uint16[de + 3] = b, this.uint32[ye + 2] = v, this.uint32[ye + 3] = A, this.uint32[ye + 4] = E, this.uint16[de + 10] = R, this.uint16[de + 11] = B, this.uint16[de + 12] = F, this.float32[ye + 7] = L, this.float32[ye + 8] = V, this.uint8[Pe + 36] = $, this.uint8[Pe + 37] = X, this.uint8[Pe + 38] = ie, this.uint32[ye + 10] = ne, this.int16[de + 22] = Ae, n;
        }
      }
      Fe.prototype.bytesPerElement = 48, ot("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Fe);
      class Ve extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f, m, b, v, A, E, R, B, F, L, V, $, X, ie, ne, Ae, de, ye, Pe, Le, tt, bt, Qe, Je, ft, ct) {
          const rt = this.length;
          return this.resize(rt + 1), this.emplace(rt, n, h, f, m, b, v, A, E, R, B, F, L, V, $, X, ie, ne, Ae, de, ye, Pe, Le, tt, bt, Qe, Je, ft, ct);
        }
        emplace(n, h, f, m, b, v, A, E, R, B, F, L, V, $, X, ie, ne, Ae, de, ye, Pe, Le, tt, bt, Qe, Je, ft, ct, rt) {
          const De = 32 * n, _t = 16 * n;
          return this.int16[De + 0] = h, this.int16[De + 1] = f, this.int16[De + 2] = m, this.int16[De + 3] = b, this.int16[De + 4] = v, this.int16[De + 5] = A, this.int16[De + 6] = E, this.int16[De + 7] = R, this.uint16[De + 8] = B, this.uint16[De + 9] = F, this.uint16[De + 10] = L, this.uint16[De + 11] = V, this.uint16[De + 12] = $, this.uint16[De + 13] = X, this.uint16[De + 14] = ie, this.uint16[De + 15] = ne, this.uint16[De + 16] = Ae, this.uint16[De + 17] = de, this.uint16[De + 18] = ye, this.uint16[De + 19] = Pe, this.uint16[De + 20] = Le, this.uint16[De + 21] = tt, this.uint16[De + 22] = bt, this.uint32[_t + 12] = Qe, this.float32[_t + 13] = Je, this.float32[_t + 14] = ft, this.uint16[De + 30] = ct, this.uint16[De + 31] = rt, n;
        }
      }
      Ve.prototype.bytesPerElement = 64, ot("StructArrayLayout8i15ui1ul2f2ui64", Ve);
      class Ye extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(n) {
          const h = this.length;
          return this.resize(h + 1), this.emplace(h, n);
        }
        emplace(n, h) {
          return this.float32[1 * n + 0] = h, n;
        }
      }
      Ye.prototype.bytesPerElement = 4, ot("StructArrayLayout1f4", Ye);
      class st extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f) {
          const m = this.length;
          return this.resize(m + 1), this.emplace(m, n, h, f);
        }
        emplace(n, h, f, m) {
          const b = 3 * n;
          return this.uint16[6 * n + 0] = h, this.float32[b + 1] = f, this.float32[b + 2] = m, n;
        }
      }
      st.prototype.bytesPerElement = 12, ot("StructArrayLayout1ui2f12", st);
      class Ze extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f) {
          const m = this.length;
          return this.resize(m + 1), this.emplace(m, n, h, f);
        }
        emplace(n, h, f, m) {
          const b = 4 * n;
          return this.uint32[2 * n + 0] = h, this.uint16[b + 2] = f, this.uint16[b + 3] = m, n;
        }
      }
      Ze.prototype.bytesPerElement = 8, ot("StructArrayLayout1ul2ui8", Ze);
      class Ge extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(n, h) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, n, h);
        }
        emplace(n, h, f) {
          const m = 2 * n;
          return this.uint16[m + 0] = h, this.uint16[m + 1] = f, n;
        }
      }
      Ge.prototype.bytesPerElement = 4, ot("StructArrayLayout2ui4", Ge);
      class ut extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(n) {
          const h = this.length;
          return this.resize(h + 1), this.emplace(h, n);
        }
        emplace(n, h) {
          return this.uint16[1 * n + 0] = h, n;
        }
      }
      ut.prototype.bytesPerElement = 2, ot("StructArrayLayout1ui2", ut);
      class Et extends g {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(n, h, f, m) {
          const b = this.length;
          return this.resize(b + 1), this.emplace(b, n, h, f, m);
        }
        emplace(n, h, f, m, b) {
          const v = 4 * n;
          return this.float32[v + 0] = h, this.float32[v + 1] = f, this.float32[v + 2] = m, this.float32[v + 3] = b, n;
        }
      }
      Et.prototype.bytesPerElement = 16, ot("StructArrayLayout4f16", Et);
      class Ke extends _ {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new M(this.anchorPointX, this.anchorPointY);
        }
      }
      Ke.prototype.size = 20;
      class et extends he {
        get(n) {
          return new Ke(this, n);
        }
      }
      ot("CollisionBoxArray", et);
      class At extends _ {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(n) {
          this._structArray.uint8[this._pos1 + 37] = n;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(n) {
          this._structArray.uint8[this._pos1 + 38] = n;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(n) {
          this._structArray.uint32[this._pos4 + 10] = n;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      At.prototype.size = 48;
      class pi extends Fe {
        get(n) {
          return new At(this, n);
        }
      }
      ot("PlacedSymbolArray", pi);
      class Mt extends _ {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(n) {
          this._structArray.uint32[this._pos4 + 12] = n;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      Mt.prototype.size = 64;
      class Ot extends Ve {
        get(n) {
          return new Mt(this, n);
        }
      }
      ot("SymbolInstanceArray", Ot);
      class _i extends Ye {
        getoffsetX(n) {
          return this.float32[1 * n + 0];
        }
      }
      ot("GlyphOffsetArray", _i);
      class gs extends D {
        getx(n) {
          return this.int16[3 * n + 0];
        }
        gety(n) {
          return this.int16[3 * n + 1];
        }
        gettileUnitDistanceFromAnchor(n) {
          return this.int16[3 * n + 2];
        }
      }
      ot("SymbolLineVertexArray", gs);
      class Ir extends _ {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      Ir.prototype.size = 12;
      class mi extends st {
        get(n) {
          return new Ir(this, n);
        }
      }
      ot("TextAnchorOffsetArray", mi);
      class Vs extends _ {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      Vs.prototype.size = 8;
      class Ms extends Ze {
        get(n) {
          return new Vs(this, n);
        }
      }
      ot("FeatureIndexArray", Ms);
      class ys extends I {
      }
      class Ps extends I {
      }
      class Kr extends I {
      }
      class $o extends N {
      }
      class Vl extends H {
      }
      class Go extends q {
      }
      class _r extends K {
      }
      class Hl extends se {
      }
      class Rh extends oe {
      }
      class mr extends ae {
      }
      class gr extends te {
      }
      class Bn extends ge {
      }
      class Rr extends Te {
      }
      class ls extends Ge {
      }
      const bs = T([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: sr } = bs;
      class Nt {
        constructor(n = []) {
          this.segments = n;
        }
        prepareSegment(n, h, f, m) {
          let b = this.segments[this.segments.length - 1];
          return n > Nt.MAX_VERTEX_ARRAY_LENGTH && Rt(`Max vertices per segment is ${Nt.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${n}`), (!b || b.vertexLength + n > Nt.MAX_VERTEX_ARRAY_LENGTH || b.sortKey !== m) && (b = { vertexOffset: h.length, primitiveOffset: f.length, vertexLength: 0, primitiveLength: 0 }, m !== void 0 && (b.sortKey = m), this.segments.push(b)), b;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const n of this.segments) for (const h in n.vaos) n.vaos[h].destroy();
        }
        static simpleSegment(n, h, f, m) {
          return new Nt([{ vertexOffset: n, primitiveOffset: h, vertexLength: f, primitiveLength: m, vaos: {}, sortKey: 0 }]);
        }
      }
      function co(a, n) {
        return 256 * (a = Ne(Math.floor(a), 0, 255)) + Ne(Math.floor(n), 0, 255);
      }
      Nt.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, ot("SegmentVector", Nt);
      const Xo = T([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
      var Wo = { exports: {} }, bd = { exports: {} };
      bd.exports = function(a, n) {
        var h, f, m, b, v, A, E, R;
        for (f = a.length - (h = 3 & a.length), m = n, v = 3432918353, A = 461845907, R = 0; R < f; ) E = 255 & a.charCodeAt(R) | (255 & a.charCodeAt(++R)) << 8 | (255 & a.charCodeAt(++R)) << 16 | (255 & a.charCodeAt(++R)) << 24, ++R, m = 27492 + (65535 & (b = 5 * (65535 & (m = (m ^= E = (65535 & (E = (E = (65535 & E) * v + (((E >>> 16) * v & 65535) << 16) & 4294967295) << 15 | E >>> 17)) * A + (((E >>> 16) * A & 65535) << 16) & 4294967295) << 13 | m >>> 19)) + ((5 * (m >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (b >>> 16) & 65535) << 16);
        switch (E = 0, h) {
          case 3:
            E ^= (255 & a.charCodeAt(R + 2)) << 16;
          case 2:
            E ^= (255 & a.charCodeAt(R + 1)) << 8;
          case 1:
            m ^= E = (65535 & (E = (E = (65535 & (E ^= 255 & a.charCodeAt(R))) * v + (((E >>> 16) * v & 65535) << 16) & 4294967295) << 15 | E >>> 17)) * A + (((E >>> 16) * A & 65535) << 16) & 4294967295;
        }
        return m ^= a.length, m = 2246822507 * (65535 & (m ^= m >>> 16)) + ((2246822507 * (m >>> 16) & 65535) << 16) & 4294967295, m = 3266489909 * (65535 & (m ^= m >>> 13)) + ((3266489909 * (m >>> 16) & 65535) << 16) & 4294967295, (m ^= m >>> 16) >>> 0;
      };
      var Jp = bd.exports, vd = { exports: {} };
      vd.exports = function(a, n) {
        for (var h, f = a.length, m = n ^ f, b = 0; f >= 4; ) h = 1540483477 * (65535 & (h = 255 & a.charCodeAt(b) | (255 & a.charCodeAt(++b)) << 8 | (255 & a.charCodeAt(++b)) << 16 | (255 & a.charCodeAt(++b)) << 24)) + ((1540483477 * (h >>> 16) & 65535) << 16), m = 1540483477 * (65535 & m) + ((1540483477 * (m >>> 16) & 65535) << 16) ^ (h = 1540483477 * (65535 & (h ^= h >>> 24)) + ((1540483477 * (h >>> 16) & 65535) << 16)), f -= 4, ++b;
        switch (f) {
          case 3:
            m ^= (255 & a.charCodeAt(b + 2)) << 16;
          case 2:
            m ^= (255 & a.charCodeAt(b + 1)) << 8;
          case 1:
            m = 1540483477 * (65535 & (m ^= 255 & a.charCodeAt(b))) + ((1540483477 * (m >>> 16) & 65535) << 16);
        }
        return m = 1540483477 * (65535 & (m ^= m >>> 13)) + ((1540483477 * (m >>> 16) & 65535) << 16), (m ^= m >>> 15) >>> 0;
      };
      var Dn = Jp, xd = vd.exports;
      Wo.exports = Dn, Wo.exports.murmur3 = Dn, Wo.exports.murmur2 = xd;
      var jl = x(Wo.exports);
      class La {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = !1;
        }
        add(n, h, f, m) {
          this.ids.push($l(n)), this.positions.push(h, f, m);
        }
        getPositions(n) {
          if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
          const h = $l(n);
          let f = 0, m = this.ids.length - 1;
          for (; f < m; ) {
            const v = f + m >> 1;
            this.ids[v] >= h ? m = v : f = v + 1;
          }
          const b = [];
          for (; this.ids[f] === h; ) b.push({ index: this.positions[3 * f], start: this.positions[3 * f + 1], end: this.positions[3 * f + 2] }), f++;
          return b;
        }
        static serialize(n, h) {
          const f = new Float64Array(n.ids), m = new Uint32Array(n.positions);
          return Gl(f, m, 0, f.length - 1), h && h.push(f.buffer, m.buffer), { ids: f, positions: m };
        }
        static deserialize(n) {
          const h = new La();
          return h.ids = n.ids, h.positions = n.positions, h.indexed = !0, h;
        }
      }
      function $l(a) {
        const n = +a;
        return !isNaN(n) && n <= Number.MAX_SAFE_INTEGER ? n : jl(String(a));
      }
      function Gl(a, n, h, f) {
        for (; h < f; ) {
          const m = a[h + f >> 1];
          let b = h - 1, v = f + 1;
          for (; ; ) {
            do
              b++;
            while (a[b] < m);
            do
              v--;
            while (a[v] > m);
            if (b >= v) break;
            qo(a, b, v), qo(n, 3 * b, 3 * v), qo(n, 3 * b + 1, 3 * v + 1), qo(n, 3 * b + 2, 3 * v + 2);
          }
          v - h < f - v ? (Gl(a, n, h, v), h = v + 1) : (Gl(a, n, v + 1, f), f = v);
        }
      }
      function qo(a, n, h) {
        const f = a[n];
        a[n] = a[h], a[h] = f;
      }
      ot("FeaturePositionMap", La);
      class Ua {
        constructor(n, h) {
          this.gl = n.gl, this.location = h;
        }
      }
      class wd extends Ua {
        constructor(n, h) {
          super(n, h), this.current = 0;
        }
        set(n) {
          this.current !== n && (this.current = n, this.gl.uniform1f(this.location, n));
        }
      }
      class Gy extends Ua {
        constructor(n, h) {
          super(n, h), this.current = [0, 0, 0, 0];
        }
        set(n) {
          n[0] === this.current[0] && n[1] === this.current[1] && n[2] === this.current[2] && n[3] === this.current[3] || (this.current = n, this.gl.uniform4f(this.location, n[0], n[1], n[2], n[3]));
        }
      }
      class Xy extends Ua {
        constructor(n, h) {
          super(n, h), this.current = jt.transparent;
        }
        set(n) {
          n.r === this.current.r && n.g === this.current.g && n.b === this.current.b && n.a === this.current.a || (this.current = n, this.gl.uniform4f(this.location, n.r, n.g, n.b, n.a));
        }
      }
      const rE = new Float32Array(16);
      function Yp(a) {
        return [co(255 * a.r, 255 * a.g), co(255 * a.b, 255 * a.a)];
      }
      class Mh {
        constructor(n, h, f) {
          this.value = n, this.uniformNames = h.map((m) => `u_${m}`), this.type = f;
        }
        setUniform(n, h, f) {
          n.set(f.constantOr(this.value));
        }
        getBinding(n, h, f) {
          return this.type === "color" ? new Xy(n, h) : new wd(n, h);
        }
      }
      class Xl {
        constructor(n, h) {
          this.uniformNames = h.map((f) => `u_${f}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(n, h) {
          this.pixelRatioFrom = h.pixelRatio, this.pixelRatioTo = n.pixelRatio, this.patternFrom = h.tlbr, this.patternTo = n.tlbr;
        }
        setUniform(n, h, f, m) {
          const b = m === "u_pattern_to" ? this.patternTo : m === "u_pattern_from" ? this.patternFrom : m === "u_pixel_ratio_to" ? this.pixelRatioTo : m === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          b && n.set(b);
        }
        getBinding(n, h, f) {
          return f.substr(0, 9) === "u_pattern" ? new Gy(n, h) : new wd(n, h);
        }
      }
      class ho {
        constructor(n, h, f, m) {
          this.expression = n, this.type = f, this.maxValue = 0, this.paintVertexAttributes = h.map((b) => ({ name: `a_${b}`, type: "Float32", components: f === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new m();
        }
        populatePaintArray(n, h, f, m, b) {
          const v = this.paintVertexArray.length, A = this.expression.evaluate(new fi(0), h, {}, m, [], b);
          this.paintVertexArray.resize(n), this._setPaintValue(v, n, A);
        }
        updatePaintArray(n, h, f, m) {
          const b = this.expression.evaluate({ zoom: 0 }, f, m);
          this._setPaintValue(n, h, b);
        }
        _setPaintValue(n, h, f) {
          if (this.type === "color") {
            const m = Yp(f);
            for (let b = n; b < h; b++) this.paintVertexArray.emplace(b, m[0], m[1]);
          } else {
            for (let m = n; m < h; m++) this.paintVertexArray.emplace(m, f);
            this.maxValue = Math.max(this.maxValue, Math.abs(f));
          }
        }
        upload(n) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = n.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class cn {
        constructor(n, h, f, m, b, v) {
          this.expression = n, this.uniformNames = h.map((A) => `u_${A}_t`), this.type = f, this.useIntegerZoom = m, this.zoom = b, this.maxValue = 0, this.paintVertexAttributes = h.map((A) => ({ name: `a_${A}`, type: "Float32", components: f === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new v();
        }
        populatePaintArray(n, h, f, m, b) {
          const v = this.expression.evaluate(new fi(this.zoom), h, {}, m, [], b), A = this.expression.evaluate(new fi(this.zoom + 1), h, {}, m, [], b), E = this.paintVertexArray.length;
          this.paintVertexArray.resize(n), this._setPaintValue(E, n, v, A);
        }
        updatePaintArray(n, h, f, m) {
          const b = this.expression.evaluate({ zoom: this.zoom }, f, m), v = this.expression.evaluate({ zoom: this.zoom + 1 }, f, m);
          this._setPaintValue(n, h, b, v);
        }
        _setPaintValue(n, h, f, m) {
          if (this.type === "color") {
            const b = Yp(f), v = Yp(m);
            for (let A = n; A < h; A++) this.paintVertexArray.emplace(A, b[0], b[1], v[0], v[1]);
          } else {
            for (let b = n; b < h; b++) this.paintVertexArray.emplace(b, f, m);
            this.maxValue = Math.max(this.maxValue, Math.abs(f), Math.abs(m));
          }
        }
        upload(n) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = n.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(n, h) {
          const f = this.useIntegerZoom ? Math.floor(h.zoom) : h.zoom, m = Ne(this.expression.interpolationFactor(f, this.zoom, this.zoom + 1), 0, 1);
          n.set(m);
        }
        getBinding(n, h, f) {
          return new wd(n, h);
        }
      }
      class Zo {
        constructor(n, h, f, m, b, v) {
          this.expression = n, this.type = h, this.useIntegerZoom = f, this.zoom = m, this.layerId = v, this.zoomInPaintVertexArray = new b(), this.zoomOutPaintVertexArray = new b();
        }
        populatePaintArray(n, h, f) {
          const m = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(n), this.zoomOutPaintVertexArray.resize(n), this._setPaintValues(m, n, h.patterns && h.patterns[this.layerId], f);
        }
        updatePaintArray(n, h, f, m, b) {
          this._setPaintValues(n, h, f.patterns && f.patterns[this.layerId], b);
        }
        _setPaintValues(n, h, f, m) {
          if (!m || !f) return;
          const { min: b, mid: v, max: A } = f, E = m[b], R = m[v], B = m[A];
          if (E && R && B) for (let F = n; F < h; F++) this.zoomInPaintVertexArray.emplace(F, R.tl[0], R.tl[1], R.br[0], R.br[1], E.tl[0], E.tl[1], E.br[0], E.br[1], R.pixelRatio, E.pixelRatio), this.zoomOutPaintVertexArray.emplace(F, R.tl[0], R.tl[1], R.br[0], R.br[1], B.tl[0], B.tl[1], B.br[0], B.br[1], R.pixelRatio, B.pixelRatio);
        }
        upload(n) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = n.createVertexBuffer(this.zoomInPaintVertexArray, Xo.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = n.createVertexBuffer(this.zoomOutPaintVertexArray, Xo.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class Wy {
        constructor(n, h, f) {
          this.binders = {}, this._buffers = [];
          const m = [];
          for (const b in n.paint._values) {
            if (!f(b)) continue;
            const v = n.paint.get(b);
            if (!(v instanceof Zr && Po(v.property.specification))) continue;
            const A = nE(b, n.type), E = v.value, R = v.property.specification.type, B = v.property.useIntegerZoom, F = v.property.specification["property-type"], L = F === "cross-faded" || F === "cross-faded-data-driven";
            if (E.kind === "constant") this.binders[b] = L ? new Xl(E.value, A) : new Mh(E.value, A, R), m.push(`/u_${b}`);
            else if (E.kind === "source" || L) {
              const V = qy(b, R, "source");
              this.binders[b] = L ? new Zo(E, R, B, h, V, n.id) : new ho(E, A, R, V), m.push(`/a_${b}`);
            } else {
              const V = qy(b, R, "composite");
              this.binders[b] = new cn(E, A, R, B, h, V), m.push(`/z_${b}`);
            }
          }
          this.cacheKey = m.sort().join("");
        }
        getMaxValue(n) {
          const h = this.binders[n];
          return h instanceof ho || h instanceof cn ? h.maxValue : 0;
        }
        populatePaintArrays(n, h, f, m, b) {
          for (const v in this.binders) {
            const A = this.binders[v];
            (A instanceof ho || A instanceof cn || A instanceof Zo) && A.populatePaintArray(n, h, f, m, b);
          }
        }
        setConstantPatternPositions(n, h) {
          for (const f in this.binders) {
            const m = this.binders[f];
            m instanceof Xl && m.setConstantPatternPositions(n, h);
          }
        }
        updatePaintArrays(n, h, f, m, b) {
          let v = !1;
          for (const A in n) {
            const E = h.getPositions(A);
            for (const R of E) {
              const B = f.feature(R.index);
              for (const F in this.binders) {
                const L = this.binders[F];
                if ((L instanceof ho || L instanceof cn || L instanceof Zo) && L.expression.isStateDependent === !0) {
                  const V = m.paint.get(F);
                  L.expression = V.value, L.updatePaintArray(R.start, R.end, B, n[A], b), v = !0;
                }
              }
            }
          }
          return v;
        }
        defines() {
          const n = [];
          for (const h in this.binders) {
            const f = this.binders[h];
            (f instanceof Mh || f instanceof Xl) && n.push(...f.uniformNames.map((m) => `#define HAS_UNIFORM_${m}`));
          }
          return n;
        }
        getBinderAttributes() {
          const n = [];
          for (const h in this.binders) {
            const f = this.binders[h];
            if (f instanceof ho || f instanceof cn) for (let m = 0; m < f.paintVertexAttributes.length; m++) n.push(f.paintVertexAttributes[m].name);
            else if (f instanceof Zo) for (let m = 0; m < Xo.members.length; m++) n.push(Xo.members[m].name);
          }
          return n;
        }
        getBinderUniforms() {
          const n = [];
          for (const h in this.binders) {
            const f = this.binders[h];
            if (f instanceof Mh || f instanceof Xl || f instanceof cn) for (const m of f.uniformNames) n.push(m);
          }
          return n;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(n, h) {
          const f = [];
          for (const m in this.binders) {
            const b = this.binders[m];
            if (b instanceof Mh || b instanceof Xl || b instanceof cn) {
              for (const v of b.uniformNames) if (h[v]) {
                const A = b.getBinding(n, h[v], v);
                f.push({ name: v, property: m, binding: A });
              }
            }
          }
          return f;
        }
        setUniforms(n, h, f, m) {
          for (const { name: b, property: v, binding: A } of h) this.binders[v].setUniform(A, m, f.get(v), b);
        }
        updatePaintBuffers(n) {
          this._buffers = [];
          for (const h in this.binders) {
            const f = this.binders[h];
            if (n && f instanceof Zo) {
              const m = n.fromScale === 2 ? f.zoomInPaintVertexBuffer : f.zoomOutPaintVertexBuffer;
              m && this._buffers.push(m);
            } else (f instanceof ho || f instanceof cn) && f.paintVertexBuffer && this._buffers.push(f.paintVertexBuffer);
          }
        }
        upload(n) {
          for (const h in this.binders) {
            const f = this.binders[h];
            (f instanceof ho || f instanceof cn || f instanceof Zo) && f.upload(n);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const n in this.binders) {
            const h = this.binders[n];
            (h instanceof ho || h instanceof cn || h instanceof Zo) && h.destroy();
          }
        }
      }
      class za {
        constructor(n, h, f = () => !0) {
          this.programConfigurations = {};
          for (const m of n) this.programConfigurations[m.id] = new Wy(m, h, f);
          this.needsUpload = !1, this._featureMap = new La(), this._bufferOffset = 0;
        }
        populatePaintArrays(n, h, f, m, b, v) {
          for (const A in this.programConfigurations) this.programConfigurations[A].populatePaintArrays(n, h, m, b, v);
          h.id !== void 0 && this._featureMap.add(h.id, f, this._bufferOffset, n), this._bufferOffset = n, this.needsUpload = !0;
        }
        updatePaintArrays(n, h, f, m) {
          for (const b of f) this.needsUpload = this.programConfigurations[b.id].updatePaintArrays(n, this._featureMap, h, b, m) || this.needsUpload;
        }
        get(n) {
          return this.programConfigurations[n];
        }
        upload(n) {
          if (this.needsUpload) {
            for (const h in this.programConfigurations) this.programConfigurations[h].upload(n);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const n in this.programConfigurations) this.programConfigurations[n].destroy();
        }
      }
      function nE(a, n) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[a] || [a.replace(`${n}-`, "").replace(/-/g, "_")];
      }
      function qy(a, n, h) {
        const f = { color: { source: q, composite: Et }, number: { source: Ye, composite: q } }, m = function(b) {
          return { "line-pattern": { source: _r, composite: _r }, "fill-pattern": { source: _r, composite: _r }, "fill-extrusion-pattern": { source: _r, composite: _r } }[b];
        }(a);
        return m && m[h] || f[n][h];
      }
      ot("ConstantBinder", Mh), ot("CrossFadedConstantBinder", Xl), ot("SourceExpressionBinder", ho), ot("CrossFadedCompositeBinder", Zo), ot("CompositeExpressionBinder", cn), ot("ProgramConfiguration", Wy, { omit: ["_buffers"] }), ot("ProgramConfigurationSet", za);
      const Xi = 8192, Qp = Math.pow(2, 14) - 1, Zy = -Qp - 1;
      function Va(a) {
        const n = Xi / a.extent, h = a.loadGeometry();
        for (let f = 0; f < h.length; f++) {
          const m = h[f];
          for (let b = 0; b < m.length; b++) {
            const v = m[b], A = Math.round(v.x * n), E = Math.round(v.y * n);
            v.x = Ne(A, Zy, Qp), v.y = Ne(E, Zy, Qp), (A < v.x || A > v.x + 1 || E < v.y || E > v.y + 1) && Rt("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return h;
      }
      function Ha(a, n) {
        return { type: a.type, id: a.id, properties: a.properties, geometry: n ? Va(a) : [] };
      }
      function Ad(a, n, h, f, m) {
        a.emplaceBack(2 * n + (f + 1) / 2, 2 * h + (m + 1) / 2);
      }
      class e_ {
        constructor(n) {
          this.zoom = n.zoom, this.overscaling = n.overscaling, this.layers = n.layers, this.layerIds = this.layers.map((h) => h.id), this.index = n.index, this.hasPattern = !1, this.layoutVertexArray = new Ps(), this.indexArray = new Rr(), this.segments = new Nt(), this.programConfigurations = new za(n.layers, n.zoom), this.stateDependentLayerIds = this.layers.filter((h) => h.isStateDependent()).map((h) => h.id);
        }
        populate(n, h, f) {
          const m = this.layers[0], b = [];
          let v = null, A = !1;
          m.type === "circle" && (v = m.layout.get("circle-sort-key"), A = !v.isConstant());
          for (const { feature: E, id: R, index: B, sourceLayerIndex: F } of n) {
            const L = this.layers[0]._featureFilter.needGeometry, V = Ha(E, L);
            if (!this.layers[0]._featureFilter.filter(new fi(this.zoom), V, f)) continue;
            const $ = A ? v.evaluate(V, {}, f) : void 0, X = { id: R, properties: E.properties, type: E.type, sourceLayerIndex: F, index: B, geometry: L ? V.geometry : Va(E), patterns: {}, sortKey: $ };
            b.push(X);
          }
          A && b.sort((E, R) => E.sortKey - R.sortKey);
          for (const E of b) {
            const { geometry: R, index: B, sourceLayerIndex: F } = E, L = n[B].feature;
            this.addFeature(E, R, B, f), h.featureIndex.insert(L, R, B, F, this.index);
          }
        }
        update(n, h, f) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, h, this.stateDependentLayers, f);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(n) {
          this.uploaded || (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, sr), this.indexBuffer = n.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(n), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(n, h, f, m) {
          for (const b of h) for (const v of b) {
            const A = v.x, E = v.y;
            if (A < 0 || A >= Xi || E < 0 || E >= Xi) continue;
            const R = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, n.sortKey), B = R.vertexLength;
            Ad(this.layoutVertexArray, A, E, -1, -1), Ad(this.layoutVertexArray, A, E, 1, -1), Ad(this.layoutVertexArray, A, E, 1, 1), Ad(this.layoutVertexArray, A, E, -1, 1), this.indexArray.emplaceBack(B, B + 1, B + 2), this.indexArray.emplaceBack(B, B + 3, B + 2), R.vertexLength += 4, R.primitiveLength += 2;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, f, {}, m);
        }
      }
      function Ky(a, n) {
        for (let h = 0; h < a.length; h++) if (Wl(n, a[h])) return !0;
        for (let h = 0; h < n.length; h++) if (Wl(a, n[h])) return !0;
        return !!t_(a, n);
      }
      function oE(a, n, h) {
        return !!Wl(a, n) || !!i_(n, a, h);
      }
      function Jy(a, n) {
        if (a.length === 1) return Qy(n, a[0]);
        for (let h = 0; h < n.length; h++) {
          const f = n[h];
          for (let m = 0; m < f.length; m++) if (Wl(a, f[m])) return !0;
        }
        for (let h = 0; h < a.length; h++) if (Qy(n, a[h])) return !0;
        for (let h = 0; h < n.length; h++) if (t_(a, n[h])) return !0;
        return !1;
      }
      function aE(a, n, h) {
        if (a.length > 1) {
          if (t_(a, n)) return !0;
          for (let f = 0; f < n.length; f++) if (i_(n[f], a, h)) return !0;
        }
        for (let f = 0; f < a.length; f++) if (i_(a[f], n, h)) return !0;
        return !1;
      }
      function t_(a, n) {
        if (a.length === 0 || n.length === 0) return !1;
        for (let h = 0; h < a.length - 1; h++) {
          const f = a[h], m = a[h + 1];
          for (let b = 0; b < n.length - 1; b++) if (lE(f, m, n[b], n[b + 1])) return !0;
        }
        return !1;
      }
      function lE(a, n, h, f) {
        return yt(a, h, f) !== yt(n, h, f) && yt(a, n, h) !== yt(a, n, f);
      }
      function i_(a, n, h) {
        const f = h * h;
        if (n.length === 1) return a.distSqr(n[0]) < f;
        for (let m = 1; m < n.length; m++) if (Yy(a, n[m - 1], n[m]) < f) return !0;
        return !1;
      }
      function Yy(a, n, h) {
        const f = n.distSqr(h);
        if (f === 0) return a.distSqr(n);
        const m = ((a.x - n.x) * (h.x - n.x) + (a.y - n.y) * (h.y - n.y)) / f;
        return a.distSqr(m < 0 ? n : m > 1 ? h : h.sub(n)._mult(m)._add(n));
      }
      function Qy(a, n) {
        let h, f, m, b = !1;
        for (let v = 0; v < a.length; v++) {
          h = a[v];
          for (let A = 0, E = h.length - 1; A < h.length; E = A++) f = h[A], m = h[E], f.y > n.y != m.y > n.y && n.x < (m.x - f.x) * (n.y - f.y) / (m.y - f.y) + f.x && (b = !b);
        }
        return b;
      }
      function Wl(a, n) {
        let h = !1;
        for (let f = 0, m = a.length - 1; f < a.length; m = f++) {
          const b = a[f], v = a[m];
          b.y > n.y != v.y > n.y && n.x < (v.x - b.x) * (n.y - b.y) / (v.y - b.y) + b.x && (h = !h);
        }
        return h;
      }
      function cE(a, n, h) {
        const f = h[0], m = h[2];
        if (a.x < f.x && n.x < f.x || a.x > m.x && n.x > m.x || a.y < f.y && n.y < f.y || a.y > m.y && n.y > m.y) return !1;
        const b = yt(a, n, h[0]);
        return b !== yt(a, n, h[1]) || b !== yt(a, n, h[2]) || b !== yt(a, n, h[3]);
      }
      function Ph(a, n, h) {
        const f = n.paint.get(a).value;
        return f.kind === "constant" ? f.value : h.programConfigurations.get(n.id).getMaxValue(a);
      }
      function Td(a) {
        return Math.sqrt(a[0] * a[0] + a[1] * a[1]);
      }
      function Ed(a, n, h, f, m) {
        if (!n[0] && !n[1]) return a;
        const b = M.convert(n)._mult(m);
        h === "viewport" && b._rotate(-f);
        const v = [];
        for (let A = 0; A < a.length; A++) v.push(a[A].sub(b));
        return v;
      }
      let e0, t0;
      ot("CircleBucket", e_, { omit: ["layers"] });
      var hE = { get paint() {
        return t0 = t0 || new y({ "circle-radius": new vt(Ie.paint_circle["circle-radius"]), "circle-color": new vt(Ie.paint_circle["circle-color"]), "circle-blur": new vt(Ie.paint_circle["circle-blur"]), "circle-opacity": new vt(Ie.paint_circle["circle-opacity"]), "circle-translate": new ht(Ie.paint_circle["circle-translate"]), "circle-translate-anchor": new ht(Ie.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new ht(Ie.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new ht(Ie.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new vt(Ie.paint_circle["circle-stroke-width"]), "circle-stroke-color": new vt(Ie.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new vt(Ie.paint_circle["circle-stroke-opacity"]) });
      }, get layout() {
        return e0 = e0 || new y({ "circle-sort-key": new vt(Ie.layout_circle["circle-sort-key"]) });
      } }, Hs = 1e-6, ql = typeof Float32Array < "u" ? Float32Array : Array;
      function s_(a) {
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
      }
      function i0(a, n, h) {
        var f = n[0], m = n[1], b = n[2], v = n[3], A = n[4], E = n[5], R = n[6], B = n[7], F = n[8], L = n[9], V = n[10], $ = n[11], X = n[12], ie = n[13], ne = n[14], Ae = n[15], de = h[0], ye = h[1], Pe = h[2], Le = h[3];
        return a[0] = de * f + ye * A + Pe * F + Le * X, a[1] = de * m + ye * E + Pe * L + Le * ie, a[2] = de * b + ye * R + Pe * V + Le * ne, a[3] = de * v + ye * B + Pe * $ + Le * Ae, a[4] = (de = h[4]) * f + (ye = h[5]) * A + (Pe = h[6]) * F + (Le = h[7]) * X, a[5] = de * m + ye * E + Pe * L + Le * ie, a[6] = de * b + ye * R + Pe * V + Le * ne, a[7] = de * v + ye * B + Pe * $ + Le * Ae, a[8] = (de = h[8]) * f + (ye = h[9]) * A + (Pe = h[10]) * F + (Le = h[11]) * X, a[9] = de * m + ye * E + Pe * L + Le * ie, a[10] = de * b + ye * R + Pe * V + Le * ne, a[11] = de * v + ye * B + Pe * $ + Le * Ae, a[12] = (de = h[12]) * f + (ye = h[13]) * A + (Pe = h[14]) * F + (Le = h[15]) * X, a[13] = de * m + ye * E + Pe * L + Le * ie, a[14] = de * b + ye * R + Pe * V + Le * ne, a[15] = de * v + ye * B + Pe * $ + Le * Ae, a;
      }
      Math.hypot || (Math.hypot = function() {
        for (var a = 0, n = arguments.length; n--; ) a += arguments[n] * arguments[n];
        return Math.sqrt(a);
      });
      var Bh, uE = i0;
      function Sd(a, n, h) {
        var f = n[0], m = n[1], b = n[2], v = n[3];
        return a[0] = h[0] * f + h[4] * m + h[8] * b + h[12] * v, a[1] = h[1] * f + h[5] * m + h[9] * b + h[13] * v, a[2] = h[2] * f + h[6] * m + h[10] * b + h[14] * v, a[3] = h[3] * f + h[7] * m + h[11] * b + h[15] * v, a;
      }
      Bh = new ql(4), ql != Float32Array && (Bh[0] = 0, Bh[1] = 0, Bh[2] = 0, Bh[3] = 0);
      class dE extends d {
        constructor(n) {
          super(n, hE);
        }
        createBucket(n) {
          return new e_(n);
        }
        queryRadius(n) {
          const h = n;
          return Ph("circle-radius", this, h) + Ph("circle-stroke-width", this, h) + Td(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(n, h, f, m, b, v, A, E) {
          const R = Ed(n, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), v.angle, A), B = this.paint.get("circle-radius").evaluate(h, f) + this.paint.get("circle-stroke-width").evaluate(h, f), F = this.paint.get("circle-pitch-alignment") === "map", L = F ? R : function($, X) {
            return $.map((ie) => s0(ie, X));
          }(R, E), V = F ? B * A : B;
          for (const $ of m) for (const X of $) {
            const ie = F ? X : s0(X, E);
            let ne = V;
            const Ae = Sd([], [X.x, X.y, 0, 1], E);
            if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? ne *= Ae[3] / v.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (ne *= v.cameraToCenterDistance / Ae[3]), oE(L, ie, ne)) return !0;
          }
          return !1;
        }
      }
      function s0(a, n) {
        const h = Sd([], [a.x, a.y, 0, 1], n);
        return new M(h[0] / h[3], h[1] / h[3]);
      }
      class r0 extends e_ {
      }
      let n0;
      ot("HeatmapBucket", r0, { omit: ["layers"] });
      var fE = { get paint() {
        return n0 = n0 || new y({ "heatmap-radius": new vt(Ie.paint_heatmap["heatmap-radius"]), "heatmap-weight": new vt(Ie.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new ht(Ie.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Ih(Ie.paint_heatmap["heatmap-color"]), "heatmap-opacity": new ht(Ie.paint_heatmap["heatmap-opacity"]) });
      } };
      function r_(a, { width: n, height: h }, f, m) {
        if (m) {
          if (m instanceof Uint8ClampedArray) m = new Uint8Array(m.buffer);
          else if (m.length !== n * h * f) throw new RangeError(`mismatched image size. expected: ${m.length} but got: ${n * h * f}`);
        } else m = new Uint8Array(n * h * f);
        return a.width = n, a.height = h, a.data = m, a;
      }
      function o0(a, { width: n, height: h }, f) {
        if (n === a.width && h === a.height) return;
        const m = r_({}, { width: n, height: h }, f);
        n_(a, m, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(a.width, n), height: Math.min(a.height, h) }, f), a.width = n, a.height = h, a.data = m.data;
      }
      function n_(a, n, h, f, m, b) {
        if (m.width === 0 || m.height === 0) return n;
        if (m.width > a.width || m.height > a.height || h.x > a.width - m.width || h.y > a.height - m.height) throw new RangeError("out of range source coordinates for image copy");
        if (m.width > n.width || m.height > n.height || f.x > n.width - m.width || f.y > n.height - m.height) throw new RangeError("out of range destination coordinates for image copy");
        const v = a.data, A = n.data;
        if (v === A) throw new Error("srcData equals dstData, so image is already copied");
        for (let E = 0; E < m.height; E++) {
          const R = ((h.y + E) * a.width + h.x) * b, B = ((f.y + E) * n.width + f.x) * b;
          for (let F = 0; F < m.width * b; F++) A[B + F] = v[R + F];
        }
        return n;
      }
      class Dh {
        constructor(n, h) {
          r_(this, n, 1, h);
        }
        resize(n) {
          o0(this, n, 1);
        }
        clone() {
          return new Dh({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(n, h, f, m, b) {
          n_(n, h, f, m, b, 1);
        }
      }
      class Mr {
        constructor(n, h) {
          r_(this, n, 4, h);
        }
        resize(n) {
          o0(this, n, 4);
        }
        replace(n, h) {
          h ? this.data.set(n) : this.data = n instanceof Uint8ClampedArray ? new Uint8Array(n.buffer) : n;
        }
        clone() {
          return new Mr({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(n, h, f, m, b) {
          n_(n, h, f, m, b, 4);
        }
      }
      function a0(a) {
        const n = {}, h = a.resolution || 256, f = a.clips ? a.clips.length : 1, m = a.image || new Mr({ width: h, height: f });
        if (Math.log(h) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${h}`);
        const b = (v, A, E) => {
          n[a.evaluationKey] = E;
          const R = a.expression.evaluate(n);
          m.data[v + A + 0] = Math.floor(255 * R.r / R.a), m.data[v + A + 1] = Math.floor(255 * R.g / R.a), m.data[v + A + 2] = Math.floor(255 * R.b / R.a), m.data[v + A + 3] = Math.floor(255 * R.a);
        };
        if (a.clips) for (let v = 0, A = 0; v < f; ++v, A += 4 * h) for (let E = 0, R = 0; E < h; E++, R += 4) {
          const B = E / (h - 1), { start: F, end: L } = a.clips[v];
          b(A, R, F * (1 - B) + L * B);
        }
        else for (let v = 0, A = 0; v < h; v++, A += 4) b(0, A, v / (h - 1));
        return m;
      }
      ot("AlphaImage", Dh), ot("RGBAImage", Mr);
      const o_ = "big-fb";
      class pE extends d {
        createBucket(n) {
          return new r0(n);
        }
        constructor(n) {
          super(n, fE), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(n) {
          n === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = a0({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbos.has(o_) && this.heatmapFbos.delete(o_);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      }
      let l0;
      var _E = { get paint() {
        return l0 = l0 || new y({ "hillshade-illumination-direction": new ht(Ie.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new ht(Ie.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new ht(Ie.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new ht(Ie.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new ht(Ie.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new ht(Ie.paint_hillshade["hillshade-accent-color"]) });
      } };
      class mE extends d {
        constructor(n) {
          super(n, _E);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      }
      const gE = T([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: yE } = gE;
      function c0(a, n, h = 2) {
        const f = n && n.length, m = f ? n[0] * h : a.length;
        let b = h0(a, 0, m, h, !0);
        const v = [];
        if (!b || b.next === b.prev) return v;
        let A, E, R;
        if (f && (b = function(B, F, L, V) {
          const $ = [];
          for (let X = 0, ie = F.length; X < ie; X++) {
            const ne = h0(B, F[X] * V, X < ie - 1 ? F[X + 1] * V : B.length, V, !1);
            ne === ne.next && (ne.steiner = !0), $.push(SE(ne));
          }
          $.sort(AE);
          for (let X = 0; X < $.length; X++) L = TE($[X], L);
          return L;
        }(a, n, b, h)), a.length > 80 * h) {
          A = 1 / 0, E = 1 / 0;
          let B = -1 / 0, F = -1 / 0;
          for (let L = h; L < m; L += h) {
            const V = a[L], $ = a[L + 1];
            V < A && (A = V), $ < E && (E = $), V > B && (B = V), $ > F && (F = $);
          }
          R = Math.max(B - A, F - E), R = R !== 0 ? 32767 / R : 0;
        }
        return Oh(b, v, h, A, E, R, 0), v;
      }
      function h0(a, n, h, f, m) {
        let b;
        if (m === function(v, A, E, R) {
          let B = 0;
          for (let F = A, L = E - R; F < E; F += R) B += (v[L] - v[F]) * (v[F + 1] + v[L + 1]), L = F;
          return B;
        }(a, n, h, f) > 0) for (let v = n; v < h; v += f) b = f0(v / f | 0, a[v], a[v + 1], b);
        else for (let v = h - f; v >= n; v -= f) b = f0(v / f | 0, a[v], a[v + 1], b);
        return b && Cd(b, b.next) && (kh(b), b = b.next), b;
      }
      function ja(a, n) {
        if (!a) return a;
        n || (n = a);
        let h, f = a;
        do
          if (h = !1, f.steiner || !Cd(f, f.next) && zi(f.prev, f, f.next) !== 0) f = f.next;
          else {
            if (kh(f), f = n = f.prev, f === f.next) break;
            h = !0;
          }
        while (h || f !== n);
        return n;
      }
      function Oh(a, n, h, f, m, b, v) {
        if (!a) return;
        !v && b && function(E, R, B, F) {
          let L = E;
          do
            L.z === 0 && (L.z = a_(L.x, L.y, R, B, F)), L.prevZ = L.prev, L.nextZ = L.next, L = L.next;
          while (L !== E);
          L.prevZ.nextZ = null, L.prevZ = null, function(V) {
            let $, X = 1;
            do {
              let ie, ne = V;
              V = null;
              let Ae = null;
              for ($ = 0; ne; ) {
                $++;
                let de = ne, ye = 0;
                for (let Le = 0; Le < X && (ye++, de = de.nextZ, de); Le++) ;
                let Pe = X;
                for (; ye > 0 || Pe > 0 && de; ) ye !== 0 && (Pe === 0 || !de || ne.z <= de.z) ? (ie = ne, ne = ne.nextZ, ye--) : (ie = de, de = de.nextZ, Pe--), Ae ? Ae.nextZ = ie : V = ie, ie.prevZ = Ae, Ae = ie;
                ne = de;
              }
              Ae.nextZ = null, X *= 2;
            } while ($ > 1);
          }(L);
        }(a, f, m, b);
        let A = a;
        for (; a.prev !== a.next; ) {
          const E = a.prev, R = a.next;
          if (b ? vE(a, f, m, b) : bE(a)) n.push(E.i, a.i, R.i), kh(a), a = R.next, A = R.next;
          else if ((a = R) === A) {
            v ? v === 1 ? Oh(a = xE(ja(a), n), n, h, f, m, b, 2) : v === 2 && wE(a, n, h, f, m, b) : Oh(ja(a), n, h, f, m, b, 1);
            break;
          }
        }
      }
      function bE(a) {
        const n = a.prev, h = a, f = a.next;
        if (zi(n, h, f) >= 0) return !1;
        const m = n.x, b = h.x, v = f.x, A = n.y, E = h.y, R = f.y, B = m < b ? m < v ? m : v : b < v ? b : v, F = A < E ? A < R ? A : R : E < R ? E : R, L = m > b ? m > v ? m : v : b > v ? b : v, V = A > E ? A > R ? A : R : E > R ? E : R;
        let $ = f.next;
        for (; $ !== n; ) {
          if ($.x >= B && $.x <= L && $.y >= F && $.y <= V && Zl(m, A, b, E, v, R, $.x, $.y) && zi($.prev, $, $.next) >= 0) return !1;
          $ = $.next;
        }
        return !0;
      }
      function vE(a, n, h, f) {
        const m = a.prev, b = a, v = a.next;
        if (zi(m, b, v) >= 0) return !1;
        const A = m.x, E = b.x, R = v.x, B = m.y, F = b.y, L = v.y, V = A < E ? A < R ? A : R : E < R ? E : R, $ = B < F ? B < L ? B : L : F < L ? F : L, X = A > E ? A > R ? A : R : E > R ? E : R, ie = B > F ? B > L ? B : L : F > L ? F : L, ne = a_(V, $, n, h, f), Ae = a_(X, ie, n, h, f);
        let de = a.prevZ, ye = a.nextZ;
        for (; de && de.z >= ne && ye && ye.z <= Ae; ) {
          if (de.x >= V && de.x <= X && de.y >= $ && de.y <= ie && de !== m && de !== v && Zl(A, B, E, F, R, L, de.x, de.y) && zi(de.prev, de, de.next) >= 0 || (de = de.prevZ, ye.x >= V && ye.x <= X && ye.y >= $ && ye.y <= ie && ye !== m && ye !== v && Zl(A, B, E, F, R, L, ye.x, ye.y) && zi(ye.prev, ye, ye.next) >= 0)) return !1;
          ye = ye.nextZ;
        }
        for (; de && de.z >= ne; ) {
          if (de.x >= V && de.x <= X && de.y >= $ && de.y <= ie && de !== m && de !== v && Zl(A, B, E, F, R, L, de.x, de.y) && zi(de.prev, de, de.next) >= 0) return !1;
          de = de.prevZ;
        }
        for (; ye && ye.z <= Ae; ) {
          if (ye.x >= V && ye.x <= X && ye.y >= $ && ye.y <= ie && ye !== m && ye !== v && Zl(A, B, E, F, R, L, ye.x, ye.y) && zi(ye.prev, ye, ye.next) >= 0) return !1;
          ye = ye.nextZ;
        }
        return !0;
      }
      function xE(a, n) {
        let h = a;
        do {
          const f = h.prev, m = h.next.next;
          !Cd(f, m) && u0(f, h, h.next, m) && Fh(f, m) && Fh(m, f) && (n.push(f.i, h.i, m.i), kh(h), kh(h.next), h = a = m), h = h.next;
        } while (h !== a);
        return ja(h);
      }
      function wE(a, n, h, f, m, b) {
        let v = a;
        do {
          let A = v.next.next;
          for (; A !== v.prev; ) {
            if (v.i !== A.i && CE(v, A)) {
              let E = d0(v, A);
              return v = ja(v, v.next), E = ja(E, E.next), Oh(v, n, h, f, m, b, 0), void Oh(E, n, h, f, m, b, 0);
            }
            A = A.next;
          }
          v = v.next;
        } while (v !== a);
      }
      function AE(a, n) {
        return a.x - n.x;
      }
      function TE(a, n) {
        const h = function(m, b) {
          let v = b;
          const A = m.x, E = m.y;
          let R, B = -1 / 0;
          do {
            if (E <= v.y && E >= v.next.y && v.next.y !== v.y) {
              const X = v.x + (E - v.y) * (v.next.x - v.x) / (v.next.y - v.y);
              if (X <= A && X > B && (B = X, R = v.x < v.next.x ? v : v.next, X === A)) return R;
            }
            v = v.next;
          } while (v !== b);
          if (!R) return null;
          const F = R, L = R.x, V = R.y;
          let $ = 1 / 0;
          v = R;
          do {
            if (A >= v.x && v.x >= L && A !== v.x && Zl(E < V ? A : B, E, L, V, E < V ? B : A, E, v.x, v.y)) {
              const X = Math.abs(E - v.y) / (A - v.x);
              Fh(v, m) && (X < $ || X === $ && (v.x > R.x || v.x === R.x && EE(R, v))) && (R = v, $ = X);
            }
            v = v.next;
          } while (v !== F);
          return R;
        }(a, n);
        if (!h) return n;
        const f = d0(h, a);
        return ja(f, f.next), ja(h, h.next);
      }
      function EE(a, n) {
        return zi(a.prev, a, n.prev) < 0 && zi(n.next, a, a.next) < 0;
      }
      function a_(a, n, h, f, m) {
        return (a = 1431655765 & ((a = 858993459 & ((a = 252645135 & ((a = 16711935 & ((a = (a - h) * m | 0) | a << 8)) | a << 4)) | a << 2)) | a << 1)) | (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - f) * m | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) << 1;
      }
      function SE(a) {
        let n = a, h = a;
        do
          (n.x < h.x || n.x === h.x && n.y < h.y) && (h = n), n = n.next;
        while (n !== a);
        return h;
      }
      function Zl(a, n, h, f, m, b, v, A) {
        return (m - v) * (n - A) >= (a - v) * (b - A) && (a - v) * (f - A) >= (h - v) * (n - A) && (h - v) * (b - A) >= (m - v) * (f - A);
      }
      function CE(a, n) {
        return a.next.i !== n.i && a.prev.i !== n.i && !function(h, f) {
          let m = h;
          do {
            if (m.i !== h.i && m.next.i !== h.i && m.i !== f.i && m.next.i !== f.i && u0(m, m.next, h, f)) return !0;
            m = m.next;
          } while (m !== h);
          return !1;
        }(a, n) && (Fh(a, n) && Fh(n, a) && function(h, f) {
          let m = h, b = !1;
          const v = (h.x + f.x) / 2, A = (h.y + f.y) / 2;
          do
            m.y > A != m.next.y > A && m.next.y !== m.y && v < (m.next.x - m.x) * (A - m.y) / (m.next.y - m.y) + m.x && (b = !b), m = m.next;
          while (m !== h);
          return b;
        }(a, n) && (zi(a.prev, a, n.prev) || zi(a, n.prev, n)) || Cd(a, n) && zi(a.prev, a, a.next) > 0 && zi(n.prev, n, n.next) > 0);
      }
      function zi(a, n, h) {
        return (n.y - a.y) * (h.x - n.x) - (n.x - a.x) * (h.y - n.y);
      }
      function Cd(a, n) {
        return a.x === n.x && a.y === n.y;
      }
      function u0(a, n, h, f) {
        const m = Rd(zi(a, n, h)), b = Rd(zi(a, n, f)), v = Rd(zi(h, f, a)), A = Rd(zi(h, f, n));
        return m !== b && v !== A || !(m !== 0 || !Id(a, h, n)) || !(b !== 0 || !Id(a, f, n)) || !(v !== 0 || !Id(h, a, f)) || !(A !== 0 || !Id(h, n, f));
      }
      function Id(a, n, h) {
        return n.x <= Math.max(a.x, h.x) && n.x >= Math.min(a.x, h.x) && n.y <= Math.max(a.y, h.y) && n.y >= Math.min(a.y, h.y);
      }
      function Rd(a) {
        return a > 0 ? 1 : a < 0 ? -1 : 0;
      }
      function Fh(a, n) {
        return zi(a.prev, a, a.next) < 0 ? zi(a, n, a.next) >= 0 && zi(a, a.prev, n) >= 0 : zi(a, n, a.prev) < 0 || zi(a, a.next, n) < 0;
      }
      function d0(a, n) {
        const h = l_(a.i, a.x, a.y), f = l_(n.i, n.x, n.y), m = a.next, b = n.prev;
        return a.next = n, n.prev = a, h.next = m, m.prev = h, f.next = h, h.prev = f, b.next = f, f.prev = b, f;
      }
      function f0(a, n, h, f) {
        const m = l_(a, n, h);
        return f ? (m.next = f.next, m.prev = f, f.next.prev = m, f.next = m) : (m.prev = m, m.next = m), m;
      }
      function kh(a) {
        a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ);
      }
      function l_(a, n, h) {
        return { i: a, x: n, y: h, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
      }
      function c_(a, n, h) {
        const f = h.patternDependencies;
        let m = !1;
        for (const b of n) {
          const v = b.paint.get(`${a}-pattern`);
          v.isConstant() || (m = !0);
          const A = v.constantOr(null);
          A && (m = !0, f[A.to] = !0, f[A.from] = !0);
        }
        return m;
      }
      function h_(a, n, h, f, m) {
        const b = m.patternDependencies;
        for (const v of n) {
          const A = v.paint.get(`${a}-pattern`).value;
          if (A.kind !== "constant") {
            let E = A.evaluate({ zoom: f - 1 }, h, {}, m.availableImages), R = A.evaluate({ zoom: f }, h, {}, m.availableImages), B = A.evaluate({ zoom: f + 1 }, h, {}, m.availableImages);
            E = E && E.name ? E.name : E, R = R && R.name ? R.name : R, B = B && B.name ? B.name : B, b[E] = !0, b[R] = !0, b[B] = !0, h.patterns[v.id] = { min: E, mid: R, max: B };
          }
        }
        return h;
      }
      class u_ {
        constructor(n) {
          this.zoom = n.zoom, this.overscaling = n.overscaling, this.layers = n.layers, this.layerIds = this.layers.map((h) => h.id), this.index = n.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Kr(), this.indexArray = new Rr(), this.indexArray2 = new ls(), this.programConfigurations = new za(n.layers, n.zoom), this.segments = new Nt(), this.segments2 = new Nt(), this.stateDependentLayerIds = this.layers.filter((h) => h.isStateDependent()).map((h) => h.id);
        }
        populate(n, h, f) {
          this.hasPattern = c_("fill", this.layers, h);
          const m = this.layers[0].layout.get("fill-sort-key"), b = !m.isConstant(), v = [];
          for (const { feature: A, id: E, index: R, sourceLayerIndex: B } of n) {
            const F = this.layers[0]._featureFilter.needGeometry, L = Ha(A, F);
            if (!this.layers[0]._featureFilter.filter(new fi(this.zoom), L, f)) continue;
            const V = b ? m.evaluate(L, {}, f, h.availableImages) : void 0, $ = { id: E, properties: A.properties, type: A.type, sourceLayerIndex: B, index: R, geometry: F ? L.geometry : Va(A), patterns: {}, sortKey: V };
            v.push($);
          }
          b && v.sort((A, E) => A.sortKey - E.sortKey);
          for (const A of v) {
            const { geometry: E, index: R, sourceLayerIndex: B } = A;
            if (this.hasPattern) {
              const F = h_("fill", this.layers, A, this.zoom, h);
              this.patternFeatures.push(F);
            } else this.addFeature(A, E, R, f, {});
            h.featureIndex.insert(n[R].feature, E, R, B, this.index);
          }
        }
        update(n, h, f) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, h, this.stateDependentLayers, f);
        }
        addFeatures(n, h, f) {
          for (const m of this.patternFeatures) this.addFeature(m, m.geometry, m.index, h, f);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(n) {
          this.uploaded || (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, yE), this.indexBuffer = n.createIndexBuffer(this.indexArray), this.indexBuffer2 = n.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(n), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(n, h, f, m, b) {
          for (const v of bl(h, 500)) {
            let A = 0;
            for (const V of v) A += V.length;
            const E = this.segments.prepareSegment(A, this.layoutVertexArray, this.indexArray), R = E.vertexLength, B = [], F = [];
            for (const V of v) {
              if (V.length === 0) continue;
              V !== v[0] && F.push(B.length / 2);
              const $ = this.segments2.prepareSegment(V.length, this.layoutVertexArray, this.indexArray2), X = $.vertexLength;
              this.layoutVertexArray.emplaceBack(V[0].x, V[0].y), this.indexArray2.emplaceBack(X + V.length - 1, X), B.push(V[0].x), B.push(V[0].y);
              for (let ie = 1; ie < V.length; ie++) this.layoutVertexArray.emplaceBack(V[ie].x, V[ie].y), this.indexArray2.emplaceBack(X + ie - 1, X + ie), B.push(V[ie].x), B.push(V[ie].y);
              $.vertexLength += V.length, $.primitiveLength += V.length;
            }
            const L = c0(B, F);
            for (let V = 0; V < L.length; V += 3) this.indexArray.emplaceBack(R + L[V], R + L[V + 1], R + L[V + 2]);
            E.vertexLength += A, E.primitiveLength += L.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, f, b, m);
        }
      }
      let p0, _0;
      ot("FillBucket", u_, { omit: ["layers", "patternFeatures"] });
      var IE = { get paint() {
        return _0 = _0 || new y({ "fill-antialias": new ht(Ie.paint_fill["fill-antialias"]), "fill-opacity": new vt(Ie.paint_fill["fill-opacity"]), "fill-color": new vt(Ie.paint_fill["fill-color"]), "fill-outline-color": new vt(Ie.paint_fill["fill-outline-color"]), "fill-translate": new ht(Ie.paint_fill["fill-translate"]), "fill-translate-anchor": new ht(Ie.paint_fill["fill-translate-anchor"]), "fill-pattern": new Ul(Ie.paint_fill["fill-pattern"]) });
      }, get layout() {
        return p0 = p0 || new y({ "fill-sort-key": new vt(Ie.layout_fill["fill-sort-key"]) });
      } };
      class RE extends d {
        constructor(n) {
          super(n, IE);
        }
        recalculate(n, h) {
          super.recalculate(n, h);
          const f = this.paint._values["fill-outline-color"];
          f.value.kind === "constant" && f.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(n) {
          return new u_(n);
        }
        queryRadius() {
          return Td(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(n, h, f, m, b, v, A) {
          return Jy(Ed(n, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), v.angle, A), m);
        }
        isTileClipped() {
          return !0;
        }
      }
      const ME = T([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), PE = T([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: BE } = ME;
      var Ko = {}, DE = w, m0 = Kl;
      function Kl(a, n, h, f, m) {
        this.properties = {}, this.extent = h, this.type = 0, this._pbf = a, this._geometry = -1, this._keys = f, this._values = m, a.readFields(OE, this, n);
      }
      function OE(a, n, h) {
        a == 1 ? n.id = h.readVarint() : a == 2 ? function(f, m) {
          for (var b = f.readVarint() + f.pos; f.pos < b; ) {
            var v = m._keys[f.readVarint()], A = m._values[f.readVarint()];
            m.properties[v] = A;
          }
        }(h, n) : a == 3 ? n.type = h.readVarint() : a == 4 && (n._geometry = h.pos);
      }
      function FE(a) {
        for (var n, h, f = 0, m = 0, b = a.length, v = b - 1; m < b; v = m++) f += ((h = a[v]).x - (n = a[m]).x) * (n.y + h.y);
        return f;
      }
      Kl.types = ["Unknown", "Point", "LineString", "Polygon"], Kl.prototype.loadGeometry = function() {
        var a = this._pbf;
        a.pos = this._geometry;
        for (var n, h = a.readVarint() + a.pos, f = 1, m = 0, b = 0, v = 0, A = []; a.pos < h; ) {
          if (m <= 0) {
            var E = a.readVarint();
            f = 7 & E, m = E >> 3;
          }
          if (m--, f === 1 || f === 2) b += a.readSVarint(), v += a.readSVarint(), f === 1 && (n && A.push(n), n = []), n.push(new DE(b, v));
          else {
            if (f !== 7) throw new Error("unknown command " + f);
            n && n.push(n[0].clone());
          }
        }
        return n && A.push(n), A;
      }, Kl.prototype.bbox = function() {
        var a = this._pbf;
        a.pos = this._geometry;
        for (var n = a.readVarint() + a.pos, h = 1, f = 0, m = 0, b = 0, v = 1 / 0, A = -1 / 0, E = 1 / 0, R = -1 / 0; a.pos < n; ) {
          if (f <= 0) {
            var B = a.readVarint();
            h = 7 & B, f = B >> 3;
          }
          if (f--, h === 1 || h === 2) (m += a.readSVarint()) < v && (v = m), m > A && (A = m), (b += a.readSVarint()) < E && (E = b), b > R && (R = b);
          else if (h !== 7) throw new Error("unknown command " + h);
        }
        return [v, E, A, R];
      }, Kl.prototype.toGeoJSON = function(a, n, h) {
        var f, m, b = this.extent * Math.pow(2, h), v = this.extent * a, A = this.extent * n, E = this.loadGeometry(), R = Kl.types[this.type];
        function B(V) {
          for (var $ = 0; $ < V.length; $++) {
            var X = V[$];
            V[$] = [360 * (X.x + v) / b - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (X.y + A) / b) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var F = [];
            for (f = 0; f < E.length; f++) F[f] = E[f][0];
            B(E = F);
            break;
          case 2:
            for (f = 0; f < E.length; f++) B(E[f]);
            break;
          case 3:
            for (E = function(V) {
              var $ = V.length;
              if ($ <= 1) return [V];
              for (var X, ie, ne = [], Ae = 0; Ae < $; Ae++) {
                var de = FE(V[Ae]);
                de !== 0 && (ie === void 0 && (ie = de < 0), ie === de < 0 ? (X && ne.push(X), X = [V[Ae]]) : X.push(V[Ae]));
              }
              return X && ne.push(X), ne;
            }(E), f = 0; f < E.length; f++) for (m = 0; m < E[f].length; m++) B(E[f][m]);
        }
        E.length === 1 ? E = E[0] : R = "Multi" + R;
        var L = { type: "Feature", geometry: { type: R, coordinates: E }, properties: this.properties };
        return "id" in this && (L.id = this.id), L;
      };
      var kE = m0, g0 = y0;
      function y0(a, n) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = a, this._keys = [], this._values = [], this._features = [], a.readFields(NE, this, n), this.length = this._features.length;
      }
      function NE(a, n, h) {
        a === 15 ? n.version = h.readVarint() : a === 1 ? n.name = h.readString() : a === 5 ? n.extent = h.readVarint() : a === 2 ? n._features.push(h.pos) : a === 3 ? n._keys.push(h.readString()) : a === 4 && n._values.push(function(f) {
          for (var m = null, b = f.readVarint() + f.pos; f.pos < b; ) {
            var v = f.readVarint() >> 3;
            m = v === 1 ? f.readString() : v === 2 ? f.readFloat() : v === 3 ? f.readDouble() : v === 4 ? f.readVarint64() : v === 5 ? f.readVarint() : v === 6 ? f.readSVarint() : v === 7 ? f.readBoolean() : null;
          }
          return m;
        }(h));
      }
      y0.prototype.feature = function(a) {
        if (a < 0 || a >= this._features.length) throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[a];
        var n = this._pbf.readVarint() + this._pbf.pos;
        return new kE(this._pbf, n, this.extent, this._keys, this._values);
      };
      var LE = g0;
      function UE(a, n, h) {
        if (a === 3) {
          var f = new LE(h, h.readVarint() + h.pos);
          f.length && (n[f.name] = f);
        }
      }
      Ko.VectorTile = function(a, n) {
        this.layers = a.readFields(UE, {}, n);
      }, Ko.VectorTileFeature = m0, Ko.VectorTileLayer = g0;
      const zE = Ko.VectorTileFeature.types, d_ = Math.pow(2, 13);
      function Nh(a, n, h, f, m, b, v, A) {
        a.emplaceBack(n, h, 2 * Math.floor(f * d_) + v, m * d_ * 2, b * d_ * 2, Math.round(A));
      }
      class f_ {
        constructor(n) {
          this.zoom = n.zoom, this.overscaling = n.overscaling, this.layers = n.layers, this.layerIds = this.layers.map((h) => h.id), this.index = n.index, this.hasPattern = !1, this.layoutVertexArray = new $o(), this.centroidVertexArray = new ys(), this.indexArray = new Rr(), this.programConfigurations = new za(n.layers, n.zoom), this.segments = new Nt(), this.stateDependentLayerIds = this.layers.filter((h) => h.isStateDependent()).map((h) => h.id);
        }
        populate(n, h, f) {
          this.features = [], this.hasPattern = c_("fill-extrusion", this.layers, h);
          for (const { feature: m, id: b, index: v, sourceLayerIndex: A } of n) {
            const E = this.layers[0]._featureFilter.needGeometry, R = Ha(m, E);
            if (!this.layers[0]._featureFilter.filter(new fi(this.zoom), R, f)) continue;
            const B = { id: b, sourceLayerIndex: A, index: v, geometry: E ? R.geometry : Va(m), properties: m.properties, type: m.type, patterns: {} };
            this.hasPattern ? this.features.push(h_("fill-extrusion", this.layers, B, this.zoom, h)) : this.addFeature(B, B.geometry, v, f, {}), h.featureIndex.insert(m, B.geometry, v, A, this.index, !0);
          }
        }
        addFeatures(n, h, f) {
          for (const m of this.features) {
            const { geometry: b } = m;
            this.addFeature(m, b, m.index, h, f);
          }
        }
        update(n, h, f) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, h, this.stateDependentLayers, f);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(n) {
          this.uploaded || (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, BE), this.centroidVertexBuffer = n.createVertexBuffer(this.centroidVertexArray, PE.members, !0), this.indexBuffer = n.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(n), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(n, h, f, m, b) {
          for (const v of bl(h, 500)) {
            const A = { x: 0, y: 0, vertexCount: 0 };
            let E = 0;
            for (const $ of v) E += $.length;
            let R = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            for (const $ of v) {
              if ($.length === 0 || HE($)) continue;
              let X = 0;
              for (let ie = 0; ie < $.length; ie++) {
                const ne = $[ie];
                if (ie >= 1) {
                  const Ae = $[ie - 1];
                  if (!VE(ne, Ae)) {
                    R.vertexLength + 4 > Nt.MAX_VERTEX_ARRAY_LENGTH && (R = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    const de = ne.sub(Ae)._perp()._unit(), ye = Ae.dist(ne);
                    X + ye > 32768 && (X = 0), Nh(this.layoutVertexArray, ne.x, ne.y, de.x, de.y, 0, 0, X), Nh(this.layoutVertexArray, ne.x, ne.y, de.x, de.y, 0, 1, X), A.x += 2 * ne.x, A.y += 2 * ne.y, A.vertexCount += 2, X += ye, Nh(this.layoutVertexArray, Ae.x, Ae.y, de.x, de.y, 0, 0, X), Nh(this.layoutVertexArray, Ae.x, Ae.y, de.x, de.y, 0, 1, X), A.x += 2 * Ae.x, A.y += 2 * Ae.y, A.vertexCount += 2;
                    const Pe = R.vertexLength;
                    this.indexArray.emplaceBack(Pe, Pe + 2, Pe + 1), this.indexArray.emplaceBack(Pe + 1, Pe + 2, Pe + 3), R.vertexLength += 4, R.primitiveLength += 2;
                  }
                }
              }
            }
            if (R.vertexLength + E > Nt.MAX_VERTEX_ARRAY_LENGTH && (R = this.segments.prepareSegment(E, this.layoutVertexArray, this.indexArray)), zE[n.type] !== "Polygon") continue;
            const B = [], F = [], L = R.vertexLength;
            for (const $ of v) if ($.length !== 0) {
              $ !== v[0] && F.push(B.length / 2);
              for (let X = 0; X < $.length; X++) {
                const ie = $[X];
                Nh(this.layoutVertexArray, ie.x, ie.y, 0, 0, 1, 1, 0), A.x += ie.x, A.y += ie.y, A.vertexCount += 1, B.push(ie.x), B.push(ie.y);
              }
            }
            const V = c0(B, F);
            for (let $ = 0; $ < V.length; $ += 3) this.indexArray.emplaceBack(L + V[$], L + V[$ + 2], L + V[$ + 1]);
            R.primitiveLength += V.length / 3, R.vertexLength += E;
            for (let $ = 0; $ < A.vertexCount; $++) {
              const X = Math.floor(A.x / A.vertexCount), ie = Math.floor(A.y / A.vertexCount);
              this.centroidVertexArray.emplaceBack(X, ie);
            }
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, f, b, m);
        }
      }
      function VE(a, n) {
        return a.x === n.x && (a.x < 0 || a.x > Xi) || a.y === n.y && (a.y < 0 || a.y > Xi);
      }
      function HE(a) {
        return a.every((n) => n.x < 0) || a.every((n) => n.x > Xi) || a.every((n) => n.y < 0) || a.every((n) => n.y > Xi);
      }
      let b0;
      ot("FillExtrusionBucket", f_, { omit: ["layers", "features"] });
      var jE = { get paint() {
        return b0 = b0 || new y({ "fill-extrusion-opacity": new ht(Ie["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new vt(Ie["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new ht(Ie["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new ht(Ie["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Ul(Ie["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new vt(Ie["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new vt(Ie["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new ht(Ie["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
      } };
      class $E extends d {
        constructor(n) {
          super(n, jE);
        }
        createBucket(n) {
          return new f_(n);
        }
        queryRadius() {
          return Td(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        queryIntersectsFeature(n, h, f, m, b, v, A, E) {
          const R = Ed(n, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), v.angle, A), B = this.paint.get("fill-extrusion-height").evaluate(h, f), F = this.paint.get("fill-extrusion-base").evaluate(h, f), L = function($, X, ie, ne) {
            const Ae = [];
            for (const de of $) {
              const ye = [de.x, de.y, 0, 1];
              Sd(ye, ye, X), Ae.push(new M(ye[0] / ye[3], ye[1] / ye[3]));
            }
            return Ae;
          }(R, E), V = function($, X, ie, ne) {
            const Ae = [], de = [], ye = ne[8] * X, Pe = ne[9] * X, Le = ne[10] * X, tt = ne[11] * X, bt = ne[8] * ie, Qe = ne[9] * ie, Je = ne[10] * ie, ft = ne[11] * ie;
            for (const ct of $) {
              const rt = [], De = [];
              for (const _t of ct) {
                const dt = _t.x, Tt = _t.y, ai = ne[0] * dt + ne[4] * Tt + ne[12], ii = ne[1] * dt + ne[5] * Tt + ne[13], es = ne[2] * dt + ne[6] * Tt + ne[14], Jr = ne[3] * dt + ne[7] * Tt + ne[15], xs = es + Le, ts = Jr + tt, js = ai + bt, $s = ii + Qe, Gs = es + Je, ki = Jr + ft, is = new M((ai + ye) / ts, (ii + Pe) / ts);
                is.z = xs / ts, rt.push(is);
                const Bs = new M(js / ki, $s / ki);
                Bs.z = Gs / ki, De.push(Bs);
              }
              Ae.push(rt), de.push(De);
            }
            return [Ae, de];
          }(m, F, B, E);
          return function($, X, ie) {
            let ne = 1 / 0;
            Jy(ie, X) && (ne = v0(ie, X[0]));
            for (let Ae = 0; Ae < X.length; Ae++) {
              const de = X[Ae], ye = $[Ae];
              for (let Pe = 0; Pe < de.length - 1; Pe++) {
                const Le = de[Pe], tt = [Le, de[Pe + 1], ye[Pe + 1], ye[Pe], Le];
                Ky(ie, tt) && (ne = Math.min(ne, v0(ie, tt)));
              }
            }
            return ne !== 1 / 0 && ne;
          }(V[0], V[1], L);
        }
      }
      function Lh(a, n) {
        return a.x * n.x + a.y * n.y;
      }
      function v0(a, n) {
        if (a.length === 1) {
          let h = 0;
          const f = n[h++];
          let m;
          for (; !m || f.equals(m); ) if (m = n[h++], !m) return 1 / 0;
          for (; h < n.length; h++) {
            const b = n[h], v = a[0], A = m.sub(f), E = b.sub(f), R = v.sub(f), B = Lh(A, A), F = Lh(A, E), L = Lh(E, E), V = Lh(R, A), $ = Lh(R, E), X = B * L - F * F, ie = (L * V - F * $) / X, ne = (B * $ - F * V) / X, Ae = f.z * (1 - ie - ne) + m.z * ie + b.z * ne;
            if (isFinite(Ae)) return Ae;
          }
          return 1 / 0;
        }
        {
          let h = 1 / 0;
          for (const f of n) h = Math.min(h, f.z);
          return h;
        }
      }
      const GE = T([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: XE } = GE, WE = T([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: qE } = WE, ZE = Ko.VectorTileFeature.types, KE = Math.cos(Math.PI / 180 * 37.5), x0 = Math.pow(2, 14) / 0.5;
      class p_ {
        constructor(n) {
          this.zoom = n.zoom, this.overscaling = n.overscaling, this.layers = n.layers, this.layerIds = this.layers.map((h) => h.id), this.index = n.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((h) => {
            this.gradients[h.id] = {};
          }), this.layoutVertexArray = new Vl(), this.layoutVertexArray2 = new Go(), this.indexArray = new Rr(), this.programConfigurations = new za(n.layers, n.zoom), this.segments = new Nt(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((h) => h.isStateDependent()).map((h) => h.id);
        }
        populate(n, h, f) {
          this.hasPattern = c_("line", this.layers, h);
          const m = this.layers[0].layout.get("line-sort-key"), b = !m.isConstant(), v = [];
          for (const { feature: A, id: E, index: R, sourceLayerIndex: B } of n) {
            const F = this.layers[0]._featureFilter.needGeometry, L = Ha(A, F);
            if (!this.layers[0]._featureFilter.filter(new fi(this.zoom), L, f)) continue;
            const V = b ? m.evaluate(L, {}, f) : void 0, $ = { id: E, properties: A.properties, type: A.type, sourceLayerIndex: B, index: R, geometry: F ? L.geometry : Va(A), patterns: {}, sortKey: V };
            v.push($);
          }
          b && v.sort((A, E) => A.sortKey - E.sortKey);
          for (const A of v) {
            const { geometry: E, index: R, sourceLayerIndex: B } = A;
            if (this.hasPattern) {
              const F = h_("line", this.layers, A, this.zoom, h);
              this.patternFeatures.push(F);
            } else this.addFeature(A, E, R, f, {});
            h.featureIndex.insert(n[R].feature, E, R, B, this.index);
          }
        }
        update(n, h, f) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, h, this.stateDependentLayers, f);
        }
        addFeatures(n, h, f) {
          for (const m of this.patternFeatures) this.addFeature(m, m.geometry, m.index, h, f);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(n) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = n.createVertexBuffer(this.layoutVertexArray2, qE)), this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, XE), this.indexBuffer = n.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(n), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(n) {
          if (n.properties && Object.prototype.hasOwnProperty.call(n.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(n.properties, "mapbox_clip_end")) return { start: +n.properties.mapbox_clip_start, end: +n.properties.mapbox_clip_end };
        }
        addFeature(n, h, f, m, b) {
          const v = this.layers[0].layout, A = v.get("line-join").evaluate(n, {}), E = v.get("line-cap"), R = v.get("line-miter-limit"), B = v.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(n);
          for (const F of h) this.addLine(F, n, A, E, R, B);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, f, b, m);
        }
        addLine(n, h, f, m, b, v) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let ne = 0; ne < n.length - 1; ne++) this.totalDistance += n[ne].dist(n[ne + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const A = ZE[h.type] === "Polygon";
          let E = n.length;
          for (; E >= 2 && n[E - 1].equals(n[E - 2]); ) E--;
          let R = 0;
          for (; R < E - 1 && n[R].equals(n[R + 1]); ) R++;
          if (E < (A ? 3 : 2)) return;
          f === "bevel" && (b = 1.05);
          const B = this.overscaling <= 16 ? 15 * Xi / (512 * this.overscaling) : 0, F = this.segments.prepareSegment(10 * E, this.layoutVertexArray, this.indexArray);
          let L, V, $, X, ie;
          this.e1 = this.e2 = -1, A && (L = n[E - 2], ie = n[R].sub(L)._unit()._perp());
          for (let ne = R; ne < E; ne++) {
            if ($ = ne === E - 1 ? A ? n[R + 1] : void 0 : n[ne + 1], $ && n[ne].equals($)) continue;
            ie && (X = ie), L && (V = L), L = n[ne], ie = $ ? $.sub(L)._unit()._perp() : X, X = X || ie;
            let Ae = X.add(ie);
            Ae.x === 0 && Ae.y === 0 || Ae._unit();
            const de = X.x * ie.x + X.y * ie.y, ye = Ae.x * ie.x + Ae.y * ie.y, Pe = ye !== 0 ? 1 / ye : 1 / 0, Le = 2 * Math.sqrt(2 - 2 * ye), tt = ye < KE && V && $, bt = X.x * ie.y - X.y * ie.x > 0;
            if (tt && ne > R) {
              const ft = L.dist(V);
              if (ft > 2 * B) {
                const ct = L.sub(L.sub(V)._mult(B / ft)._round());
                this.updateDistance(V, ct), this.addCurrentVertex(ct, X, 0, 0, F), V = ct;
              }
            }
            const Qe = V && $;
            let Je = Qe ? f : A ? "butt" : m;
            if (Qe && Je === "round" && (Pe < v ? Je = "miter" : Pe <= 2 && (Je = "fakeround")), Je === "miter" && Pe > b && (Je = "bevel"), Je === "bevel" && (Pe > 2 && (Je = "flipbevel"), Pe < b && (Je = "miter")), V && this.updateDistance(V, L), Je === "miter") Ae._mult(Pe), this.addCurrentVertex(L, Ae, 0, 0, F);
            else if (Je === "flipbevel") {
              if (Pe > 100) Ae = ie.mult(-1);
              else {
                const ft = Pe * X.add(ie).mag() / X.sub(ie).mag();
                Ae._perp()._mult(ft * (bt ? -1 : 1));
              }
              this.addCurrentVertex(L, Ae, 0, 0, F), this.addCurrentVertex(L, Ae.mult(-1), 0, 0, F);
            } else if (Je === "bevel" || Je === "fakeround") {
              const ft = -Math.sqrt(Pe * Pe - 1), ct = bt ? ft : 0, rt = bt ? 0 : ft;
              if (V && this.addCurrentVertex(L, X, ct, rt, F), Je === "fakeround") {
                const De = Math.round(180 * Le / Math.PI / 20);
                for (let _t = 1; _t < De; _t++) {
                  let dt = _t / De;
                  if (dt !== 0.5) {
                    const ai = dt - 0.5;
                    dt += dt * ai * (dt - 1) * ((1.0904 + de * (de * (3.55645 - 1.43519 * de) - 3.2452)) * ai * ai + (0.848013 + de * (0.215638 * de - 1.06021)));
                  }
                  const Tt = ie.sub(X)._mult(dt)._add(X)._unit()._mult(bt ? -1 : 1);
                  this.addHalfVertex(L, Tt.x, Tt.y, !1, bt, 0, F);
                }
              }
              $ && this.addCurrentVertex(L, ie, -ct, -rt, F);
            } else if (Je === "butt") this.addCurrentVertex(L, Ae, 0, 0, F);
            else if (Je === "square") {
              const ft = V ? 1 : -1;
              this.addCurrentVertex(L, Ae, ft, ft, F);
            } else Je === "round" && (V && (this.addCurrentVertex(L, X, 0, 0, F), this.addCurrentVertex(L, X, 1, 1, F, !0)), $ && (this.addCurrentVertex(L, ie, -1, -1, F, !0), this.addCurrentVertex(L, ie, 0, 0, F)));
            if (tt && ne < E - 1) {
              const ft = L.dist($);
              if (ft > 2 * B) {
                const ct = L.add($.sub(L)._mult(B / ft)._round());
                this.updateDistance(L, ct), this.addCurrentVertex(ct, ie, 0, 0, F), L = ct;
              }
            }
          }
        }
        addCurrentVertex(n, h, f, m, b, v = !1) {
          const A = h.y * m - h.x, E = -h.y - h.x * m;
          this.addHalfVertex(n, h.x + h.y * f, h.y - h.x * f, v, !1, f, b), this.addHalfVertex(n, A, E, v, !0, -m, b), this.distance > x0 / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(n, h, f, m, b, v));
        }
        addHalfVertex({ x: n, y: h }, f, m, b, v, A, E) {
          const R = 0.5 * (this.lineClips ? this.scaledDistance * (x0 - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((n << 1) + (b ? 1 : 0), (h << 1) + (v ? 1 : 0), Math.round(63 * f) + 128, Math.round(63 * m) + 128, 1 + (A === 0 ? 0 : A < 0 ? -1 : 1) | (63 & R) << 2, R >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const B = E.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, B), E.primitiveLength++), v ? this.e2 = B : this.e1 = B;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(n, h) {
          this.distance += n.dist(h), this.updateScaledDistance();
        }
      }
      let w0, A0;
      ot("LineBucket", p_, { omit: ["layers", "patternFeatures"] });
      var T0 = { get paint() {
        return A0 = A0 || new y({ "line-opacity": new vt(Ie.paint_line["line-opacity"]), "line-color": new vt(Ie.paint_line["line-color"]), "line-translate": new ht(Ie.paint_line["line-translate"]), "line-translate-anchor": new ht(Ie.paint_line["line-translate-anchor"]), "line-width": new vt(Ie.paint_line["line-width"]), "line-gap-width": new vt(Ie.paint_line["line-gap-width"]), "line-offset": new vt(Ie.paint_line["line-offset"]), "line-blur": new vt(Ie.paint_line["line-blur"]), "line-dasharray": new zl(Ie.paint_line["line-dasharray"]), "line-pattern": new Ul(Ie.paint_line["line-pattern"]), "line-gradient": new Ih(Ie.paint_line["line-gradient"]) });
      }, get layout() {
        return w0 = w0 || new y({ "line-cap": new ht(Ie.layout_line["line-cap"]), "line-join": new vt(Ie.layout_line["line-join"]), "line-miter-limit": new ht(Ie.layout_line["line-miter-limit"]), "line-round-limit": new ht(Ie.layout_line["line-round-limit"]), "line-sort-key": new vt(Ie.layout_line["line-sort-key"]) });
      } };
      class JE extends vt {
        possiblyEvaluate(n, h) {
          return h = new fi(Math.floor(h.zoom), { now: h.now, fadeDuration: h.fadeDuration, zoomHistory: h.zoomHistory, transition: h.transition }), super.possiblyEvaluate(n, h);
        }
        evaluate(n, h, f, m) {
          return h = nt({}, h, { zoom: Math.floor(h.zoom) }), super.evaluate(n, h, f, m);
        }
      }
      let Md;
      class YE extends d {
        constructor(n) {
          super(n, T0), this.gradientVersion = 0, Md || (Md = new JE(T0.paint.properties["line-width"].specification), Md.useIntegerZoom = !0);
        }
        _handleSpecialPaintPropertyUpdate(n) {
          if (n === "line-gradient") {
            const h = this.gradientExpression();
            this.stepInterpolant = !!function(f) {
              return f._styleExpression !== void 0;
            }(h) && h._styleExpression.expression instanceof lt, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(n, h) {
          super.recalculate(n, h), this.paint._values["line-floorwidth"] = Md.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, n);
        }
        createBucket(n) {
          return new p_(n);
        }
        queryRadius(n) {
          const h = n, f = E0(Ph("line-width", this, h), Ph("line-gap-width", this, h)), m = Ph("line-offset", this, h);
          return f / 2 + Math.abs(m) + Td(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(n, h, f, m, b, v, A) {
          const E = Ed(n, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), v.angle, A), R = A / 2 * E0(this.paint.get("line-width").evaluate(h, f), this.paint.get("line-gap-width").evaluate(h, f)), B = this.paint.get("line-offset").evaluate(h, f);
          return B && (m = function(F, L) {
            const V = [];
            for (let $ = 0; $ < F.length; $++) {
              const X = F[$], ie = [];
              for (let ne = 0; ne < X.length; ne++) {
                const Ae = X[ne - 1], de = X[ne], ye = X[ne + 1], Pe = ne === 0 ? new M(0, 0) : de.sub(Ae)._unit()._perp(), Le = ne === X.length - 1 ? new M(0, 0) : ye.sub(de)._unit()._perp(), tt = Pe._add(Le)._unit(), bt = tt.x * Le.x + tt.y * Le.y;
                bt !== 0 && tt._mult(1 / bt), ie.push(tt._mult(L)._add(de));
              }
              V.push(ie);
            }
            return V;
          }(m, B * A)), function(F, L, V) {
            for (let $ = 0; $ < L.length; $++) {
              const X = L[$];
              if (F.length >= 3) {
                for (let ie = 0; ie < X.length; ie++) if (Wl(F, X[ie])) return !0;
              }
              if (aE(F, X, V)) return !0;
            }
            return !1;
          }(E, m, R);
        }
        isTileClipped() {
          return !0;
        }
      }
      function E0(a, n) {
        return n > 0 ? n + 2 * a : a;
      }
      const QE = T([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), eS = T([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      T([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const tS = T([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
      T([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const S0 = T([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), iS = T([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function sS(a, n, h) {
        return a.sections.forEach((f) => {
          f.text = function(m, b, v) {
            const A = b.layout.get("text-transform").evaluate(v, {});
            return A === "uppercase" ? m = m.toLocaleUpperCase() : A === "lowercase" && (m = m.toLocaleLowerCase()), ir.applyArabicShaping && (m = ir.applyArabicShaping(m)), m;
          }(f.text, n, h);
        }), a;
      }
      T([{ name: "triangle", components: 3, type: "Uint16" }]), T([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), T([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), T([{ type: "Float32", name: "offsetX" }]), T([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), T([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
      const Uh = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
      var Ki = 24, C0 = ti, I0 = function(a, n, h, f, m) {
        var b, v, A = 8 * m - f - 1, E = (1 << A) - 1, R = E >> 1, B = -7, F = m - 1, L = -1, V = a[n + F];
        for (F += L, b = V & (1 << -B) - 1, V >>= -B, B += A; B > 0; b = 256 * b + a[n + F], F += L, B -= 8) ;
        for (v = b & (1 << -B) - 1, b >>= -B, B += f; B > 0; v = 256 * v + a[n + F], F += L, B -= 8) ;
        if (b === 0) b = 1 - R;
        else {
          if (b === E) return v ? NaN : 1 / 0 * (V ? -1 : 1);
          v += Math.pow(2, f), b -= R;
        }
        return (V ? -1 : 1) * v * Math.pow(2, b - f);
      }, R0 = function(a, n, h, f, m, b) {
        var v, A, E, R = 8 * b - m - 1, B = (1 << R) - 1, F = B >> 1, L = m === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, V = 0, $ = 1, X = n < 0 || n === 0 && 1 / n < 0 ? 1 : 0;
        for (n = Math.abs(n), isNaN(n) || n === 1 / 0 ? (A = isNaN(n) ? 1 : 0, v = B) : (v = Math.floor(Math.log(n) / Math.LN2), n * (E = Math.pow(2, -v)) < 1 && (v--, E *= 2), (n += v + F >= 1 ? L / E : L * Math.pow(2, 1 - F)) * E >= 2 && (v++, E /= 2), v + F >= B ? (A = 0, v = B) : v + F >= 1 ? (A = (n * E - 1) * Math.pow(2, m), v += F) : (A = n * Math.pow(2, F - 1) * Math.pow(2, m), v = 0)); m >= 8; a[h + V] = 255 & A, V += $, A /= 256, m -= 8) ;
        for (v = v << m | A, R += m; R > 0; a[h + V] = 255 & v, V += $, v /= 256, R -= 8) ;
        a[h + V - $] |= 128 * X;
      };
      function ti(a) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(a) ? a : new Uint8Array(a || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      ti.Varint = 0, ti.Fixed64 = 1, ti.Bytes = 2, ti.Fixed32 = 5;
      var __ = 4294967296, M0 = 1 / __, P0 = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
      function uo(a) {
        return a.type === ti.Bytes ? a.readVarint() + a.pos : a.pos + 1;
      }
      function Jl(a, n, h) {
        return h ? 4294967296 * n + (a >>> 0) : 4294967296 * (n >>> 0) + (a >>> 0);
      }
      function B0(a, n, h) {
        var f = n <= 16383 ? 1 : n <= 2097151 ? 2 : n <= 268435455 ? 3 : Math.floor(Math.log(n) / (7 * Math.LN2));
        h.realloc(f);
        for (var m = h.pos - 1; m >= a; m--) h.buf[m + f] = h.buf[m];
      }
      function rS(a, n) {
        for (var h = 0; h < a.length; h++) n.writeVarint(a[h]);
      }
      function nS(a, n) {
        for (var h = 0; h < a.length; h++) n.writeSVarint(a[h]);
      }
      function oS(a, n) {
        for (var h = 0; h < a.length; h++) n.writeFloat(a[h]);
      }
      function aS(a, n) {
        for (var h = 0; h < a.length; h++) n.writeDouble(a[h]);
      }
      function lS(a, n) {
        for (var h = 0; h < a.length; h++) n.writeBoolean(a[h]);
      }
      function cS(a, n) {
        for (var h = 0; h < a.length; h++) n.writeFixed32(a[h]);
      }
      function hS(a, n) {
        for (var h = 0; h < a.length; h++) n.writeSFixed32(a[h]);
      }
      function uS(a, n) {
        for (var h = 0; h < a.length; h++) n.writeFixed64(a[h]);
      }
      function dS(a, n) {
        for (var h = 0; h < a.length; h++) n.writeSFixed64(a[h]);
      }
      function Pd(a, n) {
        return (a[n] | a[n + 1] << 8 | a[n + 2] << 16) + 16777216 * a[n + 3];
      }
      function Yl(a, n, h) {
        a[h] = n, a[h + 1] = n >>> 8, a[h + 2] = n >>> 16, a[h + 3] = n >>> 24;
      }
      function D0(a, n) {
        return (a[n] | a[n + 1] << 8 | a[n + 2] << 16) + (a[n + 3] << 24);
      }
      ti.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(a, n, h) {
        for (h = h || this.length; this.pos < h; ) {
          var f = this.readVarint(), m = f >> 3, b = this.pos;
          this.type = 7 & f, a(m, n, this), this.pos === b && this.skip(f);
        }
        return n;
      }, readMessage: function(a, n) {
        return this.readFields(a, n, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var a = Pd(this.buf, this.pos);
        return this.pos += 4, a;
      }, readSFixed32: function() {
        var a = D0(this.buf, this.pos);
        return this.pos += 4, a;
      }, readFixed64: function() {
        var a = Pd(this.buf, this.pos) + Pd(this.buf, this.pos + 4) * __;
        return this.pos += 8, a;
      }, readSFixed64: function() {
        var a = Pd(this.buf, this.pos) + D0(this.buf, this.pos + 4) * __;
        return this.pos += 8, a;
      }, readFloat: function() {
        var a = I0(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, a;
      }, readDouble: function() {
        var a = I0(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, a;
      }, readVarint: function(a) {
        var n, h, f = this.buf;
        return n = 127 & (h = f[this.pos++]), h < 128 ? n : (n |= (127 & (h = f[this.pos++])) << 7, h < 128 ? n : (n |= (127 & (h = f[this.pos++])) << 14, h < 128 ? n : (n |= (127 & (h = f[this.pos++])) << 21, h < 128 ? n : function(m, b, v) {
          var A, E, R = v.buf;
          if (A = (112 & (E = R[v.pos++])) >> 4, E < 128 || (A |= (127 & (E = R[v.pos++])) << 3, E < 128) || (A |= (127 & (E = R[v.pos++])) << 10, E < 128) || (A |= (127 & (E = R[v.pos++])) << 17, E < 128) || (A |= (127 & (E = R[v.pos++])) << 24, E < 128) || (A |= (1 & (E = R[v.pos++])) << 31, E < 128)) return Jl(m, A, b);
          throw new Error("Expected varint not more than 10 bytes");
        }(n |= (15 & (h = f[this.pos])) << 28, a, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var a = this.readVarint();
        return a % 2 == 1 ? (a + 1) / -2 : a / 2;
      }, readBoolean: function() {
        return !!this.readVarint();
      }, readString: function() {
        var a = this.readVarint() + this.pos, n = this.pos;
        return this.pos = a, a - n >= 12 && P0 ? function(h, f, m) {
          return P0.decode(h.subarray(f, m));
        }(this.buf, n, a) : function(h, f, m) {
          for (var b = "", v = f; v < m; ) {
            var A, E, R, B = h[v], F = null, L = B > 239 ? 4 : B > 223 ? 3 : B > 191 ? 2 : 1;
            if (v + L > m) break;
            L === 1 ? B < 128 && (F = B) : L === 2 ? (192 & (A = h[v + 1])) == 128 && (F = (31 & B) << 6 | 63 & A) <= 127 && (F = null) : L === 3 ? (E = h[v + 2], (192 & (A = h[v + 1])) == 128 && (192 & E) == 128 && ((F = (15 & B) << 12 | (63 & A) << 6 | 63 & E) <= 2047 || F >= 55296 && F <= 57343) && (F = null)) : L === 4 && (E = h[v + 2], R = h[v + 3], (192 & (A = h[v + 1])) == 128 && (192 & E) == 128 && (192 & R) == 128 && ((F = (15 & B) << 18 | (63 & A) << 12 | (63 & E) << 6 | 63 & R) <= 65535 || F >= 1114112) && (F = null)), F === null ? (F = 65533, L = 1) : F > 65535 && (F -= 65536, b += String.fromCharCode(F >>> 10 & 1023 | 55296), F = 56320 | 1023 & F), b += String.fromCharCode(F), v += L;
          }
          return b;
        }(this.buf, n, a);
      }, readBytes: function() {
        var a = this.readVarint() + this.pos, n = this.buf.subarray(this.pos, a);
        return this.pos = a, n;
      }, readPackedVarint: function(a, n) {
        if (this.type !== ti.Bytes) return a.push(this.readVarint(n));
        var h = uo(this);
        for (a = a || []; this.pos < h; ) a.push(this.readVarint(n));
        return a;
      }, readPackedSVarint: function(a) {
        if (this.type !== ti.Bytes) return a.push(this.readSVarint());
        var n = uo(this);
        for (a = a || []; this.pos < n; ) a.push(this.readSVarint());
        return a;
      }, readPackedBoolean: function(a) {
        if (this.type !== ti.Bytes) return a.push(this.readBoolean());
        var n = uo(this);
        for (a = a || []; this.pos < n; ) a.push(this.readBoolean());
        return a;
      }, readPackedFloat: function(a) {
        if (this.type !== ti.Bytes) return a.push(this.readFloat());
        var n = uo(this);
        for (a = a || []; this.pos < n; ) a.push(this.readFloat());
        return a;
      }, readPackedDouble: function(a) {
        if (this.type !== ti.Bytes) return a.push(this.readDouble());
        var n = uo(this);
        for (a = a || []; this.pos < n; ) a.push(this.readDouble());
        return a;
      }, readPackedFixed32: function(a) {
        if (this.type !== ti.Bytes) return a.push(this.readFixed32());
        var n = uo(this);
        for (a = a || []; this.pos < n; ) a.push(this.readFixed32());
        return a;
      }, readPackedSFixed32: function(a) {
        if (this.type !== ti.Bytes) return a.push(this.readSFixed32());
        var n = uo(this);
        for (a = a || []; this.pos < n; ) a.push(this.readSFixed32());
        return a;
      }, readPackedFixed64: function(a) {
        if (this.type !== ti.Bytes) return a.push(this.readFixed64());
        var n = uo(this);
        for (a = a || []; this.pos < n; ) a.push(this.readFixed64());
        return a;
      }, readPackedSFixed64: function(a) {
        if (this.type !== ti.Bytes) return a.push(this.readSFixed64());
        var n = uo(this);
        for (a = a || []; this.pos < n; ) a.push(this.readSFixed64());
        return a;
      }, skip: function(a) {
        var n = 7 & a;
        if (n === ti.Varint) for (; this.buf[this.pos++] > 127; ) ;
        else if (n === ti.Bytes) this.pos = this.readVarint() + this.pos;
        else if (n === ti.Fixed32) this.pos += 4;
        else {
          if (n !== ti.Fixed64) throw new Error("Unimplemented type: " + n);
          this.pos += 8;
        }
      }, writeTag: function(a, n) {
        this.writeVarint(a << 3 | n);
      }, realloc: function(a) {
        for (var n = this.length || 16; n < this.pos + a; ) n *= 2;
        if (n !== this.length) {
          var h = new Uint8Array(n);
          h.set(this.buf), this.buf = h, this.length = n;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(a) {
        this.realloc(4), Yl(this.buf, a, this.pos), this.pos += 4;
      }, writeSFixed32: function(a) {
        this.realloc(4), Yl(this.buf, a, this.pos), this.pos += 4;
      }, writeFixed64: function(a) {
        this.realloc(8), Yl(this.buf, -1 & a, this.pos), Yl(this.buf, Math.floor(a * M0), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(a) {
        this.realloc(8), Yl(this.buf, -1 & a, this.pos), Yl(this.buf, Math.floor(a * M0), this.pos + 4), this.pos += 8;
      }, writeVarint: function(a) {
        (a = +a || 0) > 268435455 || a < 0 ? function(n, h) {
          var f, m;
          if (n >= 0 ? (f = n % 4294967296 | 0, m = n / 4294967296 | 0) : (m = ~(-n / 4294967296), 4294967295 ^ (f = ~(-n % 4294967296)) ? f = f + 1 | 0 : (f = 0, m = m + 1 | 0)), n >= 18446744073709552e3 || n < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
          h.realloc(10), function(b, v, A) {
            A.buf[A.pos++] = 127 & b | 128, b >>>= 7, A.buf[A.pos++] = 127 & b | 128, b >>>= 7, A.buf[A.pos++] = 127 & b | 128, b >>>= 7, A.buf[A.pos++] = 127 & b | 128, A.buf[A.pos] = 127 & (b >>>= 7);
          }(f, 0, h), function(b, v) {
            var A = (7 & b) << 4;
            v.buf[v.pos++] |= A | ((b >>>= 3) ? 128 : 0), b && (v.buf[v.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (v.buf[v.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (v.buf[v.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (v.buf[v.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (v.buf[v.pos++] = 127 & b)))));
          }(m, h);
        }(a, this) : (this.realloc(4), this.buf[this.pos++] = 127 & a | (a > 127 ? 128 : 0), a <= 127 || (this.buf[this.pos++] = 127 & (a >>>= 7) | (a > 127 ? 128 : 0), a <= 127 || (this.buf[this.pos++] = 127 & (a >>>= 7) | (a > 127 ? 128 : 0), a <= 127 || (this.buf[this.pos++] = a >>> 7 & 127))));
      }, writeSVarint: function(a) {
        this.writeVarint(a < 0 ? 2 * -a - 1 : 2 * a);
      }, writeBoolean: function(a) {
        this.writeVarint(!!a);
      }, writeString: function(a) {
        a = String(a), this.realloc(4 * a.length), this.pos++;
        var n = this.pos;
        this.pos = function(f, m, b) {
          for (var v, A, E = 0; E < m.length; E++) {
            if ((v = m.charCodeAt(E)) > 55295 && v < 57344) {
              if (!A) {
                v > 56319 || E + 1 === m.length ? (f[b++] = 239, f[b++] = 191, f[b++] = 189) : A = v;
                continue;
              }
              if (v < 56320) {
                f[b++] = 239, f[b++] = 191, f[b++] = 189, A = v;
                continue;
              }
              v = A - 55296 << 10 | v - 56320 | 65536, A = null;
            } else A && (f[b++] = 239, f[b++] = 191, f[b++] = 189, A = null);
            v < 128 ? f[b++] = v : (v < 2048 ? f[b++] = v >> 6 | 192 : (v < 65536 ? f[b++] = v >> 12 | 224 : (f[b++] = v >> 18 | 240, f[b++] = v >> 12 & 63 | 128), f[b++] = v >> 6 & 63 | 128), f[b++] = 63 & v | 128);
          }
          return b;
        }(this.buf, a, this.pos);
        var h = this.pos - n;
        h >= 128 && B0(n, h, this), this.pos = n - 1, this.writeVarint(h), this.pos += h;
      }, writeFloat: function(a) {
        this.realloc(4), R0(this.buf, a, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(a) {
        this.realloc(8), R0(this.buf, a, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(a) {
        var n = a.length;
        this.writeVarint(n), this.realloc(n);
        for (var h = 0; h < n; h++) this.buf[this.pos++] = a[h];
      }, writeRawMessage: function(a, n) {
        this.pos++;
        var h = this.pos;
        a(n, this);
        var f = this.pos - h;
        f >= 128 && B0(h, f, this), this.pos = h - 1, this.writeVarint(f), this.pos += f;
      }, writeMessage: function(a, n, h) {
        this.writeTag(a, ti.Bytes), this.writeRawMessage(n, h);
      }, writePackedVarint: function(a, n) {
        n.length && this.writeMessage(a, rS, n);
      }, writePackedSVarint: function(a, n) {
        n.length && this.writeMessage(a, nS, n);
      }, writePackedBoolean: function(a, n) {
        n.length && this.writeMessage(a, lS, n);
      }, writePackedFloat: function(a, n) {
        n.length && this.writeMessage(a, oS, n);
      }, writePackedDouble: function(a, n) {
        n.length && this.writeMessage(a, aS, n);
      }, writePackedFixed32: function(a, n) {
        n.length && this.writeMessage(a, cS, n);
      }, writePackedSFixed32: function(a, n) {
        n.length && this.writeMessage(a, hS, n);
      }, writePackedFixed64: function(a, n) {
        n.length && this.writeMessage(a, uS, n);
      }, writePackedSFixed64: function(a, n) {
        n.length && this.writeMessage(a, dS, n);
      }, writeBytesField: function(a, n) {
        this.writeTag(a, ti.Bytes), this.writeBytes(n);
      }, writeFixed32Field: function(a, n) {
        this.writeTag(a, ti.Fixed32), this.writeFixed32(n);
      }, writeSFixed32Field: function(a, n) {
        this.writeTag(a, ti.Fixed32), this.writeSFixed32(n);
      }, writeFixed64Field: function(a, n) {
        this.writeTag(a, ti.Fixed64), this.writeFixed64(n);
      }, writeSFixed64Field: function(a, n) {
        this.writeTag(a, ti.Fixed64), this.writeSFixed64(n);
      }, writeVarintField: function(a, n) {
        this.writeTag(a, ti.Varint), this.writeVarint(n);
      }, writeSVarintField: function(a, n) {
        this.writeTag(a, ti.Varint), this.writeSVarint(n);
      }, writeStringField: function(a, n) {
        this.writeTag(a, ti.Bytes), this.writeString(n);
      }, writeFloatField: function(a, n) {
        this.writeTag(a, ti.Fixed32), this.writeFloat(n);
      }, writeDoubleField: function(a, n) {
        this.writeTag(a, ti.Fixed64), this.writeDouble(n);
      }, writeBooleanField: function(a, n) {
        this.writeVarintField(a, !!n);
      } };
      var m_ = x(C0);
      const g_ = 3;
      function fS(a, n, h) {
        a === 1 && h.readMessage(pS, n);
      }
      function pS(a, n, h) {
        if (a === 3) {
          const { id: f, bitmap: m, width: b, height: v, left: A, top: E, advance: R } = h.readMessage(_S, {});
          n.push({ id: f, bitmap: new Dh({ width: b + 2 * g_, height: v + 2 * g_ }, m), metrics: { width: b, height: v, left: A, top: E, advance: R } });
        }
      }
      function _S(a, n, h) {
        a === 1 ? n.id = h.readVarint() : a === 2 ? n.bitmap = h.readBytes() : a === 3 ? n.width = h.readVarint() : a === 4 ? n.height = h.readVarint() : a === 5 ? n.left = h.readSVarint() : a === 6 ? n.top = h.readSVarint() : a === 7 && (n.advance = h.readVarint());
      }
      const O0 = g_;
      function F0(a) {
        let n = 0, h = 0;
        for (const v of a) n += v.w * v.h, h = Math.max(h, v.w);
        a.sort((v, A) => A.h - v.h);
        const f = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(n / 0.95)), h), h: 1 / 0 }];
        let m = 0, b = 0;
        for (const v of a) for (let A = f.length - 1; A >= 0; A--) {
          const E = f[A];
          if (!(v.w > E.w || v.h > E.h)) {
            if (v.x = E.x, v.y = E.y, b = Math.max(b, v.y + v.h), m = Math.max(m, v.x + v.w), v.w === E.w && v.h === E.h) {
              const R = f.pop();
              A < f.length && (f[A] = R);
            } else v.h === E.h ? (E.x += v.w, E.w -= v.w) : v.w === E.w ? (E.y += v.h, E.h -= v.h) : (f.push({ x: E.x + v.w, y: E.y, w: E.w - v.w, h: v.h }), E.y += v.h, E.h -= v.h);
            break;
          }
        }
        return { w: m, h: b, fill: n / (m * b) || 0 };
      }
      const rr = 1;
      class y_ {
        constructor(n, { pixelRatio: h, version: f, stretchX: m, stretchY: b, content: v, textFitWidth: A, textFitHeight: E }) {
          this.paddedRect = n, this.pixelRatio = h, this.stretchX = m, this.stretchY = b, this.content = v, this.version = f, this.textFitWidth = A, this.textFitHeight = E;
        }
        get tl() {
          return [this.paddedRect.x + rr, this.paddedRect.y + rr];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - rr, this.paddedRect.y + this.paddedRect.h - rr];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * rr) / this.pixelRatio, (this.paddedRect.h - 2 * rr) / this.pixelRatio];
        }
      }
      class k0 {
        constructor(n, h) {
          const f = {}, m = {};
          this.haveRenderCallbacks = [];
          const b = [];
          this.addImages(n, f, b), this.addImages(h, m, b);
          const { w: v, h: A } = F0(b), E = new Mr({ width: v || 1, height: A || 1 });
          for (const R in n) {
            const B = n[R], F = f[R].paddedRect;
            Mr.copy(B.data, E, { x: 0, y: 0 }, { x: F.x + rr, y: F.y + rr }, B.data);
          }
          for (const R in h) {
            const B = h[R], F = m[R].paddedRect, L = F.x + rr, V = F.y + rr, $ = B.data.width, X = B.data.height;
            Mr.copy(B.data, E, { x: 0, y: 0 }, { x: L, y: V }, B.data), Mr.copy(B.data, E, { x: 0, y: X - 1 }, { x: L, y: V - 1 }, { width: $, height: 1 }), Mr.copy(B.data, E, { x: 0, y: 0 }, { x: L, y: V + X }, { width: $, height: 1 }), Mr.copy(B.data, E, { x: $ - 1, y: 0 }, { x: L - 1, y: V }, { width: 1, height: X }), Mr.copy(B.data, E, { x: 0, y: 0 }, { x: L + $, y: V }, { width: 1, height: X });
          }
          this.image = E, this.iconPositions = f, this.patternPositions = m;
        }
        addImages(n, h, f) {
          for (const m in n) {
            const b = n[m], v = { x: 0, y: 0, w: b.data.width + 2 * rr, h: b.data.height + 2 * rr };
            f.push(v), h[m] = new y_(v, b), b.hasRenderCallback && this.haveRenderCallbacks.push(m);
          }
        }
        patchUpdatedImages(n, h) {
          n.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const f in n.updatedImages) this.patchUpdatedImage(this.iconPositions[f], n.getImage(f), h), this.patchUpdatedImage(this.patternPositions[f], n.getImage(f), h);
        }
        patchUpdatedImage(n, h, f) {
          if (!n || !h || n.version === h.version) return;
          n.version = h.version;
          const [m, b] = n.tl;
          f.update(h.data, void 0, { x: m, y: b });
        }
      }
      var Jo;
      ot("ImagePosition", y_), ot("ImageAtlas", k0), u.ah = void 0, (Jo = u.ah || (u.ah = {}))[Jo.none = 0] = "none", Jo[Jo.horizontal = 1] = "horizontal", Jo[Jo.vertical = 2] = "vertical", Jo[Jo.horizontalOnly = 3] = "horizontalOnly";
      const zh = -17;
      class Vh {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(n, h) {
          const f = new Vh();
          return f.scale = n || 1, f.fontStack = h, f;
        }
        static forImage(n) {
          const h = new Vh();
          return h.imageName = n, h;
        }
      }
      class Ql {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(n, h) {
          const f = new Ql();
          for (let m = 0; m < n.sections.length; m++) {
            const b = n.sections[m];
            b.image ? f.addImageSection(b) : f.addTextSection(b, h);
          }
          return f;
        }
        length() {
          return this.text.length;
        }
        getSection(n) {
          return this.sections[this.sectionIndex[n]];
        }
        getSectionIndex(n) {
          return this.sectionIndex[n];
        }
        getCharCode(n) {
          return this.text.charCodeAt(n);
        }
        verticalizePunctuation() {
          this.text = function(n) {
            let h = "";
            for (let f = 0; f < n.length; f++) {
              const m = n.charCodeAt(f + 1) || null, b = n.charCodeAt(f - 1) || null;
              h += m && gd(m) && !Uh[n[f + 1]] || b && gd(b) && !Uh[n[f - 1]] || !Uh[n[f]] ? n[f] : Uh[n[f]];
            }
            return h;
          }(this.text);
        }
        trim() {
          let n = 0;
          for (let f = 0; f < this.text.length && Dd[this.text.charCodeAt(f)]; f++) n++;
          let h = this.text.length;
          for (let f = this.text.length - 1; f >= 0 && f >= n && Dd[this.text.charCodeAt(f)]; f--) h--;
          this.text = this.text.substring(n, h), this.sectionIndex = this.sectionIndex.slice(n, h);
        }
        substring(n, h) {
          const f = new Ql();
          return f.text = this.text.substring(n, h), f.sectionIndex = this.sectionIndex.slice(n, h), f.sections = this.sections, f;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((n, h) => Math.max(n, this.sections[h].scale), 0);
        }
        addTextSection(n, h) {
          this.text += n.text, this.sections.push(Vh.forText(n.scale, n.fontStack || h));
          const f = this.sections.length - 1;
          for (let m = 0; m < n.text.length; ++m) this.sectionIndex.push(f);
        }
        addImageSection(n) {
          const h = n.image ? n.image.name : "";
          if (h.length === 0) return void Rt("Can't add FormattedSection with an empty image.");
          const f = this.getNextImageSectionCharCode();
          f ? (this.text += String.fromCharCode(f), this.sections.push(Vh.forImage(h)), this.sectionIndex.push(this.sections.length - 1)) : Rt("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function Bd(a, n, h, f, m, b, v, A, E, R, B, F, L, V, $) {
        const X = Ql.fromFeature(a, m);
        let ie;
        F === u.ah.vertical && X.verticalizePunctuation();
        const { processBidirectionalText: ne, processStyledBidirectionalText: Ae } = ir;
        if (ne && X.sections.length === 1) {
          ie = [];
          const Pe = ne(X.toString(), b_(X, R, b, n, f, V));
          for (const Le of Pe) {
            const tt = new Ql();
            tt.text = Le, tt.sections = X.sections;
            for (let bt = 0; bt < Le.length; bt++) tt.sectionIndex.push(0);
            ie.push(tt);
          }
        } else if (Ae) {
          ie = [];
          const Pe = Ae(X.text, X.sectionIndex, b_(X, R, b, n, f, V));
          for (const Le of Pe) {
            const tt = new Ql();
            tt.text = Le[0], tt.sectionIndex = Le[1], tt.sections = X.sections, ie.push(tt);
          }
        } else ie = function(Pe, Le) {
          const tt = [], bt = Pe.text;
          let Qe = 0;
          for (const Je of Le) tt.push(Pe.substring(Qe, Je)), Qe = Je;
          return Qe < bt.length && tt.push(Pe.substring(Qe, bt.length)), tt;
        }(X, b_(X, R, b, n, f, V));
        const de = [], ye = { positionedLines: de, text: X.toString(), top: B[1], bottom: B[1], left: B[0], right: B[0], writingMode: F, iconsInText: !1, verticalizable: !1 };
        return function(Pe, Le, tt, bt, Qe, Je, ft, ct, rt, De, _t, dt) {
          let Tt = 0, ai = zh, ii = 0, es = 0;
          const Jr = ct === "right" ? 1 : ct === "left" ? 0 : 0.5;
          let xs = 0;
          for (const ki of Qe) {
            ki.trim();
            const is = ki.getMaxScale(), Bs = (is - 1) * Ki, ws = { positionedGlyphs: [], lineOffset: 0 };
            Pe.positionedLines[xs] = ws;
            const Xs = ws.positionedGlyphs;
            let As = 0;
            if (!ki.length()) {
              ai += Je, ++xs;
              continue;
            }
            for (let nr = 0; nr < ki.length(); nr++) {
              const Gt = ki.getSection(nr), hi = ki.getSectionIndex(nr), gi = ki.getCharCode(nr);
              let yr = 0, Mi = null, sc = null, Fn = null, kn = Ki;
              const Yr = !(rt === u.ah.horizontal || !_t && !Sh(gi) || _t && (Dd[gi] || (ts = gi, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(ts)))));
              if (Gt.imageName) {
                const Dr = bt[Gt.imageName];
                if (!Dr) continue;
                Fn = Gt.imageName, Pe.iconsInText = Pe.iconsInText || !0, sc = Dr.paddedRect;
                const cs = Dr.displaySize;
                Gt.scale = Gt.scale * Ki / dt, Mi = { width: cs[0], height: cs[1], left: rr, top: -O0, advance: Yr ? cs[1] : cs[0] }, yr = Bs + (Ki - cs[1] * Gt.scale), kn = Mi.advance;
                const fo = Yr ? cs[0] * Gt.scale - Ki * is : cs[1] * Gt.scale - Ki * is;
                fo > 0 && fo > As && (As = fo);
              } else {
                const Dr = tt[Gt.fontStack], cs = Dr && Dr[gi];
                if (cs && cs.rect) sc = cs.rect, Mi = cs.metrics;
                else {
                  const fo = Le[Gt.fontStack], Wh = fo && fo[gi];
                  if (!Wh) continue;
                  Mi = Wh.metrics;
                }
                yr = (is - Gt.scale) * Ki;
              }
              Yr ? (Pe.verticalizable = !0, Xs.push({ glyph: gi, imageName: Fn, x: Tt, y: ai + yr, vertical: Yr, scale: Gt.scale, fontStack: Gt.fontStack, sectionIndex: hi, metrics: Mi, rect: sc }), Tt += kn * Gt.scale + De) : (Xs.push({ glyph: gi, imageName: Fn, x: Tt, y: ai + yr, vertical: Yr, scale: Gt.scale, fontStack: Gt.fontStack, sectionIndex: hi, metrics: Mi, rect: sc }), Tt += Mi.advance * Gt.scale + De);
            }
            Xs.length !== 0 && (ii = Math.max(Tt - De, ii), bS(Xs, 0, Xs.length - 1, Jr, As)), Tt = 0;
            const Br = Je * is + As;
            ws.lineOffset = Math.max(As, Bs), ai += Br, es = Math.max(Br, es), ++xs;
          }
          var ts;
          const js = ai - zh, { horizontalAlign: $s, verticalAlign: Gs } = v_(ft);
          (function(ki, is, Bs, ws, Xs, As, Br, nr, Gt) {
            const hi = (is - Bs) * Xs;
            let gi = 0;
            gi = As !== Br ? -nr * ws - zh : (-ws * Gt + 0.5) * Br;
            for (const yr of ki) for (const Mi of yr.positionedGlyphs) Mi.x += hi, Mi.y += gi;
          })(Pe.positionedLines, Jr, $s, Gs, ii, es, Je, js, Qe.length), Pe.top += -Gs * js, Pe.bottom = Pe.top + js, Pe.left += -$s * ii, Pe.right = Pe.left + ii;
        }(ye, n, h, f, ie, v, A, E, F, R, L, $), !function(Pe) {
          for (const Le of Pe) if (Le.positionedGlyphs.length !== 0) return !1;
          return !0;
        }(de) && ye;
      }
      const Dd = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, mS = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, gS = { 40: !0 };
      function N0(a, n, h, f, m, b) {
        if (n.imageName) {
          const v = f[n.imageName];
          return v ? v.displaySize[0] * n.scale * Ki / b + m : 0;
        }
        {
          const v = h[n.fontStack], A = v && v[a];
          return A ? A.metrics.advance * n.scale + m : 0;
        }
      }
      function L0(a, n, h, f) {
        const m = Math.pow(a - n, 2);
        return f ? a < n ? m / 2 : 2 * m : m + Math.abs(h) * h;
      }
      function yS(a, n, h) {
        let f = 0;
        return a === 10 && (f -= 1e4), h && (f += 150), a !== 40 && a !== 65288 || (f += 50), n !== 41 && n !== 65289 || (f += 50), f;
      }
      function U0(a, n, h, f, m, b) {
        let v = null, A = L0(n, h, m, b);
        for (const E of f) {
          const R = L0(n - E.x, h, m, b) + E.badness;
          R <= A && (v = E, A = R);
        }
        return { index: a, x: n, priorBreak: v, badness: A };
      }
      function z0(a) {
        return a ? z0(a.priorBreak).concat(a.index) : [];
      }
      function b_(a, n, h, f, m, b) {
        if (!a) return [];
        const v = [], A = function(F, L, V, $, X, ie) {
          let ne = 0;
          for (let Ae = 0; Ae < F.length(); Ae++) {
            const de = F.getSection(Ae);
            ne += N0(F.getCharCode(Ae), de, $, X, L, ie);
          }
          return ne / Math.max(1, Math.ceil(ne / V));
        }(a, n, h, f, m, b), E = a.text.indexOf("") >= 0;
        let R = 0;
        for (let F = 0; F < a.length(); F++) {
          const L = a.getSection(F), V = a.getCharCode(F);
          if (Dd[V] || (R += N0(V, L, f, m, n, b)), F < a.length() - 1) {
            const $ = !((B = V) < 11904) && (!!kt["CJK Compatibility Forms"](B) || !!kt["CJK Compatibility"](B) || !!kt["CJK Strokes"](B) || !!kt["CJK Symbols and Punctuation"](B) || !!kt["Enclosed CJK Letters and Months"](B) || !!kt["Halfwidth and Fullwidth Forms"](B) || !!kt["Ideographic Description Characters"](B) || !!kt["Vertical Forms"](B) || md.test(String.fromCodePoint(B)));
            (mS[V] || $ || L.imageName || F !== a.length() - 2 && gS[a.getCharCode(F + 1)]) && v.push(U0(F + 1, R, A, v, yS(V, a.getCharCode(F + 1), $ && E), !1));
          }
        }
        var B;
        return z0(U0(a.length(), R, A, v, 0, !0));
      }
      function v_(a) {
        let n = 0.5, h = 0.5;
        switch (a) {
          case "right":
          case "top-right":
          case "bottom-right":
            n = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            n = 0;
        }
        switch (a) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            h = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            h = 0;
        }
        return { horizontalAlign: n, verticalAlign: h };
      }
      function bS(a, n, h, f, m) {
        if (!f && !m) return;
        const b = a[h], v = (a[h].x + b.metrics.advance * b.scale) * f;
        for (let A = n; A <= h; A++) a[A].x -= v, a[A].y += m;
      }
      function vS(a, n, h) {
        const { horizontalAlign: f, verticalAlign: m } = v_(h), b = n[0] - a.displaySize[0] * f, v = n[1] - a.displaySize[1] * m;
        return { image: a, top: v, bottom: v + a.displaySize[1], left: b, right: b + a.displaySize[0] };
      }
      function V0(a) {
        var n, h;
        let f = a.left, m = a.top, b = a.right - f, v = a.bottom - m;
        const A = (n = a.image.textFitWidth) !== null && n !== void 0 ? n : "stretchOrShrink", E = (h = a.image.textFitHeight) !== null && h !== void 0 ? h : "stretchOrShrink", R = (a.image.content[2] - a.image.content[0]) / (a.image.content[3] - a.image.content[1]);
        if (E === "proportional") {
          if (A === "stretchOnly" && b / v < R || A === "proportional") {
            const B = Math.ceil(v * R);
            f *= B / b, b = B;
          }
        } else if (A === "proportional" && E === "stretchOnly" && R !== 0 && b / v > R) {
          const B = Math.ceil(b / R);
          m *= B / v, v = B;
        }
        return { x1: f, y1: m, x2: f + b, y2: m + v };
      }
      function H0(a, n, h, f, m, b) {
        const v = a.image;
        let A;
        if (v.content) {
          const ie = v.content, ne = v.pixelRatio || 1;
          A = [ie[0] / ne, ie[1] / ne, v.displaySize[0] - ie[2] / ne, v.displaySize[1] - ie[3] / ne];
        }
        const E = n.left * b, R = n.right * b;
        let B, F, L, V;
        h === "width" || h === "both" ? (V = m[0] + E - f[3], F = m[0] + R + f[1]) : (V = m[0] + (E + R - v.displaySize[0]) / 2, F = V + v.displaySize[0]);
        const $ = n.top * b, X = n.bottom * b;
        return h === "height" || h === "both" ? (B = m[1] + $ - f[0], L = m[1] + X + f[2]) : (B = m[1] + ($ + X - v.displaySize[1]) / 2, L = B + v.displaySize[1]), { image: v, top: B, right: F, bottom: L, left: V, collisionPadding: A };
      }
      const Hh = 255, On = 128, Yo = Hh * On;
      function j0(a, n) {
        const { expression: h } = n;
        if (h.kind === "constant") return { kind: "constant", layoutSize: h.evaluate(new fi(a + 1)) };
        if (h.kind === "source") return { kind: "source" };
        {
          const { zoomStops: f, interpolationType: m } = h;
          let b = 0;
          for (; b < f.length && f[b] <= a; ) b++;
          b = Math.max(0, b - 1);
          let v = b;
          for (; v < f.length && f[v] < a + 1; ) v++;
          v = Math.min(f.length - 1, v);
          const A = f[b], E = f[v];
          return h.kind === "composite" ? { kind: "composite", minZoom: A, maxZoom: E, interpolationType: m } : { kind: "camera", minZoom: A, maxZoom: E, minSize: h.evaluate(new fi(A)), maxSize: h.evaluate(new fi(E)), interpolationType: m };
        }
      }
      function x_(a, n, h) {
        let f = "never";
        const m = a.get(n);
        return m ? f = m : a.get(h) && (f = "always"), f;
      }
      const xS = Ko.VectorTileFeature.types, wS = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Od(a, n, h, f, m, b, v, A, E, R, B, F, L) {
        const V = A ? Math.min(Yo, Math.round(A[0])) : 0, $ = A ? Math.min(Yo, Math.round(A[1])) : 0;
        a.emplaceBack(n, h, Math.round(32 * f), Math.round(32 * m), b, v, (V << 1) + (E ? 1 : 0), $, 16 * R, 16 * B, 256 * F, 256 * L);
      }
      function w_(a, n, h) {
        a.emplaceBack(n.x, n.y, h), a.emplaceBack(n.x, n.y, h), a.emplaceBack(n.x, n.y, h), a.emplaceBack(n.x, n.y, h);
      }
      function AS(a) {
        for (const n of a.sections) if (Kp(n.text)) return !0;
        return !1;
      }
      class A_ {
        constructor(n) {
          this.layoutVertexArray = new Hl(), this.indexArray = new Rr(), this.programConfigurations = n, this.segments = new Nt(), this.dynamicLayoutVertexArray = new Rh(), this.opacityVertexArray = new mr(), this.hasVisibleVertices = !1, this.placedSymbolArray = new pi();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(n, h, f, m) {
          this.isEmpty() || (f && (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, QE.members), this.indexBuffer = n.createIndexBuffer(this.indexArray, h), this.dynamicLayoutVertexBuffer = n.createVertexBuffer(this.dynamicLayoutVertexArray, eS.members, !0), this.opacityVertexBuffer = n.createVertexBuffer(this.opacityVertexArray, wS, !0), this.opacityVertexBuffer.itemSize = 1), (f || m) && this.programConfigurations.upload(n));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      ot("SymbolBuffers", A_);
      class T_ {
        constructor(n, h, f) {
          this.layoutVertexArray = new n(), this.layoutAttributes = h, this.indexArray = new f(), this.segments = new Nt(), this.collisionVertexArray = new Bn();
        }
        upload(n) {
          this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = n.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = n.createVertexBuffer(this.collisionVertexArray, tS.members, !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      ot("CollisionBuffers", T_);
      class ec {
        constructor(n) {
          this.collisionBoxArray = n.collisionBoxArray, this.zoom = n.zoom, this.overscaling = n.overscaling, this.layers = n.layers, this.layerIds = this.layers.map((v) => v.id), this.index = n.index, this.pixelRatio = n.pixelRatio, this.sourceLayerIndex = n.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = s_([]), this.placementViewportMatrix = s_([]);
          const h = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = j0(this.zoom, h["text-size"]), this.iconSizeData = j0(this.zoom, h["icon-size"]);
          const f = this.layers[0].layout, m = f.get("symbol-sort-key"), b = f.get("symbol-z-order");
          this.canOverlap = x_(f, "text-overlap", "text-allow-overlap") !== "never" || x_(f, "icon-overlap", "icon-allow-overlap") !== "never" || f.get("text-ignore-placement") || f.get("icon-ignore-placement"), this.sortFeaturesByKey = b !== "viewport-y" && !m.isConstant(), this.sortFeaturesByY = (b === "viewport-y" || b === "auto" && !this.sortFeaturesByKey) && this.canOverlap, f.get("symbol-placement") === "point" && (this.writingModes = f.get("text-writing-mode").map((v) => u.ah[v])), this.stateDependentLayerIds = this.layers.filter((v) => v.isStateDependent()).map((v) => v.id), this.sourceID = n.sourceID;
        }
        createArrays() {
          this.text = new A_(new za(this.layers, this.zoom, (n) => /^text/.test(n))), this.icon = new A_(new za(this.layers, this.zoom, (n) => /^icon/.test(n))), this.glyphOffsetArray = new _i(), this.lineVertexArray = new gs(), this.symbolInstances = new Ot(), this.textAnchorOffsets = new mi();
        }
        calculateGlyphDependencies(n, h, f, m, b) {
          for (let v = 0; v < n.length; v++) if (h[n.charCodeAt(v)] = !0, (f || m) && b) {
            const A = Uh[n.charAt(v)];
            A && (h[A.charCodeAt(0)] = !0);
          }
        }
        populate(n, h, f) {
          const m = this.layers[0], b = m.layout, v = b.get("text-font"), A = b.get("text-field"), E = b.get("icon-image"), R = (A.value.kind !== "constant" || A.value.value instanceof Di && !A.value.value.isEmpty() || A.value.value.toString().length > 0) && (v.value.kind !== "constant" || v.value.value.length > 0), B = E.value.kind !== "constant" || !!E.value.value || Object.keys(E.parameters).length > 0, F = b.get("symbol-sort-key");
          if (this.features = [], !R && !B) return;
          const L = h.iconDependencies, V = h.glyphDependencies, $ = h.availableImages, X = new fi(this.zoom);
          for (const { feature: ie, id: ne, index: Ae, sourceLayerIndex: de } of n) {
            const ye = m._featureFilter.needGeometry, Pe = Ha(ie, ye);
            if (!m._featureFilter.filter(X, Pe, f)) continue;
            let Le, tt;
            if (ye || (Pe.geometry = Va(ie)), R) {
              const Qe = m.getValueAndResolveTokens("text-field", Pe, f, $), Je = Di.factory(Qe), ft = this.hasRTLText = this.hasRTLText || AS(Je);
              (!ft || ir.getRTLTextPluginStatus() === "unavailable" || ft && ir.isParsed()) && (Le = sS(Je, m, Pe));
            }
            if (B) {
              const Qe = m.getValueAndResolveTokens("icon-image", Pe, f, $);
              tt = Qe instanceof Ri ? Qe : Ri.fromString(Qe);
            }
            if (!Le && !tt) continue;
            const bt = this.sortFeaturesByKey ? F.evaluate(Pe, {}, f) : void 0;
            if (this.features.push({ id: ne, text: Le, icon: tt, index: Ae, sourceLayerIndex: de, geometry: Pe.geometry, properties: ie.properties, type: xS[ie.type], sortKey: bt }), tt && (L[tt.name] = !0), Le) {
              const Qe = v.evaluate(Pe, {}, f).join(","), Je = b.get("text-rotation-alignment") !== "viewport" && b.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(u.ah.vertical) >= 0;
              for (const ft of Le.sections) if (ft.image) L[ft.image.name] = !0;
              else {
                const ct = Th(Le.toString()), rt = ft.fontStack || Qe, De = V[rt] = V[rt] || {};
                this.calculateGlyphDependencies(ft.text, De, Je, this.allowVerticalPlacement, ct);
              }
            }
          }
          b.get("symbol-placement") === "line" && (this.features = function(ie) {
            const ne = {}, Ae = {}, de = [];
            let ye = 0;
            function Pe(Qe) {
              de.push(ie[Qe]), ye++;
            }
            function Le(Qe, Je, ft) {
              const ct = Ae[Qe];
              return delete Ae[Qe], Ae[Je] = ct, de[ct].geometry[0].pop(), de[ct].geometry[0] = de[ct].geometry[0].concat(ft[0]), ct;
            }
            function tt(Qe, Je, ft) {
              const ct = ne[Je];
              return delete ne[Je], ne[Qe] = ct, de[ct].geometry[0].shift(), de[ct].geometry[0] = ft[0].concat(de[ct].geometry[0]), ct;
            }
            function bt(Qe, Je, ft) {
              const ct = ft ? Je[0][Je[0].length - 1] : Je[0][0];
              return `${Qe}:${ct.x}:${ct.y}`;
            }
            for (let Qe = 0; Qe < ie.length; Qe++) {
              const Je = ie[Qe], ft = Je.geometry, ct = Je.text ? Je.text.toString() : null;
              if (!ct) {
                Pe(Qe);
                continue;
              }
              const rt = bt(ct, ft), De = bt(ct, ft, !0);
              if (rt in Ae && De in ne && Ae[rt] !== ne[De]) {
                const _t = tt(rt, De, ft), dt = Le(rt, De, de[_t].geometry);
                delete ne[rt], delete Ae[De], Ae[bt(ct, de[dt].geometry, !0)] = dt, de[_t].geometry = null;
              } else rt in Ae ? Le(rt, De, ft) : De in ne ? tt(rt, De, ft) : (Pe(Qe), ne[rt] = ye - 1, Ae[De] = ye - 1);
            }
            return de.filter((Qe) => Qe.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((ie, ne) => ie.sortKey - ne.sortKey);
        }
        update(n, h, f) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(n, h, this.layers, f), this.icon.programConfigurations.updatePaintArrays(n, h, this.layers, f));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(n) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(n), this.iconCollisionBox.upload(n)), this.text.upload(n, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(n, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(n, h) {
          const f = this.lineVertexArray.length;
          if (n.segment !== void 0) {
            let m = n.dist(h[n.segment + 1]), b = n.dist(h[n.segment]);
            const v = {};
            for (let A = n.segment + 1; A < h.length; A++) v[A] = { x: h[A].x, y: h[A].y, tileUnitDistanceFromAnchor: m }, A < h.length - 1 && (m += h[A + 1].dist(h[A]));
            for (let A = n.segment || 0; A >= 0; A--) v[A] = { x: h[A].x, y: h[A].y, tileUnitDistanceFromAnchor: b }, A > 0 && (b += h[A - 1].dist(h[A]));
            for (let A = 0; A < h.length; A++) {
              const E = v[A];
              this.lineVertexArray.emplaceBack(E.x, E.y, E.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: f, lineLength: this.lineVertexArray.length - f };
        }
        addSymbols(n, h, f, m, b, v, A, E, R, B, F, L) {
          const V = n.indexArray, $ = n.layoutVertexArray, X = n.segments.prepareSegment(4 * h.length, $, V, this.canOverlap ? v.sortKey : void 0), ie = this.glyphOffsetArray.length, ne = X.vertexLength, Ae = this.allowVerticalPlacement && A === u.ah.vertical ? Math.PI / 2 : 0, de = v.text && v.text.sections;
          for (let ye = 0; ye < h.length; ye++) {
            const { tl: Pe, tr: Le, bl: tt, br: bt, tex: Qe, pixelOffsetTL: Je, pixelOffsetBR: ft, minFontScaleX: ct, minFontScaleY: rt, glyphOffset: De, isSDF: _t, sectionIndex: dt } = h[ye], Tt = X.vertexLength, ai = De[1];
            Od($, E.x, E.y, Pe.x, ai + Pe.y, Qe.x, Qe.y, f, _t, Je.x, Je.y, ct, rt), Od($, E.x, E.y, Le.x, ai + Le.y, Qe.x + Qe.w, Qe.y, f, _t, ft.x, Je.y, ct, rt), Od($, E.x, E.y, tt.x, ai + tt.y, Qe.x, Qe.y + Qe.h, f, _t, Je.x, ft.y, ct, rt), Od($, E.x, E.y, bt.x, ai + bt.y, Qe.x + Qe.w, Qe.y + Qe.h, f, _t, ft.x, ft.y, ct, rt), w_(n.dynamicLayoutVertexArray, E, Ae), V.emplaceBack(Tt, Tt + 1, Tt + 2), V.emplaceBack(Tt + 1, Tt + 2, Tt + 3), X.vertexLength += 4, X.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(De[0]), ye !== h.length - 1 && dt === h[ye + 1].sectionIndex || n.programConfigurations.populatePaintArrays($.length, v, v.index, {}, L, de && de[dt]);
          }
          n.placedSymbolArray.emplaceBack(E.x, E.y, ie, this.glyphOffsetArray.length - ie, ne, R, B, E.segment, f ? f[0] : 0, f ? f[1] : 0, m[0], m[1], A, 0, !1, 0, F);
        }
        _addCollisionDebugVertex(n, h, f, m, b, v) {
          return h.emplaceBack(0, 0), n.emplaceBack(f.x, f.y, m, b, Math.round(v.x), Math.round(v.y));
        }
        addCollisionDebugVertices(n, h, f, m, b, v, A) {
          const E = b.segments.prepareSegment(4, b.layoutVertexArray, b.indexArray), R = E.vertexLength, B = b.layoutVertexArray, F = b.collisionVertexArray, L = A.anchorX, V = A.anchorY;
          this._addCollisionDebugVertex(B, F, v, L, V, new M(n, h)), this._addCollisionDebugVertex(B, F, v, L, V, new M(f, h)), this._addCollisionDebugVertex(B, F, v, L, V, new M(f, m)), this._addCollisionDebugVertex(B, F, v, L, V, new M(n, m)), E.vertexLength += 4;
          const $ = b.indexArray;
          $.emplaceBack(R, R + 1), $.emplaceBack(R + 1, R + 2), $.emplaceBack(R + 2, R + 3), $.emplaceBack(R + 3, R), E.primitiveLength += 4;
        }
        addDebugCollisionBoxes(n, h, f, m) {
          for (let b = n; b < h; b++) {
            const v = this.collisionBoxArray.get(b);
            this.addCollisionDebugVertices(v.x1, v.y1, v.x2, v.y2, m ? this.textCollisionBox : this.iconCollisionBox, v.anchorPoint, f);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new T_(gr, S0.members, ls), this.iconCollisionBox = new T_(gr, S0.members, ls);
          for (let n = 0; n < this.symbolInstances.length; n++) {
            const h = this.symbolInstances.get(n);
            this.addDebugCollisionBoxes(h.textBoxStartIndex, h.textBoxEndIndex, h, !0), this.addDebugCollisionBoxes(h.verticalTextBoxStartIndex, h.verticalTextBoxEndIndex, h, !0), this.addDebugCollisionBoxes(h.iconBoxStartIndex, h.iconBoxEndIndex, h, !1), this.addDebugCollisionBoxes(h.verticalIconBoxStartIndex, h.verticalIconBoxEndIndex, h, !1);
          }
        }
        _deserializeCollisionBoxesForSymbol(n, h, f, m, b, v, A, E, R) {
          const B = {};
          for (let F = h; F < f; F++) {
            const L = n.get(F);
            B.textBox = { x1: L.x1, y1: L.y1, x2: L.x2, y2: L.y2, anchorPointX: L.anchorPointX, anchorPointY: L.anchorPointY }, B.textFeatureIndex = L.featureIndex;
            break;
          }
          for (let F = m; F < b; F++) {
            const L = n.get(F);
            B.verticalTextBox = { x1: L.x1, y1: L.y1, x2: L.x2, y2: L.y2, anchorPointX: L.anchorPointX, anchorPointY: L.anchorPointY }, B.verticalTextFeatureIndex = L.featureIndex;
            break;
          }
          for (let F = v; F < A; F++) {
            const L = n.get(F);
            B.iconBox = { x1: L.x1, y1: L.y1, x2: L.x2, y2: L.y2, anchorPointX: L.anchorPointX, anchorPointY: L.anchorPointY }, B.iconFeatureIndex = L.featureIndex;
            break;
          }
          for (let F = E; F < R; F++) {
            const L = n.get(F);
            B.verticalIconBox = { x1: L.x1, y1: L.y1, x2: L.x2, y2: L.y2, anchorPointX: L.anchorPointX, anchorPointY: L.anchorPointY }, B.verticalIconFeatureIndex = L.featureIndex;
            break;
          }
          return B;
        }
        deserializeCollisionBoxes(n) {
          this.collisionArrays = [];
          for (let h = 0; h < this.symbolInstances.length; h++) {
            const f = this.symbolInstances.get(h);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(n, f.textBoxStartIndex, f.textBoxEndIndex, f.verticalTextBoxStartIndex, f.verticalTextBoxEndIndex, f.iconBoxStartIndex, f.iconBoxEndIndex, f.verticalIconBoxStartIndex, f.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(n, h) {
          const f = n.placedSymbolArray.get(h), m = f.vertexStartIndex + 4 * f.numGlyphs;
          for (let b = f.vertexStartIndex; b < m; b += 4) n.indexArray.emplaceBack(b, b + 1, b + 2), n.indexArray.emplaceBack(b + 1, b + 2, b + 3);
        }
        getSortedSymbolIndexes(n) {
          if (this.sortedAngle === n && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
          const h = Math.sin(n), f = Math.cos(n), m = [], b = [], v = [];
          for (let A = 0; A < this.symbolInstances.length; ++A) {
            v.push(A);
            const E = this.symbolInstances.get(A);
            m.push(0 | Math.round(h * E.anchorX + f * E.anchorY)), b.push(E.featureIndex);
          }
          return v.sort((A, E) => m[A] - m[E] || b[E] - b[A]), v;
        }
        addToSortKeyRanges(n, h) {
          const f = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          f && f.sortKey === h ? f.symbolInstanceEnd = n + 1 : this.sortKeyRanges.push({ sortKey: h, symbolInstanceStart: n, symbolInstanceEnd: n + 1 });
        }
        sortFeatures(n) {
          if (this.sortFeaturesByY && this.sortedAngle !== n && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(n), this.sortedAngle = n, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const h of this.symbolInstanceIndexes) {
              const f = this.symbolInstances.get(h);
              this.featureSortOrder.push(f.featureIndex), [f.rightJustifiedTextSymbolIndex, f.centerJustifiedTextSymbolIndex, f.leftJustifiedTextSymbolIndex].forEach((m, b, v) => {
                m >= 0 && v.indexOf(m) === b && this.addIndicesForPlacedSymbol(this.text, m);
              }), f.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, f.verticalPlacedTextSymbolIndex), f.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, f.placedIconSymbolIndex), f.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, f.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let $0, G0;
      ot("SymbolBucket", ec, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), ec.MAX_GLYPHS = 65535, ec.addDynamicAttributes = w_;
      var E_ = { get paint() {
        return G0 = G0 || new y({ "icon-opacity": new vt(Ie.paint_symbol["icon-opacity"]), "icon-color": new vt(Ie.paint_symbol["icon-color"]), "icon-halo-color": new vt(Ie.paint_symbol["icon-halo-color"]), "icon-halo-width": new vt(Ie.paint_symbol["icon-halo-width"]), "icon-halo-blur": new vt(Ie.paint_symbol["icon-halo-blur"]), "icon-translate": new ht(Ie.paint_symbol["icon-translate"]), "icon-translate-anchor": new ht(Ie.paint_symbol["icon-translate-anchor"]), "text-opacity": new vt(Ie.paint_symbol["text-opacity"]), "text-color": new vt(Ie.paint_symbol["text-color"], { runtimeType: ds, getOverride: (a) => a.textColor, hasOverride: (a) => !!a.textColor }), "text-halo-color": new vt(Ie.paint_symbol["text-halo-color"]), "text-halo-width": new vt(Ie.paint_symbol["text-halo-width"]), "text-halo-blur": new vt(Ie.paint_symbol["text-halo-blur"]), "text-translate": new ht(Ie.paint_symbol["text-translate"]), "text-translate-anchor": new ht(Ie.paint_symbol["text-translate-anchor"]) });
      }, get layout() {
        return $0 = $0 || new y({ "symbol-placement": new ht(Ie.layout_symbol["symbol-placement"]), "symbol-spacing": new ht(Ie.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new ht(Ie.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new vt(Ie.layout_symbol["symbol-sort-key"]), "symbol-z-order": new ht(Ie.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new ht(Ie.layout_symbol["icon-allow-overlap"]), "icon-overlap": new ht(Ie.layout_symbol["icon-overlap"]), "icon-ignore-placement": new ht(Ie.layout_symbol["icon-ignore-placement"]), "icon-optional": new ht(Ie.layout_symbol["icon-optional"]), "icon-rotation-alignment": new ht(Ie.layout_symbol["icon-rotation-alignment"]), "icon-size": new vt(Ie.layout_symbol["icon-size"]), "icon-text-fit": new ht(Ie.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new ht(Ie.layout_symbol["icon-text-fit-padding"]), "icon-image": new vt(Ie.layout_symbol["icon-image"]), "icon-rotate": new vt(Ie.layout_symbol["icon-rotate"]), "icon-padding": new vt(Ie.layout_symbol["icon-padding"]), "icon-keep-upright": new ht(Ie.layout_symbol["icon-keep-upright"]), "icon-offset": new vt(Ie.layout_symbol["icon-offset"]), "icon-anchor": new vt(Ie.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new ht(Ie.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new ht(Ie.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new ht(Ie.layout_symbol["text-rotation-alignment"]), "text-field": new vt(Ie.layout_symbol["text-field"]), "text-font": new vt(Ie.layout_symbol["text-font"]), "text-size": new vt(Ie.layout_symbol["text-size"]), "text-max-width": new vt(Ie.layout_symbol["text-max-width"]), "text-line-height": new ht(Ie.layout_symbol["text-line-height"]), "text-letter-spacing": new vt(Ie.layout_symbol["text-letter-spacing"]), "text-justify": new vt(Ie.layout_symbol["text-justify"]), "text-radial-offset": new vt(Ie.layout_symbol["text-radial-offset"]), "text-variable-anchor": new ht(Ie.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new vt(Ie.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new vt(Ie.layout_symbol["text-anchor"]), "text-max-angle": new ht(Ie.layout_symbol["text-max-angle"]), "text-writing-mode": new ht(Ie.layout_symbol["text-writing-mode"]), "text-rotate": new vt(Ie.layout_symbol["text-rotate"]), "text-padding": new ht(Ie.layout_symbol["text-padding"]), "text-keep-upright": new ht(Ie.layout_symbol["text-keep-upright"]), "text-transform": new vt(Ie.layout_symbol["text-transform"]), "text-offset": new vt(Ie.layout_symbol["text-offset"]), "text-allow-overlap": new ht(Ie.layout_symbol["text-allow-overlap"]), "text-overlap": new ht(Ie.layout_symbol["text-overlap"]), "text-ignore-placement": new ht(Ie.layout_symbol["text-ignore-placement"]), "text-optional": new ht(Ie.layout_symbol["text-optional"]) });
      } };
      class X0 {
        constructor(n) {
          if (n.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = n.property.overrides ? n.property.overrides.runtimeType : cr, this.defaultValue = n;
        }
        evaluate(n) {
          if (n.formattedSection) {
            const h = this.defaultValue.property.overrides;
            if (h && h.hasOverride(n.formattedSection)) return h.getOverride(n.formattedSection);
          }
          return n.feature && n.featureState ? this.defaultValue.evaluate(n.feature, n.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(n) {
          this.defaultValue.isConstant() || n(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      ot("FormatSectionOverride", X0, { omit: ["defaultValue"] });
      class Fd extends d {
        constructor(n) {
          super(n, E_);
        }
        recalculate(n, h) {
          if (super.recalculate(n, h), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            const f = this.layout.get("text-writing-mode");
            if (f) {
              const m = [];
              for (const b of f) m.indexOf(b) < 0 && m.push(b);
              this.layout._values["text-writing-mode"] = m;
            } else this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(n, h, f, m) {
          const b = this.layout.get(n).evaluate(h, {}, f, m), v = this._unevaluatedLayout._values[n];
          return v.isDataDriven() || Cl(v.value) || !b ? b : function(A, E) {
            return E.replace(/{([^{}]+)}/g, (R, B) => A && B in A ? String(A[B]) : "");
          }(h.properties, b);
        }
        createBucket(n) {
          return new ec(n);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const n of E_.paint.overridableProperties) {
            if (!Fd.hasPaintOverride(this.layout, n)) continue;
            const h = this.paint.get(n), f = new X0(h), m = new Sl(f, h.property.specification);
            let b = null;
            b = h.value.kind === "constant" || h.value.kind === "source" ? new Oo("source", m) : new Fo("composite", m, h.value.zoomStops), this.paint._values[n] = new Zr(h.property, b, h.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(n, h, f) {
          return !(!this.layout || h.isDataDriven() || f.isDataDriven()) && Fd.hasPaintOverride(this.layout, n);
        }
        static hasPaintOverride(n, h) {
          const f = n.get("text-field"), m = E_.paint.properties[h];
          let b = !1;
          const v = (A) => {
            for (const E of A) if (m.overrides && m.overrides.hasOverride(E)) return void (b = !0);
          };
          if (f.value.kind === "constant" && f.value.value instanceof Di) v(f.value.value.sections);
          else if (f.value.kind === "source") {
            const A = (R) => {
              b || (R instanceof ps && xi(R.value) === Tr ? v(R.value.sections) : R instanceof gl ? v(R.sections) : R.eachChild(A));
            }, E = f.value;
            E._styleExpression && A(E._styleExpression.expression);
          }
          return b;
        }
      }
      let W0;
      var TS = { get paint() {
        return W0 = W0 || new y({ "background-color": new ht(Ie.paint_background["background-color"]), "background-pattern": new zl(Ie.paint_background["background-pattern"]), "background-opacity": new ht(Ie.paint_background["background-opacity"]) });
      } };
      class ES extends d {
        constructor(n) {
          super(n, TS);
        }
      }
      let q0;
      var SS = { get paint() {
        return q0 = q0 || new y({ "raster-opacity": new ht(Ie.paint_raster["raster-opacity"]), "raster-hue-rotate": new ht(Ie.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new ht(Ie.paint_raster["raster-brightness-min"]), "raster-brightness-max": new ht(Ie.paint_raster["raster-brightness-max"]), "raster-saturation": new ht(Ie.paint_raster["raster-saturation"]), "raster-contrast": new ht(Ie.paint_raster["raster-contrast"]), "raster-resampling": new ht(Ie.paint_raster["raster-resampling"]), "raster-fade-duration": new ht(Ie.paint_raster["raster-fade-duration"]) });
      } };
      class CS extends d {
        constructor(n) {
          super(n, SS);
        }
      }
      class IS extends d {
        constructor(n) {
          super(n, {}), this.onAdd = (h) => {
            this.implementation.onAdd && this.implementation.onAdd(h, h.painter.context.gl);
          }, this.onRemove = (h) => {
            this.implementation.onRemove && this.implementation.onRemove(h, h.painter.context.gl);
          }, this.implementation = n;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return !1;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }
      class RS {
        constructor(n) {
          this._methodToThrottle = n, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = !1, this._methodToThrottle();
          });
        }
        trigger() {
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
            this._triggered = !1, this._methodToThrottle();
          }, 0));
        }
        remove() {
          delete this._channel, this._methodToThrottle = () => {
          };
        }
      }
      const S_ = 63710088e-1;
      class Qo {
        constructor(n, h) {
          if (isNaN(n) || isNaN(h)) throw new Error(`Invalid LngLat object: (${n}, ${h})`);
          if (this.lng = +n, this.lat = +h, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new Qo(ze(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(n) {
          const h = Math.PI / 180, f = this.lat * h, m = n.lat * h, b = Math.sin(f) * Math.sin(m) + Math.cos(f) * Math.cos(m) * Math.cos((n.lng - this.lng) * h);
          return S_ * Math.acos(Math.min(b, 1));
        }
        static convert(n) {
          if (n instanceof Qo) return n;
          if (Array.isArray(n) && (n.length === 2 || n.length === 3)) return new Qo(Number(n[0]), Number(n[1]));
          if (!Array.isArray(n) && typeof n == "object" && n !== null) return new Qo(Number("lng" in n ? n.lng : n.lon), Number(n.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const Z0 = 2 * Math.PI * S_;
      function K0(a) {
        return Z0 * Math.cos(a * Math.PI / 180);
      }
      function J0(a) {
        return (180 + a) / 360;
      }
      function Y0(a) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a * Math.PI / 360))) / 360;
      }
      function Q0(a, n) {
        return a / K0(n);
      }
      function C_(a) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90;
      }
      class jh {
        constructor(n, h, f = 0) {
          this.x = +n, this.y = +h, this.z = +f;
        }
        static fromLngLat(n, h = 0) {
          const f = Qo.convert(n);
          return new jh(J0(f.lng), Y0(f.lat), Q0(h, f.lat));
        }
        toLngLat() {
          return new Qo(360 * this.x - 180, C_(this.y));
        }
        toAltitude() {
          return this.z * K0(C_(this.y));
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Z0 * (n = C_(this.y), 1 / Math.cos(n * Math.PI / 180));
          var n;
        }
      }
      function eb(a, n, h) {
        var f = 2 * Math.PI * 6378137 / 256 / Math.pow(2, h);
        return [a * f - 2 * Math.PI * 6378137 / 2, n * f - 2 * Math.PI * 6378137 / 2];
      }
      class I_ {
        constructor(n, h, f) {
          if (!function(m, b, v) {
            return !(m < 0 || m > 25 || v < 0 || v >= Math.pow(2, m) || b < 0 || b >= Math.pow(2, m));
          }(n, h, f)) throw new Error(`x=${h}, y=${f}, z=${n} outside of bounds. 0<=x<${Math.pow(2, n)}, 0<=y<${Math.pow(2, n)} 0<=z<=25 `);
          this.z = n, this.x = h, this.y = f, this.key = $h(0, n, n, h, f);
        }
        equals(n) {
          return this.z === n.z && this.x === n.x && this.y === n.y;
        }
        url(n, h, f) {
          const m = (v = this.y, A = this.z, E = eb(256 * (b = this.x), 256 * (v = Math.pow(2, A) - v - 1), A), R = eb(256 * (b + 1), 256 * (v + 1), A), E[0] + "," + E[1] + "," + R[0] + "," + R[1]);
          var b, v, A, E, R;
          const B = function(F, L, V) {
            let $, X = "";
            for (let ie = F; ie > 0; ie--) $ = 1 << ie - 1, X += (L & $ ? 1 : 0) + (V & $ ? 2 : 0);
            return X;
          }(this.z, this.x, this.y);
          return n[(this.x + this.y) % n.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(f === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, h > 1 ? "@2x" : "").replace(/{quadkey}/g, B).replace(/{bbox-epsg-3857}/g, m);
        }
        isChildOf(n) {
          const h = this.z - n.z;
          return h > 0 && n.x === this.x >> h && n.y === this.y >> h;
        }
        getTilePoint(n) {
          const h = Math.pow(2, this.z);
          return new M((n.x * h - this.x) * Xi, (n.y * h - this.y) * Xi);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class tb {
        constructor(n, h) {
          this.wrap = n, this.canonical = h, this.key = $h(n, h.z, h.z, h.x, h.y);
        }
      }
      class Pr {
        constructor(n, h, f, m, b) {
          if (n < f) throw new Error(`overscaledZ should be >= z; overscaledZ = ${n}; z = ${f}`);
          this.overscaledZ = n, this.wrap = h, this.canonical = new I_(f, +m, +b), this.key = $h(h, n, f, m, b);
        }
        clone() {
          return new Pr(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(n) {
          return this.overscaledZ === n.overscaledZ && this.wrap === n.wrap && this.canonical.equals(n.canonical);
        }
        scaledTo(n) {
          if (n > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${n}; overscaledZ = ${this.overscaledZ}`);
          const h = this.canonical.z - n;
          return n > this.canonical.z ? new Pr(n, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Pr(n, this.wrap, n, this.canonical.x >> h, this.canonical.y >> h);
        }
        calculateScaledKey(n, h) {
          if (n > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${n}; overscaledZ = ${this.overscaledZ}`);
          const f = this.canonical.z - n;
          return n > this.canonical.z ? $h(this.wrap * +h, n, this.canonical.z, this.canonical.x, this.canonical.y) : $h(this.wrap * +h, n, n, this.canonical.x >> f, this.canonical.y >> f);
        }
        isChildOf(n) {
          if (n.wrap !== this.wrap) return !1;
          const h = this.canonical.z - n.canonical.z;
          return n.overscaledZ === 0 || n.overscaledZ < this.overscaledZ && n.canonical.x === this.canonical.x >> h && n.canonical.y === this.canonical.y >> h;
        }
        children(n) {
          if (this.overscaledZ >= n) return [new Pr(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const h = this.canonical.z + 1, f = 2 * this.canonical.x, m = 2 * this.canonical.y;
          return [new Pr(h, this.wrap, h, f, m), new Pr(h, this.wrap, h, f + 1, m), new Pr(h, this.wrap, h, f, m + 1), new Pr(h, this.wrap, h, f + 1, m + 1)];
        }
        isLessThan(n) {
          return this.wrap < n.wrap || !(this.wrap > n.wrap) && (this.overscaledZ < n.overscaledZ || !(this.overscaledZ > n.overscaledZ) && (this.canonical.x < n.canonical.x || !(this.canonical.x > n.canonical.x) && this.canonical.y < n.canonical.y));
        }
        wrapped() {
          return new Pr(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(n) {
          return new Pr(this.overscaledZ, n, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new tb(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(n) {
          return this.canonical.getTilePoint(new jh(n.x - this.wrap, n.y));
        }
      }
      function $h(a, n, h, f, m) {
        (a *= 2) < 0 && (a = -1 * a - 1);
        const b = 1 << h;
        return (b * b * a + b * m + f).toString(36) + h.toString(36) + n.toString(36);
      }
      ot("CanonicalTileID", I_), ot("OverscaledTileID", Pr, { omit: ["posMatrix"] });
      class ib {
        constructor(n, h, f, m = 1, b = 1, v = 1, A = 0) {
          if (this.uid = n, h.height !== h.width) throw new RangeError("DEM tiles must be square");
          if (f && !["mapbox", "terrarium", "custom"].includes(f)) return void Rt(`"${f}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = h.height;
          const E = this.dim = h.height - 2;
          switch (this.data = new Uint32Array(h.data.buffer), f) {
            case "terrarium":
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case "custom":
              this.redFactor = m, this.greenFactor = b, this.blueFactor = v, this.baseShift = A;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let R = 0; R < E; R++) this.data[this._idx(-1, R)] = this.data[this._idx(0, R)], this.data[this._idx(E, R)] = this.data[this._idx(E - 1, R)], this.data[this._idx(R, -1)] = this.data[this._idx(R, 0)], this.data[this._idx(R, E)] = this.data[this._idx(R, E - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(E, -1)] = this.data[this._idx(E - 1, 0)], this.data[this._idx(-1, E)] = this.data[this._idx(0, E - 1)], this.data[this._idx(E, E)] = this.data[this._idx(E - 1, E - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let R = 0; R < E; R++) for (let B = 0; B < E; B++) {
            const F = this.get(R, B);
            F > this.max && (this.max = F), F < this.min && (this.min = F);
          }
        }
        get(n, h) {
          const f = new Uint8Array(this.data.buffer), m = 4 * this._idx(n, h);
          return this.unpack(f[m], f[m + 1], f[m + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(n, h) {
          if (n < -1 || n >= this.dim + 1 || h < -1 || h >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
          return (h + 1) * this.stride + (n + 1);
        }
        unpack(n, h, f) {
          return n * this.redFactor + h * this.greenFactor + f * this.blueFactor - this.baseShift;
        }
        getPixels() {
          return new Mr({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(n, h, f) {
          if (this.dim !== n.dim) throw new Error("dem dimension mismatch");
          let m = h * this.dim, b = h * this.dim + this.dim, v = f * this.dim, A = f * this.dim + this.dim;
          switch (h) {
            case -1:
              m = b - 1;
              break;
            case 1:
              b = m + 1;
          }
          switch (f) {
            case -1:
              v = A - 1;
              break;
            case 1:
              A = v + 1;
          }
          const E = -h * this.dim, R = -f * this.dim;
          for (let B = v; B < A; B++) for (let F = m; F < b; F++) this.data[this._idx(F, B)] = n.data[this._idx(F + E, B + R)];
        }
      }
      ot("DEMData", ib);
      class sb {
        constructor(n) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let h = 0; h < n.length; h++) {
            const f = n[h];
            this._stringToNumber[f] = h, this._numberToString[h] = f;
          }
        }
        encode(n) {
          return this._stringToNumber[n];
        }
        decode(n) {
          if (n >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${n} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[n];
        }
      }
      class rb {
        constructor(n, h, f, m, b) {
          this.type = "Feature", this._vectorTileFeature = n, n._z = h, n._x = f, n._y = m, this.properties = n.properties, this.id = b;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(n) {
          this._geometry = n;
        }
        toJSON() {
          const n = { geometry: this.geometry };
          for (const h in this) h !== "_geometry" && h !== "_vectorTileFeature" && (n[h] = this[h]);
          return n;
        }
      }
      class nb {
        constructor(n, h) {
          this.tileID = n, this.x = n.canonical.x, this.y = n.canonical.y, this.z = n.canonical.z, this.grid = new Uo(Xi, 16, 0), this.grid3D = new Uo(Xi, 16, 0), this.featureIndexArray = new Ms(), this.promoteId = h;
        }
        insert(n, h, f, m, b, v) {
          const A = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(f, m, b);
          const E = v ? this.grid3D : this.grid;
          for (let R = 0; R < h.length; R++) {
            const B = h[R], F = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let L = 0; L < B.length; L++) {
              const V = B[L];
              F[0] = Math.min(F[0], V.x), F[1] = Math.min(F[1], V.y), F[2] = Math.max(F[2], V.x), F[3] = Math.max(F[3], V.y);
            }
            F[0] < Xi && F[1] < Xi && F[2] >= 0 && F[3] >= 0 && E.insert(A, F[0], F[1], F[2], F[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new Ko.VectorTile(new m_(this.rawTileData)).layers, this.sourceLayerCoder = new sb(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(n, h, f, m) {
          this.loadVTLayers();
          const b = n.params || {}, v = Xi / n.tileSize / n.scale, A = ch(b.filter), E = n.queryGeometry, R = n.queryPadding * v, B = ab(E), F = this.grid.query(B.minX - R, B.minY - R, B.maxX + R, B.maxY + R), L = ab(n.cameraQueryGeometry), V = this.grid3D.query(L.minX - R, L.minY - R, L.maxX + R, L.maxY + R, (ie, ne, Ae, de) => function(ye, Pe, Le, tt, bt) {
            for (const Je of ye) if (Pe <= Je.x && Le <= Je.y && tt >= Je.x && bt >= Je.y) return !0;
            const Qe = [new M(Pe, Le), new M(Pe, bt), new M(tt, bt), new M(tt, Le)];
            if (ye.length > 2) {
              for (const Je of Qe) if (Wl(ye, Je)) return !0;
            }
            for (let Je = 0; Je < ye.length - 1; Je++) if (cE(ye[Je], ye[Je + 1], Qe)) return !0;
            return !1;
          }(n.cameraQueryGeometry, ie - R, ne - R, Ae + R, de + R));
          for (const ie of V) F.push(ie);
          F.sort(MS);
          const $ = {};
          let X;
          for (let ie = 0; ie < F.length; ie++) {
            const ne = F[ie];
            if (ne === X) continue;
            X = ne;
            const Ae = this.featureIndexArray.get(ne);
            let de = null;
            this.loadMatchingFeature($, Ae.bucketIndex, Ae.sourceLayerIndex, Ae.featureIndex, A, b.layers, b.availableImages, h, f, m, (ye, Pe, Le) => (de || (de = Va(ye)), Pe.queryIntersectsFeature(E, ye, Le, de, this.z, n.transform, v, n.pixelPosMatrix)));
          }
          return $;
        }
        loadMatchingFeature(n, h, f, m, b, v, A, E, R, B, F) {
          const L = this.bucketLayerIDs[h];
          if (v && !function(ie, ne) {
            for (let Ae = 0; Ae < ie.length; Ae++) if (ne.indexOf(ie[Ae]) >= 0) return !0;
            return !1;
          }(v, L)) return;
          const V = this.sourceLayerCoder.decode(f), $ = this.vtLayers[V].feature(m);
          if (b.needGeometry) {
            const ie = Ha($, !0);
            if (!b.filter(new fi(this.tileID.overscaledZ), ie, this.tileID.canonical)) return;
          } else if (!b.filter(new fi(this.tileID.overscaledZ), $)) return;
          const X = this.getId($, V);
          for (let ie = 0; ie < L.length; ie++) {
            const ne = L[ie];
            if (v && v.indexOf(ne) < 0) continue;
            const Ae = E[ne];
            if (!Ae) continue;
            let de = {};
            X && B && (de = B.getState(Ae.sourceLayer || "_geojsonTileLayer", X));
            const ye = nt({}, R[ne]);
            ye.paint = ob(ye.paint, Ae.paint, $, de, A), ye.layout = ob(ye.layout, Ae.layout, $, de, A);
            const Pe = !F || F($, Ae, de);
            if (!Pe) continue;
            const Le = new rb($, this.z, this.x, this.y, X);
            Le.layer = ye;
            let tt = n[ne];
            tt === void 0 && (tt = n[ne] = []), tt.push({ featureIndex: m, feature: Le, intersectionZ: Pe });
          }
        }
        lookupSymbolFeatures(n, h, f, m, b, v, A, E) {
          const R = {};
          this.loadVTLayers();
          const B = ch(b);
          for (const F of n) this.loadMatchingFeature(R, f, m, F, B, v, A, E, h);
          return R;
        }
        hasLayer(n) {
          for (const h of this.bucketLayerIDs) for (const f of h) if (n === f) return !0;
          return !1;
        }
        getId(n, h) {
          let f = n.id;
          return this.promoteId && (f = n.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[h]], typeof f == "boolean" && (f = Number(f))), f;
        }
      }
      function ob(a, n, h, f, m) {
        return We(a, (b, v) => {
          const A = n instanceof Na ? n.get(v) : null;
          return A && A.evaluate ? A.evaluate(h, f, m) : A;
        });
      }
      function ab(a) {
        let n = 1 / 0, h = 1 / 0, f = -1 / 0, m = -1 / 0;
        for (const b of a) n = Math.min(n, b.x), h = Math.min(h, b.y), f = Math.max(f, b.x), m = Math.max(m, b.y);
        return { minX: n, minY: h, maxX: f, maxY: m };
      }
      function MS(a, n) {
        return n - a;
      }
      function lb(a, n, h, f, m) {
        const b = [];
        for (let v = 0; v < a.length; v++) {
          const A = a[v];
          let E;
          for (let R = 0; R < A.length - 1; R++) {
            let B = A[R], F = A[R + 1];
            B.x < n && F.x < n || (B.x < n ? B = new M(n, B.y + (n - B.x) / (F.x - B.x) * (F.y - B.y))._round() : F.x < n && (F = new M(n, B.y + (n - B.x) / (F.x - B.x) * (F.y - B.y))._round()), B.y < h && F.y < h || (B.y < h ? B = new M(B.x + (h - B.y) / (F.y - B.y) * (F.x - B.x), h)._round() : F.y < h && (F = new M(B.x + (h - B.y) / (F.y - B.y) * (F.x - B.x), h)._round()), B.x >= f && F.x >= f || (B.x >= f ? B = new M(f, B.y + (f - B.x) / (F.x - B.x) * (F.y - B.y))._round() : F.x >= f && (F = new M(f, B.y + (f - B.x) / (F.x - B.x) * (F.y - B.y))._round()), B.y >= m && F.y >= m || (B.y >= m ? B = new M(B.x + (m - B.y) / (F.y - B.y) * (F.x - B.x), m)._round() : F.y >= m && (F = new M(B.x + (m - B.y) / (F.y - B.y) * (F.x - B.x), m)._round()), E && B.equals(E[E.length - 1]) || (E = [B], b.push(E)), E.push(F)))));
          }
        }
        return b;
      }
      ot("FeatureIndex", nb, { omit: ["rawTileData", "sourceLayerCoder"] });
      class ea extends M {
        constructor(n, h, f, m) {
          super(n, h), this.angle = f, m !== void 0 && (this.segment = m);
        }
        clone() {
          return new ea(this.x, this.y, this.angle, this.segment);
        }
      }
      function cb(a, n, h, f, m) {
        if (n.segment === void 0 || h === 0) return !0;
        let b = n, v = n.segment + 1, A = 0;
        for (; A > -h / 2; ) {
          if (v--, v < 0) return !1;
          A -= a[v].dist(b), b = a[v];
        }
        A += a[v].dist(a[v + 1]), v++;
        const E = [];
        let R = 0;
        for (; A < h / 2; ) {
          const B = a[v], F = a[v + 1];
          if (!F) return !1;
          let L = a[v - 1].angleTo(B) - B.angleTo(F);
          for (L = Math.abs((L + 3 * Math.PI) % (2 * Math.PI) - Math.PI), E.push({ distance: A, angleDelta: L }), R += L; A - E[0].distance > f; ) R -= E.shift().angleDelta;
          if (R > m) return !1;
          v++, A += B.dist(F);
        }
        return !0;
      }
      function hb(a) {
        let n = 0;
        for (let h = 0; h < a.length - 1; h++) n += a[h].dist(a[h + 1]);
        return n;
      }
      function ub(a, n, h) {
        return a ? 0.6 * n * h : 0;
      }
      function db(a, n) {
        return Math.max(a ? a.right - a.left : 0, n ? n.right - n.left : 0);
      }
      function PS(a, n, h, f, m, b) {
        const v = ub(h, m, b), A = db(h, f) * b;
        let E = 0;
        const R = hb(a) / 2;
        for (let B = 0; B < a.length - 1; B++) {
          const F = a[B], L = a[B + 1], V = F.dist(L);
          if (E + V > R) {
            const $ = (R - E) / V, X = Us.number(F.x, L.x, $), ie = Us.number(F.y, L.y, $), ne = new ea(X, ie, L.angleTo(F), B);
            return ne._round(), !v || cb(a, ne, A, v, n) ? ne : void 0;
          }
          E += V;
        }
      }
      function BS(a, n, h, f, m, b, v, A, E) {
        const R = ub(f, b, v), B = db(f, m), F = B * v, L = a[0].x === 0 || a[0].x === E || a[0].y === 0 || a[0].y === E;
        return n - F < n / 4 && (n = F + n / 4), fb(a, L ? n / 2 * A % n : (B / 2 + 2 * b) * v * A % n, n, R, h, F, L, !1, E);
      }
      function fb(a, n, h, f, m, b, v, A, E) {
        const R = b / 2, B = hb(a);
        let F = 0, L = n - h, V = [];
        for (let $ = 0; $ < a.length - 1; $++) {
          const X = a[$], ie = a[$ + 1], ne = X.dist(ie), Ae = ie.angleTo(X);
          for (; L + h < F + ne; ) {
            L += h;
            const de = (L - F) / ne, ye = Us.number(X.x, ie.x, de), Pe = Us.number(X.y, ie.y, de);
            if (ye >= 0 && ye < E && Pe >= 0 && Pe < E && L - R >= 0 && L + R <= B) {
              const Le = new ea(ye, Pe, Ae, $);
              Le._round(), f && !cb(a, Le, b, f, m) || V.push(Le);
            }
          }
          F += ne;
        }
        return A || V.length || v || (V = fb(a, F / 2, h, f, m, b, v, !0, E)), V;
      }
      ot("Anchor", ea);
      const tc = rr;
      function pb(a, n, h, f) {
        const m = [], b = a.image, v = b.pixelRatio, A = b.paddedRect.w - 2 * tc, E = b.paddedRect.h - 2 * tc;
        let R = { x1: a.left, y1: a.top, x2: a.right, y2: a.bottom };
        const B = b.stretchX || [[0, A]], F = b.stretchY || [[0, E]], L = (De, _t) => De + _t[1] - _t[0], V = B.reduce(L, 0), $ = F.reduce(L, 0), X = A - V, ie = E - $;
        let ne = 0, Ae = V, de = 0, ye = $, Pe = 0, Le = X, tt = 0, bt = ie;
        if (b.content && f) {
          const De = b.content, _t = De[2] - De[0], dt = De[3] - De[1];
          (b.textFitWidth || b.textFitHeight) && (R = V0(a)), ne = kd(B, 0, De[0]), de = kd(F, 0, De[1]), Ae = kd(B, De[0], De[2]), ye = kd(F, De[1], De[3]), Pe = De[0] - ne, tt = De[1] - de, Le = _t - Ae, bt = dt - ye;
        }
        const Qe = R.x1, Je = R.y1, ft = R.x2 - Qe, ct = R.y2 - Je, rt = (De, _t, dt, Tt) => {
          const ai = Nd(De.stretch - ne, Ae, ft, Qe), ii = Ld(De.fixed - Pe, Le, De.stretch, V), es = Nd(_t.stretch - de, ye, ct, Je), Jr = Ld(_t.fixed - tt, bt, _t.stretch, $), xs = Nd(dt.stretch - ne, Ae, ft, Qe), ts = Ld(dt.fixed - Pe, Le, dt.stretch, V), js = Nd(Tt.stretch - de, ye, ct, Je), $s = Ld(Tt.fixed - tt, bt, Tt.stretch, $), Gs = new M(ai, es), ki = new M(xs, es), is = new M(xs, js), Bs = new M(ai, js), ws = new M(ii / v, Jr / v), Xs = new M(ts / v, $s / v), As = n * Math.PI / 180;
          if (As) {
            const Gt = Math.sin(As), hi = Math.cos(As), gi = [hi, -Gt, Gt, hi];
            Gs._matMult(gi), ki._matMult(gi), Bs._matMult(gi), is._matMult(gi);
          }
          const Br = De.stretch + De.fixed, nr = _t.stretch + _t.fixed;
          return { tl: Gs, tr: ki, bl: Bs, br: is, tex: { x: b.paddedRect.x + tc + Br, y: b.paddedRect.y + tc + nr, w: dt.stretch + dt.fixed - Br, h: Tt.stretch + Tt.fixed - nr }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: ws, pixelOffsetBR: Xs, minFontScaleX: Le / v / ft, minFontScaleY: bt / v / ct, isSDF: h };
        };
        if (f && (b.stretchX || b.stretchY)) {
          const De = _b(B, X, V), _t = _b(F, ie, $);
          for (let dt = 0; dt < De.length - 1; dt++) {
            const Tt = De[dt], ai = De[dt + 1];
            for (let ii = 0; ii < _t.length - 1; ii++) m.push(rt(Tt, _t[ii], ai, _t[ii + 1]));
          }
        } else m.push(rt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: A + 1 }, { fixed: 0, stretch: E + 1 }));
        return m;
      }
      function kd(a, n, h) {
        let f = 0;
        for (const m of a) f += Math.max(n, Math.min(h, m[1])) - Math.max(n, Math.min(h, m[0]));
        return f;
      }
      function _b(a, n, h) {
        const f = [{ fixed: -tc, stretch: 0 }];
        for (const [m, b] of a) {
          const v = f[f.length - 1];
          f.push({ fixed: m - v.stretch, stretch: v.stretch }), f.push({ fixed: m - v.stretch, stretch: v.stretch + (b - m) });
        }
        return f.push({ fixed: n + tc, stretch: h }), f;
      }
      function Nd(a, n, h, f) {
        return a / n * h + f;
      }
      function Ld(a, n, h, f) {
        return a - n * h / f;
      }
      class Ud {
        constructor(n, h, f, m, b, v, A, E, R, B) {
          var F;
          if (this.boxStartIndex = n.length, R) {
            let L = v.top, V = v.bottom;
            const $ = v.collisionPadding;
            $ && (L -= $[1], V += $[3]);
            let X = V - L;
            X > 0 && (X = Math.max(10, X), this.circleDiameter = X);
          } else {
            const L = !((F = v.image) === null || F === void 0) && F.content && (v.image.textFitWidth || v.image.textFitHeight) ? V0(v) : { x1: v.left, y1: v.top, x2: v.right, y2: v.bottom };
            L.y1 = L.y1 * A - E[0], L.y2 = L.y2 * A + E[2], L.x1 = L.x1 * A - E[3], L.x2 = L.x2 * A + E[1];
            const V = v.collisionPadding;
            if (V && (L.x1 -= V[0] * A, L.y1 -= V[1] * A, L.x2 += V[2] * A, L.y2 += V[3] * A), B) {
              const $ = new M(L.x1, L.y1), X = new M(L.x2, L.y1), ie = new M(L.x1, L.y2), ne = new M(L.x2, L.y2), Ae = B * Math.PI / 180;
              $._rotate(Ae), X._rotate(Ae), ie._rotate(Ae), ne._rotate(Ae), L.x1 = Math.min($.x, X.x, ie.x, ne.x), L.x2 = Math.max($.x, X.x, ie.x, ne.x), L.y1 = Math.min($.y, X.y, ie.y, ne.y), L.y2 = Math.max($.y, X.y, ie.y, ne.y);
            }
            n.emplaceBack(h.x, h.y, L.x1, L.y1, L.x2, L.y2, f, m, b);
          }
          this.boxEndIndex = n.length;
        }
      }
      class DS {
        constructor(n = [], h = (f, m) => f < m ? -1 : f > m ? 1 : 0) {
          if (this.data = n, this.length = this.data.length, this.compare = h, this.length > 0) for (let f = (this.length >> 1) - 1; f >= 0; f--) this._down(f);
        }
        push(n) {
          this.data.push(n), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const n = this.data[0], h = this.data.pop();
          return --this.length > 0 && (this.data[0] = h, this._down(0)), n;
        }
        peek() {
          return this.data[0];
        }
        _up(n) {
          const { data: h, compare: f } = this, m = h[n];
          for (; n > 0; ) {
            const b = n - 1 >> 1, v = h[b];
            if (f(m, v) >= 0) break;
            h[n] = v, n = b;
          }
          h[n] = m;
        }
        _down(n) {
          const { data: h, compare: f } = this, m = this.length >> 1, b = h[n];
          for (; n < m; ) {
            let v = 1 + (n << 1);
            const A = v + 1;
            if (A < this.length && f(h[A], h[v]) < 0 && (v = A), f(h[v], b) >= 0) break;
            h[n] = h[v], n = v;
          }
          h[n] = b;
        }
      }
      function OS(a, n = 1, h = !1) {
        let f = 1 / 0, m = 1 / 0, b = -1 / 0, v = -1 / 0;
        const A = a[0];
        for (let V = 0; V < A.length; V++) {
          const $ = A[V];
          (!V || $.x < f) && (f = $.x), (!V || $.y < m) && (m = $.y), (!V || $.x > b) && (b = $.x), (!V || $.y > v) && (v = $.y);
        }
        const E = Math.min(b - f, v - m);
        let R = E / 2;
        const B = new DS([], FS);
        if (E === 0) return new M(f, m);
        for (let V = f; V < b; V += E) for (let $ = m; $ < v; $ += E) B.push(new ic(V + R, $ + R, R, a));
        let F = function(V) {
          let $ = 0, X = 0, ie = 0;
          const ne = V[0];
          for (let Ae = 0, de = ne.length, ye = de - 1; Ae < de; ye = Ae++) {
            const Pe = ne[Ae], Le = ne[ye], tt = Pe.x * Le.y - Le.x * Pe.y;
            X += (Pe.x + Le.x) * tt, ie += (Pe.y + Le.y) * tt, $ += 3 * tt;
          }
          return new ic(X / $, ie / $, 0, V);
        }(a), L = B.length;
        for (; B.length; ) {
          const V = B.pop();
          (V.d > F.d || !F.d) && (F = V, h && console.log("found best %d after %d probes", Math.round(1e4 * V.d) / 1e4, L)), V.max - F.d <= n || (R = V.h / 2, B.push(new ic(V.p.x - R, V.p.y - R, R, a)), B.push(new ic(V.p.x + R, V.p.y - R, R, a)), B.push(new ic(V.p.x - R, V.p.y + R, R, a)), B.push(new ic(V.p.x + R, V.p.y + R, R, a)), L += 4);
        }
        return h && (console.log(`num probes: ${L}`), console.log(`best distance: ${F.d}`)), F.p;
      }
      function FS(a, n) {
        return n.max - a.max;
      }
      function ic(a, n, h, f) {
        this.p = new M(a, n), this.h = h, this.d = function(m, b) {
          let v = !1, A = 1 / 0;
          for (let E = 0; E < b.length; E++) {
            const R = b[E];
            for (let B = 0, F = R.length, L = F - 1; B < F; L = B++) {
              const V = R[B], $ = R[L];
              V.y > m.y != $.y > m.y && m.x < ($.x - V.x) * (m.y - V.y) / ($.y - V.y) + V.x && (v = !v), A = Math.min(A, Yy(m, V, $));
            }
          }
          return (v ? 1 : -1) * Math.sqrt(A);
        }(this.p, f), this.max = this.d + this.h * Math.SQRT2;
      }
      var vs;
      u.aq = void 0, (vs = u.aq || (u.aq = {}))[vs.center = 1] = "center", vs[vs.left = 2] = "left", vs[vs.right = 3] = "right", vs[vs.top = 4] = "top", vs[vs.bottom = 5] = "bottom", vs[vs["top-left"] = 6] = "top-left", vs[vs["top-right"] = 7] = "top-right", vs[vs["bottom-left"] = 8] = "bottom-left", vs[vs["bottom-right"] = 9] = "bottom-right";
      const ta = 7, R_ = Number.POSITIVE_INFINITY;
      function mb(a, n) {
        return n[1] !== R_ ? function(h, f, m) {
          let b = 0, v = 0;
          switch (f = Math.abs(f), m = Math.abs(m), h) {
            case "top-right":
            case "top-left":
            case "top":
              v = m - ta;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              v = -m + ta;
          }
          switch (h) {
            case "top-right":
            case "bottom-right":
            case "right":
              b = -f;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              b = f;
          }
          return [b, v];
        }(a, n[0], n[1]) : function(h, f) {
          let m = 0, b = 0;
          f < 0 && (f = 0);
          const v = f / Math.SQRT2;
          switch (h) {
            case "top-right":
            case "top-left":
              b = v - ta;
              break;
            case "bottom-right":
            case "bottom-left":
              b = -v + ta;
              break;
            case "bottom":
              b = -f + ta;
              break;
            case "top":
              b = f - ta;
          }
          switch (h) {
            case "top-right":
            case "bottom-right":
              m = -v;
              break;
            case "top-left":
            case "bottom-left":
              m = v;
              break;
            case "left":
              m = f;
              break;
            case "right":
              m = -f;
          }
          return [m, b];
        }(a, n[0]);
      }
      function gb(a, n, h) {
        var f;
        const m = a.layout, b = (f = m.get("text-variable-anchor-offset")) === null || f === void 0 ? void 0 : f.evaluate(n, {}, h);
        if (b) {
          const A = b.values, E = [];
          for (let R = 0; R < A.length; R += 2) {
            const B = E[R] = A[R], F = A[R + 1].map((L) => L * Ki);
            B.startsWith("top") ? F[1] -= ta : B.startsWith("bottom") && (F[1] += ta), E[R + 1] = F;
          }
          return new Ii(E);
        }
        const v = m.get("text-variable-anchor");
        if (v) {
          let A;
          A = a._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [m.get("text-radial-offset").evaluate(n, {}, h) * Ki, R_] : m.get("text-offset").evaluate(n, {}, h).map((R) => R * Ki);
          const E = [];
          for (const R of v) E.push(R, mb(R, A));
          return new Ii(E);
        }
        return null;
      }
      function M_(a) {
        switch (a) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function kS(a, n, h, f, m, b, v, A, E, R, B) {
        let F = b.textMaxSize.evaluate(n, {});
        F === void 0 && (F = v);
        const L = a.layers[0].layout, V = L.get("icon-offset").evaluate(n, {}, B), $ = bb(h.horizontal), X = v / 24, ie = a.tilePixelRatio * X, ne = a.tilePixelRatio * F / 24, Ae = a.tilePixelRatio * A, de = a.tilePixelRatio * L.get("symbol-spacing"), ye = L.get("text-padding") * a.tilePixelRatio, Pe = function(De, _t, dt, Tt = 1) {
          const ai = De.get("icon-padding").evaluate(_t, {}, dt), ii = ai && ai.values;
          return [ii[0] * Tt, ii[1] * Tt, ii[2] * Tt, ii[3] * Tt];
        }(L, n, B, a.tilePixelRatio), Le = L.get("text-max-angle") / 180 * Math.PI, tt = L.get("text-rotation-alignment") !== "viewport" && L.get("symbol-placement") !== "point", bt = L.get("icon-rotation-alignment") === "map" && L.get("symbol-placement") !== "point", Qe = L.get("symbol-placement"), Je = de / 2, ft = L.get("icon-text-fit");
        let ct;
        f && ft !== "none" && (a.allowVerticalPlacement && h.vertical && (ct = H0(f, h.vertical, ft, L.get("icon-text-fit-padding"), V, X)), $ && (f = H0(f, $, ft, L.get("icon-text-fit-padding"), V, X)));
        const rt = (De, _t) => {
          _t.x < 0 || _t.x >= Xi || _t.y < 0 || _t.y >= Xi || function(dt, Tt, ai, ii, es, Jr, xs, ts, js, $s, Gs, ki, is, Bs, ws, Xs, As, Br, nr, Gt, hi, gi, yr, Mi, sc) {
            const Fn = dt.addToLineVertexArray(Tt, ai);
            let kn, Yr, Dr, cs, fo = 0, Wh = 0, Ab = 0, Tb = 0, L_ = -1, U_ = -1;
            const po = {};
            let Eb = jl("");
            if (dt.allowVerticalPlacement && ii.vertical) {
              const Ds = ts.layout.get("text-rotate").evaluate(hi, {}, Mi) + 90;
              Dr = new Ud(js, Tt, $s, Gs, ki, ii.vertical, is, Bs, ws, Ds), xs && (cs = new Ud(js, Tt, $s, Gs, ki, xs, As, Br, ws, Ds));
            }
            if (es) {
              const Ds = ts.layout.get("icon-rotate").evaluate(hi, {}), Or = ts.layout.get("icon-text-fit") !== "none", $a = pb(es, Ds, yr, Or), un = xs ? pb(xs, Ds, yr, Or) : void 0;
              Yr = new Ud(js, Tt, $s, Gs, ki, es, As, Br, !1, Ds), fo = 4 * $a.length;
              const Ga = dt.iconSizeData;
              let Nn = null;
              Ga.kind === "source" ? (Nn = [On * ts.layout.get("icon-size").evaluate(hi, {})], Nn[0] > Yo && Rt(`${dt.layerIds[0]}: Value for "icon-size" is >= ${Hh}. Reduce your "icon-size".`)) : Ga.kind === "composite" && (Nn = [On * gi.compositeIconSizes[0].evaluate(hi, {}, Mi), On * gi.compositeIconSizes[1].evaluate(hi, {}, Mi)], (Nn[0] > Yo || Nn[1] > Yo) && Rt(`${dt.layerIds[0]}: Value for "icon-size" is >= ${Hh}. Reduce your "icon-size".`)), dt.addSymbols(dt.icon, $a, Nn, Gt, nr, hi, u.ah.none, Tt, Fn.lineStartIndex, Fn.lineLength, -1, Mi), L_ = dt.icon.placedSymbolArray.length - 1, un && (Wh = 4 * un.length, dt.addSymbols(dt.icon, un, Nn, Gt, nr, hi, u.ah.vertical, Tt, Fn.lineStartIndex, Fn.lineLength, -1, Mi), U_ = dt.icon.placedSymbolArray.length - 1);
            }
            const Sb = Object.keys(ii.horizontal);
            for (const Ds of Sb) {
              const Or = ii.horizontal[Ds];
              if (!kn) {
                Eb = jl(Or.text);
                const un = ts.layout.get("text-rotate").evaluate(hi, {}, Mi);
                kn = new Ud(js, Tt, $s, Gs, ki, Or, is, Bs, ws, un);
              }
              const $a = Or.positionedLines.length === 1;
              if (Ab += yb(dt, Tt, Or, Jr, ts, ws, hi, Xs, Fn, ii.vertical ? u.ah.horizontal : u.ah.horizontalOnly, $a ? Sb : [Ds], po, L_, gi, Mi), $a) break;
            }
            ii.vertical && (Tb += yb(dt, Tt, ii.vertical, Jr, ts, ws, hi, Xs, Fn, u.ah.vertical, ["vertical"], po, U_, gi, Mi));
            const US = kn ? kn.boxStartIndex : dt.collisionBoxArray.length, zS = kn ? kn.boxEndIndex : dt.collisionBoxArray.length, VS = Dr ? Dr.boxStartIndex : dt.collisionBoxArray.length, HS = Dr ? Dr.boxEndIndex : dt.collisionBoxArray.length, jS = Yr ? Yr.boxStartIndex : dt.collisionBoxArray.length, $S = Yr ? Yr.boxEndIndex : dt.collisionBoxArray.length, GS = cs ? cs.boxStartIndex : dt.collisionBoxArray.length, XS = cs ? cs.boxEndIndex : dt.collisionBoxArray.length;
            let hn = -1;
            const Vd = (Ds, Or) => Ds && Ds.circleDiameter ? Math.max(Ds.circleDiameter, Or) : Or;
            hn = Vd(kn, hn), hn = Vd(Dr, hn), hn = Vd(Yr, hn), hn = Vd(cs, hn);
            const Cb = hn > -1 ? 1 : 0;
            Cb && (hn *= sc / Ki), dt.glyphOffsetArray.length >= ec.MAX_GLYPHS && Rt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), hi.sortKey !== void 0 && dt.addToSortKeyRanges(dt.symbolInstances.length, hi.sortKey);
            const WS = gb(ts, hi, Mi), [qS, ZS] = function(Ds, Or) {
              const $a = Ds.length, un = Or == null ? void 0 : Or.values;
              if ((un == null ? void 0 : un.length) > 0) for (let Ga = 0; Ga < un.length; Ga += 2) {
                const Nn = un[Ga + 1];
                Ds.emplaceBack(u.aq[un[Ga]], Nn[0], Nn[1]);
              }
              return [$a, Ds.length];
            }(dt.textAnchorOffsets, WS);
            dt.symbolInstances.emplaceBack(Tt.x, Tt.y, po.right >= 0 ? po.right : -1, po.center >= 0 ? po.center : -1, po.left >= 0 ? po.left : -1, po.vertical || -1, L_, U_, Eb, US, zS, VS, HS, jS, $S, GS, XS, $s, Ab, Tb, fo, Wh, Cb, 0, is, hn, qS, ZS);
          }(a, _t, De, h, f, m, ct, a.layers[0], a.collisionBoxArray, n.index, n.sourceLayerIndex, a.index, ie, [ye, ye, ye, ye], tt, E, Ae, Pe, bt, V, n, b, R, B, v);
        };
        if (Qe === "line") for (const De of lb(n.geometry, 0, 0, Xi, Xi)) {
          const _t = BS(De, de, Le, h.vertical || $, f, 24, ne, a.overscaling, Xi);
          for (const dt of _t) $ && NS(a, $.text, Je, dt) || rt(De, dt);
        }
        else if (Qe === "line-center") {
          for (const De of n.geometry) if (De.length > 1) {
            const _t = PS(De, Le, h.vertical || $, f, 24, ne);
            _t && rt(De, _t);
          }
        } else if (n.type === "Polygon") for (const De of bl(n.geometry, 0)) {
          const _t = OS(De, 16);
          rt(De[0], new ea(_t.x, _t.y, 0));
        }
        else if (n.type === "LineString") for (const De of n.geometry) rt(De, new ea(De[0].x, De[0].y, 0));
        else if (n.type === "Point") for (const De of n.geometry) for (const _t of De) rt([_t], new ea(_t.x, _t.y, 0));
      }
      function yb(a, n, h, f, m, b, v, A, E, R, B, F, L, V, $) {
        const X = function(Ae, de, ye, Pe, Le, tt, bt, Qe) {
          const Je = Pe.layout.get("text-rotate").evaluate(tt, {}) * Math.PI / 180, ft = [];
          for (const ct of de.positionedLines) for (const rt of ct.positionedGlyphs) {
            if (!rt.rect) continue;
            const De = rt.rect || {};
            let _t = O0 + 1, dt = !0, Tt = 1, ai = 0;
            const ii = (Le || Qe) && rt.vertical, es = rt.metrics.advance * rt.scale / 2;
            if (Qe && de.verticalizable && (ai = ct.lineOffset / 2 - (rt.imageName ? -(Ki - rt.metrics.width * rt.scale) / 2 : (rt.scale - 1) * Ki)), rt.imageName) {
              const Gt = bt[rt.imageName];
              dt = Gt.sdf, Tt = Gt.pixelRatio, _t = rr / Tt;
            }
            const Jr = Le ? [rt.x + es, rt.y] : [0, 0];
            let xs = Le ? [0, 0] : [rt.x + es + ye[0], rt.y + ye[1] - ai], ts = [0, 0];
            ii && (ts = xs, xs = [0, 0]);
            const js = rt.metrics.isDoubleResolution ? 2 : 1, $s = (rt.metrics.left - _t) * rt.scale - es + xs[0], Gs = (-rt.metrics.top - _t) * rt.scale + xs[1], ki = $s + De.w / js * rt.scale / Tt, is = Gs + De.h / js * rt.scale / Tt, Bs = new M($s, Gs), ws = new M(ki, Gs), Xs = new M($s, is), As = new M(ki, is);
            if (ii) {
              const Gt = new M(-es, es - zh), hi = -Math.PI / 2, gi = Ki / 2 - es, yr = new M(5 - zh - gi, -(rt.imageName ? gi : 0)), Mi = new M(...ts);
              Bs._rotateAround(hi, Gt)._add(yr)._add(Mi), ws._rotateAround(hi, Gt)._add(yr)._add(Mi), Xs._rotateAround(hi, Gt)._add(yr)._add(Mi), As._rotateAround(hi, Gt)._add(yr)._add(Mi);
            }
            if (Je) {
              const Gt = Math.sin(Je), hi = Math.cos(Je), gi = [hi, -Gt, Gt, hi];
              Bs._matMult(gi), ws._matMult(gi), Xs._matMult(gi), As._matMult(gi);
            }
            const Br = new M(0, 0), nr = new M(0, 0);
            ft.push({ tl: Bs, tr: ws, bl: Xs, br: As, tex: De, writingMode: de.writingMode, glyphOffset: Jr, sectionIndex: rt.sectionIndex, isSDF: dt, pixelOffsetTL: Br, pixelOffsetBR: nr, minFontScaleX: 0, minFontScaleY: 0 });
          }
          return ft;
        }(0, h, A, m, b, v, f, a.allowVerticalPlacement), ie = a.textSizeData;
        let ne = null;
        ie.kind === "source" ? (ne = [On * m.layout.get("text-size").evaluate(v, {})], ne[0] > Yo && Rt(`${a.layerIds[0]}: Value for "text-size" is >= ${Hh}. Reduce your "text-size".`)) : ie.kind === "composite" && (ne = [On * V.compositeTextSizes[0].evaluate(v, {}, $), On * V.compositeTextSizes[1].evaluate(v, {}, $)], (ne[0] > Yo || ne[1] > Yo) && Rt(`${a.layerIds[0]}: Value for "text-size" is >= ${Hh}. Reduce your "text-size".`)), a.addSymbols(a.text, X, ne, A, b, v, R, n, E.lineStartIndex, E.lineLength, L, $);
        for (const Ae of B) F[Ae] = a.text.placedSymbolArray.length - 1;
        return 4 * X.length;
      }
      function bb(a) {
        for (const n in a) return a[n];
        return null;
      }
      function NS(a, n, h, f) {
        const m = a.compareText;
        if (n in m) {
          const b = m[n];
          for (let v = b.length - 1; v >= 0; v--) if (f.dist(b[v]) < h) return !0;
        } else m[n] = [];
        return m[n].push(f), !1;
      }
      const vb = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class P_ {
        static from(n) {
          if (!(n instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
          const [h, f] = new Uint8Array(n, 0, 2);
          if (h !== 219) throw new Error("Data does not appear to be in a KDBush format.");
          const m = f >> 4;
          if (m !== 1) throw new Error(`Got v${m} data when expected v1.`);
          const b = vb[15 & f];
          if (!b) throw new Error("Unrecognized array type.");
          const [v] = new Uint16Array(n, 2, 1), [A] = new Uint32Array(n, 4, 1);
          return new P_(A, v, b, n);
        }
        constructor(n, h = 64, f = Float64Array, m) {
          if (isNaN(n) || n < 0) throw new Error(`Unpexpected numItems value: ${n}.`);
          this.numItems = +n, this.nodeSize = Math.min(Math.max(+h, 2), 65535), this.ArrayType = f, this.IndexArrayType = n < 65536 ? Uint16Array : Uint32Array;
          const b = vb.indexOf(this.ArrayType), v = 2 * n * this.ArrayType.BYTES_PER_ELEMENT, A = n * this.IndexArrayType.BYTES_PER_ELEMENT, E = (8 - A % 8) % 8;
          if (b < 0) throw new Error(`Unexpected typed array class: ${f}.`);
          m && m instanceof ArrayBuffer ? (this.data = m, this.ids = new this.IndexArrayType(this.data, 8, n), this.coords = new this.ArrayType(this.data, 8 + A + E, 2 * n), this._pos = 2 * n, this._finished = !0) : (this.data = new ArrayBuffer(8 + v + A + E), this.ids = new this.IndexArrayType(this.data, 8, n), this.coords = new this.ArrayType(this.data, 8 + A + E, 2 * n), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + b]), new Uint16Array(this.data, 2, 1)[0] = h, new Uint32Array(this.data, 4, 1)[0] = n);
        }
        add(n, h) {
          const f = this._pos >> 1;
          return this.ids[f] = f, this.coords[this._pos++] = n, this.coords[this._pos++] = h, f;
        }
        finish() {
          const n = this._pos >> 1;
          if (n !== this.numItems) throw new Error(`Added ${n} items when expected ${this.numItems}.`);
          return B_(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
        }
        range(n, h, f, m) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: b, coords: v, nodeSize: A } = this, E = [0, b.length - 1, 0], R = [];
          for (; E.length; ) {
            const B = E.pop() || 0, F = E.pop() || 0, L = E.pop() || 0;
            if (F - L <= A) {
              for (let ie = L; ie <= F; ie++) {
                const ne = v[2 * ie], Ae = v[2 * ie + 1];
                ne >= n && ne <= f && Ae >= h && Ae <= m && R.push(b[ie]);
              }
              continue;
            }
            const V = L + F >> 1, $ = v[2 * V], X = v[2 * V + 1];
            $ >= n && $ <= f && X >= h && X <= m && R.push(b[V]), (B === 0 ? n <= $ : h <= X) && (E.push(L), E.push(V - 1), E.push(1 - B)), (B === 0 ? f >= $ : m >= X) && (E.push(V + 1), E.push(F), E.push(1 - B));
          }
          return R;
        }
        within(n, h, f) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: m, coords: b, nodeSize: v } = this, A = [0, m.length - 1, 0], E = [], R = f * f;
          for (; A.length; ) {
            const B = A.pop() || 0, F = A.pop() || 0, L = A.pop() || 0;
            if (F - L <= v) {
              for (let ie = L; ie <= F; ie++) wb(b[2 * ie], b[2 * ie + 1], n, h) <= R && E.push(m[ie]);
              continue;
            }
            const V = L + F >> 1, $ = b[2 * V], X = b[2 * V + 1];
            wb($, X, n, h) <= R && E.push(m[V]), (B === 0 ? n - f <= $ : h - f <= X) && (A.push(L), A.push(V - 1), A.push(1 - B)), (B === 0 ? n + f >= $ : h + f >= X) && (A.push(V + 1), A.push(F), A.push(1 - B));
          }
          return E;
        }
      }
      function B_(a, n, h, f, m, b) {
        if (m - f <= h) return;
        const v = f + m >> 1;
        xb(a, n, v, f, m, b), B_(a, n, h, f, v - 1, 1 - b), B_(a, n, h, v + 1, m, 1 - b);
      }
      function xb(a, n, h, f, m, b) {
        for (; m > f; ) {
          if (m - f > 600) {
            const R = m - f + 1, B = h - f + 1, F = Math.log(R), L = 0.5 * Math.exp(2 * F / 3), V = 0.5 * Math.sqrt(F * L * (R - L) / R) * (B - R / 2 < 0 ? -1 : 1);
            xb(a, n, h, Math.max(f, Math.floor(h - B * L / R + V)), Math.min(m, Math.floor(h + (R - B) * L / R + V)), b);
          }
          const v = n[2 * h + b];
          let A = f, E = m;
          for (Gh(a, n, f, h), n[2 * m + b] > v && Gh(a, n, f, m); A < E; ) {
            for (Gh(a, n, A, E), A++, E--; n[2 * A + b] < v; ) A++;
            for (; n[2 * E + b] > v; ) E--;
          }
          n[2 * f + b] === v ? Gh(a, n, f, E) : (E++, Gh(a, n, E, m)), E <= h && (f = E + 1), h <= E && (m = E - 1);
        }
      }
      function Gh(a, n, h, f) {
        D_(a, h, f), D_(n, 2 * h, 2 * f), D_(n, 2 * h + 1, 2 * f + 1);
      }
      function D_(a, n, h) {
        const f = a[n];
        a[n] = a[h], a[h] = f;
      }
      function wb(a, n, h, f) {
        const m = a - h, b = n - f;
        return m * m + b * b;
      }
      var O_;
      u.bg = void 0, (O_ = u.bg || (u.bg = {})).create = "create", O_.load = "load", O_.fullLoad = "fullLoad";
      let zd = null, Xh = [];
      const F_ = 1e3 / 60, k_ = "loadTime", N_ = "fullLoadTime", LS = { mark(a) {
        performance.mark(a);
      }, frame(a) {
        const n = a;
        zd != null && Xh.push(n - zd), zd = n;
      }, clearMetrics() {
        zd = null, Xh = [], performance.clearMeasures(k_), performance.clearMeasures(N_);
        for (const a in u.bg) performance.clearMarks(u.bg[a]);
      }, getPerformanceMetrics() {
        performance.measure(k_, u.bg.create, u.bg.load), performance.measure(N_, u.bg.create, u.bg.fullLoad);
        const a = performance.getEntriesByName(k_)[0].duration, n = performance.getEntriesByName(N_)[0].duration, h = Xh.length, f = 1 / (Xh.reduce((b, v) => b + v, 0) / h / 1e3), m = Xh.filter((b) => b > F_).reduce((b, v) => b + (v - F_) / F_, 0);
        return { loadTime: a, fullLoadTime: n, fps: f, percentDroppedFrames: m / (h + m) * 100, totalFrames: h };
      } };
      u.$ = class extends k {
      }, u.A = ql, u.B = Gp, u.C = function(a) {
        if (Fs == null) {
          const n = a.navigator ? a.navigator.userAgent : null;
          Fs = !!a.safari || !(!n || !(/\b(iPad|iPhone|iPod)\b/.test(n) || n.match("Safari") && !n.match("Chrome")));
        }
        return Fs;
      }, u.D = ht, u.E = lr, u.F = class {
        constructor(a, n) {
          this.target = a, this.mapId = n, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new RS(() => this.process()), this.subscription = function(h, f, m, b) {
            return h.addEventListener(f, m, !1), { unsubscribe: () => {
              h.removeEventListener(f, m, !1);
            } };
          }(this.target, "message", (h) => this.receive(h)), this.globalScope = di(self) ? a : window;
        }
        registerMessageHandler(a, n) {
          this.messageHandlers[a] = n;
        }
        sendAsync(a, n) {
          return new Promise((h, f) => {
            const m = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            this.resolveRejects[m] = { resolve: h, reject: f }, n && n.signal.addEventListener("abort", () => {
              delete this.resolveRejects[m];
              const A = { id: m, type: "<cancel>", origin: location.origin, targetMapId: a.targetMapId, sourceMapId: this.mapId };
              this.target.postMessage(A);
            }, { once: !0 });
            const b = [], v = Object.assign(Object.assign({}, a), { id: m, sourceMapId: this.mapId, origin: location.origin, data: zo(a.data, b) });
            this.target.postMessage(v, { transfer: b });
          });
        }
        receive(a) {
          const n = a.data, h = n.id;
          if (!(n.origin !== "file://" && location.origin !== "file://" && n.origin !== "resource://android" && location.origin !== "resource://android" && n.origin !== location.origin || n.targetMapId && this.mapId !== n.targetMapId)) {
            if (n.type === "<cancel>") {
              delete this.tasks[h];
              const f = this.abortControllers[h];
              return delete this.abortControllers[h], void (f && f.abort());
            }
            if (di(self) || n.mustQueue) return this.tasks[h] = n, this.taskQueue.push(h), void this.invoker.trigger();
            this.processTask(h, n);
          }
        }
        process() {
          if (this.taskQueue.length === 0) return;
          const a = this.taskQueue.shift(), n = this.tasks[a];
          delete this.tasks[a], this.taskQueue.length > 0 && this.invoker.trigger(), n && this.processTask(a, n);
        }
        processTask(a, n) {
          return c(this, void 0, void 0, function* () {
            if (n.type === "<response>") {
              const m = this.resolveRejects[a];
              return delete this.resolveRejects[a], m ? void (n.error ? m.reject(Vo(n.error)) : m.resolve(Vo(n.data))) : void 0;
            }
            if (!this.messageHandlers[n.type]) return void this.completeTask(a, new Error(`Could not find a registered handler for ${n.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
            const h = Vo(n.data), f = new AbortController();
            this.abortControllers[a] = f;
            try {
              const m = yield this.messageHandlers[n.type](n.sourceMapId, h, f);
              this.completeTask(a, null, m);
            } catch (m) {
              this.completeTask(a, m);
            }
          });
        }
        completeTask(a, n, h) {
          const f = [];
          delete this.abortControllers[a];
          const m = { id: a, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: n ? zo(n) : null, data: zo(h, f) };
          this.target.postMessage(m, { transfer: f });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }, u.G = En, u.H = function() {
        var a = new ql(16);
        return ql != Float32Array && (a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0), a[0] = 1, a[5] = 1, a[10] = 1, a[15] = 1, a;
      }, u.I = y_, u.J = function(a, n, h) {
        var f, m, b, v, A, E, R, B, F, L, V, $, X = h[0], ie = h[1], ne = h[2];
        return n === a ? (a[12] = n[0] * X + n[4] * ie + n[8] * ne + n[12], a[13] = n[1] * X + n[5] * ie + n[9] * ne + n[13], a[14] = n[2] * X + n[6] * ie + n[10] * ne + n[14], a[15] = n[3] * X + n[7] * ie + n[11] * ne + n[15]) : (m = n[1], b = n[2], v = n[3], A = n[4], E = n[5], R = n[6], B = n[7], F = n[8], L = n[9], V = n[10], $ = n[11], a[0] = f = n[0], a[1] = m, a[2] = b, a[3] = v, a[4] = A, a[5] = E, a[6] = R, a[7] = B, a[8] = F, a[9] = L, a[10] = V, a[11] = $, a[12] = f * X + A * ie + F * ne + n[12], a[13] = m * X + E * ie + L * ne + n[13], a[14] = b * X + R * ie + V * ne + n[14], a[15] = v * X + B * ie + $ * ne + n[15]), a;
      }, u.K = function(a, n, h) {
        var f = h[0], m = h[1], b = h[2];
        return a[0] = n[0] * f, a[1] = n[1] * f, a[2] = n[2] * f, a[3] = n[3] * f, a[4] = n[4] * m, a[5] = n[5] * m, a[6] = n[6] * m, a[7] = n[7] * m, a[8] = n[8] * b, a[9] = n[9] * b, a[10] = n[10] * b, a[11] = n[11] * b, a[12] = n[12], a[13] = n[13], a[14] = n[14], a[15] = n[15], a;
      }, u.L = i0, u.M = function(a, n) {
        const h = {};
        for (let f = 0; f < n.length; f++) {
          const m = n[f];
          m in a && (h[m] = a[m]);
        }
        return h;
      }, u.N = Qo, u.O = J0, u.P = M, u.Q = Y0, u.R = Mr, u.S = Pr, u.T = Ll, u.U = me, u.V = we, u.W = Js, u.X = Xi, u.Y = T, u.Z = jh, u._ = c, u.a = or, u.a$ = function(a, n) {
        var h = a[0], f = a[1], m = a[2], b = a[3], v = a[4], A = a[5], E = a[6], R = a[7], B = a[8], F = a[9], L = a[10], V = a[11], $ = a[12], X = a[13], ie = a[14], ne = a[15], Ae = n[0], de = n[1], ye = n[2], Pe = n[3], Le = n[4], tt = n[5], bt = n[6], Qe = n[7], Je = n[8], ft = n[9], ct = n[10], rt = n[11], De = n[12], _t = n[13], dt = n[14], Tt = n[15];
        return Math.abs(h - Ae) <= Hs * Math.max(1, Math.abs(h), Math.abs(Ae)) && Math.abs(f - de) <= Hs * Math.max(1, Math.abs(f), Math.abs(de)) && Math.abs(m - ye) <= Hs * Math.max(1, Math.abs(m), Math.abs(ye)) && Math.abs(b - Pe) <= Hs * Math.max(1, Math.abs(b), Math.abs(Pe)) && Math.abs(v - Le) <= Hs * Math.max(1, Math.abs(v), Math.abs(Le)) && Math.abs(A - tt) <= Hs * Math.max(1, Math.abs(A), Math.abs(tt)) && Math.abs(E - bt) <= Hs * Math.max(1, Math.abs(E), Math.abs(bt)) && Math.abs(R - Qe) <= Hs * Math.max(1, Math.abs(R), Math.abs(Qe)) && Math.abs(B - Je) <= Hs * Math.max(1, Math.abs(B), Math.abs(Je)) && Math.abs(F - ft) <= Hs * Math.max(1, Math.abs(F), Math.abs(ft)) && Math.abs(L - ct) <= Hs * Math.max(1, Math.abs(L), Math.abs(ct)) && Math.abs(V - rt) <= Hs * Math.max(1, Math.abs(V), Math.abs(rt)) && Math.abs($ - De) <= Hs * Math.max(1, Math.abs($), Math.abs(De)) && Math.abs(X - _t) <= Hs * Math.max(1, Math.abs(X), Math.abs(_t)) && Math.abs(ie - dt) <= Hs * Math.max(1, Math.abs(ie), Math.abs(dt)) && Math.abs(ne - Tt) <= Hs * Math.max(1, Math.abs(ne), Math.abs(Tt));
      }, u.a0 = Nt, u.a1 = I_, u.a2 = He, u.a3 = (a) => {
        const n = window.document.createElement("video");
        return n.muted = !0, new Promise((h) => {
          n.onloadstart = () => {
            h(n);
          };
          for (const f of a) {
            const m = window.document.createElement("source");
            Bi(f) || (n.crossOrigin = "Anonymous"), m.src = f, n.appendChild(m);
          }
        });
      }, u.a4 = function() {
        return mt++;
      }, u.a5 = et, u.a6 = ec, u.a7 = ch, u.a8 = Ha, u.a9 = rb, u.aA = function(a) {
        if (a.type === "custom") return new IS(a);
        switch (a.type) {
          case "background":
            return new ES(a);
          case "circle":
            return new dE(a);
          case "fill":
            return new RE(a);
          case "fill-extrusion":
            return new $E(a);
          case "heatmap":
            return new pE(a);
          case "hillshade":
            return new mE(a);
          case "line":
            return new YE(a);
          case "raster":
            return new CS(a);
          case "symbol":
            return new Fd(a);
        }
      }, u.aB = it, u.aC = function(a, n) {
        if (!a) return [{ command: "setStyle", args: [n] }];
        let h = [];
        try {
          if (!zt(a.version, n.version)) return [{ command: "setStyle", args: [n] }];
          zt(a.center, n.center) || h.push({ command: "setCenter", args: [n.center] }), zt(a.zoom, n.zoom) || h.push({ command: "setZoom", args: [n.zoom] }), zt(a.bearing, n.bearing) || h.push({ command: "setBearing", args: [n.bearing] }), zt(a.pitch, n.pitch) || h.push({ command: "setPitch", args: [n.pitch] }), zt(a.sprite, n.sprite) || h.push({ command: "setSprite", args: [n.sprite] }), zt(a.glyphs, n.glyphs) || h.push({ command: "setGlyphs", args: [n.glyphs] }), zt(a.transition, n.transition) || h.push({ command: "setTransition", args: [n.transition] }), zt(a.light, n.light) || h.push({ command: "setLight", args: [n.light] }), zt(a.terrain, n.terrain) || h.push({ command: "setTerrain", args: [n.terrain] }), zt(a.sky, n.sky) || h.push({ command: "setSky", args: [n.sky] }), zt(a.projection, n.projection) || h.push({ command: "setProjection", args: [n.projection] });
          const f = {}, m = [];
          (function(v, A, E, R) {
            let B;
            for (B in A = A || {}, v = v || {}) Object.prototype.hasOwnProperty.call(v, B) && (Object.prototype.hasOwnProperty.call(A, B) || Hr(B, E, R));
            for (B in A) Object.prototype.hasOwnProperty.call(A, B) && (Object.prototype.hasOwnProperty.call(v, B) ? zt(v[B], A[B]) || (v[B].type === "geojson" && A[B].type === "geojson" && Cn(v, A, B) ? oi(E, { command: "setGeoJSONSourceData", args: [B, A[B].data] }) : Ar(B, A, E, R)) : Ji(B, A, E));
          })(a.sources, n.sources, m, f);
          const b = [];
          a.layers && a.layers.forEach((v) => {
            "source" in v && f[v.source] ? h.push({ command: "removeLayer", args: [v.id] }) : b.push(v);
          }), h = h.concat(m), function(v, A, E) {
            A = A || [];
            const R = (v = v || []).map(Jn), B = A.map(Jn), F = v.reduce(In, {}), L = A.reduce(In, {}), V = R.slice(), $ = /* @__PURE__ */ Object.create(null);
            let X, ie, ne, Ae, de;
            for (let ye = 0, Pe = 0; ye < R.length; ye++) X = R[ye], Object.prototype.hasOwnProperty.call(L, X) ? Pe++ : (oi(E, { command: "removeLayer", args: [X] }), V.splice(V.indexOf(X, Pe), 1));
            for (let ye = 0, Pe = 0; ye < B.length; ye++) X = B[B.length - 1 - ye], V[V.length - 1 - ye] !== X && (Object.prototype.hasOwnProperty.call(F, X) ? (oi(E, { command: "removeLayer", args: [X] }), V.splice(V.lastIndexOf(X, V.length - Pe), 1)) : Pe++, Ae = V[V.length - ye], oi(E, { command: "addLayer", args: [L[X], Ae] }), V.splice(V.length - ye, 0, X), $[X] = !0);
            for (let ye = 0; ye < B.length; ye++) if (X = B[ye], ie = F[X], ne = L[X], !$[X] && !zt(ie, ne)) if (zt(ie.source, ne.source) && zt(ie["source-layer"], ne["source-layer"]) && zt(ie.type, ne.type)) {
              for (de in Ls(ie.layout, ne.layout, E, X, null, "setLayoutProperty"), Ls(ie.paint, ne.paint, E, X, null, "setPaintProperty"), zt(ie.filter, ne.filter) || oi(E, { command: "setFilter", args: [X, ne.filter] }), zt(ie.minzoom, ne.minzoom) && zt(ie.maxzoom, ne.maxzoom) || oi(E, { command: "setLayerZoomRange", args: [X, ne.minzoom, ne.maxzoom] }), ie) Object.prototype.hasOwnProperty.call(ie, de) && de !== "layout" && de !== "paint" && de !== "filter" && de !== "metadata" && de !== "minzoom" && de !== "maxzoom" && (de.indexOf("paint.") === 0 ? Ls(ie[de], ne[de], E, X, de.slice(6), "setPaintProperty") : zt(ie[de], ne[de]) || oi(E, { command: "setLayerProperty", args: [X, de, ne[de]] }));
              for (de in ne) Object.prototype.hasOwnProperty.call(ne, de) && !Object.prototype.hasOwnProperty.call(ie, de) && de !== "layout" && de !== "paint" && de !== "filter" && de !== "metadata" && de !== "minzoom" && de !== "maxzoom" && (de.indexOf("paint.") === 0 ? Ls(ie[de], ne[de], E, X, de.slice(6), "setPaintProperty") : zt(ie[de], ne[de]) || oi(E, { command: "setLayerProperty", args: [X, de, ne[de]] }));
            } else oi(E, { command: "removeLayer", args: [X] }), Ae = V[V.lastIndexOf(X) + 1], oi(E, { command: "addLayer", args: [ne, Ae] });
          }(b, n.layers, h);
        } catch (f) {
          console.warn("Unable to compute style diff:", f), h = [{ command: "setStyle", args: [n] }];
        }
        return h;
      }, u.aD = function(a) {
        const n = [], h = a.id;
        return h === void 0 && n.push({ message: `layers.${h}: missing required property "id"` }), a.render === void 0 && n.push({ message: `layers.${h}: missing required method "render"` }), a.renderingMode && a.renderingMode !== "2d" && a.renderingMode !== "3d" && n.push({ message: `layers.${h}: property "renderingMode" must be either "2d" or "3d"` }), n;
      }, u.aE = function a(n, h) {
        if (Array.isArray(n)) {
          if (!Array.isArray(h) || n.length !== h.length) return !1;
          for (let f = 0; f < n.length; f++) if (!a(n[f], h[f])) return !1;
          return !0;
        }
        if (typeof n == "object" && n !== null && h !== null) {
          if (typeof h != "object" || Object.keys(n).length !== Object.keys(h).length) return !1;
          for (const f in n) if (!a(n[f], h[f])) return !1;
          return !0;
        }
        return n === h;
      }, u.aF = We, u.aG = at, u.aH = class extends Ua {
        constructor(a, n) {
          super(a, n), this.current = 0;
        }
        set(a) {
          this.current !== a && (this.current = a, this.gl.uniform1i(this.location, a));
        }
      }, u.aI = wd, u.aJ = class extends Ua {
        constructor(a, n) {
          super(a, n), this.current = rE;
        }
        set(a) {
          if (a[12] !== this.current[12] || a[0] !== this.current[0]) return this.current = a, void this.gl.uniformMatrix4fv(this.location, !1, a);
          for (let n = 1; n < 16; n++) if (a[n] !== this.current[n]) {
            this.current = a, this.gl.uniformMatrix4fv(this.location, !1, a);
            break;
          }
        }
      }, u.aK = Gy, u.aL = Xy, u.aM = jt, u.aN = class extends Ua {
        constructor(a, n) {
          super(a, n), this.current = [0, 0, 0];
        }
        set(a) {
          a[0] === this.current[0] && a[1] === this.current[1] && a[2] === this.current[2] || (this.current = a, this.gl.uniform3f(this.location, a[0], a[1], a[2]));
        }
      }, u.aO = class extends Ua {
        constructor(a, n) {
          super(a, n), this.current = [0, 0];
        }
        set(a) {
          a[0] === this.current[0] && a[1] === this.current[1] || (this.current = a, this.gl.uniform2f(this.location, a[0], a[1]));
        }
      }, u.aP = function(a, n, h, f, m, b, v) {
        var A = 1 / (n - h), E = 1 / (f - m), R = 1 / (b - v);
        return a[0] = -2 * A, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = -2 * E, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 2 * R, a[11] = 0, a[12] = (n + h) * A, a[13] = (m + f) * E, a[14] = (v + b) * R, a[15] = 1, a;
      }, u.aQ = uE, u.aR = class extends fe {
      }, u.aS = iS, u.aT = class extends Te {
      }, u.aU = o_, u.aV = function(a) {
        return a <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));
      }, u.aW = a0, u.aX = ys, u.aY = Rr, u.aZ = class extends ut {
      }, u.a_ = function(a, n) {
        return a[0] === n[0] && a[1] === n[1] && a[2] === n[2] && a[3] === n[3] && a[4] === n[4] && a[5] === n[5] && a[6] === n[6] && a[7] === n[7] && a[8] === n[8] && a[9] === n[9] && a[10] === n[10] && a[11] === n[11] && a[12] === n[12] && a[13] === n[13] && a[14] === n[14] && a[15] === n[15];
      }, u.aa = function(a) {
        const n = {};
        if (a.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (h, f, m, b) => {
          const v = m || b;
          return n[f] = !v || v.toLowerCase(), "";
        }), n["max-age"]) {
          const h = parseInt(n["max-age"], 10);
          isNaN(h) ? delete n["max-age"] : n["max-age"] = h;
        }
        return n;
      }, u.ab = function(a, n) {
        const h = [];
        for (const f in a) f in n || h.push(f);
        return h;
      }, u.ac = Ne, u.ad = function(a, n, h) {
        var f = Math.sin(h), m = Math.cos(h), b = n[0], v = n[1], A = n[2], E = n[3], R = n[4], B = n[5], F = n[6], L = n[7];
        return n !== a && (a[8] = n[8], a[9] = n[9], a[10] = n[10], a[11] = n[11], a[12] = n[12], a[13] = n[13], a[14] = n[14], a[15] = n[15]), a[0] = b * m + R * f, a[1] = v * m + B * f, a[2] = A * m + F * f, a[3] = E * m + L * f, a[4] = R * m - b * f, a[5] = B * m - v * f, a[6] = F * m - A * f, a[7] = L * m - E * f, a;
      }, u.ae = function(a) {
        var n = new ql(16);
        return n[0] = a[0], n[1] = a[1], n[2] = a[2], n[3] = a[3], n[4] = a[4], n[5] = a[5], n[6] = a[6], n[7] = a[7], n[8] = a[8], n[9] = a[9], n[10] = a[10], n[11] = a[11], n[12] = a[12], n[13] = a[13], n[14] = a[14], n[15] = a[15], n;
      }, u.af = Sd, u.ag = function(a, n) {
        let h = 0, f = 0;
        if (a.kind === "constant") f = a.layoutSize;
        else if (a.kind !== "source") {
          const { interpolationType: m, minZoom: b, maxZoom: v } = a, A = m ? Ne(zs.interpolationFactor(m, n, b, v), 0, 1) : 0;
          a.kind === "camera" ? f = Us.number(a.minSize, a.maxSize, A) : h = A;
        }
        return { uSizeT: h, uSize: f };
      }, u.ai = function(a, { uSize: n, uSizeT: h }, { lowerSize: f, upperSize: m }) {
        return a.kind === "source" ? f / On : a.kind === "composite" ? Us.number(f / On, m / On, h) : n;
      }, u.aj = w_, u.ak = function(a, n, h, f) {
        const m = n.y - a.y, b = n.x - a.x, v = f.y - h.y, A = f.x - h.x, E = v * b - A * m;
        if (E === 0) return null;
        const R = (A * (a.y - h.y) - v * (a.x - h.x)) / E;
        return new M(a.x + R * b, a.y + R * m);
      }, u.al = lb, u.am = Ky, u.an = s_, u.ao = function(a) {
        let n = 1 / 0, h = 1 / 0, f = -1 / 0, m = -1 / 0;
        for (const b of a) n = Math.min(n, b.x), h = Math.min(h, b.y), f = Math.max(f, b.x), m = Math.max(m, b.y);
        return [n, h, f, m];
      }, u.ap = Ki, u.ar = x_, u.as = function(a, n) {
        var h = n[0], f = n[1], m = n[2], b = n[3], v = n[4], A = n[5], E = n[6], R = n[7], B = n[8], F = n[9], L = n[10], V = n[11], $ = n[12], X = n[13], ie = n[14], ne = n[15], Ae = h * A - f * v, de = h * E - m * v, ye = h * R - b * v, Pe = f * E - m * A, Le = f * R - b * A, tt = m * R - b * E, bt = B * X - F * $, Qe = B * ie - L * $, Je = B * ne - V * $, ft = F * ie - L * X, ct = F * ne - V * X, rt = L * ne - V * ie, De = Ae * rt - de * ct + ye * ft + Pe * Je - Le * Qe + tt * bt;
        return De ? (a[0] = (A * rt - E * ct + R * ft) * (De = 1 / De), a[1] = (m * ct - f * rt - b * ft) * De, a[2] = (X * tt - ie * Le + ne * Pe) * De, a[3] = (L * Le - F * tt - V * Pe) * De, a[4] = (E * Je - v * rt - R * Qe) * De, a[5] = (h * rt - m * Je + b * Qe) * De, a[6] = (ie * ye - $ * tt - ne * de) * De, a[7] = (B * tt - L * ye + V * de) * De, a[8] = (v * ct - A * Je + R * bt) * De, a[9] = (f * Je - h * ct - b * bt) * De, a[10] = ($ * Le - X * ye + ne * Ae) * De, a[11] = (F * ye - B * Le - V * Ae) * De, a[12] = (A * Qe - v * ft - E * bt) * De, a[13] = (h * ft - f * Qe + m * bt) * De, a[14] = (X * de - $ * Pe - ie * Ae) * De, a[15] = (B * Pe - F * de + L * Ae) * De, a) : null;
      }, u.at = M_, u.au = v_, u.av = P_, u.aw = function() {
        const a = {}, n = Ie.$version;
        for (const h in Ie.$root) {
          const f = Ie.$root[h];
          if (f.required) {
            let m = null;
            m = h === "version" ? n : f.type === "array" ? [] : {}, m != null && (a[h] = m);
          }
        }
        return a;
      }, u.ax = Ah, u.ay = Zi, u.az = function(a) {
        a = a.slice();
        const n = /* @__PURE__ */ Object.create(null);
        for (let h = 0; h < a.length; h++) n[a[h].id] = a[h];
        for (let h = 0; h < a.length; h++) "ref" in a[h] && (a[h] = Sn(a[h], n[a[h].ref]));
        return a;
      }, u.b = Hi, u.b0 = function(a, n) {
        return a[0] = n[0], a[1] = n[1], a[2] = n[2], a[3] = n[3], a[4] = n[4], a[5] = n[5], a[6] = n[6], a[7] = n[7], a[8] = n[8], a[9] = n[9], a[10] = n[10], a[11] = n[11], a[12] = n[12], a[13] = n[13], a[14] = n[14], a[15] = n[15], a;
      }, u.b1 = function(a, n, h) {
        return a[0] = n[0] * h[0], a[1] = n[1] * h[1], a[2] = n[2] * h[2], a[3] = n[3] * h[3], a;
      }, u.b2 = function(a, n) {
        return a[0] * n[0] + a[1] * n[1] + a[2] * n[2] + a[3] * n[3];
      }, u.b3 = ze, u.b4 = tb, u.b5 = Q0, u.b6 = function(a, n, h, f, m) {
        var b, v = 1 / Math.tan(n / 2);
        return a[0] = v / h, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = v, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[11] = -1, a[12] = 0, a[13] = 0, a[15] = 0, m != null && m !== 1 / 0 ? (a[10] = (m + f) * (b = 1 / (f - m)), a[14] = 2 * m * f * b) : (a[10] = -1, a[14] = -2 * f), a;
      }, u.b7 = function(a, n, h) {
        var f = Math.sin(h), m = Math.cos(h), b = n[4], v = n[5], A = n[6], E = n[7], R = n[8], B = n[9], F = n[10], L = n[11];
        return n !== a && (a[0] = n[0], a[1] = n[1], a[2] = n[2], a[3] = n[3], a[12] = n[12], a[13] = n[13], a[14] = n[14], a[15] = n[15]), a[4] = b * m + R * f, a[5] = v * m + B * f, a[6] = A * m + F * f, a[7] = E * m + L * f, a[8] = R * m - b * f, a[9] = B * m - v * f, a[10] = F * m - A * f, a[11] = L * m - E * f, a;
      }, u.b8 = Ee, u.b9 = Oe, u.bA = C0, u.bB = function(a) {
        return a.message === Pi;
      }, u.bC = Do, u.bD = ir, u.ba = function(a) {
        return a * Math.PI / 180;
      }, u.bb = function(a, n) {
        const { x: h, y: f } = jh.fromLngLat(n);
        return !(a < 0 || a > 25 || f < 0 || f >= 1 || h < 0 || h >= 1);
      }, u.bc = function(a, n) {
        return a[0] = n[0], a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = n[1], a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = n[2], a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
      }, u.bd = class extends D {
      }, u.be = S_, u.bf = LS, u.bh = Qt, u.bi = function(a, n) {
        or.REGISTERED_PROTOCOLS[a] = n;
      }, u.bj = function(a) {
        delete or.REGISTERED_PROTOCOLS[a];
      }, u.bk = function(a, n) {
        const h = {};
        for (let m = 0; m < a.length; m++) {
          const b = n && n[a[m].id] || hd(a[m]);
          n && (n[a[m].id] = b);
          let v = h[b];
          v || (v = h[b] = []), v.push(a[m]);
        }
        const f = [];
        for (const m in h) f.push(h[m]);
        return f;
      }, u.bl = ot, u.bm = sb, u.bn = nb, u.bo = k0, u.bp = function(a) {
        a.bucket.createArrays(), a.bucket.tilePixelRatio = Xi / (512 * a.bucket.overscaling), a.bucket.compareText = {}, a.bucket.iconsNeedLinear = !1;
        const n = a.bucket.layers[0], h = n.layout, f = n._unevaluatedLayout._values, m = { layoutIconSize: f["icon-size"].possiblyEvaluate(new fi(a.bucket.zoom + 1), a.canonical), layoutTextSize: f["text-size"].possiblyEvaluate(new fi(a.bucket.zoom + 1), a.canonical), textMaxSize: f["text-size"].possiblyEvaluate(new fi(18)) };
        if (a.bucket.textSizeData.kind === "composite") {
          const { minZoom: R, maxZoom: B } = a.bucket.textSizeData;
          m.compositeTextSizes = [f["text-size"].possiblyEvaluate(new fi(R), a.canonical), f["text-size"].possiblyEvaluate(new fi(B), a.canonical)];
        }
        if (a.bucket.iconSizeData.kind === "composite") {
          const { minZoom: R, maxZoom: B } = a.bucket.iconSizeData;
          m.compositeIconSizes = [f["icon-size"].possiblyEvaluate(new fi(R), a.canonical), f["icon-size"].possiblyEvaluate(new fi(B), a.canonical)];
        }
        const b = h.get("text-line-height") * Ki, v = h.get("text-rotation-alignment") !== "viewport" && h.get("symbol-placement") !== "point", A = h.get("text-keep-upright"), E = h.get("text-size");
        for (const R of a.bucket.features) {
          const B = h.get("text-font").evaluate(R, {}, a.canonical).join(","), F = E.evaluate(R, {}, a.canonical), L = m.layoutTextSize.evaluate(R, {}, a.canonical), V = m.layoutIconSize.evaluate(R, {}, a.canonical), $ = { horizontal: {}, vertical: void 0 }, X = R.text;
          let ie, ne = [0, 0];
          if (X) {
            const ye = X.toString(), Pe = h.get("text-letter-spacing").evaluate(R, {}, a.canonical) * Ki, Le = Xp(ye) ? Pe : 0, tt = h.get("text-anchor").evaluate(R, {}, a.canonical), bt = gb(n, R, a.canonical);
            if (!bt) {
              const ct = h.get("text-radial-offset").evaluate(R, {}, a.canonical);
              ne = ct ? mb(tt, [ct * Ki, R_]) : h.get("text-offset").evaluate(R, {}, a.canonical).map((rt) => rt * Ki);
            }
            let Qe = v ? "center" : h.get("text-justify").evaluate(R, {}, a.canonical);
            const Je = h.get("symbol-placement") === "point" ? h.get("text-max-width").evaluate(R, {}, a.canonical) * Ki : 1 / 0, ft = () => {
              a.bucket.allowVerticalPlacement && Th(ye) && ($.vertical = Bd(X, a.glyphMap, a.glyphPositions, a.imagePositions, B, Je, b, tt, "left", Le, ne, u.ah.vertical, !0, L, F));
            };
            if (!v && bt) {
              const ct = /* @__PURE__ */ new Set();
              if (Qe === "auto") for (let De = 0; De < bt.values.length; De += 2) ct.add(M_(bt.values[De]));
              else ct.add(Qe);
              let rt = !1;
              for (const De of ct) if (!$.horizontal[De]) if (rt) $.horizontal[De] = $.horizontal[0];
              else {
                const _t = Bd(X, a.glyphMap, a.glyphPositions, a.imagePositions, B, Je, b, "center", De, Le, ne, u.ah.horizontal, !1, L, F);
                _t && ($.horizontal[De] = _t, rt = _t.positionedLines.length === 1);
              }
              ft();
            } else {
              Qe === "auto" && (Qe = M_(tt));
              const ct = Bd(X, a.glyphMap, a.glyphPositions, a.imagePositions, B, Je, b, tt, Qe, Le, ne, u.ah.horizontal, !1, L, F);
              ct && ($.horizontal[Qe] = ct), ft(), Th(ye) && v && A && ($.vertical = Bd(X, a.glyphMap, a.glyphPositions, a.imagePositions, B, Je, b, tt, Qe, Le, ne, u.ah.vertical, !1, L, F));
            }
          }
          let Ae = !1;
          if (R.icon && R.icon.name) {
            const ye = a.imageMap[R.icon.name];
            ye && (ie = vS(a.imagePositions[R.icon.name], h.get("icon-offset").evaluate(R, {}, a.canonical), h.get("icon-anchor").evaluate(R, {}, a.canonical)), Ae = !!ye.sdf, a.bucket.sdfIcons === void 0 ? a.bucket.sdfIcons = Ae : a.bucket.sdfIcons !== Ae && Rt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (ye.pixelRatio !== a.bucket.pixelRatio || h.get("icon-rotate").constantOr(1) !== 0) && (a.bucket.iconsNeedLinear = !0));
          }
          const de = bb($.horizontal) || $.vertical;
          a.bucket.iconsInText = !!de && de.iconsInText, (de || ie) && kS(a.bucket, R, $, ie, a.imageMap, m, L, V, ne, Ae, a.canonical);
        }
        a.showCollisionBoxes && a.bucket.generateCollisionDebugBuffers();
      }, u.bq = p_, u.br = u_, u.bs = f_, u.bt = Ko, u.bu = m_, u.bv = class {
        constructor(a) {
          this._marks = { start: [a.url, "start"].join("#"), end: [a.url, "end"].join("#"), measure: a.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let a = performance.getEntriesByName(this._marks.measure);
          return a.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), a = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), a;
        }
      }, u.bw = function(a, n, h, f, m) {
        return c(this, void 0, void 0, function* () {
          if (we()) try {
            return yield Js(a, n, h, f, m);
          } catch {
          }
          return function(b, v, A, E, R) {
            const B = b.width, F = b.height;
            ji && Li || (ji = new OffscreenCanvas(B, F), Li = ji.getContext("2d", { willReadFrequently: !0 })), ji.width = B, ji.height = F, Li.drawImage(b, 0, 0, B, F);
            const L = Li.getImageData(v, A, E, R);
            return Li.clearRect(0, 0, B, F), L.data;
          }(a, n, h, f, m);
        });
      }, u.bx = ib, u.by = x, u.bz = w, u.c = Tn, u.d = (a) => c(void 0, void 0, void 0, function* () {
        if (a.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
        const n = new Blob([new Uint8Array(a)], { type: "image/png" });
        try {
          return createImageBitmap(n);
        } catch (h) {
          throw new Error(`Could not load image because of ${h.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
        }
      }), u.e = nt, u.f = (a) => new Promise((n, h) => {
        const f = new Image();
        f.onload = () => {
          n(f), URL.revokeObjectURL(f.src), f.onload = null, window.requestAnimationFrame(() => {
            f.src = An;
          });
        }, f.onerror = () => h(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
        const m = new Blob([new Uint8Array(a)], { type: "image/png" });
        f.src = a.byteLength ? URL.createObjectURL(m) : An;
      }), u.g = ar, u.h = (a, n) => ni(nt(a, { type: "json" }), n), u.i = di, u.j = Ns, u.k = ks, u.l = (a, n) => ni(nt(a, { type: "arrayBuffer" }), n), u.m = ni, u.n = function(a) {
        return new m_(a).readFields(fS, []);
      }, u.o = Dh, u.p = F0, u.q = y, u.r = $p, u.s = Bi, u.t = xh, u.u = lo, u.v = Ie, u.w = Rt, u.x = function([a, n, h]) {
        return n += 90, n *= Math.PI / 180, h *= Math.PI / 180, { x: a * Math.cos(n) * Math.sin(h), y: a * Math.sin(n) * Math.sin(h), z: a * Math.cos(h) };
      }, u.y = Us, u.z = fi;
    }), o("worker", ["./shared"], function(u) {
      class c {
        constructor(z) {
          this.keyCache = {}, z && this.replace(z);
        }
        replace(z) {
          this._layerConfigs = {}, this._layers = {}, this.update(z, []);
        }
        update(z, U) {
          for (const ee of z) {
            this._layerConfigs[ee.id] = ee;
            const ue = this._layers[ee.id] = u.aA(ee);
            ue._featureFilter = u.a7(ue.filter), this.keyCache[ee.id] && delete this.keyCache[ee.id];
          }
          for (const ee of U) delete this.keyCache[ee], delete this._layerConfigs[ee], delete this._layers[ee];
          this.familiesBySource = {};
          const W = u.bk(Object.values(this._layerConfigs), this.keyCache);
          for (const ee of W) {
            const ue = ee.map((Re) => this._layers[Re.id]), pe = ue[0];
            if (pe.visibility === "none") continue;
            const xe = pe.source || "";
            let le = this.familiesBySource[xe];
            le || (le = this.familiesBySource[xe] = {});
            const Be = pe.sourceLayer || "_geojsonTileLayer";
            let ke = le[Be];
            ke || (ke = le[Be] = []), ke.push(ue);
          }
        }
      }
      class x {
        constructor(z) {
          const U = {}, W = [];
          for (const xe in z) {
            const le = z[xe], Be = U[xe] = {};
            for (const ke in le) {
              const Re = le[+ke];
              if (!Re || Re.bitmap.width === 0 || Re.bitmap.height === 0) continue;
              const je = { x: 0, y: 0, w: Re.bitmap.width + 2, h: Re.bitmap.height + 2 };
              W.push(je), Be[ke] = { rect: je, metrics: Re.metrics };
            }
          }
          const { w: ee, h: ue } = u.p(W), pe = new u.o({ width: ee || 1, height: ue || 1 });
          for (const xe in z) {
            const le = z[xe];
            for (const Be in le) {
              const ke = le[+Be];
              if (!ke || ke.bitmap.width === 0 || ke.bitmap.height === 0) continue;
              const Re = U[xe][Be].rect;
              u.o.copy(ke.bitmap, pe, { x: 0, y: 0 }, { x: Re.x + 1, y: Re.y + 1 }, ke.bitmap);
            }
          }
          this.image = pe, this.positions = U;
        }
      }
      u.bl("GlyphAtlas", x);
      class w {
        constructor(z) {
          this.tileID = new u.S(z.tileID.overscaledZ, z.tileID.wrap, z.tileID.canonical.z, z.tileID.canonical.x, z.tileID.canonical.y), this.uid = z.uid, this.zoom = z.zoom, this.pixelRatio = z.pixelRatio, this.tileSize = z.tileSize, this.source = z.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = z.showCollisionBoxes, this.collectResourceTiming = !!z.collectResourceTiming, this.returnDependencies = !!z.returnDependencies, this.promoteId = z.promoteId, this.inFlightDependencies = [];
        }
        parse(z, U, W, ee) {
          return u._(this, void 0, void 0, function* () {
            this.status = "parsing", this.data = z, this.collisionBoxArray = new u.a5();
            const ue = new u.bm(Object.keys(z.layers).sort()), pe = new u.bn(this.tileID, this.promoteId);
            pe.bucketLayerIDs = [];
            const xe = {}, le = { featureIndex: pe, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: W }, Be = U.familiesBySource[this.source];
            for (const Ct in Be) {
              const Vt = z.layers[Ct];
              if (!Vt) continue;
              Vt.version === 1 && u.w(`Vector tile source "${this.source}" layer "${Ct}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const Zt = ue.encode(Ct), Si = [];
              for (let Ui = 0; Ui < Vt.length; Ui++) {
                const ns = Vt.feature(Ui), Rn = pe.getId(ns, Ct);
                Si.push({ feature: ns, id: Rn, index: Ui, sourceLayerIndex: Zt });
              }
              for (const Ui of Be[Ct]) {
                const ns = Ui[0];
                ns.source !== this.source && u.w(`layer.source = ${ns.source} does not equal this.source = ${this.source}`), ns.minzoom && this.zoom < Math.floor(ns.minzoom) || ns.maxzoom && this.zoom >= ns.maxzoom || ns.visibility !== "none" && (C(Ui, this.zoom, W), (xe[ns.id] = ns.createBucket({ index: pe.bucketLayerIDs.length, layers: Ui, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Zt, sourceID: this.source })).populate(Si, le, this.tileID.canonical), pe.bucketLayerIDs.push(Ui.map((Rn) => Rn.id)));
              }
            }
            const ke = u.aF(le.glyphDependencies, (Ct) => Object.keys(Ct).map(Number));
            this.inFlightDependencies.forEach((Ct) => Ct == null ? void 0 : Ct.abort()), this.inFlightDependencies = [];
            let Re = Promise.resolve({});
            if (Object.keys(ke).length) {
              const Ct = new AbortController();
              this.inFlightDependencies.push(Ct), Re = ee.sendAsync({ type: "GG", data: { stacks: ke, source: this.source, tileID: this.tileID, type: "glyphs" } }, Ct);
            }
            const je = Object.keys(le.iconDependencies);
            let pt = Promise.resolve({});
            if (je.length) {
              const Ct = new AbortController();
              this.inFlightDependencies.push(Ct), pt = ee.sendAsync({ type: "GI", data: { icons: je, source: this.source, tileID: this.tileID, type: "icons" } }, Ct);
            }
            const gt = Object.keys(le.patternDependencies);
            let Lt = Promise.resolve({});
            if (gt.length) {
              const Ct = new AbortController();
              this.inFlightDependencies.push(Ct), Lt = ee.sendAsync({ type: "GI", data: { icons: gt, source: this.source, tileID: this.tileID, type: "patterns" } }, Ct);
            }
            const [St, Ft, Pt] = yield Promise.all([Re, pt, Lt]), Ei = new x(St), li = new u.bo(Ft, Pt);
            for (const Ct in xe) {
              const Vt = xe[Ct];
              Vt instanceof u.a6 ? (C(Vt.layers, this.zoom, W), u.bp({ bucket: Vt, glyphMap: St, glyphPositions: Ei.positions, imageMap: Ft, imagePositions: li.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : Vt.hasPattern && (Vt instanceof u.bq || Vt instanceof u.br || Vt instanceof u.bs) && (C(Vt.layers, this.zoom, W), Vt.addFeatures(le, this.tileID.canonical, li.patternPositions));
            }
            return this.status = "done", { buckets: Object.values(xe).filter((Ct) => !Ct.isEmpty()), featureIndex: pe, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Ei.image, imageAtlas: li, glyphMap: this.returnDependencies ? St : null, iconMap: this.returnDependencies ? Ft : null, glyphPositions: this.returnDependencies ? Ei.positions : null };
          });
        }
      }
      function C(re, z, U) {
        const W = new u.z(z);
        for (const ee of re) ee.recalculate(W, U);
      }
      class M {
        constructor(z, U, W) {
          this.actor = z, this.layerIndex = U, this.availableImages = W, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadVectorTile(z, U) {
          return u._(this, void 0, void 0, function* () {
            const W = yield u.l(z.request, U);
            try {
              return { vectorTile: new u.bt.VectorTile(new u.bu(W.data)), rawData: W.data, cacheControl: W.cacheControl, expires: W.expires };
            } catch (ee) {
              const ue = new Uint8Array(W.data);
              let pe = `Unable to parse the tile at ${z.request.url}, `;
              throw pe += ue[0] === 31 && ue[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${ee.message}`, new Error(pe);
            }
          });
        }
        loadTile(z) {
          return u._(this, void 0, void 0, function* () {
            const U = z.uid, W = !!(z && z.request && z.request.collectResourceTiming) && new u.bv(z.request), ee = new w(z);
            this.loading[U] = ee;
            const ue = new AbortController();
            ee.abort = ue;
            try {
              const pe = yield this.loadVectorTile(z, ue);
              if (delete this.loading[U], !pe) return null;
              const xe = pe.rawData, le = {};
              pe.expires && (le.expires = pe.expires), pe.cacheControl && (le.cacheControl = pe.cacheControl);
              const Be = {};
              if (W) {
                const Re = W.finish();
                Re && (Be.resourceTiming = JSON.parse(JSON.stringify(Re)));
              }
              ee.vectorTile = pe.vectorTile;
              const ke = ee.parse(pe.vectorTile, this.layerIndex, this.availableImages, this.actor);
              this.loaded[U] = ee, this.fetching[U] = { rawTileData: xe, cacheControl: le, resourceTiming: Be };
              try {
                const Re = yield ke;
                return u.e({ rawTileData: xe.slice(0) }, Re, le, Be);
              } finally {
                delete this.fetching[U];
              }
            } catch (pe) {
              throw delete this.loading[U], ee.status = "done", this.loaded[U] = ee, pe;
            }
          });
        }
        reloadTile(z) {
          return u._(this, void 0, void 0, function* () {
            const U = z.uid;
            if (!this.loaded || !this.loaded[U]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
            const W = this.loaded[U];
            if (W.showCollisionBoxes = z.showCollisionBoxes, W.status === "parsing") {
              const ee = yield W.parse(W.vectorTile, this.layerIndex, this.availableImages, this.actor);
              let ue;
              if (this.fetching[U]) {
                const { rawTileData: pe, cacheControl: xe, resourceTiming: le } = this.fetching[U];
                delete this.fetching[U], ue = u.e({ rawTileData: pe.slice(0) }, ee, xe, le);
              } else ue = ee;
              return ue;
            }
            if (W.status === "done" && W.vectorTile) return W.parse(W.vectorTile, this.layerIndex, this.availableImages, this.actor);
          });
        }
        abortTile(z) {
          return u._(this, void 0, void 0, function* () {
            const U = this.loading, W = z.uid;
            U && U[W] && U[W].abort && (U[W].abort.abort(), delete U[W]);
          });
        }
        removeTile(z) {
          return u._(this, void 0, void 0, function* () {
            this.loaded && this.loaded[z.uid] && delete this.loaded[z.uid];
          });
        }
      }
      class P {
        constructor() {
          this.loaded = {};
        }
        loadTile(z) {
          return u._(this, void 0, void 0, function* () {
            const { uid: U, encoding: W, rawImageData: ee, redFactor: ue, greenFactor: pe, blueFactor: xe, baseShift: le } = z, Be = ee.width + 2, ke = ee.height + 2, Re = u.b(ee) ? new u.R({ width: Be, height: ke }, yield u.bw(ee, -1, -1, Be, ke)) : ee, je = new u.bx(U, Re, W, ue, pe, xe, le);
            return this.loaded = this.loaded || {}, this.loaded[U] = je, je;
          });
        }
        removeTile(z) {
          const U = this.loaded, W = z.uid;
          U && U[W] && delete U[W];
        }
      }
      function j(re, z) {
        if (re.length !== 0) {
          Y(re[0], z);
          for (var U = 1; U < re.length; U++) Y(re[U], !z);
        }
      }
      function Y(re, z) {
        for (var U = 0, W = 0, ee = 0, ue = re.length, pe = ue - 1; ee < ue; pe = ee++) {
          var xe = (re[ee][0] - re[pe][0]) * (re[pe][1] + re[ee][1]), le = U + xe;
          W += Math.abs(U) >= Math.abs(xe) ? U - le + xe : xe - le + U, U = le;
        }
        U + W >= 0 != !!z && re.reverse();
      }
      var Q = u.by(function re(z, U) {
        var W, ee = z && z.type;
        if (ee === "FeatureCollection") for (W = 0; W < z.features.length; W++) re(z.features[W], U);
        else if (ee === "GeometryCollection") for (W = 0; W < z.geometries.length; W++) re(z.geometries[W], U);
        else if (ee === "Feature") re(z.geometry, U);
        else if (ee === "Polygon") j(z.coordinates, U);
        else if (ee === "MultiPolygon") for (W = 0; W < z.coordinates.length; W++) j(z.coordinates[W], U);
        return z;
      });
      const _e = u.bt.VectorTileFeature.prototype.toGeoJSON;
      var me = { exports: {} }, we = u.bz, Ee = u.bt.VectorTileFeature, Oe = Ne;
      function Ne(re, z) {
        this.options = z || {}, this.features = re, this.length = re.length;
      }
      function ze(re, z) {
        this.id = typeof re.id == "number" ? re.id : void 0, this.type = re.type, this.rawGeometry = re.type === 1 ? [re.geometry] : re.geometry, this.properties = re.tags, this.extent = z || 4096;
      }
      Ne.prototype.feature = function(re) {
        return new ze(this.features[re], this.options.extent);
      }, ze.prototype.loadGeometry = function() {
        var re = this.rawGeometry;
        this.geometry = [];
        for (var z = 0; z < re.length; z++) {
          for (var U = re[z], W = [], ee = 0; ee < U.length; ee++) W.push(new we(U[ee][0], U[ee][1]));
          this.geometry.push(W);
        }
        return this.geometry;
      }, ze.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var re = this.geometry, z = 1 / 0, U = -1 / 0, W = 1 / 0, ee = -1 / 0, ue = 0; ue < re.length; ue++) for (var pe = re[ue], xe = 0; xe < pe.length; xe++) {
          var le = pe[xe];
          z = Math.min(z, le.x), U = Math.max(U, le.x), W = Math.min(W, le.y), ee = Math.max(ee, le.y);
        }
        return [z, W, U, ee];
      }, ze.prototype.toGeoJSON = Ee.prototype.toGeoJSON;
      var nt = u.bA, mt = Oe;
      function We(re) {
        var z = new nt();
        return function(U, W) {
          for (var ee in U.layers) W.writeMessage(3, at, U.layers[ee]);
        }(re, z), z.finish();
      }
      function at(re, z) {
        var U;
        z.writeVarintField(15, re.version || 1), z.writeStringField(1, re.name || ""), z.writeVarintField(5, re.extent || 4096);
        var W = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (U = 0; U < re.length; U++) W.feature = re.feature(U), z.writeMessage(2, it, W);
        var ee = W.keys;
        for (U = 0; U < ee.length; U++) z.writeStringField(3, ee[U]);
        var ue = W.values;
        for (U = 0; U < ue.length; U++) z.writeMessage(4, Fs, ue[U]);
      }
      function it(re, z) {
        var U = re.feature;
        U.id !== void 0 && z.writeVarintField(1, U.id), z.writeMessage(2, Ut, re), z.writeVarintField(3, U.type), z.writeMessage(4, di, U);
      }
      function Ut(re, z) {
        var U = re.feature, W = re.keys, ee = re.values, ue = re.keycache, pe = re.valuecache;
        for (var xe in U.properties) {
          var le = U.properties[xe], Be = ue[xe];
          if (le !== null) {
            Be === void 0 && (W.push(xe), ue[xe] = Be = W.length - 1), z.writeVarint(Be);
            var ke = typeof le;
            ke !== "string" && ke !== "boolean" && ke !== "number" && (le = JSON.stringify(le));
            var Re = ke + ":" + le, je = pe[Re];
            je === void 0 && (ee.push(le), pe[Re] = je = ee.length - 1), z.writeVarint(je);
          }
        }
      }
      function Rt(re, z) {
        return (z << 3) + (7 & re);
      }
      function yt(re) {
        return re << 1 ^ re >> 31;
      }
      function di(re, z) {
        for (var U = re.loadGeometry(), W = re.type, ee = 0, ue = 0, pe = U.length, xe = 0; xe < pe; xe++) {
          var le = U[xe], Be = 1;
          W === 1 && (Be = le.length), z.writeVarint(Rt(1, Be));
          for (var ke = W === 3 ? le.length - 1 : le.length, Re = 0; Re < ke; Re++) {
            Re === 1 && W !== 1 && z.writeVarint(Rt(2, ke - 1));
            var je = le[Re].x - ee, pt = le[Re].y - ue;
            z.writeVarint(yt(je)), z.writeVarint(yt(pt)), ee += je, ue += pt;
          }
          W === 3 && z.writeVarint(Rt(7, 1));
        }
      }
      function Fs(re, z) {
        var U = typeof re;
        U === "string" ? z.writeStringField(1, re) : U === "boolean" ? z.writeBooleanField(7, re) : U === "number" && (re % 1 != 0 ? z.writeDoubleField(3, re) : re < 0 ? z.writeSVarintField(6, re) : z.writeVarintField(5, re));
      }
      me.exports = We, me.exports.fromVectorTileJs = We, me.exports.fromGeojsonVt = function(re, z) {
        z = z || {};
        var U = {};
        for (var W in re) U[W] = new mt(re[W].features, z), U[W].name = W, U[W].version = z.version, U[W].extent = z.extent;
        return We({ layers: U });
      }, me.exports.GeoJSONWrapper = mt;
      var Hi = u.by(me.exports);
      const An = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (re) => re }, Js = Math.fround || (ji = new Float32Array(1), (re) => (ji[0] = +re, ji[0]));
      var ji;
      const Li = 3, Pi = 5, Tn = 6;
      class or {
        constructor(z) {
          this.options = Object.assign(Object.create(An), z), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(z) {
          const { log: U, minZoom: W, maxZoom: ee } = this.options;
          U && console.time("total time");
          const ue = `prepare ${z.length} points`;
          U && console.time(ue), this.points = z;
          const pe = [];
          for (let le = 0; le < z.length; le++) {
            const Be = z[le];
            if (!Be.geometry) continue;
            const [ke, Re] = Be.geometry.coordinates, je = Js(Qt(ke)), pt = Js(Zi(Re));
            pe.push(je, pt, 1 / 0, le, -1, 1), this.options.reduce && pe.push(0);
          }
          let xe = this.trees[ee + 1] = this._createTree(pe);
          U && console.timeEnd(ue);
          for (let le = ee; le >= W; le--) {
            const Be = +Date.now();
            xe = this.trees[le] = this._createTree(this._cluster(xe, le)), U && console.log("z%d: %d clusters in %dms", le, xe.numItems, +Date.now() - Be);
          }
          return U && console.timeEnd("total time"), this;
        }
        getClusters(z, U) {
          let W = ((z[0] + 180) % 360 + 360) % 360 - 180;
          const ee = Math.max(-90, Math.min(90, z[1]));
          let ue = z[2] === 180 ? 180 : ((z[2] + 180) % 360 + 360) % 360 - 180;
          const pe = Math.max(-90, Math.min(90, z[3]));
          if (z[2] - z[0] >= 360) W = -180, ue = 180;
          else if (W > ue) {
            const Re = this.getClusters([W, ee, 180, pe], U), je = this.getClusters([-180, ee, ue, pe], U);
            return Re.concat(je);
          }
          const xe = this.trees[this._limitZoom(U)], le = xe.range(Qt(W), Zi(pe), Qt(ue), Zi(ee)), Be = xe.data, ke = [];
          for (const Re of le) {
            const je = this.stride * Re;
            ke.push(Be[je + Pi] > 1 ? ar(Be, je, this.clusterProps) : this.points[Be[je + Li]]);
          }
          return ke;
        }
        getChildren(z) {
          const U = this._getOriginId(z), W = this._getOriginZoom(z), ee = "No cluster with the specified id.", ue = this.trees[W];
          if (!ue) throw new Error(ee);
          const pe = ue.data;
          if (U * this.stride >= pe.length) throw new Error(ee);
          const xe = this.options.radius / (this.options.extent * Math.pow(2, W - 1)), le = ue.within(pe[U * this.stride], pe[U * this.stride + 1], xe), Be = [];
          for (const ke of le) {
            const Re = ke * this.stride;
            pe[Re + 4] === z && Be.push(pe[Re + Pi] > 1 ? ar(pe, Re, this.clusterProps) : this.points[pe[Re + Li]]);
          }
          if (Be.length === 0) throw new Error(ee);
          return Be;
        }
        getLeaves(z, U, W) {
          const ee = [];
          return this._appendLeaves(ee, z, U = U || 10, W = W || 0, 0), ee;
        }
        getTile(z, U, W) {
          const ee = this.trees[this._limitZoom(z)], ue = Math.pow(2, z), { extent: pe, radius: xe } = this.options, le = xe / pe, Be = (W - le) / ue, ke = (W + 1 + le) / ue, Re = { features: [] };
          return this._addTileFeatures(ee.range((U - le) / ue, Be, (U + 1 + le) / ue, ke), ee.data, U, W, ue, Re), U === 0 && this._addTileFeatures(ee.range(1 - le / ue, Be, 1, ke), ee.data, ue, W, ue, Re), U === ue - 1 && this._addTileFeatures(ee.range(0, Be, le / ue, ke), ee.data, -1, W, ue, Re), Re.features.length ? Re : null;
        }
        getClusterExpansionZoom(z) {
          let U = this._getOriginZoom(z) - 1;
          for (; U <= this.options.maxZoom; ) {
            const W = this.getChildren(z);
            if (U++, W.length !== 1) break;
            z = W[0].properties.cluster_id;
          }
          return U;
        }
        _appendLeaves(z, U, W, ee, ue) {
          const pe = this.getChildren(U);
          for (const xe of pe) {
            const le = xe.properties;
            if (le && le.cluster ? ue + le.point_count <= ee ? ue += le.point_count : ue = this._appendLeaves(z, le.cluster_id, W, ee, ue) : ue < ee ? ue++ : z.push(xe), z.length === W) break;
          }
          return ue;
        }
        _createTree(z) {
          const U = new u.av(z.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let W = 0; W < z.length; W += this.stride) U.add(z[W], z[W + 1]);
          return U.finish(), U.data = z, U;
        }
        _addTileFeatures(z, U, W, ee, ue, pe) {
          for (const xe of z) {
            const le = xe * this.stride, Be = U[le + Pi] > 1;
            let ke, Re, je;
            if (Be) ke = En(U, le, this.clusterProps), Re = U[le], je = U[le + 1];
            else {
              const Lt = this.points[U[le + Li]];
              ke = Lt.properties;
              const [St, Ft] = Lt.geometry.coordinates;
              Re = Qt(St), je = Zi(Ft);
            }
            const pt = { type: 1, geometry: [[Math.round(this.options.extent * (Re * ue - W)), Math.round(this.options.extent * (je * ue - ee))]], tags: ke };
            let gt;
            gt = Be || this.options.generateId ? U[le + Li] : this.points[U[le + Li]].id, gt !== void 0 && (pt.id = gt), pe.features.push(pt);
          }
        }
        _limitZoom(z) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));
        }
        _cluster(z, U) {
          const { radius: W, extent: ee, reduce: ue, minPoints: pe } = this.options, xe = W / (ee * Math.pow(2, U)), le = z.data, Be = [], ke = this.stride;
          for (let Re = 0; Re < le.length; Re += ke) {
            if (le[Re + 2] <= U) continue;
            le[Re + 2] = U;
            const je = le[Re], pt = le[Re + 1], gt = z.within(le[Re], le[Re + 1], xe), Lt = le[Re + Pi];
            let St = Lt;
            for (const Ft of gt) {
              const Pt = Ft * ke;
              le[Pt + 2] > U && (St += le[Pt + Pi]);
            }
            if (St > Lt && St >= pe) {
              let Ft, Pt = je * Lt, Ei = pt * Lt, li = -1;
              const Ct = ((Re / ke | 0) << 5) + (U + 1) + this.points.length;
              for (const Vt of gt) {
                const Zt = Vt * ke;
                if (le[Zt + 2] <= U) continue;
                le[Zt + 2] = U;
                const Si = le[Zt + Pi];
                Pt += le[Zt] * Si, Ei += le[Zt + 1] * Si, le[Zt + 4] = Ct, ue && (Ft || (Ft = this._map(le, Re, !0), li = this.clusterProps.length, this.clusterProps.push(Ft)), ue(Ft, this._map(le, Zt)));
              }
              le[Re + 4] = Ct, Be.push(Pt / St, Ei / St, 1 / 0, Ct, -1, St), ue && Be.push(li);
            } else {
              for (let Ft = 0; Ft < ke; Ft++) Be.push(le[Re + Ft]);
              if (St > 1) for (const Ft of gt) {
                const Pt = Ft * ke;
                if (!(le[Pt + 2] <= U)) {
                  le[Pt + 2] = U;
                  for (let Ei = 0; Ei < ke; Ei++) Be.push(le[Pt + Ei]);
                }
              }
            }
          }
          return Be;
        }
        _getOriginId(z) {
          return z - this.points.length >> 5;
        }
        _getOriginZoom(z) {
          return (z - this.points.length) % 32;
        }
        _map(z, U, W) {
          if (z[U + Pi] > 1) {
            const pe = this.clusterProps[z[U + Tn]];
            return W ? Object.assign({}, pe) : pe;
          }
          const ee = this.points[z[U + Li]].properties, ue = this.options.map(ee);
          return W && ue === ee ? Object.assign({}, ue) : ue;
        }
      }
      function ar(re, z, U) {
        return { type: "Feature", id: re[z + Li], properties: En(re, z, U), geometry: { type: "Point", coordinates: [(W = re[z], 360 * (W - 0.5)), ni(re[z + 1])] } };
        var W;
      }
      function En(re, z, U) {
        const W = re[z + Pi], ee = W >= 1e4 ? `${Math.round(W / 1e3)}k` : W >= 1e3 ? Math.round(W / 100) / 10 + "k" : W, ue = re[z + Tn], pe = ue === -1 ? {} : Object.assign({}, U[ue]);
        return Object.assign(pe, { cluster: !0, cluster_id: re[z + Li], point_count: W, point_count_abbreviated: ee });
      }
      function Qt(re) {
        return re / 360 + 0.5;
      }
      function Zi(re) {
        const z = Math.sin(re * Math.PI / 180), U = 0.5 - 0.25 * Math.log((1 + z) / (1 - z)) / Math.PI;
        return U < 0 ? 0 : U > 1 ? 1 : U;
      }
      function ni(re) {
        const z = (180 - 360 * re) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(z)) / Math.PI - 90;
      }
      function Bi(re, z, U, W) {
        let ee = W;
        const ue = z + (U - z >> 1);
        let pe, xe = U - z;
        const le = re[z], Be = re[z + 1], ke = re[U], Re = re[U + 1];
        for (let je = z + 3; je < U; je += 3) {
          const pt = Vr(re[je], re[je + 1], le, Be, ke, Re);
          if (pt > ee) pe = je, ee = pt;
          else if (pt === ee) {
            const gt = Math.abs(je - ue);
            gt < xe && (pe = je, xe = gt);
          }
        }
        ee > W && (pe - z > 3 && Bi(re, z, pe, W), re[pe + 2] = ee, U - pe > 3 && Bi(re, pe, U, W));
      }
      function Vr(re, z, U, W, ee, ue) {
        let pe = ee - U, xe = ue - W;
        if (pe !== 0 || xe !== 0) {
          const le = ((re - U) * pe + (z - W) * xe) / (pe * pe + xe * xe);
          le > 1 ? (U = ee, W = ue) : le > 0 && (U += pe * le, W += xe * le);
        }
        return pe = re - U, xe = z - W, pe * pe + xe * xe;
      }
      function Ss(re, z, U, W) {
        const ee = { id: re ?? null, type: z, geometry: U, tags: W, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if (z === "Point" || z === "MultiPoint" || z === "LineString") ks(ee, U);
        else if (z === "Polygon") ks(ee, U[0]);
        else if (z === "MultiLineString") for (const ue of U) ks(ee, ue);
        else if (z === "MultiPolygon") for (const ue of U) ks(ee, ue[0]);
        return ee;
      }
      function ks(re, z) {
        for (let U = 0; U < z.length; U += 3) re.minX = Math.min(re.minX, z[U]), re.minY = Math.min(re.minY, z[U + 1]), re.maxX = Math.max(re.maxX, z[U]), re.maxY = Math.max(re.maxY, z[U + 1]);
      }
      function Ns(re, z, U, W) {
        if (!z.geometry) return;
        const ee = z.geometry.coordinates;
        if (ee && ee.length === 0) return;
        const ue = z.geometry.type, pe = Math.pow(U.tolerance / ((1 << U.maxZoom) * U.extent), 2);
        let xe = [], le = z.id;
        if (U.promoteId ? le = z.properties[U.promoteId] : U.generateId && (le = W || 0), ue === "Point") lr(ee, xe);
        else if (ue === "MultiPoint") for (const Be of ee) lr(Be, xe);
        else if (ue === "LineString") Ie(ee, xe, pe, !1);
        else if (ue === "MultiLineString") {
          if (U.lineMetrics) {
            for (const Be of ee) xe = [], Ie(Be, xe, pe, !1), re.push(Ss(le, "LineString", xe, z.properties));
            return;
          }
          Cs(ee, xe, pe, !1);
        } else if (ue === "Polygon") Cs(ee, xe, pe, !0);
        else {
          if (ue !== "MultiPolygon") {
            if (ue === "GeometryCollection") {
              for (const Be of z.geometry.geometries) Ns(re, { id: le, geometry: Be, properties: z.properties }, U, W);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const Be of ee) {
            const ke = [];
            Cs(Be, ke, pe, !0), xe.push(ke);
          }
        }
        re.push(Ss(le, ue, xe, z.properties));
      }
      function lr(re, z) {
        z.push(Sn(re[0]), zt(re[1]), 0);
      }
      function Ie(re, z, U, W) {
        let ee, ue, pe = 0;
        for (let le = 0; le < re.length; le++) {
          const Be = Sn(re[le][0]), ke = zt(re[le][1]);
          z.push(Be, ke, 0), le > 0 && (pe += W ? (ee * ke - Be * ue) / 2 : Math.sqrt(Math.pow(Be - ee, 2) + Math.pow(ke - ue, 2))), ee = Be, ue = ke;
        }
        const xe = z.length - 3;
        z[2] = 1, Bi(z, 0, xe, U), z[xe + 2] = 1, z.size = Math.abs(pe), z.start = 0, z.end = z.size;
      }
      function Cs(re, z, U, W) {
        for (let ee = 0; ee < re.length; ee++) {
          const ue = [];
          Ie(re[ee], ue, U, W), z.push(ue);
        }
      }
      function Sn(re) {
        return re / 360 + 0.5;
      }
      function zt(re) {
        const z = Math.sin(re * Math.PI / 180), U = 0.5 - 0.25 * Math.log((1 + z) / (1 - z)) / Math.PI;
        return U < 0 ? 0 : U > 1 ? 1 : U;
      }
      function oi(re, z, U, W, ee, ue, pe, xe) {
        if (W /= z, ue >= (U /= z) && pe < W) return re;
        if (pe < U || ue >= W) return null;
        const le = [];
        for (const Be of re) {
          const ke = Be.geometry;
          let Re = Be.type;
          const je = ee === 0 ? Be.minX : Be.minY, pt = ee === 0 ? Be.maxX : Be.maxY;
          if (je >= U && pt < W) {
            le.push(Be);
            continue;
          }
          if (pt < U || je >= W) continue;
          let gt = [];
          if (Re === "Point" || Re === "MultiPoint") Ji(ke, gt, U, W, ee);
          else if (Re === "LineString") Hr(ke, gt, U, W, ee, !1, xe.lineMetrics);
          else if (Re === "MultiLineString") Cn(ke, gt, U, W, ee, !1);
          else if (Re === "Polygon") Cn(ke, gt, U, W, ee, !0);
          else if (Re === "MultiPolygon") for (const Lt of ke) {
            const St = [];
            Cn(Lt, St, U, W, ee, !0), St.length && gt.push(St);
          }
          if (gt.length) {
            if (xe.lineMetrics && Re === "LineString") {
              for (const Lt of gt) le.push(Ss(Be.id, Re, Lt, Be.tags));
              continue;
            }
            Re !== "LineString" && Re !== "MultiLineString" || (gt.length === 1 ? (Re = "LineString", gt = gt[0]) : Re = "MultiLineString"), Re !== "Point" && Re !== "MultiPoint" || (Re = gt.length === 3 ? "Point" : "MultiPoint"), le.push(Ss(Be.id, Re, gt, Be.tags));
          }
        }
        return le.length ? le : null;
      }
      function Ji(re, z, U, W, ee) {
        for (let ue = 0; ue < re.length; ue += 3) {
          const pe = re[ue + ee];
          pe >= U && pe <= W && Ls(z, re[ue], re[ue + 1], re[ue + 2]);
        }
      }
      function Hr(re, z, U, W, ee, ue, pe) {
        let xe = Ar(re);
        const le = ee === 0 ? Jn : In;
        let Be, ke, Re = re.start;
        for (let St = 0; St < re.length - 3; St += 3) {
          const Ft = re[St], Pt = re[St + 1], Ei = re[St + 2], li = re[St + 3], Ct = re[St + 4], Vt = ee === 0 ? Ft : Pt, Zt = ee === 0 ? li : Ct;
          let Si = !1;
          pe && (Be = Math.sqrt(Math.pow(Ft - li, 2) + Math.pow(Pt - Ct, 2))), Vt < U ? Zt > U && (ke = le(xe, Ft, Pt, li, Ct, U), pe && (xe.start = Re + Be * ke)) : Vt > W ? Zt < W && (ke = le(xe, Ft, Pt, li, Ct, W), pe && (xe.start = Re + Be * ke)) : Ls(xe, Ft, Pt, Ei), Zt < U && Vt >= U && (ke = le(xe, Ft, Pt, li, Ct, U), Si = !0), Zt > W && Vt <= W && (ke = le(xe, Ft, Pt, li, Ct, W), Si = !0), !ue && Si && (pe && (xe.end = Re + Be * ke), z.push(xe), xe = Ar(re)), pe && (Re += Be);
        }
        let je = re.length - 3;
        const pt = re[je], gt = re[je + 1], Lt = ee === 0 ? pt : gt;
        Lt >= U && Lt <= W && Ls(xe, pt, gt, re[je + 2]), je = xe.length - 3, ue && je >= 3 && (xe[je] !== xe[0] || xe[je + 1] !== xe[1]) && Ls(xe, xe[0], xe[1], xe[2]), xe.length && z.push(xe);
      }
      function Ar(re) {
        const z = [];
        return z.size = re.size, z.start = re.start, z.end = re.end, z;
      }
      function Cn(re, z, U, W, ee, ue) {
        for (const pe of re) Hr(pe, z, U, W, ee, ue, !1);
      }
      function Ls(re, z, U, W) {
        re.push(z, U, W);
      }
      function Jn(re, z, U, W, ee, ue) {
        const pe = (ue - z) / (W - z);
        return Ls(re, ue, U + (ee - U) * pe, 1), pe;
      }
      function In(re, z, U, W, ee, ue) {
        const pe = (ue - U) / (ee - U);
        return Ls(re, z + (W - z) * pe, ue, 1), pe;
      }
      function He(re, z) {
        const U = [];
        for (let W = 0; W < re.length; W++) {
          const ee = re[W], ue = ee.type;
          let pe;
          if (ue === "Point" || ue === "MultiPoint" || ue === "LineString") pe = Ys(ee.geometry, z);
          else if (ue === "MultiLineString" || ue === "Polygon") {
            pe = [];
            for (const xe of ee.geometry) pe.push(Ys(xe, z));
          } else if (ue === "MultiPolygon") {
            pe = [];
            for (const xe of ee.geometry) {
              const le = [];
              for (const Be of xe) le.push(Ys(Be, z));
              pe.push(le);
            }
          }
          U.push(Ss(ee.id, ue, pe, ee.tags));
        }
        return U;
      }
      function Ys(re, z) {
        const U = [];
        U.size = re.size, re.start !== void 0 && (U.start = re.start, U.end = re.end);
        for (let W = 0; W < re.length; W += 3) U.push(re[W] + z, re[W + 1], re[W + 2]);
        return U;
      }
      function Yi(re, z) {
        if (re.transformed) return re;
        const U = 1 << re.z, W = re.x, ee = re.y;
        for (const ue of re.features) {
          const pe = ue.geometry, xe = ue.type;
          if (ue.geometry = [], xe === 1) for (let le = 0; le < pe.length; le += 2) ue.geometry.push(Is(pe[le], pe[le + 1], z, U, W, ee));
          else for (let le = 0; le < pe.length; le++) {
            const Be = [];
            for (let ke = 0; ke < pe[le].length; ke += 2) Be.push(Is(pe[le][ke], pe[le][ke + 1], z, U, W, ee));
            ue.geometry.push(Be);
          }
        }
        return re.transformed = !0, re;
      }
      function Is(re, z, U, W, ee, ue) {
        return [Math.round(U * (re * W - ee)), Math.round(U * (z * W - ue))];
      }
      function cr(re, z, U, W, ee) {
        const ue = z === ee.maxZoom ? 0 : ee.tolerance / ((1 << z) * ee.extent), pe = { features: [], numPoints: 0, numSimplified: 0, numFeatures: re.length, source: null, x: U, y: W, z, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const xe of re) qe(pe, xe, ue, ee);
        return pe;
      }
      function qe(re, z, U, W) {
        const ee = z.geometry, ue = z.type, pe = [];
        if (re.minX = Math.min(re.minX, z.minX), re.minY = Math.min(re.minY, z.minY), re.maxX = Math.max(re.maxX, z.maxX), re.maxY = Math.max(re.maxY, z.maxY), ue === "Point" || ue === "MultiPoint") for (let xe = 0; xe < ee.length; xe += 3) pe.push(ee[xe], ee[xe + 1]), re.numPoints++, re.numSimplified++;
        else if (ue === "LineString") It(pe, ee, re, U, !1, !1);
        else if (ue === "MultiLineString" || ue === "Polygon") for (let xe = 0; xe < ee.length; xe++) It(pe, ee[xe], re, U, ue === "Polygon", xe === 0);
        else if (ue === "MultiPolygon") for (let xe = 0; xe < ee.length; xe++) {
          const le = ee[xe];
          for (let Be = 0; Be < le.length; Be++) It(pe, le[Be], re, U, !0, Be === 0);
        }
        if (pe.length) {
          let xe = z.tags || null;
          if (ue === "LineString" && W.lineMetrics) {
            xe = {};
            for (const Be in z.tags) xe[Be] = z.tags[Be];
            xe.mapbox_clip_start = ee.start / ee.size, xe.mapbox_clip_end = ee.end / ee.size;
          }
          const le = { geometry: pe, type: ue === "Polygon" || ue === "MultiPolygon" ? 3 : ue === "LineString" || ue === "MultiLineString" ? 2 : 1, tags: xe };
          z.id !== null && (le.id = z.id), re.features.push(le);
        }
      }
      function It(re, z, U, W, ee, ue) {
        const pe = W * W;
        if (W > 0 && z.size < (ee ? pe : W)) return void (U.numPoints += z.length / 3);
        const xe = [];
        for (let le = 0; le < z.length; le += 3) (W === 0 || z[le + 2] > pe) && (U.numSimplified++, xe.push(z[le], z[le + 1])), U.numPoints++;
        ee && function(le, Be) {
          let ke = 0;
          for (let Re = 0, je = le.length, pt = je - 2; Re < je; pt = Re, Re += 2) ke += (le[Re] - le[pt]) * (le[Re + 1] + le[pt + 1]);
          if (ke > 0 === Be) for (let Re = 0, je = le.length; Re < je / 2; Re += 2) {
            const pt = le[Re], gt = le[Re + 1];
            le[Re] = le[je - 2 - Re], le[Re + 1] = le[je - 1 - Re], le[je - 2 - Re] = pt, le[je - 1 - Re] = gt;
          }
        }(xe, ue), re.push(xe);
      }
      const xt = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
      class ds {
        constructor(z, U) {
          const W = (U = this.options = function(ue, pe) {
            for (const xe in pe) ue[xe] = pe[xe];
            return ue;
          }(Object.create(xt), U)).debug;
          if (W && console.time("preprocess data"), U.maxZoom < 0 || U.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
          if (U.promoteId && U.generateId) throw new Error("promoteId and generateId cannot be used together.");
          let ee = function(ue, pe) {
            const xe = [];
            if (ue.type === "FeatureCollection") for (let le = 0; le < ue.features.length; le++) Ns(xe, ue.features[le], pe, le);
            else Ns(xe, ue.type === "Feature" ? ue : { geometry: ue }, pe);
            return xe;
          }(z, U);
          this.tiles = {}, this.tileCoords = [], W && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", U.indexMaxZoom, U.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), ee = function(ue, pe) {
            const xe = pe.buffer / pe.extent;
            let le = ue;
            const Be = oi(ue, 1, -1 - xe, xe, 0, -1, 2, pe), ke = oi(ue, 1, 1 - xe, 2 + xe, 0, -1, 2, pe);
            return (Be || ke) && (le = oi(ue, 1, -xe, 1 + xe, 0, -1, 2, pe) || [], Be && (le = He(Be, 1).concat(le)), ke && (le = le.concat(He(ke, -1)))), le;
          }(ee, U), ee.length && this.splitTile(ee, 0, 0, 0), W && (ee.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(z, U, W, ee, ue, pe, xe) {
          const le = [z, U, W, ee], Be = this.options, ke = Be.debug;
          for (; le.length; ) {
            ee = le.pop(), W = le.pop(), U = le.pop(), z = le.pop();
            const Re = 1 << U, je = Qs(U, W, ee);
            let pt = this.tiles[je];
            if (!pt && (ke > 1 && console.time("creation"), pt = this.tiles[je] = cr(z, U, W, ee, Be), this.tileCoords.push({ z: U, x: W, y: ee }), ke)) {
              ke > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", U, W, ee, pt.numFeatures, pt.numPoints, pt.numSimplified), console.timeEnd("creation"));
              const Si = `z${U}`;
              this.stats[Si] = (this.stats[Si] || 0) + 1, this.total++;
            }
            if (pt.source = z, ue == null) {
              if (U === Be.indexMaxZoom || pt.numPoints <= Be.indexMaxPoints) continue;
            } else {
              if (U === Be.maxZoom || U === ue) continue;
              if (ue != null) {
                const Si = ue - U;
                if (W !== pe >> Si || ee !== xe >> Si) continue;
              }
            }
            if (pt.source = null, z.length === 0) continue;
            ke > 1 && console.time("clipping");
            const gt = 0.5 * Be.buffer / Be.extent, Lt = 0.5 - gt, St = 0.5 + gt, Ft = 1 + gt;
            let Pt = null, Ei = null, li = null, Ct = null, Vt = oi(z, Re, W - gt, W + St, 0, pt.minX, pt.maxX, Be), Zt = oi(z, Re, W + Lt, W + Ft, 0, pt.minX, pt.maxX, Be);
            z = null, Vt && (Pt = oi(Vt, Re, ee - gt, ee + St, 1, pt.minY, pt.maxY, Be), Ei = oi(Vt, Re, ee + Lt, ee + Ft, 1, pt.minY, pt.maxY, Be), Vt = null), Zt && (li = oi(Zt, Re, ee - gt, ee + St, 1, pt.minY, pt.maxY, Be), Ct = oi(Zt, Re, ee + Lt, ee + Ft, 1, pt.minY, pt.maxY, Be), Zt = null), ke > 1 && console.timeEnd("clipping"), le.push(Pt || [], U + 1, 2 * W, 2 * ee), le.push(Ei || [], U + 1, 2 * W, 2 * ee + 1), le.push(li || [], U + 1, 2 * W + 1, 2 * ee), le.push(Ct || [], U + 1, 2 * W + 1, 2 * ee + 1);
          }
        }
        getTile(z, U, W) {
          z = +z, U = +U, W = +W;
          const ee = this.options, { extent: ue, debug: pe } = ee;
          if (z < 0 || z > 24) return null;
          const xe = 1 << z, le = Qs(z, U = U + xe & xe - 1, W);
          if (this.tiles[le]) return Yi(this.tiles[le], ue);
          pe > 1 && console.log("drilling down to z%d-%d-%d", z, U, W);
          let Be, ke = z, Re = U, je = W;
          for (; !Be && ke > 0; ) ke--, Re >>= 1, je >>= 1, Be = this.tiles[Qs(ke, Re, je)];
          return Be && Be.source ? (pe > 1 && (console.log("found parent tile z%d-%d-%d", ke, Re, je), console.time("drilling down")), this.splitTile(Be.source, ke, Re, je, z, U, W), pe > 1 && console.timeEnd("drilling down"), this.tiles[le] ? Yi(this.tiles[le], ue) : null) : null;
        }
      }
      function Qs(re, z, U) {
        return 32 * ((1 << re) * U + z) + re;
      }
      function wt(re, z) {
        return z ? re.properties[z] : re.id;
      }
      function hr(re, z) {
        if (re == null) return !0;
        if (re.type === "Feature") return wt(re, z) != null;
        if (re.type === "FeatureCollection") {
          const U = /* @__PURE__ */ new Set();
          for (const W of re.features) {
            const ee = wt(W, z);
            if (ee == null || U.has(ee)) return !1;
            U.add(ee);
          }
          return !0;
        }
        return !1;
      }
      function Tr(re, z) {
        const U = /* @__PURE__ */ new Map();
        if (re != null) if (re.type === "Feature") U.set(wt(re, z), re);
        else for (const W of re.features) U.set(wt(W, z), W);
        return U;
      }
      class Er extends M {
        constructor() {
          super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
        }
        loadVectorTile(z, U) {
          return u._(this, void 0, void 0, function* () {
            const W = z.tileID.canonical;
            if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
            const ee = this._geoJSONIndex.getTile(W.z, W.x, W.y);
            if (!ee) return null;
            const ue = new class {
              constructor(xe) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = u.X, this.length = xe.length, this._features = xe;
              }
              feature(xe) {
                return new class {
                  constructor(le) {
                    this._feature = le, this.extent = u.X, this.type = le.type, this.properties = le.tags, "id" in le && !isNaN(le.id) && (this.id = parseInt(le.id, 10));
                  }
                  loadGeometry() {
                    if (this._feature.type === 1) {
                      const le = [];
                      for (const Be of this._feature.geometry) le.push([new u.P(Be[0], Be[1])]);
                      return le;
                    }
                    {
                      const le = [];
                      for (const Be of this._feature.geometry) {
                        const ke = [];
                        for (const Re of Be) ke.push(new u.P(Re[0], Re[1]));
                        le.push(ke);
                      }
                      return le;
                    }
                  }
                  toGeoJSON(le, Be, ke) {
                    return _e.call(this, le, Be, ke);
                  }
                }(this._features[xe]);
              }
            }(ee.features);
            let pe = Hi(ue);
            return pe.byteOffset === 0 && pe.byteLength === pe.buffer.byteLength || (pe = new Uint8Array(pe)), { vectorTile: ue, rawData: pe.buffer };
          });
        }
        loadData(z) {
          return u._(this, void 0, void 0, function* () {
            var U;
            (U = this._pendingRequest) === null || U === void 0 || U.abort();
            const W = !!(z && z.request && z.request.collectResourceTiming) && new u.bv(z.request);
            this._pendingRequest = new AbortController();
            try {
              this._pendingData = this.loadAndProcessGeoJSON(z, this._pendingRequest), this._geoJSONIndex = z.cluster ? new or(function({ superclusterOptions: pe, clusterProperties: xe }) {
                if (!xe || !pe) return pe;
                const le = {}, Be = {}, ke = { accumulated: null, zoom: 0 }, Re = { properties: null }, je = Object.keys(xe);
                for (const pt of je) {
                  const [gt, Lt] = xe[pt], St = u.bC(Lt), Ft = u.bC(typeof gt == "string" ? [gt, ["accumulated"], ["get", pt]] : gt);
                  le[pt] = St.value, Be[pt] = Ft.value;
                }
                return pe.map = (pt) => {
                  Re.properties = pt;
                  const gt = {};
                  for (const Lt of je) gt[Lt] = le[Lt].evaluate(ke, Re);
                  return gt;
                }, pe.reduce = (pt, gt) => {
                  Re.properties = gt;
                  for (const Lt of je) ke.accumulated = pt[Lt], pt[Lt] = Be[Lt].evaluate(ke, Re);
                }, pe;
              }(z)).load((yield this._pendingData).features) : (ee = yield this._pendingData, new ds(ee, z.geojsonVtOptions)), this.loaded = {};
              const ue = {};
              if (W) {
                const pe = W.finish();
                pe && (ue.resourceTiming = {}, ue.resourceTiming[z.source] = JSON.parse(JSON.stringify(pe)));
              }
              return ue;
            } catch (ue) {
              if (delete this._pendingRequest, u.bB(ue)) return { abandoned: !0 };
              throw ue;
            }
            var ee;
          });
        }
        getData() {
          return u._(this, void 0, void 0, function* () {
            return this._pendingData;
          });
        }
        reloadTile(z) {
          const U = this.loaded;
          return U && U[z.uid] ? super.reloadTile(z) : this.loadTile(z);
        }
        loadAndProcessGeoJSON(z, U) {
          return u._(this, void 0, void 0, function* () {
            let W = yield this.loadGeoJSON(z, U);
            if (delete this._pendingRequest, typeof W != "object") throw new Error(`Input data given to '${z.source}' is not a valid GeoJSON object.`);
            if (Q(W, !0), z.filter) {
              const ee = u.bC(z.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
              if (ee.result === "error") throw new Error(ee.value.map((pe) => `${pe.key}: ${pe.message}`).join(", "));
              W = { type: "FeatureCollection", features: W.features.filter((pe) => ee.value.evaluate({ zoom: 0 }, pe)) };
            }
            return W;
          });
        }
        loadGeoJSON(z, U) {
          return u._(this, void 0, void 0, function* () {
            const { promoteId: W } = z;
            if (z.request) {
              const ee = yield u.h(z.request, U);
              return this._dataUpdateable = hr(ee.data, W) ? Tr(ee.data, W) : void 0, ee.data;
            }
            if (typeof z.data == "string") try {
              const ee = JSON.parse(z.data);
              return this._dataUpdateable = hr(ee, W) ? Tr(ee, W) : void 0, ee;
            } catch {
              throw new Error(`Input data given to '${z.source}' is not a valid GeoJSON object.`);
            }
            if (!z.dataDiff) throw new Error(`Input data given to '${z.source}' is not a valid GeoJSON object.`);
            if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${z.source}`);
            return function(ee, ue, pe) {
              var xe, le, Be, ke;
              if (ue.removeAll && ee.clear(), ue.remove) for (const Re of ue.remove) ee.delete(Re);
              if (ue.add) for (const Re of ue.add) {
                const je = wt(Re, pe);
                je != null && ee.set(je, Re);
              }
              if (ue.update) for (const Re of ue.update) {
                let je = ee.get(Re.id);
                if (je == null) continue;
                const pt = !Re.removeAllProperties && (((xe = Re.removeProperties) === null || xe === void 0 ? void 0 : xe.length) > 0 || ((le = Re.addOrUpdateProperties) === null || le === void 0 ? void 0 : le.length) > 0);
                if ((Re.newGeometry || Re.removeAllProperties || pt) && (je = Object.assign({}, je), ee.set(Re.id, je), pt && (je.properties = Object.assign({}, je.properties))), Re.newGeometry && (je.geometry = Re.newGeometry), Re.removeAllProperties) je.properties = {};
                else if (((Be = Re.removeProperties) === null || Be === void 0 ? void 0 : Be.length) > 0) for (const gt of Re.removeProperties) Object.prototype.hasOwnProperty.call(je.properties, gt) && delete je.properties[gt];
                if (((ke = Re.addOrUpdateProperties) === null || ke === void 0 ? void 0 : ke.length) > 0) for (const { key: gt, value: Lt } of Re.addOrUpdateProperties) je.properties[gt] = Lt;
              }
            }(this._dataUpdateable, z.dataDiff, W), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
          });
        }
        removeSource(z) {
          return u._(this, void 0, void 0, function* () {
            this._pendingRequest && this._pendingRequest.abort();
          });
        }
        getClusterExpansionZoom(z) {
          return this._geoJSONIndex.getClusterExpansionZoom(z.clusterId);
        }
        getClusterChildren(z) {
          return this._geoJSONIndex.getChildren(z.clusterId);
        }
        getClusterLeaves(z) {
          return this._geoJSONIndex.getLeaves(z.clusterId, z.limit, z.offset);
        }
      }
      class er {
        constructor(z) {
          this.self = z, this.actor = new u.F(z), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (U, W) => {
            if (this.externalWorkerSourceTypes[U]) throw new Error(`Worker source with name "${U}" already registered.`);
            this.externalWorkerSourceTypes[U] = W;
          }, this.self.addProtocol = u.bi, this.self.removeProtocol = u.bj, this.self.registerRTLTextPlugin = (U) => {
            if (u.bD.isParsed()) throw new Error("RTL text plugin already registered.");
            u.bD.setMethods(U);
          }, this.actor.registerMessageHandler("LDT", (U, W) => this._getDEMWorkerSource(U, W.source).loadTile(W)), this.actor.registerMessageHandler("RDT", (U, W) => u._(this, void 0, void 0, function* () {
            this._getDEMWorkerSource(U, W.source).removeTile(W);
          })), this.actor.registerMessageHandler("GCEZ", (U, W) => u._(this, void 0, void 0, function* () {
            return this._getWorkerSource(U, W.type, W.source).getClusterExpansionZoom(W);
          })), this.actor.registerMessageHandler("GCC", (U, W) => u._(this, void 0, void 0, function* () {
            return this._getWorkerSource(U, W.type, W.source).getClusterChildren(W);
          })), this.actor.registerMessageHandler("GCL", (U, W) => u._(this, void 0, void 0, function* () {
            return this._getWorkerSource(U, W.type, W.source).getClusterLeaves(W);
          })), this.actor.registerMessageHandler("LD", (U, W) => this._getWorkerSource(U, W.type, W.source).loadData(W)), this.actor.registerMessageHandler("GD", (U, W) => this._getWorkerSource(U, W.type, W.source).getData()), this.actor.registerMessageHandler("LT", (U, W) => this._getWorkerSource(U, W.type, W.source).loadTile(W)), this.actor.registerMessageHandler("RT", (U, W) => this._getWorkerSource(U, W.type, W.source).reloadTile(W)), this.actor.registerMessageHandler("AT", (U, W) => this._getWorkerSource(U, W.type, W.source).abortTile(W)), this.actor.registerMessageHandler("RMT", (U, W) => this._getWorkerSource(U, W.type, W.source).removeTile(W)), this.actor.registerMessageHandler("RS", (U, W) => u._(this, void 0, void 0, function* () {
            if (!this.workerSources[U] || !this.workerSources[U][W.type] || !this.workerSources[U][W.type][W.source]) return;
            const ee = this.workerSources[U][W.type][W.source];
            delete this.workerSources[U][W.type][W.source], ee.removeSource !== void 0 && ee.removeSource(W);
          })), this.actor.registerMessageHandler("RM", (U) => u._(this, void 0, void 0, function* () {
            delete this.layerIndexes[U], delete this.availableImages[U], delete this.workerSources[U], delete this.demWorkerSources[U];
          })), this.actor.registerMessageHandler("SR", (U, W) => u._(this, void 0, void 0, function* () {
            this.referrer = W;
          })), this.actor.registerMessageHandler("SRPS", (U, W) => this._syncRTLPluginState(U, W)), this.actor.registerMessageHandler("IS", (U, W) => u._(this, void 0, void 0, function* () {
            this.self.importScripts(W);
          })), this.actor.registerMessageHandler("SI", (U, W) => this._setImages(U, W)), this.actor.registerMessageHandler("UL", (U, W) => u._(this, void 0, void 0, function* () {
            this._getLayerIndex(U).update(W.layers, W.removedIds);
          })), this.actor.registerMessageHandler("SL", (U, W) => u._(this, void 0, void 0, function* () {
            this._getLayerIndex(U).replace(W);
          }));
        }
        _setImages(z, U) {
          return u._(this, void 0, void 0, function* () {
            this.availableImages[z] = U;
            for (const W in this.workerSources[z]) {
              const ee = this.workerSources[z][W];
              for (const ue in ee) ee[ue].availableImages = U;
            }
          });
        }
        _syncRTLPluginState(z, U) {
          return u._(this, void 0, void 0, function* () {
            if (u.bD.isParsed()) return u.bD.getState();
            if (U.pluginStatus !== "loading") return u.bD.setState(U), U;
            const W = U.pluginURL;
            if (this.self.importScripts(W), u.bD.isParsed()) {
              const ee = { pluginStatus: "loaded", pluginURL: W };
              return u.bD.setState(ee), ee;
            }
            throw u.bD.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${W}`);
          });
        }
        _getAvailableImages(z) {
          let U = this.availableImages[z];
          return U || (U = []), U;
        }
        _getLayerIndex(z) {
          let U = this.layerIndexes[z];
          return U || (U = this.layerIndexes[z] = new c()), U;
        }
        _getWorkerSource(z, U, W) {
          if (this.workerSources[z] || (this.workerSources[z] = {}), this.workerSources[z][U] || (this.workerSources[z][U] = {}), !this.workerSources[z][U][W]) {
            const ee = { sendAsync: (ue, pe) => (ue.targetMapId = z, this.actor.sendAsync(ue, pe)) };
            switch (U) {
              case "vector":
                this.workerSources[z][U][W] = new M(ee, this._getLayerIndex(z), this._getAvailableImages(z));
                break;
              case "geojson":
                this.workerSources[z][U][W] = new Er(ee, this._getLayerIndex(z), this._getAvailableImages(z));
                break;
              default:
                this.workerSources[z][U][W] = new this.externalWorkerSourceTypes[U](ee, this._getLayerIndex(z), this._getAvailableImages(z));
            }
          }
          return this.workerSources[z][U][W];
        }
        _getDEMWorkerSource(z, U) {
          return this.demWorkerSources[z] || (this.demWorkerSources[z] = {}), this.demWorkerSources[z][U] || (this.demWorkerSources[z][U] = new P()), this.demWorkerSources[z][U];
        }
      }
      return u.i(self) && (self.worker = new er(self)), er;
    }), o("index", ["exports", "./shared"], function(u, c) {
      var x = "4.7.1";
      let w, C;
      const M = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frameAsync: (y) => new Promise((r, d) => {
        const p = requestAnimationFrame(r);
        y.signal.addEventListener("abort", () => {
          cancelAnimationFrame(p), d(c.c());
        });
      }), getImageData(y, r = 0) {
        return this.getImageCanvasContext(y).getImageData(-r, -r, y.width + 2 * r, y.height + 2 * r);
      }, getImageCanvasContext(y) {
        const r = window.document.createElement("canvas"), d = r.getContext("2d", { willReadFrequently: !0 });
        if (!d) throw new Error("failed to create canvas 2d context");
        return r.width = y.width, r.height = y.height, d.drawImage(y, 0, 0, y.width, y.height), d;
      }, resolveURL: (y) => (w || (w = document.createElement("a")), w.href = y, w.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && (C == null && (C = matchMedia("(prefers-reduced-motion: reduce)")), C.matches);
      } };
      class P {
        static testProp(r) {
          if (!P.docStyle) return r[0];
          for (let d = 0; d < r.length; d++) if (r[d] in P.docStyle) return r[d];
          return r[0];
        }
        static create(r, d, p) {
          const _ = window.document.createElement(r);
          return d !== void 0 && (_.className = d), p && p.appendChild(_), _;
        }
        static createNS(r, d) {
          return window.document.createElementNS(r, d);
        }
        static disableDrag() {
          P.docStyle && P.selectProp && (P.userSelect = P.docStyle[P.selectProp], P.docStyle[P.selectProp] = "none");
        }
        static enableDrag() {
          P.docStyle && P.selectProp && (P.docStyle[P.selectProp] = P.userSelect);
        }
        static setTransform(r, d) {
          r.style[P.transformProp] = d;
        }
        static addEventListener(r, d, p, _ = {}) {
          r.addEventListener(d, p, "passive" in _ ? _ : _.capture);
        }
        static removeEventListener(r, d, p, _ = {}) {
          r.removeEventListener(d, p, "passive" in _ ? _ : _.capture);
        }
        static suppressClickInternal(r) {
          r.preventDefault(), r.stopPropagation(), window.removeEventListener("click", P.suppressClickInternal, !0);
        }
        static suppressClick() {
          window.addEventListener("click", P.suppressClickInternal, !0), window.setTimeout(() => {
            window.removeEventListener("click", P.suppressClickInternal, !0);
          }, 0);
        }
        static getScale(r) {
          const d = r.getBoundingClientRect();
          return { x: d.width / r.offsetWidth || 1, y: d.height / r.offsetHeight || 1, boundingClientRect: d };
        }
        static getPoint(r, d, p) {
          const _ = d.boundingClientRect;
          return new c.P((p.clientX - _.left) / d.x - r.clientLeft, (p.clientY - _.top) / d.y - r.clientTop);
        }
        static mousePos(r, d) {
          const p = P.getScale(r);
          return P.getPoint(r, p, d);
        }
        static touchPos(r, d) {
          const p = [], _ = P.getScale(r);
          for (let g = 0; g < d.length; g++) p.push(P.getPoint(r, _, d[g]));
          return p;
        }
        static mouseButton(r) {
          return r.button;
        }
        static remove(r) {
          r.parentNode && r.parentNode.removeChild(r);
        }
      }
      P.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, P.selectProp = P.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), P.transformProp = P.testProp(["transform", "WebkitTransform"]);
      const j = { supported: !1, testSupport: function(y) {
        !_e && Q && (me ? we(y) : Y = y);
      } };
      let Y, Q, _e = !1, me = !1;
      function we(y) {
        const r = y.createTexture();
        y.bindTexture(y.TEXTURE_2D, r);
        try {
          if (y.texImage2D(y.TEXTURE_2D, 0, y.RGBA, y.RGBA, y.UNSIGNED_BYTE, Q), y.isContextLost()) return;
          j.supported = !0;
        } catch {
        }
        y.deleteTexture(r), _e = !0;
      }
      var Ee;
      typeof document < "u" && (Q = document.createElement("img"), Q.onload = () => {
        Y && we(Y), Y = null, me = !0;
      }, Q.onerror = () => {
        _e = !0, Y = null;
      }, Q.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(y) {
        let r, d, p, _;
        y.resetRequestQueue = () => {
          r = [], d = 0, p = 0, _ = {};
        }, y.addThrottleControl = (I) => {
          const D = p++;
          return _[D] = I, D;
        }, y.removeThrottleControl = (I) => {
          delete _[I], T();
        }, y.getImage = (I, D, k = !0) => new Promise((N, H) => {
          j.supported && (I.headers || (I.headers = {}), I.headers.accept = "image/webp,*/*"), c.e(I, { type: "image" }), r.push({ abortController: D, requestParameters: I, supportImageRefresh: k, state: "queued", onError: (q) => {
            H(q);
          }, onSuccess: (q) => {
            N(q);
          } }), T();
        });
        const g = (I) => c._(this, void 0, void 0, function* () {
          I.state = "running";
          const { requestParameters: D, supportImageRefresh: k, onError: N, onSuccess: H, abortController: q } = I, K = k === !1 && !c.i(self) && !c.g(D.url) && (!D.headers || Object.keys(D.headers).reduce((ae, he) => ae && he === "accept", !0));
          d++;
          const se = K ? S(D, q) : c.m(D, q);
          try {
            const ae = yield se;
            delete I.abortController, I.state = "completed", ae.data instanceof HTMLImageElement || c.b(ae.data) ? H(ae) : ae.data && H({ data: yield (oe = ae.data, typeof createImageBitmap == "function" ? c.d(oe) : c.f(oe)), cacheControl: ae.cacheControl, expires: ae.expires });
          } catch (ae) {
            delete I.abortController, N(ae);
          } finally {
            d--, T();
          }
          var oe;
        }), T = () => {
          const I = (() => {
            for (const D of Object.keys(_)) if (_[D]()) return !0;
            return !1;
          })() ? c.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : c.a.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let D = d; D < I && r.length > 0; D++) {
            const k = r.shift();
            k.abortController.signal.aborted ? D-- : g(k);
          }
        }, S = (I, D) => new Promise((k, N) => {
          const H = new Image(), q = I.url, K = I.credentials;
          K && K === "include" ? H.crossOrigin = "use-credentials" : (K && K === "same-origin" || !c.s(q)) && (H.crossOrigin = "anonymous"), D.signal.addEventListener("abort", () => {
            H.src = "", N(c.c());
          }), H.fetchPriority = "high", H.onload = () => {
            H.onerror = H.onload = null, k({ data: H });
          }, H.onerror = () => {
            H.onerror = H.onload = null, D.signal.aborted || N(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          }, H.src = q;
        });
      }(Ee || (Ee = {})), Ee.resetRequestQueue();
      class Oe {
        constructor(r) {
          this._transformRequestFn = r;
        }
        transformRequest(r, d) {
          return this._transformRequestFn && this._transformRequestFn(r, d) || { url: r };
        }
        setTransformRequest(r) {
          this._transformRequestFn = r;
        }
      }
      function Ne(y) {
        var r = new c.A(3);
        return r[0] = y[0], r[1] = y[1], r[2] = y[2], r;
      }
      var ze, nt = function(y, r, d) {
        return y[0] = r[0] - d[0], y[1] = r[1] - d[1], y[2] = r[2] - d[2], y;
      };
      ze = new c.A(3), c.A != Float32Array && (ze[0] = 0, ze[1] = 0, ze[2] = 0);
      var mt = function(y) {
        var r = y[0], d = y[1];
        return r * r + d * d;
      };
      function We(y) {
        const r = [];
        if (typeof y == "string") r.push({ id: "default", url: y });
        else if (y && y.length > 0) {
          const d = [];
          for (const { id: p, url: _ } of y) {
            const g = `${p}${_}`;
            d.indexOf(g) === -1 && (d.push(g), r.push({ id: p, url: _ }));
          }
        }
        return r;
      }
      function at(y, r, d) {
        const p = y.split("?");
        return p[0] += `${r}${d}`, p.join("?");
      }
      (function() {
        var y = new c.A(2);
        c.A != Float32Array && (y[0] = 0, y[1] = 0);
      })();
      class it {
        constructor(r, d, p, _) {
          this.context = r, this.format = p, this.texture = r.gl.createTexture(), this.update(d, _);
        }
        update(r, d, p) {
          const { width: _, height: g } = r, T = !(this.size && this.size[0] === _ && this.size[1] === g || p), { context: S } = this, { gl: I } = S;
          if (this.useMipmap = !!(d && d.useMipmap), I.bindTexture(I.TEXTURE_2D, this.texture), S.pixelStoreUnpackFlipY.set(!1), S.pixelStoreUnpack.set(1), S.pixelStoreUnpackPremultiplyAlpha.set(this.format === I.RGBA && (!d || d.premultiply !== !1)), T) this.size = [_, g], r instanceof HTMLImageElement || r instanceof HTMLCanvasElement || r instanceof HTMLVideoElement || r instanceof ImageData || c.b(r) ? I.texImage2D(I.TEXTURE_2D, 0, this.format, this.format, I.UNSIGNED_BYTE, r) : I.texImage2D(I.TEXTURE_2D, 0, this.format, _, g, 0, this.format, I.UNSIGNED_BYTE, r.data);
          else {
            const { x: D, y: k } = p || { x: 0, y: 0 };
            r instanceof HTMLImageElement || r instanceof HTMLCanvasElement || r instanceof HTMLVideoElement || r instanceof ImageData || c.b(r) ? I.texSubImage2D(I.TEXTURE_2D, 0, D, k, I.RGBA, I.UNSIGNED_BYTE, r) : I.texSubImage2D(I.TEXTURE_2D, 0, D, k, _, g, I.RGBA, I.UNSIGNED_BYTE, r.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && I.generateMipmap(I.TEXTURE_2D);
        }
        bind(r, d, p) {
          const { context: _ } = this, { gl: g } = _;
          g.bindTexture(g.TEXTURE_2D, this.texture), p !== g.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (p = g.LINEAR), r !== this.filter && (g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, r), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, p || r), this.filter = r), d !== this.wrap && (g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, d), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, d), this.wrap = d);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: r } = this.context;
          r.deleteTexture(this.texture), this.texture = null;
        }
      }
      function Ut(y) {
        const { userImage: r } = y;
        return !!(r && r.render && r.render()) && (y.data.replace(new Uint8Array(r.data.buffer)), !0);
      }
      class Rt extends c.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new c.R({ width: 1, height: 1 }), this.dirty = !0;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(r) {
          if (this.loaded !== r && (this.loaded = r, r)) {
            for (const { ids: d, promiseResolve: p } of this.requestors) p(this._getImagesForIds(d));
            this.requestors = [];
          }
        }
        getImage(r) {
          const d = this.images[r];
          if (d && !d.data && d.spriteData) {
            const p = d.spriteData;
            d.data = new c.R({ width: p.width, height: p.height }, p.context.getImageData(p.x, p.y, p.width, p.height).data), d.spriteData = null;
          }
          return d;
        }
        addImage(r, d) {
          if (this.images[r]) throw new Error(`Image id ${r} already exist, use updateImage instead`);
          this._validate(r, d) && (this.images[r] = d);
        }
        _validate(r, d) {
          let p = !0;
          const _ = d.data || d.spriteData;
          return this._validateStretch(d.stretchX, _ && _.width) || (this.fire(new c.j(new Error(`Image "${r}" has invalid "stretchX" value`))), p = !1), this._validateStretch(d.stretchY, _ && _.height) || (this.fire(new c.j(new Error(`Image "${r}" has invalid "stretchY" value`))), p = !1), this._validateContent(d.content, d) || (this.fire(new c.j(new Error(`Image "${r}" has invalid "content" value`))), p = !1), p;
        }
        _validateStretch(r, d) {
          if (!r) return !0;
          let p = 0;
          for (const _ of r) {
            if (_[0] < p || _[1] < _[0] || d < _[1]) return !1;
            p = _[1];
          }
          return !0;
        }
        _validateContent(r, d) {
          if (!r) return !0;
          if (r.length !== 4) return !1;
          const p = d.spriteData, _ = p && p.width || d.data.width, g = p && p.height || d.data.height;
          return !(r[0] < 0 || _ < r[0] || r[1] < 0 || g < r[1] || r[2] < 0 || _ < r[2] || r[3] < 0 || g < r[3] || r[2] < r[0] || r[3] < r[1]);
        }
        updateImage(r, d, p = !0) {
          const _ = this.getImage(r);
          if (p && (_.data.width !== d.data.width || _.data.height !== d.data.height)) throw new Error(`size mismatch between old image (${_.data.width}x${_.data.height}) and new image (${d.data.width}x${d.data.height}).`);
          d.version = _.version + 1, this.images[r] = d, this.updatedImages[r] = !0;
        }
        removeImage(r) {
          const d = this.images[r];
          delete this.images[r], delete this.patterns[r], d.userImage && d.userImage.onRemove && d.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(r) {
          return new Promise((d, p) => {
            let _ = !0;
            if (!this.isLoaded()) for (const g of r) this.images[g] || (_ = !1);
            this.isLoaded() || _ ? d(this._getImagesForIds(r)) : this.requestors.push({ ids: r, promiseResolve: d });
          });
        }
        _getImagesForIds(r) {
          const d = {};
          for (const p of r) {
            let _ = this.getImage(p);
            _ || (this.fire(new c.k("styleimagemissing", { id: p })), _ = this.getImage(p)), _ ? d[p] = { data: _.data.clone(), pixelRatio: _.pixelRatio, sdf: _.sdf, version: _.version, stretchX: _.stretchX, stretchY: _.stretchY, content: _.content, textFitWidth: _.textFitWidth, textFitHeight: _.textFitHeight, hasRenderCallback: !!(_.userImage && _.userImage.render) } : c.w(`Image "${p}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          return d;
        }
        getPixelSize() {
          const { width: r, height: d } = this.atlasImage;
          return { width: r, height: d };
        }
        getPattern(r) {
          const d = this.patterns[r], p = this.getImage(r);
          if (!p) return null;
          if (d && d.position.version === p.version) return d.position;
          if (d) d.position.version = p.version;
          else {
            const _ = { w: p.data.width + 2, h: p.data.height + 2, x: 0, y: 0 }, g = new c.I(_, p);
            this.patterns[r] = { bin: _, position: g };
          }
          return this._updatePatternAtlas(), this.patterns[r].position;
        }
        bind(r) {
          const d = r.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new it(r, this.atlasImage, d.RGBA), this.atlasTexture.bind(d.LINEAR, d.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const r = [];
          for (const g in this.patterns) r.push(this.patterns[g].bin);
          const { w: d, h: p } = c.p(r), _ = this.atlasImage;
          _.resize({ width: d || 1, height: p || 1 });
          for (const g in this.patterns) {
            const { bin: T } = this.patterns[g], S = T.x + 1, I = T.y + 1, D = this.getImage(g).data, k = D.width, N = D.height;
            c.R.copy(D, _, { x: 0, y: 0 }, { x: S, y: I }, { width: k, height: N }), c.R.copy(D, _, { x: 0, y: N - 1 }, { x: S, y: I - 1 }, { width: k, height: 1 }), c.R.copy(D, _, { x: 0, y: 0 }, { x: S, y: I + N }, { width: k, height: 1 }), c.R.copy(D, _, { x: k - 1, y: 0 }, { x: S - 1, y: I }, { width: 1, height: N }), c.R.copy(D, _, { x: 0, y: 0 }, { x: S + k, y: I }, { width: 1, height: N });
          }
          this.dirty = !0;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(r) {
          for (const d of r) {
            if (this.callbackDispatchedThisFrame[d]) continue;
            this.callbackDispatchedThisFrame[d] = !0;
            const p = this.getImage(d);
            p || c.w(`Image with ID: "${d}" was not found`), Ut(p) && this.updateImage(d, p);
          }
        }
      }
      const yt = 1e20;
      function di(y, r, d, p, _, g, T, S, I) {
        for (let D = r; D < r + p; D++) Fs(y, d * g + D, g, _, T, S, I);
        for (let D = d; D < d + _; D++) Fs(y, D * g + r, 1, p, T, S, I);
      }
      function Fs(y, r, d, p, _, g, T) {
        g[0] = 0, T[0] = -yt, T[1] = yt, _[0] = y[r];
        for (let S = 1, I = 0, D = 0; S < p; S++) {
          _[S] = y[r + S * d];
          const k = S * S;
          do {
            const N = g[I];
            D = (_[S] - _[N] + k - N * N) / (S - N) / 2;
          } while (D <= T[I] && --I > -1);
          I++, g[I] = S, T[I] = D, T[I + 1] = yt;
        }
        for (let S = 0, I = 0; S < p; S++) {
          for (; T[I + 1] < S; ) I++;
          const D = g[I], k = S - D;
          y[r + S * d] = _[D] + k * k;
        }
      }
      class Hi {
        constructor(r, d) {
          this.requestManager = r, this.localIdeographFontFamily = d, this.entries = {};
        }
        setURL(r) {
          this.url = r;
        }
        getGlyphs(r) {
          return c._(this, void 0, void 0, function* () {
            const d = [];
            for (const g in r) for (const T of r[g]) d.push(this._getAndCacheGlyphsPromise(g, T));
            const p = yield Promise.all(d), _ = {};
            for (const { stack: g, id: T, glyph: S } of p) _[g] || (_[g] = {}), _[g][T] = S && { id: S.id, bitmap: S.bitmap.clone(), metrics: S.metrics };
            return _;
          });
        }
        _getAndCacheGlyphsPromise(r, d) {
          return c._(this, void 0, void 0, function* () {
            let p = this.entries[r];
            p || (p = this.entries[r] = { glyphs: {}, requests: {}, ranges: {} });
            let _ = p.glyphs[d];
            if (_ !== void 0) return { stack: r, id: d, glyph: _ };
            if (_ = this._tinySDF(p, r, d), _) return p.glyphs[d] = _, { stack: r, id: d, glyph: _ };
            const g = Math.floor(d / 256);
            if (256 * g > 65535) throw new Error("glyphs > 65535 not supported");
            if (p.ranges[g]) return { stack: r, id: d, glyph: _ };
            if (!this.url) throw new Error("glyphsUrl is not set");
            if (!p.requests[g]) {
              const S = Hi.loadGlyphRange(r, g, this.url, this.requestManager);
              p.requests[g] = S;
            }
            const T = yield p.requests[g];
            for (const S in T) this._doesCharSupportLocalGlyph(+S) || (p.glyphs[+S] = T[+S]);
            return p.ranges[g] = !0, { stack: r, id: d, glyph: T[d] || null };
          });
        }
        _doesCharSupportLocalGlyph(r) {
          return !!this.localIdeographFontFamily && new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(r));
        }
        _tinySDF(r, d, p) {
          const _ = this.localIdeographFontFamily;
          if (!_ || !this._doesCharSupportLocalGlyph(p)) return;
          let g = r.tinySDF;
          if (!g) {
            let S = "400";
            /bold/i.test(d) ? S = "900" : /medium/i.test(d) ? S = "500" : /light/i.test(d) && (S = "200"), g = r.tinySDF = new Hi.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: _, fontWeight: S });
          }
          const T = g.draw(String.fromCharCode(p));
          return { id: p, bitmap: new c.o({ width: T.width || 60, height: T.height || 60 }, T.data), metrics: { width: T.glyphWidth / 2 || 24, height: T.glyphHeight / 2 || 24, left: T.glyphLeft / 2 + 0.5 || 0, top: T.glyphTop / 2 - 27.5 || -8, advance: T.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
        }
      }
      Hi.loadGlyphRange = function(y, r, d, p) {
        return c._(this, void 0, void 0, function* () {
          const _ = 256 * r, g = _ + 255, T = p.transformRequest(d.replace("{fontstack}", y).replace("{range}", `${_}-${g}`), "Glyphs"), S = yield c.l(T, new AbortController());
          if (!S || !S.data) throw new Error(`Could not load glyph range. range: ${r}, ${_}-${g}`);
          const I = {};
          for (const D of c.n(S.data)) I[D.id] = D;
          return I;
        });
      }, Hi.TinySDF = class {
        constructor({ fontSize: y = 24, buffer: r = 3, radius: d = 8, cutoff: p = 0.25, fontFamily: _ = "sans-serif", fontWeight: g = "normal", fontStyle: T = "normal" } = {}) {
          this.buffer = r, this.cutoff = p, this.radius = d;
          const S = this.size = y + 4 * r, I = this._createCanvas(S), D = this.ctx = I.getContext("2d", { willReadFrequently: !0 });
          D.font = `${T} ${g} ${y}px ${_}`, D.textBaseline = "alphabetic", D.textAlign = "left", D.fillStyle = "black", this.gridOuter = new Float64Array(S * S), this.gridInner = new Float64Array(S * S), this.f = new Float64Array(S), this.z = new Float64Array(S + 1), this.v = new Uint16Array(S);
        }
        _createCanvas(y) {
          const r = document.createElement("canvas");
          return r.width = r.height = y, r;
        }
        draw(y) {
          const { width: r, actualBoundingBoxAscent: d, actualBoundingBoxDescent: p, actualBoundingBoxLeft: _, actualBoundingBoxRight: g } = this.ctx.measureText(y), T = Math.ceil(d), S = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(g - _))), I = Math.min(this.size - this.buffer, T + Math.ceil(p)), D = S + 2 * this.buffer, k = I + 2 * this.buffer, N = Math.max(D * k, 0), H = new Uint8ClampedArray(N), q = { data: H, width: D, height: k, glyphWidth: S, glyphHeight: I, glyphTop: T, glyphLeft: 0, glyphAdvance: r };
          if (S === 0 || I === 0) return q;
          const { ctx: K, buffer: se, gridInner: oe, gridOuter: ae } = this;
          K.clearRect(se, se, S, I), K.fillText(y, se, se + T);
          const he = K.getImageData(se, se, S, I);
          ae.fill(yt, 0, N), oe.fill(0, 0, N);
          for (let te = 0; te < I; te++) for (let fe = 0; fe < S; fe++) {
            const ge = he.data[4 * (te * S + fe) + 3] / 255;
            if (ge === 0) continue;
            const Te = (te + se) * D + fe + se;
            if (ge === 1) ae[Te] = 0, oe[Te] = yt;
            else {
              const Fe = 0.5 - ge;
              ae[Te] = Fe > 0 ? Fe * Fe : 0, oe[Te] = Fe < 0 ? Fe * Fe : 0;
            }
          }
          di(ae, 0, 0, D, k, D, this.f, this.v, this.z), di(oe, se, se, S, I, D, this.f, this.v, this.z);
          for (let te = 0; te < N; te++) {
            const fe = Math.sqrt(ae[te]) - Math.sqrt(oe[te]);
            H[te] = Math.round(255 - 255 * (fe / this.radius + this.cutoff));
          }
          return q;
        }
      };
      class An {
        constructor() {
          this.specification = c.v.light.position;
        }
        possiblyEvaluate(r, d) {
          return c.x(r.expression.evaluate(d));
        }
        interpolate(r, d, p) {
          return { x: c.y.number(r.x, d.x, p), y: c.y.number(r.y, d.y, p), z: c.y.number(r.z, d.z, p) };
        }
      }
      let Js;
      class ji extends c.E {
        constructor(r) {
          super(), Js = Js || new c.q({ anchor: new c.D(c.v.light.anchor), position: new An(), color: new c.D(c.v.light.color), intensity: new c.D(c.v.light.intensity) }), this._transitionable = new c.T(Js), this.setLight(r), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(r, d = {}) {
          if (!this._validate(c.r, r, d)) for (const p in r) {
            const _ = r[p];
            p.endsWith("-transition") ? this._transitionable.setTransition(p.slice(0, -11), _) : this._transitionable.setValue(p, _);
          }
        }
        updateTransitions(r) {
          this._transitioning = this._transitionable.transitioned(r, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(r) {
          this.properties = this._transitioning.possiblyEvaluate(r);
        }
        _validate(r, d, p) {
          return (!p || p.validate !== !1) && c.t(this, r.call(c.u, { value: d, style: { glyphs: !0, sprite: !0 }, styleSpec: c.v }));
        }
      }
      const Li = new c.q({ "sky-color": new c.D(c.v.sky["sky-color"]), "horizon-color": new c.D(c.v.sky["horizon-color"]), "fog-color": new c.D(c.v.sky["fog-color"]), "fog-ground-blend": new c.D(c.v.sky["fog-ground-blend"]), "horizon-fog-blend": new c.D(c.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new c.D(c.v.sky["sky-horizon-blend"]), "atmosphere-blend": new c.D(c.v.sky["atmosphere-blend"]) });
      class Pi extends c.E {
        constructor(r) {
          super(), this._transitionable = new c.T(Li), this.setSky(r), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new c.z(0));
        }
        setSky(r, d = {}) {
          if (!this._validate(c.B, r, d)) {
            r || (r = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
            for (const p in r) {
              const _ = r[p];
              p.endsWith("-transition") ? this._transitionable.setTransition(p.slice(0, -11), _) : this._transitionable.setValue(p, _);
            }
          }
        }
        getSky() {
          return this._transitionable.serialize();
        }
        updateTransitions(r) {
          this._transitioning = this._transitionable.transitioned(r, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(r) {
          this.properties = this._transitioning.possiblyEvaluate(r);
        }
        _validate(r, d, p = {}) {
          return (p == null ? void 0 : p.validate) !== !1 && c.t(this, r.call(c.u, c.e({ value: d, style: { glyphs: !0, sprite: !0 }, styleSpec: c.v })));
        }
        calculateFogBlendOpacity(r) {
          return r < 60 ? 0 : r < 70 ? (r - 60) / 10 : 1;
        }
      }
      class Tn {
        constructor(r, d) {
          this.width = r, this.height = d, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(r, d) {
          const p = r.join(",") + String(d);
          return this.dashEntry[p] || (this.dashEntry[p] = this.addDash(r, d)), this.dashEntry[p];
        }
        getDashRanges(r, d, p) {
          const _ = [];
          let g = r.length % 2 == 1 ? -r[r.length - 1] * p : 0, T = r[0] * p, S = !0;
          _.push({ left: g, right: T, isDash: S, zeroLength: r[0] === 0 });
          let I = r[0];
          for (let D = 1; D < r.length; D++) {
            S = !S;
            const k = r[D];
            g = I * p, I += k, T = I * p, _.push({ left: g, right: T, isDash: S, zeroLength: k === 0 });
          }
          return _;
        }
        addRoundDash(r, d, p) {
          const _ = d / 2;
          for (let g = -p; g <= p; g++) {
            const T = this.width * (this.nextRow + p + g);
            let S = 0, I = r[S];
            for (let D = 0; D < this.width; D++) {
              D / I.right > 1 && (I = r[++S]);
              const k = Math.abs(D - I.left), N = Math.abs(D - I.right), H = Math.min(k, N);
              let q;
              const K = g / p * (_ + 1);
              if (I.isDash) {
                const se = _ - Math.abs(K);
                q = Math.sqrt(H * H + se * se);
              } else q = _ - Math.sqrt(H * H + K * K);
              this.data[T + D] = Math.max(0, Math.min(255, q + 128));
            }
          }
        }
        addRegularDash(r) {
          for (let S = r.length - 1; S >= 0; --S) {
            const I = r[S], D = r[S + 1];
            I.zeroLength ? r.splice(S, 1) : D && D.isDash === I.isDash && (D.left = I.left, r.splice(S, 1));
          }
          const d = r[0], p = r[r.length - 1];
          d.isDash === p.isDash && (d.left = p.left - this.width, p.right = d.right + this.width);
          const _ = this.width * this.nextRow;
          let g = 0, T = r[g];
          for (let S = 0; S < this.width; S++) {
            S / T.right > 1 && (T = r[++g]);
            const I = Math.abs(S - T.left), D = Math.abs(S - T.right), k = Math.min(I, D);
            this.data[_ + S] = Math.max(0, Math.min(255, (T.isDash ? k : -k) + 128));
          }
        }
        addDash(r, d) {
          const p = d ? 7 : 0, _ = 2 * p + 1;
          if (this.nextRow + _ > this.height) return c.w("LineAtlas out of space"), null;
          let g = 0;
          for (let S = 0; S < r.length; S++) g += r[S];
          if (g !== 0) {
            const S = this.width / g, I = this.getDashRanges(r, this.width, S);
            d ? this.addRoundDash(I, S, p) : this.addRegularDash(I);
          }
          const T = { y: (this.nextRow + p + 0.5) / this.height, height: 2 * p / this.height, width: g };
          return this.nextRow += _, this.dirty = !0, T;
        }
        bind(r) {
          const d = r.gl;
          this.texture ? (d.bindTexture(d.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, d.texSubImage2D(d.TEXTURE_2D, 0, 0, 0, this.width, this.height, d.ALPHA, d.UNSIGNED_BYTE, this.data))) : (this.texture = d.createTexture(), d.bindTexture(d.TEXTURE_2D, this.texture), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.REPEAT), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.REPEAT), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR), d.texImage2D(d.TEXTURE_2D, 0, d.ALPHA, this.width, this.height, 0, d.ALPHA, d.UNSIGNED_BYTE, this.data));
        }
      }
      const or = "maplibre_preloaded_worker_pool";
      class ar {
        constructor() {
          this.active = {};
        }
        acquire(r) {
          if (!this.workers) for (this.workers = []; this.workers.length < ar.workerCount; ) this.workers.push(new Worker(c.a.WORKER_URL));
          return this.active[r] = !0, this.workers.slice();
        }
        release(r) {
          delete this.active[r], this.numActive() === 0 && (this.workers.forEach((d) => {
            d.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[or];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const En = Math.floor(M.hardwareConcurrency / 2);
      let Qt, Zi;
      function ni() {
        return Qt || (Qt = new ar()), Qt;
      }
      ar.workerCount = c.C(globalThis) ? Math.max(Math.min(En, 3), 1) : 1;
      class Bi {
        constructor(r, d) {
          this.workerPool = r, this.actors = [], this.currentActor = 0, this.id = d;
          const p = this.workerPool.acquire(d);
          for (let _ = 0; _ < p.length; _++) {
            const g = new c.F(p[_], d);
            g.name = `Worker ${_}`, this.actors.push(g);
          }
          if (!this.actors.length) throw new Error("No actors found");
        }
        broadcast(r, d) {
          const p = [];
          for (const _ of this.actors) p.push(_.sendAsync({ type: r, data: d }));
          return Promise.all(p);
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove(r = !0) {
          this.actors.forEach((d) => {
            d.remove();
          }), this.actors = [], r && this.workerPool.release(this.id);
        }
        registerMessageHandler(r, d) {
          for (const p of this.actors) p.registerMessageHandler(r, d);
        }
      }
      function Vr() {
        return Zi || (Zi = new Bi(ni(), c.G), Zi.registerMessageHandler("GR", (y, r, d) => c.m(r, d))), Zi;
      }
      function Ss(y, r) {
        const d = c.H();
        return c.J(d, d, [1, 1, 0]), c.K(d, d, [0.5 * y.width, 0.5 * y.height, 1]), c.L(d, d, y.calculatePosMatrix(r.toUnwrapped()));
      }
      function ks(y, r, d, p, _, g) {
        const T = function(N, H, q) {
          if (N) for (const K of N) {
            const se = H[K];
            if (se && se.source === q && se.type === "fill-extrusion") return !0;
          }
          else for (const K in H) {
            const se = H[K];
            if (se.source === q && se.type === "fill-extrusion") return !0;
          }
          return !1;
        }(_ && _.layers, r, y.id), S = g.maxPitchScaleFactor(), I = y.tilesIn(p, S, T);
        I.sort(Ns);
        const D = [];
        for (const N of I) D.push({ wrappedTileID: N.tileID.wrapped().key, queryResults: N.tile.queryRenderedFeatures(r, d, y._state, N.queryGeometry, N.cameraQueryGeometry, N.scale, _, g, S, Ss(y.transform, N.tileID)) });
        const k = function(N) {
          const H = {}, q = {};
          for (const K of N) {
            const se = K.queryResults, oe = K.wrappedTileID, ae = q[oe] = q[oe] || {};
            for (const he in se) {
              const te = se[he], fe = ae[he] = ae[he] || {}, ge = H[he] = H[he] || [];
              for (const Te of te) fe[Te.featureIndex] || (fe[Te.featureIndex] = !0, ge.push(Te));
            }
          }
          return H;
        }(D);
        for (const N in k) k[N].forEach((H) => {
          const q = H.feature, K = y.getFeatureState(q.layer["source-layer"], q.id);
          q.source = q.layer.source, q.layer["source-layer"] && (q.sourceLayer = q.layer["source-layer"]), q.state = K;
        });
        return k;
      }
      function Ns(y, r) {
        const d = y.tileID, p = r.tileID;
        return d.overscaledZ - p.overscaledZ || d.canonical.y - p.canonical.y || d.wrap - p.wrap || d.canonical.x - p.canonical.x;
      }
      function lr(y, r, d) {
        return c._(this, void 0, void 0, function* () {
          let p = y;
          if (y.url ? p = (yield c.h(r.transformRequest(y.url, "Source"), d)).data : yield M.frameAsync(d), !p) return null;
          const _ = c.M(c.e(p, y), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
          return "vector_layers" in p && p.vector_layers && (_.vectorLayerIds = p.vector_layers.map((g) => g.id)), _;
        });
      }
      class Ie {
        constructor(r, d) {
          r && (d ? this.setSouthWest(r).setNorthEast(d) : Array.isArray(r) && (r.length === 4 ? this.setSouthWest([r[0], r[1]]).setNorthEast([r[2], r[3]]) : this.setSouthWest(r[0]).setNorthEast(r[1])));
        }
        setNorthEast(r) {
          return this._ne = r instanceof c.N ? new c.N(r.lng, r.lat) : c.N.convert(r), this;
        }
        setSouthWest(r) {
          return this._sw = r instanceof c.N ? new c.N(r.lng, r.lat) : c.N.convert(r), this;
        }
        extend(r) {
          const d = this._sw, p = this._ne;
          let _, g;
          if (r instanceof c.N) _ = r, g = r;
          else {
            if (!(r instanceof Ie)) return Array.isArray(r) ? r.length === 4 || r.every(Array.isArray) ? this.extend(Ie.convert(r)) : this.extend(c.N.convert(r)) : r && ("lng" in r || "lon" in r) && "lat" in r ? this.extend(c.N.convert(r)) : this;
            if (_ = r._sw, g = r._ne, !_ || !g) return this;
          }
          return d || p ? (d.lng = Math.min(_.lng, d.lng), d.lat = Math.min(_.lat, d.lat), p.lng = Math.max(g.lng, p.lng), p.lat = Math.max(g.lat, p.lat)) : (this._sw = new c.N(_.lng, _.lat), this._ne = new c.N(g.lng, g.lat)), this;
        }
        getCenter() {
          return new c.N((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new c.N(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new c.N(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(r) {
          const { lng: d, lat: p } = c.N.convert(r);
          let _ = this._sw.lng <= d && d <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (_ = this._sw.lng >= d && d >= this._ne.lng), this._sw.lat <= p && p <= this._ne.lat && _;
        }
        static convert(r) {
          return r instanceof Ie ? r : r && new Ie(r);
        }
        static fromLngLat(r, d = 0) {
          const p = 360 * d / 40075017, _ = p / Math.cos(Math.PI / 180 * r.lat);
          return new Ie(new c.N(r.lng - _, r.lat - p), new c.N(r.lng + _, r.lat + p));
        }
        adjustAntiMeridian() {
          const r = new c.N(this._sw.lng, this._sw.lat), d = new c.N(this._ne.lng, this._ne.lat);
          return new Ie(r, r.lng > d.lng ? new c.N(d.lng + 360, d.lat) : d);
        }
      }
      class Cs {
        constructor(r, d, p) {
          this.bounds = Ie.convert(this.validateBounds(r)), this.minzoom = d || 0, this.maxzoom = p || 24;
        }
        validateBounds(r) {
          return Array.isArray(r) && r.length === 4 ? [Math.max(-180, r[0]), Math.max(-90, r[1]), Math.min(180, r[2]), Math.min(90, r[3])] : [-180, -90, 180, 90];
        }
        contains(r) {
          const d = Math.pow(2, r.z), p = Math.floor(c.O(this.bounds.getWest()) * d), _ = Math.floor(c.Q(this.bounds.getNorth()) * d), g = Math.ceil(c.O(this.bounds.getEast()) * d), T = Math.ceil(c.Q(this.bounds.getSouth()) * d);
          return r.x >= p && r.x < g && r.y >= _ && r.y < T;
        }
      }
      class Sn extends c.E {
        constructor(r, d, p, _) {
          if (super(), this.id = r, this.dispatcher = p, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, c.e(this, c.M(d, ["url", "scheme", "tileSize", "promoteId"])), this._options = c.e({ type: "vector" }, d), this._collectResourceTiming = d.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(_);
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new c.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const r = yield lr(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), r && (c.e(this, r), r.bounds && (this.tileBounds = new Cs(r.bounds, this.minzoom, this.maxzoom)), this.fire(new c.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new c.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (r) {
              this._tileJSONRequest = null, this.fire(new c.j(r));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(r) {
          return !this.tileBounds || this.tileBounds.contains(r.canonical);
        }
        onAdd(r) {
          this.map = r, this.load();
        }
        setSourceProperty(r) {
          this._tileJSONRequest && this._tileJSONRequest.abort(), r(), this.load();
        }
        setTiles(r) {
          return this.setSourceProperty(() => {
            this._options.tiles = r;
          }), this;
        }
        setUrl(r) {
          return this.setSourceProperty(() => {
            this.url = r, this._options.url = r;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        serialize() {
          return c.e({}, this._options);
        }
        loadTile(r) {
          return c._(this, void 0, void 0, function* () {
            const d = r.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), p = { request: this.map._requestManager.transformRequest(d, "Tile"), uid: r.uid, tileID: r.tileID, zoom: r.tileID.overscaledZ, tileSize: this.tileSize * r.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            p.request.collectResourceTiming = this._collectResourceTiming;
            let _ = "RT";
            if (r.actor && r.state !== "expired") {
              if (r.state === "loading") return new Promise((g, T) => {
                r.reloadPromise = { resolve: g, reject: T };
              });
            } else r.actor = this.dispatcher.getActor(), _ = "LT";
            r.abortController = new AbortController();
            try {
              const g = yield r.actor.sendAsync({ type: _, data: p }, r.abortController);
              if (delete r.abortController, r.aborted) return;
              this._afterTileLoadWorkerResponse(r, g);
            } catch (g) {
              if (delete r.abortController, r.aborted) return;
              if (g && g.status !== 404) throw g;
              this._afterTileLoadWorkerResponse(r, null);
            }
          });
        }
        _afterTileLoadWorkerResponse(r, d) {
          if (d && d.resourceTiming && (r.resourceTiming = d.resourceTiming), d && this.map._refreshExpiredTiles && r.setExpiryData(d), r.loadVectorData(d, this.map.painter), r.reloadPromise) {
            const p = r.reloadPromise;
            r.reloadPromise = null, this.loadTile(r).then(p.resolve).catch(p.reject);
          }
        }
        abortTile(r) {
          return c._(this, void 0, void 0, function* () {
            r.abortController && (r.abortController.abort(), delete r.abortController), r.actor && (yield r.actor.sendAsync({ type: "AT", data: { uid: r.uid, type: this.type, source: this.id } }));
          });
        }
        unloadTile(r) {
          return c._(this, void 0, void 0, function* () {
            r.unloadVectorData(), r.actor && (yield r.actor.sendAsync({ type: "RMT", data: { uid: r.uid, type: this.type, source: this.id } }));
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class zt extends c.E {
        constructor(r, d, p, _) {
          super(), this.id = r, this.dispatcher = p, this.setEventedParent(_), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = c.e({ type: "raster" }, d), c.e(this, c.M(d, ["url", "scheme", "tileSize"]));
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new c.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const r = yield lr(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, r && (c.e(this, r), r.bounds && (this.tileBounds = new Cs(r.bounds, this.minzoom, this.maxzoom)), this.fire(new c.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new c.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (r) {
              this._tileJSONRequest = null, this.fire(new c.j(r));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(r) {
          this.map = r, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        setSourceProperty(r) {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), r(), this.load();
        }
        setTiles(r) {
          return this.setSourceProperty(() => {
            this._options.tiles = r;
          }), this;
        }
        setUrl(r) {
          return this.setSourceProperty(() => {
            this.url = r, this._options.url = r;
          }), this;
        }
        serialize() {
          return c.e({}, this._options);
        }
        hasTile(r) {
          return !this.tileBounds || this.tileBounds.contains(r.canonical);
        }
        loadTile(r) {
          return c._(this, void 0, void 0, function* () {
            const d = r.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            r.abortController = new AbortController();
            try {
              const p = yield Ee.getImage(this.map._requestManager.transformRequest(d, "Tile"), r.abortController, this.map._refreshExpiredTiles);
              if (delete r.abortController, r.aborted) return void (r.state = "unloaded");
              if (p && p.data) {
                this.map._refreshExpiredTiles && p.cacheControl && p.expires && r.setExpiryData({ cacheControl: p.cacheControl, expires: p.expires });
                const _ = this.map.painter.context, g = _.gl, T = p.data;
                r.texture = this.map.painter.getTileTexture(T.width), r.texture ? r.texture.update(T, { useMipmap: !0 }) : (r.texture = new it(_, T, g.RGBA, { useMipmap: !0 }), r.texture.bind(g.LINEAR, g.CLAMP_TO_EDGE, g.LINEAR_MIPMAP_NEAREST)), r.state = "loaded";
              }
            } catch (p) {
              if (delete r.abortController, r.aborted) r.state = "unloaded";
              else if (p) throw r.state = "errored", p;
            }
          });
        }
        abortTile(r) {
          return c._(this, void 0, void 0, function* () {
            r.abortController && (r.abortController.abort(), delete r.abortController);
          });
        }
        unloadTile(r) {
          return c._(this, void 0, void 0, function* () {
            r.texture && this.map.painter.saveTileTexture(r.texture);
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class oi extends zt {
        constructor(r, d, p, _) {
          super(r, d, p, _), this.type = "raster-dem", this.maxzoom = 22, this._options = c.e({ type: "raster-dem" }, d), this.encoding = d.encoding || "mapbox", this.redFactor = d.redFactor, this.greenFactor = d.greenFactor, this.blueFactor = d.blueFactor, this.baseShift = d.baseShift;
        }
        loadTile(r) {
          return c._(this, void 0, void 0, function* () {
            const d = r.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), p = this.map._requestManager.transformRequest(d, "Tile");
            r.neighboringTiles = this._getNeighboringTiles(r.tileID), r.abortController = new AbortController();
            try {
              const _ = yield Ee.getImage(p, r.abortController, this.map._refreshExpiredTiles);
              if (delete r.abortController, r.aborted) return void (r.state = "unloaded");
              if (_ && _.data) {
                const g = _.data;
                this.map._refreshExpiredTiles && _.cacheControl && _.expires && r.setExpiryData({ cacheControl: _.cacheControl, expires: _.expires });
                const T = c.b(g) && c.U() ? g : yield this.readImageNow(g), S = { type: this.type, uid: r.uid, source: this.id, rawImageData: T, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                if (!r.actor || r.state === "expired") {
                  r.actor = this.dispatcher.getActor();
                  const I = yield r.actor.sendAsync({ type: "LDT", data: S });
                  r.dem = I, r.needsHillshadePrepare = !0, r.needsTerrainPrepare = !0, r.state = "loaded";
                }
              }
            } catch (_) {
              if (delete r.abortController, r.aborted) r.state = "unloaded";
              else if (_) throw r.state = "errored", _;
            }
          });
        }
        readImageNow(r) {
          return c._(this, void 0, void 0, function* () {
            if (typeof VideoFrame < "u" && c.V()) {
              const d = r.width + 2, p = r.height + 2;
              try {
                return new c.R({ width: d, height: p }, yield c.W(r, -1, -1, d, p));
              } catch {
              }
            }
            return M.getImageData(r, 1);
          });
        }
        _getNeighboringTiles(r) {
          const d = r.canonical, p = Math.pow(2, d.z), _ = (d.x - 1 + p) % p, g = d.x === 0 ? r.wrap - 1 : r.wrap, T = (d.x + 1 + p) % p, S = d.x + 1 === p ? r.wrap + 1 : r.wrap, I = {};
          return I[new c.S(r.overscaledZ, g, d.z, _, d.y).key] = { backfilled: !1 }, I[new c.S(r.overscaledZ, S, d.z, T, d.y).key] = { backfilled: !1 }, d.y > 0 && (I[new c.S(r.overscaledZ, g, d.z, _, d.y - 1).key] = { backfilled: !1 }, I[new c.S(r.overscaledZ, r.wrap, d.z, d.x, d.y - 1).key] = { backfilled: !1 }, I[new c.S(r.overscaledZ, S, d.z, T, d.y - 1).key] = { backfilled: !1 }), d.y + 1 < p && (I[new c.S(r.overscaledZ, g, d.z, _, d.y + 1).key] = { backfilled: !1 }, I[new c.S(r.overscaledZ, r.wrap, d.z, d.x, d.y + 1).key] = { backfilled: !1 }, I[new c.S(r.overscaledZ, S, d.z, T, d.y + 1).key] = { backfilled: !1 }), I;
        }
        unloadTile(r) {
          return c._(this, void 0, void 0, function* () {
            r.demTexture && this.map.painter.saveTileTexture(r.demTexture), r.fbo && (r.fbo.destroy(), delete r.fbo), r.dem && delete r.dem, delete r.neighboringTiles, r.state = "unloaded", r.actor && (yield r.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: r.uid, source: this.id } }));
          });
        }
      }
      class Ji extends c.E {
        constructor(r, d, p, _) {
          super(), this.id = r, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = p.getActor(), this.setEventedParent(_), this._data = d.data, this._options = c.e({}, d), this._collectResourceTiming = d.collectResourceTiming, d.maxzoom !== void 0 && (this.maxzoom = d.maxzoom), d.type && (this.type = d.type), d.attribution && (this.attribution = d.attribution), this.promoteId = d.promoteId;
          const g = c.X / this.tileSize;
          d.clusterMaxZoom !== void 0 && this.maxzoom <= d.clusterMaxZoom && c.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${d.clusterMaxZoom}".`), this.workerOptions = c.e({ source: this.id, cluster: d.cluster || !1, geojsonVtOptions: { buffer: (d.buffer !== void 0 ? d.buffer : 128) * g, tolerance: (d.tolerance !== void 0 ? d.tolerance : 0.375) * g, extent: c.X, maxZoom: this.maxzoom, lineMetrics: d.lineMetrics || !1, generateId: d.generateId || !1 }, superclusterOptions: { maxZoom: d.clusterMaxZoom !== void 0 ? d.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, d.clusterMinPoints || 2), extent: c.X, radius: (d.clusterRadius || 50) * g, log: !1, generateId: d.generateId || !1 }, clusterProperties: d.clusterProperties, filter: d.filter }, d.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            yield this._updateWorkerData();
          });
        }
        onAdd(r) {
          this.map = r, this.load();
        }
        setData(r) {
          return this._data = r, this._updateWorkerData(), this;
        }
        updateData(r) {
          return this._updateWorkerData(r), this;
        }
        getData() {
          return c._(this, void 0, void 0, function* () {
            const r = c.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: "GD", data: r });
          });
        }
        setClusterOptions(r) {
          return this.workerOptions.cluster = r.cluster, r && (r.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = r.clusterRadius), r.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = r.clusterMaxZoom)), this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(r) {
          return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: r, source: this.id } });
        }
        getClusterChildren(r) {
          return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: r, source: this.id } });
        }
        getClusterLeaves(r, d, p) {
          return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: r, limit: d, offset: p } });
        }
        _updateWorkerData(r) {
          return c._(this, void 0, void 0, function* () {
            const d = c.e({ type: this.type }, this.workerOptions);
            r ? d.dataDiff = r : typeof this._data == "string" ? (d.request = this.map._requestManager.transformRequest(M.resolveURL(this._data), "Source"), d.request.collectResourceTiming = this._collectResourceTiming) : d.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new c.k("dataloading", { dataType: "source" }));
            try {
              const p = yield this.actor.sendAsync({ type: "LD", data: d });
              if (this._pendingLoads--, this._removed || p.abandoned) return void this.fire(new c.k("dataabort", { dataType: "source" }));
              let _ = null;
              p.resourceTiming && p.resourceTiming[this.id] && (_ = p.resourceTiming[this.id].slice(0));
              const g = { dataType: "source" };
              this._collectResourceTiming && _ && _.length > 0 && c.e(g, { resourceTiming: _ }), this.fire(new c.k("data", Object.assign(Object.assign({}, g), { sourceDataType: "metadata" }))), this.fire(new c.k("data", Object.assign(Object.assign({}, g), { sourceDataType: "content" })));
            } catch (p) {
              if (this._pendingLoads--, this._removed) return void this.fire(new c.k("dataabort", { dataType: "source" }));
              this.fire(new c.j(p));
            }
          });
        }
        loaded() {
          return this._pendingLoads === 0;
        }
        loadTile(r) {
          return c._(this, void 0, void 0, function* () {
            const d = r.actor ? "RT" : "LT";
            r.actor = this.actor;
            const p = { type: this.type, uid: r.uid, tileID: r.tileID, zoom: r.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            r.abortController = new AbortController();
            const _ = yield this.actor.sendAsync({ type: d, data: p }, r.abortController);
            delete r.abortController, r.unloadVectorData(), r.aborted || r.loadVectorData(_, this.map.painter, d === "RT");
          });
        }
        abortTile(r) {
          return c._(this, void 0, void 0, function* () {
            r.abortController && (r.abortController.abort(), delete r.abortController), r.aborted = !0;
          });
        }
        unloadTile(r) {
          return c._(this, void 0, void 0, function* () {
            r.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: r.uid, type: this.type, source: this.id } });
          });
        }
        onRemove() {
          this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
        }
        serialize() {
          return c.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }
      var Hr = c.Y([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      class Ar extends c.E {
        constructor(r, d, p, _) {
          super(), this.id = r, this.dispatcher = p, this.coordinates = d.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(_), this.options = d;
        }
        load(r) {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new c.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
            try {
              const d = yield Ee.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
              this._request = null, this._loaded = !0, d && d.data && (this.image = d.data, r && (this.coordinates = r), this._finishLoading());
            } catch (d) {
              this._request = null, this._loaded = !0, this.fire(new c.j(d));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(r) {
          return r.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = r.url, this.load(r.coordinates).finally(() => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new c.k("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(r) {
          this.map = r, this.load();
        }
        onRemove() {
          this._request && (this._request.abort(), this._request = null);
        }
        setCoordinates(r) {
          this.coordinates = r;
          const d = r.map(c.Z.fromLngLat);
          this.tileID = function(_) {
            let g = 1 / 0, T = 1 / 0, S = -1 / 0, I = -1 / 0;
            for (const H of _) g = Math.min(g, H.x), T = Math.min(T, H.y), S = Math.max(S, H.x), I = Math.max(I, H.y);
            const D = Math.max(S - g, I - T), k = Math.max(0, Math.floor(-Math.log(D) / Math.LN2)), N = Math.pow(2, k);
            return new c.a1(k, Math.floor((g + S) / 2 * N), Math.floor((T + I) / 2 * N));
          }(d), this.minzoom = this.maxzoom = this.tileID.z;
          const p = d.map((_) => this.tileID.getTilePoint(_)._round());
          return this._boundsArray = new c.$(), this._boundsArray.emplaceBack(p[0].x, p[0].y, 0, 0), this._boundsArray.emplaceBack(p[1].x, p[1].y, c.X, 0), this._boundsArray.emplaceBack(p[3].x, p[3].y, 0, c.X), this._boundsArray.emplaceBack(p[2].x, p[2].y, c.X, c.X), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new c.k("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image) return;
          const r = this.map.painter.context, d = r.gl;
          this.boundsBuffer || (this.boundsBuffer = r.createVertexBuffer(this._boundsArray, Hr.members)), this.boundsSegments || (this.boundsSegments = c.a0.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new it(r, this.image, d.RGBA), this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE));
          let p = !1;
          for (const _ in this.tiles) {
            const g = this.tiles[_];
            g.state !== "loaded" && (g.state = "loaded", g.texture = this.texture, p = !0);
          }
          p && this.fire(new c.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        loadTile(r) {
          return c._(this, void 0, void 0, function* () {
            this.tileID && this.tileID.equals(r.tileID.canonical) ? (this.tiles[String(r.tileID.wrap)] = r, r.buckets = {}) : r.state = "errored";
          });
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
      }
      class Cn extends Ar {
        constructor(r, d, p, _) {
          super(r, d, p, _), this.roundZoom = !0, this.type = "video", this.options = d;
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !1;
            const r = this.options;
            this.urls = [];
            for (const d of r.urls) this.urls.push(this.map._requestManager.transformRequest(d, "Source").url);
            try {
              const d = yield c.a3(this.urls);
              if (this._loaded = !0, !d) return;
              this.video = d, this.video.loop = !0, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading();
            } catch (d) {
              this.fire(new c.j(d));
            }
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(r) {
          if (this.video) {
            const d = this.video.seekable;
            r < d.start(0) || r > d.end(0) ? this.fire(new c.j(new c.a2(`sources.${this.id}`, null, `Playback for this video can be set only between the ${d.start(0)} and ${d.end(0)}-second mark.`))) : this.video.currentTime = r;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(r) {
          this.map || (this.map = r, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
          const r = this.map.painter.context, d = r.gl;
          this.boundsBuffer || (this.boundsBuffer = r.createVertexBuffer(this._boundsArray, Hr.members)), this.boundsSegments || (this.boundsSegments = c.a0.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE), d.texSubImage2D(d.TEXTURE_2D, 0, 0, 0, d.RGBA, d.UNSIGNED_BYTE, this.video)) : (this.texture = new it(r, this.video, d.RGBA), this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE));
          let p = !1;
          for (const _ in this.tiles) {
            const g = this.tiles[_];
            g.state !== "loaded" && (g.state = "loaded", g.texture = this.texture, p = !0);
          }
          p && this.fire(new c.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }
      class Ls extends Ar {
        constructor(r, d, p, _) {
          super(r, d, p, _), d.coordinates ? Array.isArray(d.coordinates) && d.coordinates.length === 4 && !d.coordinates.some((g) => !Array.isArray(g) || g.length !== 2 || g.some((T) => typeof T != "number")) || this.fire(new c.j(new c.a2(`sources.${r}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new c.j(new c.a2(`sources.${r}`, null, 'missing required property "coordinates"'))), d.animate && typeof d.animate != "boolean" && this.fire(new c.j(new c.a2(`sources.${r}`, null, 'optional "animate" property must be a boolean value'))), d.canvas ? typeof d.canvas == "string" || d.canvas instanceof HTMLCanvasElement || this.fire(new c.j(new c.a2(`sources.${r}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new c.j(new c.a2(`sources.${r}`, null, 'missing required property "canvas"'))), this.options = d, this.animate = d.animate === void 0 || d.animate;
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new c.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          });
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(r) {
          this.map = r, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let r = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, r = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, r = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
          const d = this.map.painter.context, p = d.gl;
          this.boundsBuffer || (this.boundsBuffer = d.createVertexBuffer(this._boundsArray, Hr.members)), this.boundsSegments || (this.boundsSegments = c.a0.simpleSegment(0, 0, 4, 2)), this.texture ? (r || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new it(d, this.canvas, p.RGBA, { premultiply: !0 });
          let _ = !1;
          for (const g in this.tiles) {
            const T = this.tiles[g];
            T.state !== "loaded" && (T.state = "loaded", T.texture = this.texture, _ = !0);
          }
          _ && this.fire(new c.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const r of [this.canvas.width, this.canvas.height]) if (isNaN(r) || r <= 0) return !0;
          return !1;
        }
      }
      const Jn = {}, In = (y) => {
        switch (y) {
          case "geojson":
            return Ji;
          case "image":
            return Ar;
          case "raster":
            return zt;
          case "raster-dem":
            return oi;
          case "vector":
            return Sn;
          case "video":
            return Cn;
          case "canvas":
            return Ls;
        }
        return Jn[y];
      }, He = "RTLPluginLoaded";
      class Ys extends c.E {
        constructor() {
          super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Vr();
        }
        _syncState(r) {
          return this.status = r, this.dispatcher.broadcast("SRPS", { pluginStatus: r, pluginURL: this.url }).catch((d) => {
            throw this.status = "error", d;
          });
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          this.status = "unavailable", this.url = null;
        }
        setRTLTextPlugin(r) {
          return c._(this, arguments, void 0, function* (d, p = !1) {
            if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            if (this.url = M.resolveURL(d), !this.url) throw new Error(`requested url ${d} is invalid`);
            if (this.status === "unavailable") {
              if (!p) return this._requestImport();
              this.status = "deferred", this._syncState(this.status);
            } else if (this.status === "requested") return this._requestImport();
          });
        }
        _requestImport() {
          return c._(this, void 0, void 0, function* () {
            yield this._syncState("loading"), this.status = "loaded", this.fire(new c.k(He));
          });
        }
        lazyLoad() {
          this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
        }
      }
      let Yi = null;
      function Is() {
        return Yi || (Yi = new Ys()), Yi;
      }
      class cr {
        constructor(r, d) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = r, this.uid = c.a4(), this.uses = 0, this.tileSize = d, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(r) {
          const d = r + this.timeAdded;
          d < this.fadeEndTime || (this.fadeEndTime = d);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        clearTextures(r) {
          this.demTexture && r.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(r, d, p) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", r) {
            r.featureIndex && (this.latestFeatureIndex = r.featureIndex, r.rawTileData ? (this.latestRawTileData = r.rawTileData, this.latestFeatureIndex.rawTileData = r.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = r.collisionBoxArray, this.buckets = function(_, g) {
              const T = {};
              if (!g) return T;
              for (const S of _) {
                const I = S.layerIds.map((D) => g.getLayer(D)).filter(Boolean);
                if (I.length !== 0) {
                  S.layers = I, S.stateDependentLayerIds && (S.stateDependentLayers = S.stateDependentLayerIds.map((D) => I.filter((k) => k.id === D)[0]));
                  for (const D of I) T[D.id] = S;
                }
              }
              return T;
            }(r.buckets, d.style), this.hasSymbolBuckets = !1;
            for (const _ in this.buckets) {
              const g = this.buckets[_];
              if (g instanceof c.a6) {
                if (this.hasSymbolBuckets = !0, !p) break;
                g.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const _ in this.buckets) {
              const g = this.buckets[_];
              if (g instanceof c.a6 && g.hasRTLText) {
                this.hasRTLText = !0, Is().lazyLoad();
                break;
              }
            }
            this.queryPadding = 0;
            for (const _ in this.buckets) {
              const g = this.buckets[_];
              this.queryPadding = Math.max(this.queryPadding, d.style.getLayer(_).queryRadius(g));
            }
            r.imageAtlas && (this.imageAtlas = r.imageAtlas), r.glyphAtlasImage && (this.glyphAtlasImage = r.glyphAtlasImage);
          } else this.collisionBoxArray = new c.a5();
        }
        unloadVectorData() {
          for (const r in this.buckets) this.buckets[r].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(r) {
          return this.buckets[r.id];
        }
        upload(r) {
          for (const p in this.buckets) {
            const _ = this.buckets[p];
            _.uploadPending() && _.upload(r);
          }
          const d = r.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new it(r, this.imageAtlas.image, d.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new it(r, this.glyphAtlasImage, d.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(r) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(r, this.imageAtlasTexture);
        }
        queryRenderedFeatures(r, d, p, _, g, T, S, I, D, k) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: _, cameraQueryGeometry: g, scale: T, tileSize: this.tileSize, pixelPosMatrix: k, transform: I, params: S, queryPadding: this.queryPadding * D }, r, d, p) : {};
        }
        querySourceFeatures(r, d) {
          const p = this.latestFeatureIndex;
          if (!p || !p.rawTileData) return;
          const _ = p.loadVTLayers(), g = d && d.sourceLayer ? d.sourceLayer : "", T = _._geojsonTileLayer || _[g];
          if (!T) return;
          const S = c.a7(d && d.filter), { z: I, x: D, y: k } = this.tileID.canonical, N = { z: I, x: D, y: k };
          for (let H = 0; H < T.length; H++) {
            const q = T.feature(H);
            if (S.needGeometry) {
              const oe = c.a8(q, !0);
              if (!S.filter(new c.z(this.tileID.overscaledZ), oe, this.tileID.canonical)) continue;
            } else if (!S.filter(new c.z(this.tileID.overscaledZ), q)) continue;
            const K = p.getId(q, g), se = new c.a9(q, I, D, k, K);
            se.tile = N, r.push(se);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(r) {
          const d = this.expirationTime;
          if (r.cacheControl) {
            const p = c.aa(r.cacheControl);
            p["max-age"] && (this.expirationTime = Date.now() + 1e3 * p["max-age"]);
          } else r.expires && (this.expirationTime = new Date(r.expires).getTime());
          if (this.expirationTime) {
            const p = Date.now();
            let _ = !1;
            if (this.expirationTime > p) _ = !1;
            else if (d) if (this.expirationTime < d) _ = !0;
            else {
              const g = this.expirationTime - d;
              g ? this.expirationTime = p + Math.max(g, 3e4) : _ = !0;
            }
            else _ = !0;
            _ ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(r, d) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(r).length === 0) return;
          const p = this.latestFeatureIndex.loadVTLayers();
          for (const _ in this.buckets) {
            if (!d.style.hasLayer(_)) continue;
            const g = this.buckets[_], T = g.layers[0].sourceLayer || "_geojsonTileLayer", S = p[T], I = r[T];
            if (!S || !I || Object.keys(I).length === 0) continue;
            g.update(I, S, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const D = d && d.style && d.style.getLayer(_);
            D && (this.queryPadding = Math.max(this.queryPadding, D.queryRadius(g)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < M.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(r) {
          this.symbolFadeHoldUntil = M.now() + r;
        }
        setDependencies(r, d) {
          const p = {};
          for (const _ of d) p[_] = !0;
          this.dependencies[r] = p;
        }
        hasDependency(r, d) {
          for (const p of r) {
            const _ = this.dependencies[p];
            if (_) {
              for (const g of d) if (_[g]) return !0;
            }
          }
          return !1;
        }
      }
      class qe {
        constructor(r, d) {
          this.max = r, this.onRemove = d, this.reset();
        }
        reset() {
          for (const r in this.data) for (const d of this.data[r]) d.timeout && clearTimeout(d.timeout), this.onRemove(d.value);
          return this.data = {}, this.order = [], this;
        }
        add(r, d, p) {
          const _ = r.wrapped().key;
          this.data[_] === void 0 && (this.data[_] = []);
          const g = { value: d, timeout: void 0 };
          if (p !== void 0 && (g.timeout = setTimeout(() => {
            this.remove(r, g);
          }, p)), this.data[_].push(g), this.order.push(_), this.order.length > this.max) {
            const T = this._getAndRemoveByKey(this.order[0]);
            T && this.onRemove(T);
          }
          return this;
        }
        has(r) {
          return r.wrapped().key in this.data;
        }
        getAndRemove(r) {
          return this.has(r) ? this._getAndRemoveByKey(r.wrapped().key) : null;
        }
        _getAndRemoveByKey(r) {
          const d = this.data[r].shift();
          return d.timeout && clearTimeout(d.timeout), this.data[r].length === 0 && delete this.data[r], this.order.splice(this.order.indexOf(r), 1), d.value;
        }
        getByKey(r) {
          const d = this.data[r];
          return d ? d[0].value : null;
        }
        get(r) {
          return this.has(r) ? this.data[r.wrapped().key][0].value : null;
        }
        remove(r, d) {
          if (!this.has(r)) return this;
          const p = r.wrapped().key, _ = d === void 0 ? 0 : this.data[p].indexOf(d), g = this.data[p][_];
          return this.data[p].splice(_, 1), g.timeout && clearTimeout(g.timeout), this.data[p].length === 0 && delete this.data[p], this.onRemove(g.value), this.order.splice(this.order.indexOf(p), 1), this;
        }
        setMaxSize(r) {
          for (this.max = r; this.order.length > this.max; ) {
            const d = this._getAndRemoveByKey(this.order[0]);
            d && this.onRemove(d);
          }
          return this;
        }
        filter(r) {
          const d = [];
          for (const p in this.data) for (const _ of this.data[p]) r(_.value) || d.push(_);
          for (const p of d) this.remove(p.value.tileID, p);
        }
      }
      class It {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(r, d, p) {
          const _ = String(d);
          if (this.stateChanges[r] = this.stateChanges[r] || {}, this.stateChanges[r][_] = this.stateChanges[r][_] || {}, c.e(this.stateChanges[r][_], p), this.deletedStates[r] === null) {
            this.deletedStates[r] = {};
            for (const g in this.state[r]) g !== _ && (this.deletedStates[r][g] = null);
          } else if (this.deletedStates[r] && this.deletedStates[r][_] === null) {
            this.deletedStates[r][_] = {};
            for (const g in this.state[r][_]) p[g] || (this.deletedStates[r][_][g] = null);
          } else for (const g in p) this.deletedStates[r] && this.deletedStates[r][_] && this.deletedStates[r][_][g] === null && delete this.deletedStates[r][_][g];
        }
        removeFeatureState(r, d, p) {
          if (this.deletedStates[r] === null) return;
          const _ = String(d);
          if (this.deletedStates[r] = this.deletedStates[r] || {}, p && d !== void 0) this.deletedStates[r][_] !== null && (this.deletedStates[r][_] = this.deletedStates[r][_] || {}, this.deletedStates[r][_][p] = null);
          else if (d !== void 0) if (this.stateChanges[r] && this.stateChanges[r][_]) for (p in this.deletedStates[r][_] = {}, this.stateChanges[r][_]) this.deletedStates[r][_][p] = null;
          else this.deletedStates[r][_] = null;
          else this.deletedStates[r] = null;
        }
        getState(r, d) {
          const p = String(d), _ = c.e({}, (this.state[r] || {})[p], (this.stateChanges[r] || {})[p]);
          if (this.deletedStates[r] === null) return {};
          if (this.deletedStates[r]) {
            const g = this.deletedStates[r][d];
            if (g === null) return {};
            for (const T in g) delete _[T];
          }
          return _;
        }
        initializeTileState(r, d) {
          r.setFeatureState(this.state, d);
        }
        coalesceChanges(r, d) {
          const p = {};
          for (const _ in this.stateChanges) {
            this.state[_] = this.state[_] || {};
            const g = {};
            for (const T in this.stateChanges[_]) this.state[_][T] || (this.state[_][T] = {}), c.e(this.state[_][T], this.stateChanges[_][T]), g[T] = this.state[_][T];
            p[_] = g;
          }
          for (const _ in this.deletedStates) {
            this.state[_] = this.state[_] || {};
            const g = {};
            if (this.deletedStates[_] === null) for (const T in this.state[_]) g[T] = {}, this.state[_][T] = {};
            else for (const T in this.deletedStates[_]) {
              if (this.deletedStates[_][T] === null) this.state[_][T] = {};
              else for (const S of Object.keys(this.deletedStates[_][T])) delete this.state[_][T][S];
              g[T] = this.state[_][T];
            }
            p[_] = p[_] || {}, c.e(p[_], g);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(p).length !== 0) for (const _ in r) r[_].setFeatureState(p, d);
        }
      }
      class xt extends c.E {
        constructor(r, d, p) {
          super(), this.id = r, this.dispatcher = p, this.on("data", (_) => this._dataHandler(_)), this.on("dataloading", () => {
            this._sourceErrored = !1;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = ((_, g, T, S) => {
            const I = new (In(g.type))(_, g, T, S);
            if (I.id !== _) throw new Error(`Expected Source id to be ${_} instead of ${I.id}`);
            return I;
          })(r, d, p, this), this._tiles = {}, this._cache = new qe(0, (_) => this._unloadTile(_)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new It(), this._didEmitContent = !1, this._updated = !1;
        }
        onAdd(r) {
          this.map = r, this._maxTileCacheSize = r ? r._maxTileCacheSize : null, this._maxTileCacheZoomLevels = r ? r._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(r);
        }
        onRemove(r) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(r);
        }
        loaded() {
          if (this._sourceErrored) return !0;
          if (!this._sourceLoaded || !this._source.loaded()) return !1;
          if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
          if (!this._updated) return !1;
          for (const r in this._tiles) {
            const d = this._tiles[r];
            if (d.state !== "loaded" && d.state !== "errored") return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused) return;
          const r = this._shouldReloadOnResume;
          this._paused = !1, this._shouldReloadOnResume = !1, r && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(r, d, p) {
          return c._(this, void 0, void 0, function* () {
            try {
              yield this._source.loadTile(r), this._tileLoaded(r, d, p);
            } catch (_) {
              r.state = "errored", _.status !== 404 ? this._source.fire(new c.j(_, { tile: r })) : this.update(this.transform, this.terrain);
            }
          });
        }
        _unloadTile(r) {
          this._source.unloadTile && this._source.unloadTile(r);
        }
        _abortTile(r) {
          this._source.abortTile && this._source.abortTile(r), this._source.fire(new c.k("dataabort", { tile: r, coord: r.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(r) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const d in this._tiles) {
            const p = this._tiles[d];
            p.upload(r), p.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((r) => r.tileID).sort(ds).map((r) => r.key);
        }
        getRenderableIds(r) {
          const d = [];
          for (const p in this._tiles) this._isIdRenderable(p, r) && d.push(this._tiles[p]);
          return r ? d.sort((p, _) => {
            const g = p.tileID, T = _.tileID, S = new c.P(g.canonical.x, g.canonical.y)._rotate(this.transform.angle), I = new c.P(T.canonical.x, T.canonical.y)._rotate(this.transform.angle);
            return g.overscaledZ - T.overscaledZ || I.y - S.y || I.x - S.x;
          }).map((p) => p.tileID.key) : d.map((p) => p.tileID).sort(ds).map((p) => p.key);
        }
        hasRenderableParent(r) {
          const d = this.findLoadedParent(r, 0);
          return !!d && this._isIdRenderable(d.tileID.key);
        }
        _isIdRenderable(r, d) {
          return this._tiles[r] && this._tiles[r].hasData() && !this._coveredTiles[r] && (d || !this._tiles[r].holdingForFade());
        }
        reload() {
          if (this._paused) this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const r in this._tiles) this._tiles[r].state !== "errored" && this._reloadTile(r, "reloading");
          }
        }
        _reloadTile(r, d) {
          return c._(this, void 0, void 0, function* () {
            const p = this._tiles[r];
            p && (p.state !== "loading" && (p.state = d), yield this._loadTile(p, r, d));
          });
        }
        _tileLoaded(r, d, p) {
          r.timeAdded = M.now(), p === "expired" && (r.refreshedUponExpiration = !0), this._setTileReloadTimer(d, r), this.getSource().type === "raster-dem" && r.dem && this._backfillDEM(r), this._state.initializeTileState(r, this.map ? this.map.painter : null), r.aborted || this._source.fire(new c.k("data", { dataType: "source", tile: r, coord: r.tileID }));
        }
        _backfillDEM(r) {
          const d = this.getRenderableIds();
          for (let _ = 0; _ < d.length; _++) {
            const g = d[_];
            if (r.neighboringTiles && r.neighboringTiles[g]) {
              const T = this.getTileByID(g);
              p(r, T), p(T, r);
            }
          }
          function p(_, g) {
            _.needsHillshadePrepare = !0, _.needsTerrainPrepare = !0;
            let T = g.tileID.canonical.x - _.tileID.canonical.x;
            const S = g.tileID.canonical.y - _.tileID.canonical.y, I = Math.pow(2, _.tileID.canonical.z), D = g.tileID.key;
            T === 0 && S === 0 || Math.abs(S) > 1 || (Math.abs(T) > 1 && (Math.abs(T + I) === 1 ? T += I : Math.abs(T - I) === 1 && (T -= I)), g.dem && _.dem && (_.dem.backfillBorder(g.dem, T, S), _.neighboringTiles && _.neighboringTiles[D] && (_.neighboringTiles[D].backfilled = !0)));
          }
        }
        getTile(r) {
          return this.getTileByID(r.key);
        }
        getTileByID(r) {
          return this._tiles[r];
        }
        _retainLoadedChildren(r, d, p, _) {
          for (const g in this._tiles) {
            let T = this._tiles[g];
            if (_[g] || !T.hasData() || T.tileID.overscaledZ <= d || T.tileID.overscaledZ > p) continue;
            let S = T.tileID;
            for (; T && T.tileID.overscaledZ > d + 1; ) {
              const D = T.tileID.scaledTo(T.tileID.overscaledZ - 1);
              T = this._tiles[D.key], T && T.hasData() && (S = D);
            }
            let I = S;
            for (; I.overscaledZ > d; ) if (I = I.scaledTo(I.overscaledZ - 1), r[I.key]) {
              _[S.key] = S;
              break;
            }
          }
        }
        findLoadedParent(r, d) {
          if (r.key in this._loadedParentTiles) {
            const p = this._loadedParentTiles[r.key];
            return p && p.tileID.overscaledZ >= d ? p : null;
          }
          for (let p = r.overscaledZ - 1; p >= d; p--) {
            const _ = r.scaledTo(p), g = this._getLoadedTile(_);
            if (g) return g;
          }
        }
        findLoadedSibling(r) {
          return this._getLoadedTile(r);
        }
        _getLoadedTile(r) {
          const d = this._tiles[r.key];
          return d && d.hasData() ? d : this._cache.getByKey(r.wrapped().key);
        }
        updateCacheSize(r) {
          const d = Math.ceil(r.width / this._source.tileSize) + 1, p = Math.ceil(r.height / this._source.tileSize) + 1, _ = Math.floor(d * p * (this._maxTileCacheZoomLevels === null ? c.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), g = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, _) : _;
          this._cache.setMaxSize(g);
        }
        handleWrapJump(r) {
          const d = Math.round((r - (this._prevLng === void 0 ? r : this._prevLng)) / 360);
          if (this._prevLng = r, d) {
            const p = {};
            for (const _ in this._tiles) {
              const g = this._tiles[_];
              g.tileID = g.tileID.unwrapTo(g.tileID.wrap + d), p[g.tileID.key] = g;
            }
            this._tiles = p;
            for (const _ in this._timers) clearTimeout(this._timers[_]), delete this._timers[_];
            for (const _ in this._tiles) this._setTileReloadTimer(_, this._tiles[_]);
          }
        }
        _updateCoveredAndRetainedTiles(r, d, p, _, g, T) {
          const S = {}, I = {}, D = Object.keys(r), k = M.now();
          for (const N of D) {
            const H = r[N], q = this._tiles[N];
            if (!q || q.fadeEndTime !== 0 && q.fadeEndTime <= k) continue;
            const K = this.findLoadedParent(H, d), se = this.findLoadedSibling(H), oe = K || se || null;
            oe && (this._addTile(oe.tileID), S[oe.tileID.key] = oe.tileID), I[N] = H;
          }
          this._retainLoadedChildren(I, _, p, r);
          for (const N in S) r[N] || (this._coveredTiles[N] = !0, r[N] = S[N]);
          if (T) {
            const N = {}, H = {};
            for (const q of g) this._tiles[q.key].hasData() ? N[q.key] = q : H[q.key] = q;
            for (const q in H) {
              const K = H[q].children(this._source.maxzoom);
              this._tiles[K[0].key] && this._tiles[K[1].key] && this._tiles[K[2].key] && this._tiles[K[3].key] && (N[K[0].key] = r[K[0].key] = K[0], N[K[1].key] = r[K[1].key] = K[1], N[K[2].key] = r[K[2].key] = K[2], N[K[3].key] = r[K[3].key] = K[3], delete H[q]);
            }
            for (const q in H) {
              const K = H[q], se = this.findLoadedParent(K, this._source.minzoom), oe = this.findLoadedSibling(K), ae = se || oe || null;
              if (ae) {
                N[ae.tileID.key] = r[ae.tileID.key] = ae.tileID;
                for (const he in N) N[he].isChildOf(ae.tileID) && delete N[he];
              }
            }
            for (const q in this._tiles) N[q] || (this._coveredTiles[q] = !0);
          }
        }
        update(r, d) {
          if (!this._sourceLoaded || this._paused) return;
          let p;
          this.transform = r, this.terrain = d, this.updateCacheSize(r), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? p = r.getVisibleUnwrappedCoordinates(this._source.tileID).map((k) => new c.S(k.canonical.z, k.wrap, k.canonical.z, k.canonical.x, k.canonical.y)) : (p = r.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: d }), this._source.hasTile && (p = p.filter((k) => this._source.hasTile(k)))) : p = [];
          const _ = r.coveringZoomLevel(this._source), g = Math.max(_ - xt.maxOverzooming, this._source.minzoom), T = Math.max(_ + xt.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const k = {};
            for (const N of p) if (N.canonical.z > this._source.minzoom) {
              const H = N.scaledTo(N.canonical.z - 1);
              k[H.key] = H;
              const q = N.scaledTo(Math.max(this._source.minzoom, Math.min(N.canonical.z, 5)));
              k[q.key] = q;
            }
            p = p.concat(Object.values(k));
          }
          const S = p.length === 0 && !this._updated && this._didEmitContent;
          this._updated = !0, S && this.fire(new c.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
          const I = this._updateRetainedTiles(p, _);
          Qs(this._source.type) && this._updateCoveredAndRetainedTiles(I, g, T, _, p, d);
          for (const k in I) this._tiles[k].clearFadeHold();
          const D = c.ab(this._tiles, I);
          for (const k of D) {
            const N = this._tiles[k];
            N.hasSymbolBuckets && !N.holdingForFade() ? N.setHoldDuration(this.map._fadeDuration) : N.hasSymbolBuckets && !N.symbolFadeFinished() || this._removeTile(k);
          }
          this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const r in this._tiles) this._tiles[r].holdingForFade() && this._removeTile(r);
        }
        _updateRetainedTiles(r, d) {
          var p;
          const _ = {}, g = {}, T = Math.max(d - xt.maxOverzooming, this._source.minzoom), S = Math.max(d + xt.maxUnderzooming, this._source.minzoom), I = {};
          for (const D of r) {
            const k = this._addTile(D);
            _[D.key] = D, k.hasData() || d < this._source.maxzoom && (I[D.key] = D);
          }
          this._retainLoadedChildren(I, d, S, _);
          for (const D of r) {
            let k = this._tiles[D.key];
            if (k.hasData()) continue;
            if (d + 1 > this._source.maxzoom) {
              const H = D.children(this._source.maxzoom)[0], q = this.getTile(H);
              if (q && q.hasData()) {
                _[H.key] = H;
                continue;
              }
            } else {
              const H = D.children(this._source.maxzoom);
              if (_[H[0].key] && _[H[1].key] && _[H[2].key] && _[H[3].key]) continue;
            }
            let N = k.wasRequested();
            for (let H = D.overscaledZ - 1; H >= T; --H) {
              const q = D.scaledTo(H);
              if (g[q.key]) break;
              if (g[q.key] = !0, k = this.getTile(q), !k && N && (k = this._addTile(q)), k) {
                const K = k.hasData();
                if ((K || !(!((p = this.map) === null || p === void 0) && p.cancelPendingTileRequestsWhileZooming) || N) && (_[q.key] = q), N = k.wasRequested(), K) break;
              }
            }
          }
          return _;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const r in this._tiles) {
            const d = [];
            let p, _ = this._tiles[r].tileID;
            for (; _.overscaledZ > 0; ) {
              if (_.key in this._loadedParentTiles) {
                p = this._loadedParentTiles[_.key];
                break;
              }
              d.push(_.key);
              const g = _.scaledTo(_.overscaledZ - 1);
              if (p = this._getLoadedTile(g), p) break;
              _ = g;
            }
            for (const g of d) this._loadedParentTiles[g] = p;
          }
        }
        _updateLoadedSiblingTileCache() {
          this._loadedSiblingTiles = {};
          for (const r in this._tiles) {
            const d = this._tiles[r].tileID, p = this._getLoadedTile(d);
            this._loadedSiblingTiles[d.key] = p;
          }
        }
        _addTile(r) {
          let d = this._tiles[r.key];
          if (d) return d;
          d = this._cache.getAndRemove(r), d && (this._setTileReloadTimer(r.key, d), d.tileID = r, this._state.initializeTileState(d, this.map ? this.map.painter : null), this._cacheTimers[r.key] && (clearTimeout(this._cacheTimers[r.key]), delete this._cacheTimers[r.key], this._setTileReloadTimer(r.key, d)));
          const p = d;
          return d || (d = new cr(r, this._source.tileSize * r.overscaleFactor()), this._loadTile(d, r.key, d.state)), d.uses++, this._tiles[r.key] = d, p || this._source.fire(new c.k("dataloading", { tile: d, coord: d.tileID, dataType: "source" })), d;
        }
        _setTileReloadTimer(r, d) {
          r in this._timers && (clearTimeout(this._timers[r]), delete this._timers[r]);
          const p = d.getExpiryTimeout();
          p && (this._timers[r] = setTimeout(() => {
            this._reloadTile(r, "expired"), delete this._timers[r];
          }, p));
        }
        _removeTile(r) {
          const d = this._tiles[r];
          d && (d.uses--, delete this._tiles[r], this._timers[r] && (clearTimeout(this._timers[r]), delete this._timers[r]), d.uses > 0 || (d.hasData() && d.state !== "reloading" ? this._cache.add(d.tileID, d, d.getExpiryTimeout()) : (d.aborted = !0, this._abortTile(d), this._unloadTile(d))));
        }
        _dataHandler(r) {
          const d = r.sourceDataType;
          r.dataType === "source" && d === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && r.dataType === "source" && d === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
        }
        clearTiles() {
          this._shouldReloadOnResume = !1, this._paused = !1;
          for (const r in this._tiles) this._removeTile(r);
          this._cache.reset();
        }
        tilesIn(r, d, p) {
          const _ = [], g = this.transform;
          if (!g) return _;
          const T = p ? g.getCameraQueryGeometry(r) : r, S = r.map((K) => g.pointCoordinate(K, this.terrain)), I = T.map((K) => g.pointCoordinate(K, this.terrain)), D = this.getIds();
          let k = 1 / 0, N = 1 / 0, H = -1 / 0, q = -1 / 0;
          for (const K of I) k = Math.min(k, K.x), N = Math.min(N, K.y), H = Math.max(H, K.x), q = Math.max(q, K.y);
          for (let K = 0; K < D.length; K++) {
            const se = this._tiles[D[K]];
            if (se.holdingForFade()) continue;
            const oe = se.tileID, ae = Math.pow(2, g.zoom - se.tileID.overscaledZ), he = d * se.queryPadding * c.X / se.tileSize / ae, te = [oe.getTilePoint(new c.Z(k, N)), oe.getTilePoint(new c.Z(H, q))];
            if (te[0].x - he < c.X && te[0].y - he < c.X && te[1].x + he >= 0 && te[1].y + he >= 0) {
              const fe = S.map((Te) => oe.getTilePoint(Te)), ge = I.map((Te) => oe.getTilePoint(Te));
              _.push({ tile: se, tileID: oe, queryGeometry: fe, cameraQueryGeometry: ge, scale: ae });
            }
          }
          return _;
        }
        getVisibleCoordinates(r) {
          const d = this.getRenderableIds(r).map((p) => this._tiles[p].tileID);
          for (const p of d) p.posMatrix = this.transform.calculatePosMatrix(p.toUnwrapped());
          return d;
        }
        hasTransition() {
          if (this._source.hasTransition()) return !0;
          if (Qs(this._source.type)) {
            const r = M.now();
            for (const d in this._tiles) if (this._tiles[d].fadeEndTime >= r) return !0;
          }
          return !1;
        }
        setFeatureState(r, d, p) {
          this._state.updateState(r = r || "_geojsonTileLayer", d, p);
        }
        removeFeatureState(r, d, p) {
          this._state.removeFeatureState(r = r || "_geojsonTileLayer", d, p);
        }
        getFeatureState(r, d) {
          return this._state.getState(r = r || "_geojsonTileLayer", d);
        }
        setDependencies(r, d, p) {
          const _ = this._tiles[r];
          _ && _.setDependencies(d, p);
        }
        reloadTilesForDependencies(r, d) {
          for (const p in this._tiles) this._tiles[p].hasDependency(r, d) && this._reloadTile(p, "reloading");
          this._cache.filter((p) => !p.hasDependency(r, d));
        }
      }
      function ds(y, r) {
        const d = Math.abs(2 * y.wrap) - +(y.wrap < 0), p = Math.abs(2 * r.wrap) - +(r.wrap < 0);
        return y.overscaledZ - r.overscaledZ || p - d || r.canonical.y - y.canonical.y || r.canonical.x - y.canonical.x;
      }
      function Qs(y) {
        return y === "raster" || y === "image" || y === "video";
      }
      xt.maxOverzooming = 10, xt.maxUnderzooming = 3;
      class wt {
        constructor(r, d) {
          this.reset(r, d);
        }
        reset(r, d) {
          this.points = r || [], this._distances = [0];
          for (let p = 1; p < this.points.length; p++) this._distances[p] = this._distances[p - 1] + this.points[p].dist(this.points[p - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(d || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(r) {
          if (this.points.length === 1) return this.points[0];
          r = c.ac(r, 0, 1);
          let d = 1, p = this._distances[d];
          const _ = r * this.paddedLength + this.padding;
          for (; p < _ && d < this._distances.length; ) p = this._distances[++d];
          const g = d - 1, T = this._distances[g], S = p - T, I = S > 0 ? (_ - T) / S : 0;
          return this.points[g].mult(1 - I).add(this.points[d].mult(I));
        }
      }
      function hr(y, r) {
        let d = !0;
        return y === "always" || y !== "never" && r !== "never" || (d = !1), d;
      }
      class Tr {
        constructor(r, d, p) {
          const _ = this.boxCells = [], g = this.circleCells = [];
          this.xCellCount = Math.ceil(r / p), this.yCellCount = Math.ceil(d / p);
          for (let T = 0; T < this.xCellCount * this.yCellCount; T++) _.push([]), g.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = r, this.height = d, this.xScale = this.xCellCount / r, this.yScale = this.yCellCount / d, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(r, d, p, _, g) {
          this._forEachCell(d, p, _, g, this._insertBoxCell, this.boxUid++), this.boxKeys.push(r), this.bboxes.push(d), this.bboxes.push(p), this.bboxes.push(_), this.bboxes.push(g);
        }
        insertCircle(r, d, p, _) {
          this._forEachCell(d - _, p - _, d + _, p + _, this._insertCircleCell, this.circleUid++), this.circleKeys.push(r), this.circles.push(d), this.circles.push(p), this.circles.push(_);
        }
        _insertBoxCell(r, d, p, _, g, T) {
          this.boxCells[g].push(T);
        }
        _insertCircleCell(r, d, p, _, g, T) {
          this.circleCells[g].push(T);
        }
        _query(r, d, p, _, g, T, S) {
          if (p < 0 || r > this.width || _ < 0 || d > this.height) return [];
          const I = [];
          if (r <= 0 && d <= 0 && this.width <= p && this.height <= _) {
            if (g) return [{ key: null, x1: r, y1: d, x2: p, y2: _ }];
            for (let D = 0; D < this.boxKeys.length; D++) I.push({ key: this.boxKeys[D], x1: this.bboxes[4 * D], y1: this.bboxes[4 * D + 1], x2: this.bboxes[4 * D + 2], y2: this.bboxes[4 * D + 3] });
            for (let D = 0; D < this.circleKeys.length; D++) {
              const k = this.circles[3 * D], N = this.circles[3 * D + 1], H = this.circles[3 * D + 2];
              I.push({ key: this.circleKeys[D], x1: k - H, y1: N - H, x2: k + H, y2: N + H });
            }
          } else this._forEachCell(r, d, p, _, this._queryCell, I, { hitTest: g, overlapMode: T, seenUids: { box: {}, circle: {} } }, S);
          return I;
        }
        query(r, d, p, _) {
          return this._query(r, d, p, _, !1, null);
        }
        hitTest(r, d, p, _, g, T) {
          return this._query(r, d, p, _, !0, g, T).length > 0;
        }
        hitTestCircle(r, d, p, _, g) {
          const T = r - p, S = r + p, I = d - p, D = d + p;
          if (S < 0 || T > this.width || D < 0 || I > this.height) return !1;
          const k = [];
          return this._forEachCell(T, I, S, D, this._queryCellCircle, k, { hitTest: !0, overlapMode: _, circle: { x: r, y: d, radius: p }, seenUids: { box: {}, circle: {} } }, g), k.length > 0;
        }
        _queryCell(r, d, p, _, g, T, S, I) {
          const { seenUids: D, hitTest: k, overlapMode: N } = S, H = this.boxCells[g];
          if (H !== null) {
            const K = this.bboxes;
            for (const se of H) if (!D.box[se]) {
              D.box[se] = !0;
              const oe = 4 * se, ae = this.boxKeys[se];
              if (r <= K[oe + 2] && d <= K[oe + 3] && p >= K[oe + 0] && _ >= K[oe + 1] && (!I || I(ae)) && (!k || !hr(N, ae.overlapMode)) && (T.push({ key: ae, x1: K[oe], y1: K[oe + 1], x2: K[oe + 2], y2: K[oe + 3] }), k)) return !0;
            }
          }
          const q = this.circleCells[g];
          if (q !== null) {
            const K = this.circles;
            for (const se of q) if (!D.circle[se]) {
              D.circle[se] = !0;
              const oe = 3 * se, ae = this.circleKeys[se];
              if (this._circleAndRectCollide(K[oe], K[oe + 1], K[oe + 2], r, d, p, _) && (!I || I(ae)) && (!k || !hr(N, ae.overlapMode))) {
                const he = K[oe], te = K[oe + 1], fe = K[oe + 2];
                if (T.push({ key: ae, x1: he - fe, y1: te - fe, x2: he + fe, y2: te + fe }), k) return !0;
              }
            }
          }
          return !1;
        }
        _queryCellCircle(r, d, p, _, g, T, S, I) {
          const { circle: D, seenUids: k, overlapMode: N } = S, H = this.boxCells[g];
          if (H !== null) {
            const K = this.bboxes;
            for (const se of H) if (!k.box[se]) {
              k.box[se] = !0;
              const oe = 4 * se, ae = this.boxKeys[se];
              if (this._circleAndRectCollide(D.x, D.y, D.radius, K[oe + 0], K[oe + 1], K[oe + 2], K[oe + 3]) && (!I || I(ae)) && !hr(N, ae.overlapMode)) return T.push(!0), !0;
            }
          }
          const q = this.circleCells[g];
          if (q !== null) {
            const K = this.circles;
            for (const se of q) if (!k.circle[se]) {
              k.circle[se] = !0;
              const oe = 3 * se, ae = this.circleKeys[se];
              if (this._circlesCollide(K[oe], K[oe + 1], K[oe + 2], D.x, D.y, D.radius) && (!I || I(ae)) && !hr(N, ae.overlapMode)) return T.push(!0), !0;
            }
          }
        }
        _forEachCell(r, d, p, _, g, T, S, I) {
          const D = this._convertToXCellCoord(r), k = this._convertToYCellCoord(d), N = this._convertToXCellCoord(p), H = this._convertToYCellCoord(_);
          for (let q = D; q <= N; q++) for (let K = k; K <= H; K++) if (g.call(this, r, d, p, _, this.xCellCount * K + q, T, S, I)) return;
        }
        _convertToXCellCoord(r) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(r * this.xScale)));
        }
        _convertToYCellCoord(r) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(r * this.yScale)));
        }
        _circlesCollide(r, d, p, _, g, T) {
          const S = _ - r, I = g - d, D = p + T;
          return D * D > S * S + I * I;
        }
        _circleAndRectCollide(r, d, p, _, g, T, S) {
          const I = (T - _) / 2, D = Math.abs(r - (_ + I));
          if (D > I + p) return !1;
          const k = (S - g) / 2, N = Math.abs(d - (g + k));
          if (N > k + p) return !1;
          if (D <= I || N <= k) return !0;
          const H = D - I, q = N - k;
          return H * H + q * q <= p * p;
        }
      }
      function Er(y, r, d, p, _) {
        const g = c.H();
        return r ? (c.K(g, g, [1 / _, 1 / _, 1]), d || c.ad(g, g, p.angle)) : c.L(g, p.labelPlaneMatrix, y), g;
      }
      function er(y, r, d, p, _) {
        if (r) {
          const g = c.ae(y);
          return c.K(g, g, [_, _, 1]), d || c.ad(g, g, -p.angle), g;
        }
        return p.glCoordMatrix;
      }
      function re(y, r, d, p) {
        let _;
        p ? (_ = [y, r, p(y, r), 1], c.af(_, _, d)) : (_ = [y, r, 0, 1], Lt(_, _, d));
        const g = _[3];
        return { point: new c.P(_[0] / g, _[1] / g), signedDistanceFromCamera: g, isOccluded: !1 };
      }
      function z(y, r) {
        return 0.5 + y / r * 0.5;
      }
      function U(y, r) {
        return y.x >= -r[0] && y.x <= r[0] && y.y >= -r[1] && y.y <= r[1];
      }
      function W(y, r, d, p, _, g, T, S, I, D, k, N, H, q, K) {
        const se = p ? y.textSizeData : y.iconSizeData, oe = c.ag(se, d.transform.zoom), ae = [256 / d.width * 2 + 1, 256 / d.height * 2 + 1], he = p ? y.text.dynamicLayoutVertexArray : y.icon.dynamicLayoutVertexArray;
        he.clear();
        const te = y.lineVertexArray, fe = p ? y.text.placedSymbolArray : y.icon.placedSymbolArray, ge = d.transform.width / d.transform.height;
        let Te = !1;
        for (let Fe = 0; Fe < fe.length; Fe++) {
          const Ve = fe.get(Fe);
          if (Ve.hidden || Ve.writingMode === c.ah.vertical && !Te) {
            gt(Ve.numGlyphs, he);
            continue;
          }
          Te = !1;
          const Ye = re(Ve.anchorX, Ve.anchorY, r, K);
          if (!U(Ye.point, ae)) {
            gt(Ve.numGlyphs, he);
            continue;
          }
          const st = z(d.transform.cameraToCenterDistance, Ye.signedDistanceFromCamera), Ze = c.ai(se, oe, Ve), Ge = T ? Ze / st : Ze * st, ut = { getElevation: K, labelPlaneMatrix: _, lineVertexArray: te, pitchWithMap: T, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: D, tileAnchorPoint: new c.P(Ve.anchorX, Ve.anchorY), unwrappedTileID: k, width: N, height: H, translation: q }, Et = pe(ut, Ve, Ge, !1, S, r, g, y.glyphOffsetArray, he, ge, I);
          Te = Et.useVertical, (Et.notEnoughRoom || Te || Et.needsFlipping && pe(ut, Ve, Ge, !0, S, r, g, y.glyphOffsetArray, he, ge, I).notEnoughRoom) && gt(Ve.numGlyphs, he);
        }
        p ? y.text.dynamicLayoutVertexBuffer.updateData(he) : y.icon.dynamicLayoutVertexBuffer.updateData(he);
      }
      function ee(y, r, d, p, _, g, T, S) {
        const I = g.glyphStartIndex + g.numGlyphs, D = g.lineStartIndex, k = g.lineStartIndex + g.lineLength, N = r.getoffsetX(g.glyphStartIndex), H = r.getoffsetX(I - 1), q = je(y * N, d, p, _, g.segment, D, k, S, T);
        if (!q) return null;
        const K = je(y * H, d, p, _, g.segment, D, k, S, T);
        return K ? S.projectionCache.anyProjectionOccluded ? null : { first: q, last: K } : null;
      }
      function ue(y, r, d, p) {
        return y === c.ah.horizontal && Math.abs(d.y - r.y) > Math.abs(d.x - r.x) * p ? { useVertical: !0 } : (y === c.ah.vertical ? r.y < d.y : r.x > d.x) ? { needsFlipping: !0 } : null;
      }
      function pe(y, r, d, p, _, g, T, S, I, D, k) {
        const N = d / 24, H = r.lineOffsetX * N, q = r.lineOffsetY * N;
        let K;
        if (r.numGlyphs > 1) {
          const se = r.glyphStartIndex + r.numGlyphs, oe = r.lineStartIndex, ae = r.lineStartIndex + r.lineLength, he = ee(N, S, H, q, p, r, k, y);
          if (!he) return { notEnoughRoom: !0 };
          const te = re(he.first.point.x, he.first.point.y, T, y.getElevation).point, fe = re(he.last.point.x, he.last.point.y, T, y.getElevation).point;
          if (_ && !p) {
            const ge = ue(r.writingMode, te, fe, D);
            if (ge) return ge;
          }
          K = [he.first];
          for (let ge = r.glyphStartIndex + 1; ge < se - 1; ge++) K.push(je(N * S.getoffsetX(ge), H, q, p, r.segment, oe, ae, y, k));
          K.push(he.last);
        } else {
          if (_ && !p) {
            const oe = re(y.tileAnchorPoint.x, y.tileAnchorPoint.y, g, y.getElevation).point, ae = r.lineStartIndex + r.segment + 1, he = new c.P(y.lineVertexArray.getx(ae), y.lineVertexArray.gety(ae)), te = re(he.x, he.y, g, y.getElevation), fe = te.signedDistanceFromCamera > 0 ? te.point : function(Te, Fe, Ve, Ye, st, Ze) {
              return xe(Te, Fe, Ve, 1, st, Ze);
            }(y.tileAnchorPoint, he, oe, 0, g, y), ge = ue(r.writingMode, oe, fe, D);
            if (ge) return ge;
          }
          const se = je(N * S.getoffsetX(r.glyphStartIndex), H, q, p, r.segment, r.lineStartIndex, r.lineStartIndex + r.lineLength, y, k);
          if (!se || y.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
          K = [se];
        }
        for (const se of K) c.aj(I, se.point, se.angle);
        return {};
      }
      function xe(y, r, d, p, _, g) {
        const T = y.add(y.sub(r)._unit()), S = _ !== void 0 ? re(T.x, T.y, _, g.getElevation).point : Be(T.x, T.y, g).point, I = d.sub(S);
        return d.add(I._mult(p / I.mag()));
      }
      function le(y, r, d) {
        const p = r.projectionCache;
        if (p.projections[y]) return p.projections[y];
        const _ = new c.P(r.lineVertexArray.getx(y), r.lineVertexArray.gety(y)), g = Be(_.x, _.y, r);
        if (g.signedDistanceFromCamera > 0) return p.projections[y] = g.point, p.anyProjectionOccluded = p.anyProjectionOccluded || g.isOccluded, g.point;
        const T = y - d.direction;
        return function(S, I, D, k, N) {
          return xe(S, I, D, k, void 0, N);
        }(d.distanceFromAnchor === 0 ? r.tileAnchorPoint : new c.P(r.lineVertexArray.getx(T), r.lineVertexArray.gety(T)), _, d.previousVertex, d.absOffsetX - d.distanceFromAnchor + 1, r);
      }
      function Be(y, r, d) {
        const p = y + d.translation[0], _ = r + d.translation[1];
        let g;
        return !d.pitchWithMap && d.projection.useSpecialProjectionForSymbols ? (g = d.projection.projectTileCoordinates(p, _, d.unwrappedTileID, d.getElevation), g.point.x = (0.5 * g.point.x + 0.5) * d.width, g.point.y = (0.5 * -g.point.y + 0.5) * d.height) : (g = re(p, _, d.labelPlaneMatrix, d.getElevation), g.isOccluded = !1), g;
      }
      function ke(y, r, d) {
        return y._unit()._perp()._mult(r * d);
      }
      function Re(y, r, d, p, _, g, T, S, I) {
        if (S.projectionCache.offsets[y]) return S.projectionCache.offsets[y];
        const D = d.add(r);
        if (y + I.direction < p || y + I.direction >= _) return S.projectionCache.offsets[y] = D, D;
        const k = le(y + I.direction, S, I), N = ke(k.sub(d), T, I.direction), H = d.add(N), q = k.add(N);
        return S.projectionCache.offsets[y] = c.ak(g, D, H, q) || D, S.projectionCache.offsets[y];
      }
      function je(y, r, d, p, _, g, T, S, I) {
        const D = p ? y - r : y + r;
        let k = D > 0 ? 1 : -1, N = 0;
        p && (k *= -1, N = Math.PI), k < 0 && (N += Math.PI);
        let H, q = k > 0 ? g + _ : g + _ + 1;
        S.projectionCache.cachedAnchorPoint ? H = S.projectionCache.cachedAnchorPoint : (H = Be(S.tileAnchorPoint.x, S.tileAnchorPoint.y, S).point, S.projectionCache.cachedAnchorPoint = H);
        let K, se, oe = H, ae = H, he = 0, te = 0;
        const fe = Math.abs(D), ge = [];
        let Te;
        for (; he + te <= fe; ) {
          if (q += k, q < g || q >= T) return null;
          he += te, ae = oe, se = K;
          const Ye = { absOffsetX: fe, direction: k, distanceFromAnchor: he, previousVertex: ae };
          if (oe = le(q, S, Ye), d === 0) ge.push(ae), Te = oe.sub(ae);
          else {
            let st;
            const Ze = oe.sub(ae);
            st = Ze.mag() === 0 ? ke(le(q + k, S, Ye).sub(oe), d, k) : ke(Ze, d, k), se || (se = ae.add(st)), K = Re(q, st, oe, g, T, se, d, S, Ye), ge.push(se), Te = K.sub(se);
          }
          te = Te.mag();
        }
        const Fe = Te._mult((fe - he) / te)._add(se || ae), Ve = N + Math.atan2(oe.y - ae.y, oe.x - ae.x);
        return ge.push(Fe), { point: Fe, angle: I ? Ve : 0, path: ge };
      }
      const pt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function gt(y, r) {
        for (let d = 0; d < y; d++) {
          const p = r.length;
          r.resize(p + 4), r.float32.set(pt, 3 * p);
        }
      }
      function Lt(y, r, d) {
        const p = r[0], _ = r[1];
        return y[0] = d[0] * p + d[4] * _ + d[12], y[1] = d[1] * p + d[5] * _ + d[13], y[3] = d[3] * p + d[7] * _ + d[15], y;
      }
      const St = 100;
      class Ft {
        constructor(r, d, p = new Tr(r.width + 200, r.height + 200, 25), _ = new Tr(r.width + 200, r.height + 200, 25)) {
          this.transform = r, this.mapProjection = d, this.grid = p, this.ignoredGrid = _, this.pitchFactor = Math.cos(r._pitch) * r.cameraToCenterDistance, this.screenRightBoundary = r.width + St, this.screenBottomBoundary = r.height + St, this.gridRightBoundary = r.width + 200, this.gridBottomBoundary = r.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(r, d, p, _, g, T, S, I, D, k, N) {
          const H = r.anchorPointX + I[0], q = r.anchorPointY + I[1], K = this.projectAndGetPerspectiveRatio(_, H, q, g, k), se = p * K.perspectiveRatio;
          let oe;
          if (T || S) oe = this._projectCollisionBox(r, se, _, g, T, S, I, K, k, N);
          else {
            const ge = K.point.x + (N ? N.x * se : 0), Te = K.point.y + (N ? N.y * se : 0);
            oe = { allPointsOccluded: !1, box: [ge + r.x1 * se, Te + r.y1 * se, ge + r.x2 * se, Te + r.y2 * se] };
          }
          const [ae, he, te, fe] = oe.box;
          return this.mapProjection.useSpecialProjectionForSymbols && (T ? oe.allPointsOccluded : this.mapProjection.isOccluded(H, q, g)) || K.perspectiveRatio < this.perspectiveRatioCutoff || !this.isInsideGrid(ae, he, te, fe) || d !== "always" && this.grid.hitTest(ae, he, te, fe, d, D) ? { box: [ae, he, te, fe], placeable: !1, offscreen: !1 } : { box: [ae, he, te, fe], placeable: !0, offscreen: this.isOffscreen(ae, he, te, fe) };
        }
        placeCollisionCircles(r, d, p, _, g, T, S, I, D, k, N, H, q, K, se, oe) {
          const ae = [], he = new c.P(d.anchorX, d.anchorY), te = this.getPerspectiveRatio(T, he.x, he.y, S, oe), fe = (N ? g / te : g * te) / c.ap, ge = { getElevation: oe, labelPlaneMatrix: I, lineVertexArray: p, pitchWithMap: N, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: this.mapProjection, tileAnchorPoint: he, unwrappedTileID: S, width: this.transform.width, height: this.transform.height, translation: se }, Te = ee(fe, _, d.lineOffsetX * fe, d.lineOffsetY * fe, !1, d, !1, ge);
          let Fe = !1, Ve = !1, Ye = !0;
          if (Te) {
            const st = 0.5 * q * te + K, Ze = new c.P(-100, -100), Ge = new c.P(this.screenRightBoundary, this.screenBottomBoundary), ut = new wt(), Et = Te.first, Ke = Te.last;
            let et = [];
            for (let Mt = Et.path.length - 1; Mt >= 1; Mt--) et.push(Et.path[Mt]);
            for (let Mt = 1; Mt < Ke.path.length; Mt++) et.push(Ke.path[Mt]);
            const At = 2.5 * st;
            if (D) {
              const Mt = this.projectPathToScreenSpace(et, ge, D);
              et = Mt.some((Ot) => Ot.signedDistanceFromCamera <= 0) ? [] : Mt.map((Ot) => Ot.point);
            }
            let pi = [];
            if (et.length > 0) {
              const Mt = et[0].clone(), Ot = et[0].clone();
              for (let _i = 1; _i < et.length; _i++) Mt.x = Math.min(Mt.x, et[_i].x), Mt.y = Math.min(Mt.y, et[_i].y), Ot.x = Math.max(Ot.x, et[_i].x), Ot.y = Math.max(Ot.y, et[_i].y);
              pi = Mt.x >= Ze.x && Ot.x <= Ge.x && Mt.y >= Ze.y && Ot.y <= Ge.y ? [et] : Ot.x < Ze.x || Mt.x > Ge.x || Ot.y < Ze.y || Mt.y > Ge.y ? [] : c.al([et], Ze.x, Ze.y, Ge.x, Ge.y);
            }
            for (const Mt of pi) {
              ut.reset(Mt, 0.25 * st);
              let Ot = 0;
              Ot = ut.length <= 0.5 * st ? 1 : Math.ceil(ut.paddedLength / At) + 1;
              for (let _i = 0; _i < Ot; _i++) {
                const gs = _i / Math.max(Ot - 1, 1), Ir = ut.lerp(gs), mi = Ir.x + St, Vs = Ir.y + St;
                ae.push(mi, Vs, st, 0);
                const Ms = mi - st, ys = Vs - st, Ps = mi + st, Kr = Vs + st;
                if (Ye = Ye && this.isOffscreen(Ms, ys, Ps, Kr), Ve = Ve || this.isInsideGrid(Ms, ys, Ps, Kr), r !== "always" && this.grid.hitTestCircle(mi, Vs, st, r, H) && (Fe = !0, !k)) return { circles: [], offscreen: !1, collisionDetected: Fe };
              }
            }
          }
          return { circles: !k && Fe || !Ve || te < this.perspectiveRatioCutoff ? [] : ae, offscreen: Ye, collisionDetected: Fe };
        }
        projectPathToScreenSpace(r, d, p) {
          return r.map((_) => re(_.x, _.y, p, d.getElevation));
        }
        queryRenderedSymbols(r) {
          if (r.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
          const d = [];
          let p = 1 / 0, _ = 1 / 0, g = -1 / 0, T = -1 / 0;
          for (const k of r) {
            const N = new c.P(k.x + St, k.y + St);
            p = Math.min(p, N.x), _ = Math.min(_, N.y), g = Math.max(g, N.x), T = Math.max(T, N.y), d.push(N);
          }
          const S = this.grid.query(p, _, g, T).concat(this.ignoredGrid.query(p, _, g, T)), I = {}, D = {};
          for (const k of S) {
            const N = k.key;
            if (I[N.bucketInstanceId] === void 0 && (I[N.bucketInstanceId] = {}), I[N.bucketInstanceId][N.featureIndex]) continue;
            const H = [new c.P(k.x1, k.y1), new c.P(k.x2, k.y1), new c.P(k.x2, k.y2), new c.P(k.x1, k.y2)];
            c.am(d, H) && (I[N.bucketInstanceId][N.featureIndex] = !0, D[N.bucketInstanceId] === void 0 && (D[N.bucketInstanceId] = []), D[N.bucketInstanceId].push(N.featureIndex));
          }
          return D;
        }
        insertCollisionBox(r, d, p, _, g, T) {
          (p ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: _, featureIndex: g, collisionGroupID: T, overlapMode: d }, r[0], r[1], r[2], r[3]);
        }
        insertCollisionCircles(r, d, p, _, g, T) {
          const S = p ? this.ignoredGrid : this.grid, I = { bucketInstanceId: _, featureIndex: g, collisionGroupID: T, overlapMode: d };
          for (let D = 0; D < r.length; D += 4) S.insertCircle(I, r[D], r[D + 1], r[D + 2]);
        }
        projectAndGetPerspectiveRatio(r, d, p, _, g) {
          let T;
          g ? (T = [d, p, g(d, p), 1], c.af(T, T, r)) : (T = [d, p, 0, 1], Lt(T, T, r));
          const S = T[3];
          return { point: new c.P((T[0] / S + 1) / 2 * this.transform.width + St, (-T[1] / S + 1) / 2 * this.transform.height + St), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / S * 0.5, isOccluded: !1, signedDistanceFromCamera: S };
        }
        getPerspectiveRatio(r, d, p, _, g) {
          const T = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(d, p, _, g) : re(d, p, r, g);
          return 0.5 + this.transform.cameraToCenterDistance / T.signedDistanceFromCamera * 0.5;
        }
        isOffscreen(r, d, p, _) {
          return p < St || r >= this.screenRightBoundary || _ < St || d > this.screenBottomBoundary;
        }
        isInsideGrid(r, d, p, _) {
          return p >= 0 && r < this.gridRightBoundary && _ >= 0 && d < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const r = c.an([]);
          return c.J(r, r, [-100, -100, 0]), r;
        }
        _projectCollisionBox(r, d, p, _, g, T, S, I, D, k) {
          let N = new c.P(1, 0), H = new c.P(0, 1);
          const q = new c.P(r.anchorPointX + S[0], r.anchorPointY + S[1]);
          if (T && !g) {
            const Ye = this.projectAndGetPerspectiveRatio(p, q.x + 1, q.y, _, D).point.sub(I.point).unit(), st = Math.atan(Ye.y / Ye.x) + (Ye.x < 0 ? Math.PI : 0), Ze = Math.sin(st), Ge = Math.cos(st);
            N = new c.P(Ge, Ze), H = new c.P(-Ze, Ge);
          } else if (!T && g) {
            const Ye = -this.transform.angle, st = Math.sin(Ye), Ze = Math.cos(Ye);
            N = new c.P(Ze, st), H = new c.P(-st, Ze);
          }
          let K = I.point, se = d;
          if (g) {
            K = q;
            const Ye = this.transform.zoom - Math.floor(this.transform.zoom);
            se = Math.pow(2, -Ye), se *= this.mapProjection.getPitchedTextCorrection(this.transform, q, _), k || (se *= c.ac(0.5 + I.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4));
          }
          k && (K = K.add(N.mult(k.x * se)).add(H.mult(k.y * se)));
          const oe = r.x1 * se, ae = r.x2 * se, he = (oe + ae) / 2, te = r.y1 * se, fe = r.y2 * se, ge = (te + fe) / 2, Te = [{ offsetX: oe, offsetY: te }, { offsetX: he, offsetY: te }, { offsetX: ae, offsetY: te }, { offsetX: ae, offsetY: ge }, { offsetX: ae, offsetY: fe }, { offsetX: he, offsetY: fe }, { offsetX: oe, offsetY: fe }, { offsetX: oe, offsetY: ge }];
          let Fe = [];
          for (const { offsetX: Ye, offsetY: st } of Te) Fe.push(new c.P(K.x + N.x * Ye + H.x * st, K.y + N.y * Ye + H.y * st));
          let Ve = !1;
          if (g) {
            const Ye = Fe.map((st) => this.projectAndGetPerspectiveRatio(p, st.x, st.y, _, D));
            Ve = Ye.some((st) => !st.isOccluded), Fe = Ye.map((st) => st.point);
          } else Ve = !0;
          return { box: c.ao(Fe), allPointsOccluded: !Ve };
        }
      }
      function Pt(y, r, d) {
        return r * (c.X / (y.tileSize * Math.pow(2, d - y.tileID.overscaledZ)));
      }
      class Ei {
        constructor(r, d, p, _) {
          this.opacity = r ? Math.max(0, Math.min(1, r.opacity + (r.placed ? d : -d))) : _ && p ? 1 : 0, this.placed = p;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class li {
        constructor(r, d, p, _, g) {
          this.text = new Ei(r ? r.text : null, d, p, g), this.icon = new Ei(r ? r.icon : null, d, _, g);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class Ct {
        constructor(r, d, p) {
          this.text = r, this.icon = d, this.skipFade = p;
        }
      }
      class Vt {
        constructor() {
          this.invProjMatrix = c.H(), this.viewportMatrix = c.H(), this.circles = [];
        }
      }
      class Zt {
        constructor(r, d, p, _, g) {
          this.bucketInstanceId = r, this.featureIndex = d, this.sourceLayerIndex = p, this.bucketIndex = _, this.tileID = g;
        }
      }
      class Si {
        constructor(r) {
          this.crossSourceCollisions = r, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(r) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[r]) {
            const d = ++this.maxGroupID;
            this.collisionGroups[r] = { ID: d, predicate: (p) => p.collisionGroupID === d };
          }
          return this.collisionGroups[r];
        }
      }
      function Ui(y, r, d, p, _) {
        const { horizontalAlign: g, verticalAlign: T } = c.au(y);
        return new c.P(-(g - 0.5) * r + p[0] * _, -(T - 0.5) * d + p[1] * _);
      }
      class ns {
        constructor(r, d, p, _, g, T) {
          this.transform = r.clone(), this.terrain = p, this.collisionIndex = new Ft(this.transform, d), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = _, this.retainedQueryData = {}, this.collisionGroups = new Si(g), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = T, T && (T.prevPlacement = void 0), this.placedOrientations = {};
        }
        _getTerrainElevationFunc(r) {
          const d = this.terrain;
          return d ? (p, _) => d.getElevation(r, p, _) : null;
        }
        getBucketParts(r, d, p, _) {
          const g = p.getBucket(d), T = p.latestFeatureIndex;
          if (!g || !T || d.id !== g.layerIds[0]) return;
          const S = p.collisionBoxArray, I = g.layers[0].layout, D = g.layers[0].paint, k = Math.pow(2, this.transform.zoom - p.tileID.overscaledZ), N = p.tileSize / c.X, H = p.tileID.toUnwrapped(), q = this.transform.calculatePosMatrix(H), K = I.get("text-pitch-alignment") === "map", se = I.get("text-rotation-alignment") === "map", oe = Pt(p, 1, this.transform.zoom), ae = this.collisionIndex.mapProjection.translatePosition(this.transform, p, D.get("text-translate"), D.get("text-translate-anchor")), he = this.collisionIndex.mapProjection.translatePosition(this.transform, p, D.get("icon-translate"), D.get("icon-translate-anchor")), te = Er(q, K, se, this.transform, oe);
          let fe = null;
          if (K) {
            const Te = er(q, K, se, this.transform, oe);
            fe = c.L([], this.transform.labelPlaneMatrix, Te);
          }
          this.retainedQueryData[g.bucketInstanceId] = new Zt(g.bucketInstanceId, T, g.sourceLayerIndex, g.index, p.tileID);
          const ge = { bucket: g, layout: I, translationText: ae, translationIcon: he, posMatrix: q, unwrappedTileID: H, textLabelPlaneMatrix: te, labelToScreenMatrix: fe, scale: k, textPixelRatio: N, holdingForFade: p.holdingForFade(), collisionBoxArray: S, partiallyEvaluatedTextSize: c.ag(g.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(g.sourceID) };
          if (_) for (const Te of g.sortKeyRanges) {
            const { sortKey: Fe, symbolInstanceStart: Ve, symbolInstanceEnd: Ye } = Te;
            r.push({ sortKey: Fe, symbolInstanceStart: Ve, symbolInstanceEnd: Ye, parameters: ge });
          }
          else r.push({ symbolInstanceStart: 0, symbolInstanceEnd: g.symbolInstances.length, parameters: ge });
        }
        attemptAnchorPlacement(r, d, p, _, g, T, S, I, D, k, N, H, q, K, se, oe, ae, he, te) {
          const fe = c.aq[r.textAnchor], ge = [r.textOffset0, r.textOffset1], Te = Ui(fe, p, _, ge, g), Fe = this.collisionIndex.placeCollisionBox(d, H, I, D, k, S, T, oe, N.predicate, te, Te);
          if ((!he || this.collisionIndex.placeCollisionBox(he, H, I, D, k, S, T, ae, N.predicate, te, Te).placeable) && Fe.placeable) {
            let Ve;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[q.crossTileID] && this.prevPlacement.placements[q.crossTileID] && this.prevPlacement.placements[q.crossTileID].text && (Ve = this.prevPlacement.variableOffsets[q.crossTileID].anchor), q.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[q.crossTileID] = { textOffset: ge, width: p, height: _, anchor: fe, textBoxScale: g, prevAnchor: Ve }, this.markUsedJustification(K, fe, q, se), K.allowVerticalPlacement && (this.markUsedOrientation(K, se, q), this.placedOrientations[q.crossTileID] = se), { shift: Te, placedGlyphBoxes: Fe };
          }
        }
        placeLayerBucketPart(r, d, p) {
          const { bucket: _, layout: g, translationText: T, translationIcon: S, posMatrix: I, unwrappedTileID: D, textLabelPlaneMatrix: k, labelToScreenMatrix: N, textPixelRatio: H, holdingForFade: q, collisionBoxArray: K, partiallyEvaluatedTextSize: se, collisionGroup: oe } = r.parameters, ae = g.get("text-optional"), he = g.get("icon-optional"), te = c.ar(g, "text-overlap", "text-allow-overlap"), fe = te === "always", ge = c.ar(g, "icon-overlap", "icon-allow-overlap"), Te = ge === "always", Fe = g.get("text-rotation-alignment") === "map", Ve = g.get("text-pitch-alignment") === "map", Ye = g.get("icon-text-fit") !== "none", st = g.get("symbol-z-order") === "viewport-y", Ze = fe && (Te || !_.hasIconData() || he), Ge = Te && (fe || !_.hasTextData() || ae);
          !_.collisionArrays && K && _.deserializeCollisionBoxes(K);
          const ut = this._getTerrainElevationFunc(this.retainedQueryData[_.bucketInstanceId].tileID), Et = (Ke, et, At) => {
            var pi, Mt;
            if (d[Ke.crossTileID]) return;
            if (q) return void (this.placements[Ke.crossTileID] = new Ct(!1, !1, !1));
            let Ot = !1, _i = !1, gs = !0, Ir = null, mi = { box: null, placeable: !1, offscreen: null }, Vs = { box: null, placeable: !1, offscreen: null }, Ms = null, ys = null, Ps = null, Kr = 0, $o = 0, Vl = 0;
            et.textFeatureIndex ? Kr = et.textFeatureIndex : Ke.useRuntimeCollisionCircles && (Kr = Ke.featureIndex), et.verticalTextFeatureIndex && ($o = et.verticalTextFeatureIndex);
            const Go = et.textBox;
            if (Go) {
              const mr = (ls) => {
                let bs = c.ah.horizontal;
                if (_.allowVerticalPlacement && !ls && this.prevPlacement) {
                  const sr = this.prevPlacement.placedOrientations[Ke.crossTileID];
                  sr && (this.placedOrientations[Ke.crossTileID] = sr, bs = sr, this.markUsedOrientation(_, bs, Ke));
                }
                return bs;
              }, gr = (ls, bs) => {
                if (_.allowVerticalPlacement && Ke.numVerticalGlyphVertices > 0 && et.verticalTextBox) {
                  for (const sr of _.writingModes) if (sr === c.ah.vertical ? (mi = bs(), Vs = mi) : mi = ls(), mi && mi.placeable) break;
                } else mi = ls();
              }, Bn = Ke.textAnchorOffsetStartIndex, Rr = Ke.textAnchorOffsetEndIndex;
              if (Rr === Bn) {
                const ls = (bs, sr) => {
                  const Nt = this.collisionIndex.placeCollisionBox(bs, te, H, I, D, Ve, Fe, T, oe.predicate, ut);
                  return Nt && Nt.placeable && (this.markUsedOrientation(_, sr, Ke), this.placedOrientations[Ke.crossTileID] = sr), Nt;
                };
                gr(() => ls(Go, c.ah.horizontal), () => {
                  const bs = et.verticalTextBox;
                  return _.allowVerticalPlacement && Ke.numVerticalGlyphVertices > 0 && bs ? ls(bs, c.ah.vertical) : { box: null, offscreen: null };
                }), mr(mi && mi.placeable);
              } else {
                let ls = c.aq[(Mt = (pi = this.prevPlacement) === null || pi === void 0 ? void 0 : pi.variableOffsets[Ke.crossTileID]) === null || Mt === void 0 ? void 0 : Mt.anchor];
                const bs = (Nt, co, Xo) => {
                  const Wo = Nt.x2 - Nt.x1, bd = Nt.y2 - Nt.y1, Jp = Ke.textBoxScale, vd = Ye && ge === "never" ? co : null;
                  let Dn = null, xd = te === "never" ? 1 : 2, jl = "never";
                  ls && xd++;
                  for (let La = 0; La < xd; La++) {
                    for (let $l = Bn; $l < Rr; $l++) {
                      const Gl = _.textAnchorOffsets.get($l);
                      if (ls && Gl.textAnchor !== ls) continue;
                      const qo = this.attemptAnchorPlacement(Gl, Nt, Wo, bd, Jp, Fe, Ve, H, I, D, oe, jl, Ke, _, Xo, T, S, vd, ut);
                      if (qo && (Dn = qo.placedGlyphBoxes, Dn && Dn.placeable)) return Ot = !0, Ir = qo.shift, Dn;
                    }
                    ls ? ls = null : jl = te;
                  }
                  return p && !Dn && (Dn = { box: this.collisionIndex.placeCollisionBox(Go, "always", H, I, D, Ve, Fe, T, oe.predicate, ut, new c.P(0, 0)).box, offscreen: !1, placeable: !1 }), Dn;
                };
                gr(() => bs(Go, et.iconBox, c.ah.horizontal), () => {
                  const Nt = et.verticalTextBox;
                  return _.allowVerticalPlacement && (!mi || !mi.placeable) && Ke.numVerticalGlyphVertices > 0 && Nt ? bs(Nt, et.verticalIconBox, c.ah.vertical) : { box: null, occluded: !0, offscreen: null };
                }), mi && (Ot = mi.placeable, gs = mi.offscreen);
                const sr = mr(mi && mi.placeable);
                if (!Ot && this.prevPlacement) {
                  const Nt = this.prevPlacement.variableOffsets[Ke.crossTileID];
                  Nt && (this.variableOffsets[Ke.crossTileID] = Nt, this.markUsedJustification(_, Nt.anchor, Ke, sr));
                }
              }
            }
            if (Ms = mi, Ot = Ms && Ms.placeable, gs = Ms && Ms.offscreen, Ke.useRuntimeCollisionCircles) {
              const mr = _.text.placedSymbolArray.get(Ke.centerJustifiedTextSymbolIndex), gr = c.ai(_.textSizeData, se, mr), Bn = g.get("text-padding");
              ys = this.collisionIndex.placeCollisionCircles(te, mr, _.lineVertexArray, _.glyphOffsetArray, gr, I, D, k, N, p, Ve, oe.predicate, Ke.collisionCircleDiameter, Bn, T, ut), ys.circles.length && ys.collisionDetected && !p && c.w("Collisions detected, but collision boxes are not shown"), Ot = fe || ys.circles.length > 0 && !ys.collisionDetected, gs = gs && ys.offscreen;
            }
            if (et.iconFeatureIndex && (Vl = et.iconFeatureIndex), et.iconBox) {
              const mr = (gr) => this.collisionIndex.placeCollisionBox(gr, ge, H, I, D, Ve, Fe, S, oe.predicate, ut, Ye && Ir ? Ir : void 0);
              Vs && Vs.placeable && et.verticalIconBox ? (Ps = mr(et.verticalIconBox), _i = Ps.placeable) : (Ps = mr(et.iconBox), _i = Ps.placeable), gs = gs && Ps.offscreen;
            }
            const _r = ae || Ke.numHorizontalGlyphVertices === 0 && Ke.numVerticalGlyphVertices === 0, Hl = he || Ke.numIconVertices === 0;
            _r || Hl ? Hl ? _r || (_i = _i && Ot) : Ot = _i && Ot : _i = Ot = _i && Ot;
            const Rh = _i && Ps.placeable;
            if (Ot && Ms.placeable && this.collisionIndex.insertCollisionBox(Ms.box, te, g.get("text-ignore-placement"), _.bucketInstanceId, Vs && Vs.placeable && $o ? $o : Kr, oe.ID), Rh && this.collisionIndex.insertCollisionBox(Ps.box, ge, g.get("icon-ignore-placement"), _.bucketInstanceId, Vl, oe.ID), ys && Ot && this.collisionIndex.insertCollisionCircles(ys.circles, te, g.get("text-ignore-placement"), _.bucketInstanceId, Kr, oe.ID), p && this.storeCollisionData(_.bucketInstanceId, At, et, Ms, Ps, ys), Ke.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            if (_.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[Ke.crossTileID] = new Ct(Ot || Ze, _i || Ge, gs || _.justReloaded), d[Ke.crossTileID] = !0;
          };
          if (st) {
            if (r.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
            const Ke = _.getSortedSymbolIndexes(this.transform.angle);
            for (let et = Ke.length - 1; et >= 0; --et) {
              const At = Ke[et];
              Et(_.symbolInstances.get(At), _.collisionArrays[At], At);
            }
          } else for (let Ke = r.symbolInstanceStart; Ke < r.symbolInstanceEnd; Ke++) Et(_.symbolInstances.get(Ke), _.collisionArrays[Ke], Ke);
          if (p && _.bucketInstanceId in this.collisionCircleArrays) {
            const Ke = this.collisionCircleArrays[_.bucketInstanceId];
            c.as(Ke.invProjMatrix, I), Ke.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          _.justReloaded = !1;
        }
        storeCollisionData(r, d, p, _, g, T) {
          if (p.textBox || p.iconBox) {
            let S, I;
            this.collisionBoxArrays.has(r) ? S = this.collisionBoxArrays.get(r) : (S = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(r, S)), S.has(d) ? I = S.get(d) : (I = { text: null, icon: null }, S.set(d, I)), p.textBox && (I.text = _.box), p.iconBox && (I.icon = g.box);
          }
          if (T) {
            let S = this.collisionCircleArrays[r];
            S === void 0 && (S = this.collisionCircleArrays[r] = new Vt());
            for (let I = 0; I < T.circles.length; I += 4) S.circles.push(T.circles[I + 0]), S.circles.push(T.circles[I + 1]), S.circles.push(T.circles[I + 2]), S.circles.push(T.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(r, d, p, _) {
          let g;
          g = _ === c.ah.vertical ? p.verticalPlacedTextSymbolIndex : { left: p.leftJustifiedTextSymbolIndex, center: p.centerJustifiedTextSymbolIndex, right: p.rightJustifiedTextSymbolIndex }[c.at(d)];
          const T = [p.leftJustifiedTextSymbolIndex, p.centerJustifiedTextSymbolIndex, p.rightJustifiedTextSymbolIndex, p.verticalPlacedTextSymbolIndex];
          for (const S of T) S >= 0 && (r.text.placedSymbolArray.get(S).crossTileID = g >= 0 && S !== g ? 0 : p.crossTileID);
        }
        markUsedOrientation(r, d, p) {
          const _ = d === c.ah.horizontal || d === c.ah.horizontalOnly ? d : 0, g = d === c.ah.vertical ? d : 0, T = [p.leftJustifiedTextSymbolIndex, p.centerJustifiedTextSymbolIndex, p.rightJustifiedTextSymbolIndex];
          for (const S of T) r.text.placedSymbolArray.get(S).placedOrientation = _;
          p.verticalPlacedTextSymbolIndex && (r.text.placedSymbolArray.get(p.verticalPlacedTextSymbolIndex).placedOrientation = g);
        }
        commit(r) {
          this.commitTime = r, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const d = this.prevPlacement;
          let p = !1;
          this.prevZoomAdjustment = d ? d.zoomAdjustment(this.transform.zoom) : 0;
          const _ = d ? d.symbolFadeChange(r) : 1, g = d ? d.opacities : {}, T = d ? d.variableOffsets : {}, S = d ? d.placedOrientations : {};
          for (const I in this.placements) {
            const D = this.placements[I], k = g[I];
            k ? (this.opacities[I] = new li(k, _, D.text, D.icon), p = p || D.text !== k.text.placed || D.icon !== k.icon.placed) : (this.opacities[I] = new li(null, _, D.text, D.icon, D.skipFade), p = p || D.text || D.icon);
          }
          for (const I in g) {
            const D = g[I];
            if (!this.opacities[I]) {
              const k = new li(D, _, !1, !1);
              k.isHidden() || (this.opacities[I] = k, p = p || D.text.placed || D.icon.placed);
            }
          }
          for (const I in T) this.variableOffsets[I] || !this.opacities[I] || this.opacities[I].isHidden() || (this.variableOffsets[I] = T[I]);
          for (const I in S) this.placedOrientations[I] || !this.opacities[I] || this.opacities[I].isHidden() || (this.placedOrientations[I] = S[I]);
          if (d && d.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
          p ? this.lastPlacementChangeTime = r : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = d ? d.lastPlacementChangeTime : r);
        }
        updateLayerOpacities(r, d) {
          const p = {};
          for (const _ of d) {
            const g = _.getBucket(r);
            g && _.latestFeatureIndex && r.id === g.layerIds[0] && this.updateBucketOpacities(g, _.tileID, p, _.collisionBoxArray);
          }
        }
        updateBucketOpacities(r, d, p, _) {
          r.hasTextData() && (r.text.opacityVertexArray.clear(), r.text.hasVisibleVertices = !1), r.hasIconData() && (r.icon.opacityVertexArray.clear(), r.icon.hasVisibleVertices = !1), r.hasIconCollisionBoxData() && r.iconCollisionBox.collisionVertexArray.clear(), r.hasTextCollisionBoxData() && r.textCollisionBox.collisionVertexArray.clear();
          const g = r.layers[0], T = g.layout, S = new li(null, 0, !1, !1, !0), I = T.get("text-allow-overlap"), D = T.get("icon-allow-overlap"), k = g._unevaluatedLayout.hasValue("text-variable-anchor") || g._unevaluatedLayout.hasValue("text-variable-anchor-offset"), N = T.get("text-rotation-alignment") === "map", H = T.get("text-pitch-alignment") === "map", q = T.get("icon-text-fit") !== "none", K = new li(null, 0, I && (D || !r.hasIconData() || T.get("icon-optional")), D && (I || !r.hasTextData() || T.get("text-optional")), !0);
          !r.collisionArrays && _ && (r.hasIconCollisionBoxData() || r.hasTextCollisionBoxData()) && r.deserializeCollisionBoxes(_);
          const se = (ae, he, te) => {
            for (let fe = 0; fe < he / 4; fe++) ae.opacityVertexArray.emplaceBack(te);
            ae.hasVisibleVertices = ae.hasVisibleVertices || te !== on;
          }, oe = this.collisionBoxArrays.get(r.bucketInstanceId);
          for (let ae = 0; ae < r.symbolInstances.length; ae++) {
            const he = r.symbolInstances.get(ae), { numHorizontalGlyphVertices: te, numVerticalGlyphVertices: fe, crossTileID: ge } = he;
            let Te = this.opacities[ge];
            p[ge] ? Te = S : Te || (Te = K, this.opacities[ge] = Te), p[ge] = !0;
            const Fe = he.numIconVertices > 0, Ve = this.placedOrientations[he.crossTileID], Ye = Ve === c.ah.vertical, st = Ve === c.ah.horizontal || Ve === c.ah.horizontalOnly;
            if (te > 0 || fe > 0) {
              const Ge = Ri(Te.text);
              se(r.text, te, Ye ? on : Ge), se(r.text, fe, st ? on : Ge);
              const ut = Te.text.isHidden();
              [he.rightJustifiedTextSymbolIndex, he.centerJustifiedTextSymbolIndex, he.leftJustifiedTextSymbolIndex].forEach((et) => {
                et >= 0 && (r.text.placedSymbolArray.get(et).hidden = ut || Ye ? 1 : 0);
              }), he.verticalPlacedTextSymbolIndex >= 0 && (r.text.placedSymbolArray.get(he.verticalPlacedTextSymbolIndex).hidden = ut || st ? 1 : 0);
              const Et = this.variableOffsets[he.crossTileID];
              Et && this.markUsedJustification(r, Et.anchor, he, Ve);
              const Ke = this.placedOrientations[he.crossTileID];
              Ke && (this.markUsedJustification(r, "left", he, Ke), this.markUsedOrientation(r, Ke, he));
            }
            if (Fe) {
              const Ge = Ri(Te.icon), ut = !(q && he.verticalPlacedIconSymbolIndex && Ye);
              he.placedIconSymbolIndex >= 0 && (se(r.icon, he.numIconVertices, ut ? Ge : on), r.icon.placedSymbolArray.get(he.placedIconSymbolIndex).hidden = Te.icon.isHidden()), he.verticalPlacedIconSymbolIndex >= 0 && (se(r.icon, he.numVerticalIconVertices, ut ? on : Ge), r.icon.placedSymbolArray.get(he.verticalPlacedIconSymbolIndex).hidden = Te.icon.isHidden());
            }
            const Ze = oe && oe.has(ae) ? oe.get(ae) : { text: null, icon: null };
            if (r.hasIconCollisionBoxData() || r.hasTextCollisionBoxData()) {
              const Ge = r.collisionArrays[ae];
              if (Ge) {
                let ut = new c.P(0, 0);
                if (Ge.textBox || Ge.verticalTextBox) {
                  let Et = !0;
                  if (k) {
                    const Ke = this.variableOffsets[ge];
                    Ke ? (ut = Ui(Ke.anchor, Ke.width, Ke.height, Ke.textOffset, Ke.textBoxScale), N && ut._rotate(H ? this.transform.angle : -this.transform.angle)) : Et = !1;
                  }
                  if (Ge.textBox || Ge.verticalTextBox) {
                    let Ke;
                    Ge.textBox && (Ke = Ye), Ge.verticalTextBox && (Ke = st), Rn(r.textCollisionBox.collisionVertexArray, Te.text.placed, !Et || Ke, Ze.text, ut.x, ut.y);
                  }
                }
                if (Ge.iconBox || Ge.verticalIconBox) {
                  const Et = !!(!st && Ge.verticalIconBox);
                  let Ke;
                  Ge.iconBox && (Ke = Et), Ge.verticalIconBox && (Ke = !Et), Rn(r.iconCollisionBox.collisionVertexArray, Te.icon.placed, Ke, Ze.icon, q ? ut.x : 0, q ? ut.y : 0);
                }
              }
            }
          }
          if (r.sortFeatures(this.transform.angle), this.retainedQueryData[r.bucketInstanceId] && (this.retainedQueryData[r.bucketInstanceId].featureSortOrder = r.featureSortOrder), r.hasTextData() && r.text.opacityVertexBuffer && r.text.opacityVertexBuffer.updateData(r.text.opacityVertexArray), r.hasIconData() && r.icon.opacityVertexBuffer && r.icon.opacityVertexBuffer.updateData(r.icon.opacityVertexArray), r.hasIconCollisionBoxData() && r.iconCollisionBox.collisionVertexBuffer && r.iconCollisionBox.collisionVertexBuffer.updateData(r.iconCollisionBox.collisionVertexArray), r.hasTextCollisionBoxData() && r.textCollisionBox.collisionVertexBuffer && r.textCollisionBox.collisionVertexBuffer.updateData(r.textCollisionBox.collisionVertexArray), r.text.opacityVertexArray.length !== r.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${r.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${r.text.layoutVertexArray.length}) / 4`);
          if (r.icon.opacityVertexArray.length !== r.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${r.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${r.icon.layoutVertexArray.length}) / 4`);
          if (r.bucketInstanceId in this.collisionCircleArrays) {
            const ae = this.collisionCircleArrays[r.bucketInstanceId];
            r.placementInvProjMatrix = ae.invProjMatrix, r.placementViewportMatrix = ae.viewportMatrix, r.collisionCircleArray = ae.circles, delete this.collisionCircleArrays[r.bucketInstanceId];
          }
        }
        symbolFadeChange(r) {
          return this.fadeDuration === 0 ? 1 : (r - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(r) {
          return Math.max(0, (this.transform.zoom - r) / 1.5);
        }
        hasTransitions(r) {
          return this.stale || r - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(r, d) {
          const p = this.zoomAtLastRecencyCheck === d ? 1 - this.zoomAdjustment(d) : 1;
          return this.zoomAtLastRecencyCheck = d, this.commitTime + this.fadeDuration * p > r;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function Rn(y, r, d, p, _, g) {
        p && p.length !== 0 || (p = [0, 0, 0, 0]);
        const T = p[0] - St, S = p[1] - St, I = p[2] - St, D = p[3] - St;
        y.emplaceBack(r ? 1 : 0, d ? 1 : 0, _ || 0, g || 0, T, S), y.emplaceBack(r ? 1 : 0, d ? 1 : 0, _ || 0, g || 0, I, S), y.emplaceBack(r ? 1 : 0, d ? 1 : 0, _ || 0, g || 0, I, D), y.emplaceBack(r ? 1 : 0, d ? 1 : 0, _ || 0, g || 0, T, D);
      }
      const jt = Math.pow(2, 25), fs = Math.pow(2, 24), jr = Math.pow(2, 17), Di = Math.pow(2, 16), Ci = Math.pow(2, 9), Yn = Math.pow(2, 8), Ii = Math.pow(2, 1);
      function Ri(y) {
        if (y.opacity === 0 && !y.placed) return 0;
        if (y.opacity === 1 && y.placed) return 4294967295;
        const r = y.placed ? 1 : 0, d = Math.floor(127 * y.opacity);
        return d * jt + r * fs + d * jr + r * Di + d * Ci + r * Yn + d * Ii + r;
      }
      const on = 0;
      function $r() {
        return { isOccluded: (y, r, d) => !1, getPitchedTextCorrection: (y, r, d) => 1, get useSpecialProjectionForSymbols() {
          return !1;
        }, projectTileCoordinates(y, r, d, p) {
          throw new Error("Not implemented.");
        }, translatePosition: (y, r, d, p) => function(_, g, T, S, I = !1) {
          if (!T[0] && !T[1]) return [0, 0];
          const D = I ? S === "map" ? _.angle : 0 : S === "viewport" ? -_.angle : 0;
          if (D) {
            const k = Math.sin(D), N = Math.cos(D);
            T = [T[0] * N - T[1] * k, T[0] * k + T[1] * N];
          }
          return [I ? T[0] : Pt(g, T[0], _.zoom), I ? T[1] : Pt(g, T[1], _.zoom)];
        }(y, r, d, p), getCircleRadiusCorrection: (y) => 1 };
      }
      class xi {
        constructor(r) {
          this._sortAcrossTiles = r.layout.get("symbol-z-order") !== "viewport-y" && !r.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(r, d, p, _, g) {
          const T = this._bucketParts;
          for (; this._currentTileIndex < r.length; ) if (d.getBucketParts(T, _, r[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, g()) return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, T.sort((S, I) => S.sortKey - I.sortKey)); this._currentPartIndex < T.length; ) if (d.placeLayerBucketPart(T[this._currentPartIndex], this._seenCrossTileIDs, p), this._currentPartIndex++, g()) return !0;
          return !1;
        }
      }
      class os {
        constructor(r, d, p, _, g, T, S, I) {
          this.placement = new ns(r, $r(), d, T, S, I), this._currentPlacementIndex = p.length - 1, this._forceFullPlacement = _, this._showCollisionBoxes = g, this._done = !1;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(r, d, p) {
          const _ = M.now(), g = () => !this._forceFullPlacement && M.now() - _ > 2;
          for (; this._currentPlacementIndex >= 0; ) {
            const T = d[r[this._currentPlacementIndex]], S = this.placement.collisionIndex.transform.zoom;
            if (T.type === "symbol" && (!T.minzoom || T.minzoom <= S) && (!T.maxzoom || T.maxzoom > S)) {
              if (this._inProgressLayer || (this._inProgressLayer = new xi(T)), this._inProgressLayer.continuePlacement(p[T.source], this.placement, this._showCollisionBoxes, T, g)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(r) {
          return this.placement.commit(r), this.placement;
        }
      }
      const ps = 512 / c.X / 2;
      class wi {
        constructor(r, d, p) {
          this.tileID = r, this.bucketInstanceId = p, this._symbolsByKey = {};
          const _ = /* @__PURE__ */ new Map();
          for (let g = 0; g < d.length; g++) {
            const T = d.get(g), S = T.key, I = _.get(S);
            I ? I.push(T) : _.set(S, [T]);
          }
          for (const [g, T] of _) {
            const S = { positions: T.map((I) => ({ x: Math.floor(I.anchorX * ps), y: Math.floor(I.anchorY * ps) })), crossTileIDs: T.map((I) => I.crossTileID) };
            if (S.positions.length > 128) {
              const I = new c.av(S.positions.length, 16, Uint16Array);
              for (const { x: D, y: k } of S.positions) I.add(D, k);
              I.finish(), delete S.positions, S.index = I;
            }
            this._symbolsByKey[g] = S;
          }
        }
        getScaledCoordinates(r, d) {
          const { x: p, y: _, z: g } = this.tileID.canonical, { x: T, y: S, z: I } = d.canonical, D = ps / Math.pow(2, I - g), k = (S * c.X + r.anchorY) * D, N = _ * c.X * ps;
          return { x: Math.floor((T * c.X + r.anchorX) * D - p * c.X * ps), y: Math.floor(k - N) };
        }
        findMatches(r, d, p) {
          const _ = this.tileID.canonical.z < d.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - d.canonical.z);
          for (let g = 0; g < r.length; g++) {
            const T = r.get(g);
            if (T.crossTileID) continue;
            const S = this._symbolsByKey[T.key];
            if (!S) continue;
            const I = this.getScaledCoordinates(T, d);
            if (S.index) {
              const D = S.index.range(I.x - _, I.y - _, I.x + _, I.y + _).sort();
              for (const k of D) {
                const N = S.crossTileIDs[k];
                if (!p[N]) {
                  p[N] = !0, T.crossTileID = N;
                  break;
                }
              }
            } else if (S.positions) for (let D = 0; D < S.positions.length; D++) {
              const k = S.positions[D], N = S.crossTileIDs[D];
              if (Math.abs(k.x - I.x) <= _ && Math.abs(k.y - I.y) <= _ && !p[N]) {
                p[N] = !0, T.crossTileID = N;
                break;
              }
            }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map(({ crossTileIDs: r }) => r);
        }
      }
      class Mn {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class Rs {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(r) {
          const d = Math.round((r - this.lng) / 360);
          if (d !== 0) for (const p in this.indexes) {
            const _ = this.indexes[p], g = {};
            for (const T in _) {
              const S = _[T];
              S.tileID = S.tileID.unwrapTo(S.tileID.wrap + d), g[S.tileID.key] = S;
            }
            this.indexes[p] = g;
          }
          this.lng = r;
        }
        addBucket(r, d, p) {
          if (this.indexes[r.overscaledZ] && this.indexes[r.overscaledZ][r.key]) {
            if (this.indexes[r.overscaledZ][r.key].bucketInstanceId === d.bucketInstanceId) return !1;
            this.removeBucketCrossTileIDs(r.overscaledZ, this.indexes[r.overscaledZ][r.key]);
          }
          for (let g = 0; g < d.symbolInstances.length; g++) d.symbolInstances.get(g).crossTileID = 0;
          this.usedCrossTileIDs[r.overscaledZ] || (this.usedCrossTileIDs[r.overscaledZ] = {});
          const _ = this.usedCrossTileIDs[r.overscaledZ];
          for (const g in this.indexes) {
            const T = this.indexes[g];
            if (Number(g) > r.overscaledZ) for (const S in T) {
              const I = T[S];
              I.tileID.isChildOf(r) && I.findMatches(d.symbolInstances, r, _);
            }
            else {
              const S = T[r.scaledTo(Number(g)).key];
              S && S.findMatches(d.symbolInstances, r, _);
            }
          }
          for (let g = 0; g < d.symbolInstances.length; g++) {
            const T = d.symbolInstances.get(g);
            T.crossTileID || (T.crossTileID = p.generate(), _[T.crossTileID] = !0);
          }
          return this.indexes[r.overscaledZ] === void 0 && (this.indexes[r.overscaledZ] = {}), this.indexes[r.overscaledZ][r.key] = new wi(r, d.symbolInstances, d.bucketInstanceId), !0;
        }
        removeBucketCrossTileIDs(r, d) {
          for (const p of d.getCrossTileIDsLists()) for (const _ of p) delete this.usedCrossTileIDs[r][_];
        }
        removeStaleBuckets(r) {
          let d = !1;
          for (const p in this.indexes) {
            const _ = this.indexes[p];
            for (const g in _) r[_[g].bucketInstanceId] || (this.removeBucketCrossTileIDs(p, _[g]), delete _[g], d = !0);
          }
          return d;
        }
      }
      class Qn {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new Mn(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(r, d, p) {
          let _ = this.layerIndexes[r.id];
          _ === void 0 && (_ = this.layerIndexes[r.id] = new Rs());
          let g = !1;
          const T = {};
          _.handleWrapJump(p);
          for (const S of d) {
            const I = S.getBucket(r);
            I && r.id === I.layerIds[0] && (I.bucketInstanceId || (I.bucketInstanceId = ++this.maxBucketInstanceId), _.addBucket(S.tileID, I, this.crossTileIDs) && (g = !0), T[I.bucketInstanceId] = !0);
          }
          return _.removeStaleBuckets(T) && (g = !0), g;
        }
        pruneUnusedLayers(r) {
          const d = {};
          r.forEach((p) => {
            d[p] = !0;
          });
          for (const p in this.layerIndexes) d[p] || delete this.layerIndexes[p];
        }
      }
      const _s = (y, r) => c.t(y, r && r.filter((d) => d.identifier !== "source.canvas")), Gr = c.aw();
      class Eo extends c.E {
        constructor(r, d = {}) {
          super(), this._rtlPluginLoaded = () => {
            for (const p in this.sourceCaches) {
              const _ = this.sourceCaches[p].getSource().type;
              _ !== "vector" && _ !== "geojson" || this.sourceCaches[p].reload();
            }
          }, this.map = r, this.dispatcher = new Bi(ni(), r._getMapId()), this.dispatcher.registerMessageHandler("GG", (p, _) => this.getGlyphs(p, _)), this.dispatcher.registerMessageHandler("GI", (p, _) => this.getImages(p, _)), this.imageManager = new Rt(), this.imageManager.setEventedParent(this), this.glyphManager = new Hi(r._requestManager, d.localIdeographFontFamily), this.lineAtlas = new Tn(256, 512), this.crossTileSymbolIndex = new Qn(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new c.ax(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", c.ay()), Is().on(He, this._rtlPluginLoaded), this.on("data", (p) => {
            if (p.dataType !== "source" || p.sourceDataType !== "metadata") return;
            const _ = this.sourceCaches[p.sourceId];
            if (!_) return;
            const g = _.getSource();
            if (g && g.vectorLayerIds) for (const T in this._layers) {
              const S = this._layers[T];
              S.source === g.id && this._validateLayer(S);
            }
          });
        }
        loadURL(r, d = {}, p) {
          this.fire(new c.k("dataloading", { dataType: "style" })), d.validate = typeof d.validate != "boolean" || d.validate;
          const _ = this.map._requestManager.transformRequest(r, "Style");
          this._loadStyleRequest = new AbortController();
          const g = this._loadStyleRequest;
          c.h(_, this._loadStyleRequest).then((T) => {
            this._loadStyleRequest = null, this._load(T.data, d, p);
          }).catch((T) => {
            this._loadStyleRequest = null, T && !g.signal.aborted && this.fire(new c.j(T));
          });
        }
        loadJSON(r, d = {}, p) {
          this.fire(new c.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), M.frameAsync(this._frameRequest).then(() => {
            this._frameRequest = null, d.validate = d.validate !== !1, this._load(r, d, p);
          }).catch(() => {
          });
        }
        loadEmpty() {
          this.fire(new c.k("dataloading", { dataType: "style" })), this._load(Gr, { validate: !1 });
        }
        _load(r, d, p) {
          var _;
          const g = d.transformStyle ? d.transformStyle(p, r) : r;
          if (!d.validate || !_s(this, c.u(g))) {
            this._loaded = !0, this.stylesheet = g;
            for (const T in g.sources) this.addSource(T, g.sources[T], { validate: !1 });
            g.sprite ? this._loadSprite(g.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(g.glyphs), this._createLayers(), this.light = new ji(this.stylesheet.light), this.sky = new Pi(this.stylesheet.sky), this.map.setTerrain((_ = this.stylesheet.terrain) !== null && _ !== void 0 ? _ : null), this.fire(new c.k("data", { dataType: "style" })), this.fire(new c.k("style.load"));
          }
        }
        _createLayers() {
          const r = c.az(this.stylesheet.layers);
          this.dispatcher.broadcast("SL", r), this._order = r.map((d) => d.id), this._layers = {}, this._serializedLayers = null;
          for (const d of r) {
            const p = c.aA(d);
            p.setEventedParent(this, { layer: { id: d.id } }), this._layers[d.id] = p;
          }
        }
        _loadSprite(r, d = !1, p = void 0) {
          let _;
          this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(g, T, S, I) {
            return c._(this, void 0, void 0, function* () {
              const D = We(g), k = S > 1 ? "@2x" : "", N = {}, H = {};
              for (const { id: q, url: K } of D) {
                const se = T.transformRequest(at(K, k, ".json"), "SpriteJSON");
                N[q] = c.h(se, I);
                const oe = T.transformRequest(at(K, k, ".png"), "SpriteImage");
                H[q] = Ee.getImage(oe, I);
              }
              return yield Promise.all([...Object.values(N), ...Object.values(H)]), function(q, K) {
                return c._(this, void 0, void 0, function* () {
                  const se = {};
                  for (const oe in q) {
                    se[oe] = {};
                    const ae = M.getImageCanvasContext((yield K[oe]).data), he = (yield q[oe]).data;
                    for (const te in he) {
                      const { width: fe, height: ge, x: Te, y: Fe, sdf: Ve, pixelRatio: Ye, stretchX: st, stretchY: Ze, content: Ge, textFitWidth: ut, textFitHeight: Et } = he[te];
                      se[oe][te] = { data: null, pixelRatio: Ye, sdf: Ve, stretchX: st, stretchY: Ze, content: Ge, textFitWidth: ut, textFitHeight: Et, spriteData: { width: fe, height: ge, x: Te, y: Fe, context: ae } };
                    }
                  }
                  return se;
                });
              }(N, H);
            });
          }(r, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((g) => {
            if (this._spriteRequest = null, g) for (const T in g) {
              this._spritesImagesIds[T] = [];
              const S = this._spritesImagesIds[T] ? this._spritesImagesIds[T].filter((I) => !(I in g)) : [];
              for (const I of S) this.imageManager.removeImage(I), this._changedImages[I] = !0;
              for (const I in g[T]) {
                const D = T === "default" ? I : `${T}:${I}`;
                this._spritesImagesIds[T].push(D), D in this.imageManager.images ? this.imageManager.updateImage(D, g[T][I], !1) : this.imageManager.addImage(D, g[T][I]), d && (this._changedImages[D] = !0);
              }
            }
          }).catch((g) => {
            this._spriteRequest = null, _ = g, this.fire(new c.j(_));
          }).finally(() => {
            this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), d && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.k("data", { dataType: "style" })), p && p(_);
          });
        }
        _unloadSprite() {
          for (const r of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(r), this._changedImages[r] = !0;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.k("data", { dataType: "style" }));
        }
        _validateLayer(r) {
          const d = this.sourceCaches[r.source];
          if (!d) return;
          const p = r.sourceLayer;
          if (!p) return;
          const _ = d.getSource();
          (_.type === "geojson" || _.vectorLayerIds && _.vectorLayerIds.indexOf(p) === -1) && this.fire(new c.j(new Error(`Source layer "${p}" does not exist on source "${_.id}" as specified by style layer "${r.id}".`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
          for (const r in this.sourceCaches) if (!this.sourceCaches[r].loaded()) return !1;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(r, d = !1) {
          const p = this._serializedAllLayers();
          if (!r || r.length === 0) return Object.values(d ? c.aB(p) : p);
          const _ = [];
          for (const g of r) if (p[g]) {
            const T = d ? c.aB(p[g]) : p[g];
            _.push(T);
          }
          return _;
        }
        _serializedAllLayers() {
          let r = this._serializedLayers;
          if (r) return r;
          r = this._serializedLayers = {};
          const d = Object.keys(this._layers);
          for (const p of d) {
            const _ = this._layers[p];
            _.type !== "custom" && (r[p] = _.serialize());
          }
          return r;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition() || this.sky && this.sky.hasTransition()) return !0;
          for (const r in this.sourceCaches) if (this.sourceCaches[r].hasTransition()) return !0;
          for (const r in this._layers) if (this._layers[r].hasTransition()) return !0;
          return !1;
        }
        _checkLoaded() {
          if (!this._loaded) throw new Error("Style is not done loading.");
        }
        update(r) {
          if (!this._loaded) return;
          const d = this._changed;
          if (d) {
            const _ = Object.keys(this._updatedLayers), g = Object.keys(this._removedLayers);
            (_.length || g.length) && this._updateWorkerLayers(_, g);
            for (const T in this._updatedSources) {
              const S = this._updatedSources[T];
              if (S === "reload") this._reloadSource(T);
              else {
                if (S !== "clear") throw new Error(`Invalid action ${S}`);
                this._clearSource(T);
              }
            }
            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
            for (const T in this._updatedPaintProps) this._layers[T].updateTransitions(r);
            this.light.updateTransitions(r), this.sky.updateTransitions(r), this._resetUpdates();
          }
          const p = {};
          for (const _ in this.sourceCaches) {
            const g = this.sourceCaches[_];
            p[_] = g.used, g.used = !1;
          }
          for (const _ of this._order) {
            const g = this._layers[_];
            g.recalculate(r, this._availableImages), !g.isHidden(r.zoom) && g.source && (this.sourceCaches[g.source].used = !0);
          }
          for (const _ in p) {
            const g = this.sourceCaches[_];
            !!p[_] != !!g.used && g.fire(new c.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: _ }));
          }
          this.light.recalculate(r), this.sky.recalculate(r), this.z = r.zoom, d && this.fire(new c.k("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const r = Object.keys(this._changedImages);
          if (r.length) {
            for (const d in this.sourceCaches) this.sourceCaches[d].reloadTilesForDependencies(["icons", "patterns"], r);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const r in this.sourceCaches) this.sourceCaches[r].reloadTilesForDependencies(["glyphs"], [""]);
            this._glyphsDidChange = !1;
          }
        }
        _updateWorkerLayers(r, d) {
          this.dispatcher.broadcast("UL", { layers: this._serializeByIds(r, !1), removedIds: d });
        }
        _resetUpdates() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
        }
        setState(r, d = {}) {
          var p;
          this._checkLoaded();
          const _ = this.serialize();
          if (r = d.transformStyle ? d.transformStyle(_, r) : r, ((p = d.validate) === null || p === void 0 || p) && _s(this, c.u(r))) return !1;
          (r = c.aB(r)).layers = c.az(r.layers);
          const g = c.aC(_, r), T = this._getOperationsToPerform(g);
          if (T.unimplemented.length > 0) throw new Error(`Unimplemented: ${T.unimplemented.join(", ")}.`);
          if (T.operations.length === 0) return !1;
          for (const S of T.operations) S();
          return this.stylesheet = r, this._serializedLayers = null, !0;
        }
        _getOperationsToPerform(r) {
          const d = [], p = [];
          for (const _ of r) switch (_.command) {
            case "setCenter":
            case "setZoom":
            case "setBearing":
            case "setPitch":
              continue;
            case "addLayer":
              d.push(() => this.addLayer.apply(this, _.args));
              break;
            case "removeLayer":
              d.push(() => this.removeLayer.apply(this, _.args));
              break;
            case "setPaintProperty":
              d.push(() => this.setPaintProperty.apply(this, _.args));
              break;
            case "setLayoutProperty":
              d.push(() => this.setLayoutProperty.apply(this, _.args));
              break;
            case "setFilter":
              d.push(() => this.setFilter.apply(this, _.args));
              break;
            case "addSource":
              d.push(() => this.addSource.apply(this, _.args));
              break;
            case "removeSource":
              d.push(() => this.removeSource.apply(this, _.args));
              break;
            case "setLayerZoomRange":
              d.push(() => this.setLayerZoomRange.apply(this, _.args));
              break;
            case "setLight":
              d.push(() => this.setLight.apply(this, _.args));
              break;
            case "setGeoJSONSourceData":
              d.push(() => this.setGeoJSONSourceData.apply(this, _.args));
              break;
            case "setGlyphs":
              d.push(() => this.setGlyphs.apply(this, _.args));
              break;
            case "setSprite":
              d.push(() => this.setSprite.apply(this, _.args));
              break;
            case "setSky":
              d.push(() => this.setSky.apply(this, _.args));
              break;
            case "setTerrain":
              d.push(() => this.map.setTerrain.apply(this, _.args));
              break;
            case "setTransition":
              d.push(() => {
              });
              break;
            default:
              p.push(_.command);
          }
          return { operations: d, unimplemented: p };
        }
        addImage(r, d) {
          if (this.getImage(r)) return this.fire(new c.j(new Error(`An image named "${r}" already exists.`)));
          this.imageManager.addImage(r, d), this._afterImageUpdated(r);
        }
        updateImage(r, d) {
          this.imageManager.updateImage(r, d);
        }
        getImage(r) {
          return this.imageManager.getImage(r);
        }
        removeImage(r) {
          if (!this.getImage(r)) return this.fire(new c.j(new Error(`An image named "${r}" does not exist.`)));
          this.imageManager.removeImage(r), this._afterImageUpdated(r);
        }
        _afterImageUpdated(r) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[r] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.k("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(r, d, p = {}) {
          if (this._checkLoaded(), this.sourceCaches[r] !== void 0) throw new Error(`Source "${r}" already exists.`);
          if (!d.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(d).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(d.type) >= 0 && this._validate(c.u.source, `sources.${r}`, d, null, p)) return;
          this.map && this.map._collectResourceTiming && (d.collectResourceTiming = !0);
          const _ = this.sourceCaches[r] = new xt(r, d, this.dispatcher);
          _.style = this, _.setEventedParent(this, () => ({ isSourceLoaded: _.loaded(), source: _.serialize(), sourceId: r })), _.onAdd(this.map), this._changed = !0;
        }
        removeSource(r) {
          if (this._checkLoaded(), this.sourceCaches[r] === void 0) throw new Error("There is no source with this ID");
          for (const p in this._layers) if (this._layers[p].source === r) return this.fire(new c.j(new Error(`Source "${r}" cannot be removed while layer "${p}" is using it.`)));
          const d = this.sourceCaches[r];
          delete this.sourceCaches[r], delete this._updatedSources[r], d.fire(new c.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: r })), d.setEventedParent(null), d.onRemove(this.map), this._changed = !0;
        }
        setGeoJSONSourceData(r, d) {
          if (this._checkLoaded(), this.sourceCaches[r] === void 0) throw new Error(`There is no source with this ID=${r}`);
          const p = this.sourceCaches[r].getSource();
          if (p.type !== "geojson") throw new Error(`geojsonSource.type is ${p.type}, which is !== 'geojson`);
          p.setData(d), this._changed = !0;
        }
        getSource(r) {
          return this.sourceCaches[r] && this.sourceCaches[r].getSource();
        }
        addLayer(r, d, p = {}) {
          this._checkLoaded();
          const _ = r.id;
          if (this.getLayer(_)) return void this.fire(new c.j(new Error(`Layer "${_}" already exists on this map.`)));
          let g;
          if (r.type === "custom") {
            if (_s(this, c.aD(r))) return;
            g = c.aA(r);
          } else {
            if ("source" in r && typeof r.source == "object" && (this.addSource(_, r.source), r = c.aB(r), r = c.e(r, { source: _ })), this._validate(c.u.layer, `layers.${_}`, r, { arrayIndex: -1 }, p)) return;
            g = c.aA(r), this._validateLayer(g), g.setEventedParent(this, { layer: { id: _ } });
          }
          const T = d ? this._order.indexOf(d) : this._order.length;
          if (d && T === -1) this.fire(new c.j(new Error(`Cannot add layer "${_}" before non-existing layer "${d}".`)));
          else {
            if (this._order.splice(T, 0, _), this._layerOrderChanged = !0, this._layers[_] = g, this._removedLayers[_] && g.source && g.type !== "custom") {
              const S = this._removedLayers[_];
              delete this._removedLayers[_], S.type !== g.type ? this._updatedSources[g.source] = "clear" : (this._updatedSources[g.source] = "reload", this.sourceCaches[g.source].pause());
            }
            this._updateLayer(g), g.onAdd && g.onAdd(this.map);
          }
        }
        moveLayer(r, d) {
          if (this._checkLoaded(), this._changed = !0, !this._layers[r]) return void this.fire(new c.j(new Error(`The layer '${r}' does not exist in the map's style and cannot be moved.`)));
          if (r === d) return;
          const p = this._order.indexOf(r);
          this._order.splice(p, 1);
          const _ = d ? this._order.indexOf(d) : this._order.length;
          d && _ === -1 ? this.fire(new c.j(new Error(`Cannot move layer "${r}" before non-existing layer "${d}".`))) : (this._order.splice(_, 0, r), this._layerOrderChanged = !0);
        }
        removeLayer(r) {
          this._checkLoaded();
          const d = this._layers[r];
          if (!d) return void this.fire(new c.j(new Error(`Cannot remove non-existing layer "${r}".`)));
          d.setEventedParent(null);
          const p = this._order.indexOf(r);
          this._order.splice(p, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[r] = d, delete this._layers[r], this._serializedLayers && delete this._serializedLayers[r], delete this._updatedLayers[r], delete this._updatedPaintProps[r], d.onRemove && d.onRemove(this.map);
        }
        getLayer(r) {
          return this._layers[r];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(r) {
          return r in this._layers;
        }
        setLayerZoomRange(r, d, p) {
          this._checkLoaded();
          const _ = this.getLayer(r);
          _ ? _.minzoom === d && _.maxzoom === p || (d != null && (_.minzoom = d), p != null && (_.maxzoom = p), this._updateLayer(_)) : this.fire(new c.j(new Error(`Cannot set the zoom range of non-existing layer "${r}".`)));
        }
        setFilter(r, d, p = {}) {
          this._checkLoaded();
          const _ = this.getLayer(r);
          if (_) {
            if (!c.aE(_.filter, d)) return d == null ? (_.filter = void 0, void this._updateLayer(_)) : void (this._validate(c.u.filter, `layers.${_.id}.filter`, d, null, p) || (_.filter = c.aB(d), this._updateLayer(_)));
          } else this.fire(new c.j(new Error(`Cannot filter non-existing layer "${r}".`)));
        }
        getFilter(r) {
          return c.aB(this.getLayer(r).filter);
        }
        setLayoutProperty(r, d, p, _ = {}) {
          this._checkLoaded();
          const g = this.getLayer(r);
          g ? c.aE(g.getLayoutProperty(d), p) || (g.setLayoutProperty(d, p, _), this._updateLayer(g)) : this.fire(new c.j(new Error(`Cannot style non-existing layer "${r}".`)));
        }
        getLayoutProperty(r, d) {
          const p = this.getLayer(r);
          if (p) return p.getLayoutProperty(d);
          this.fire(new c.j(new Error(`Cannot get style of non-existing layer "${r}".`)));
        }
        setPaintProperty(r, d, p, _ = {}) {
          this._checkLoaded();
          const g = this.getLayer(r);
          g ? c.aE(g.getPaintProperty(d), p) || (g.setPaintProperty(d, p, _) && this._updateLayer(g), this._changed = !0, this._updatedPaintProps[r] = !0, this._serializedLayers = null) : this.fire(new c.j(new Error(`Cannot style non-existing layer "${r}".`)));
        }
        getPaintProperty(r, d) {
          return this.getLayer(r).getPaintProperty(d);
        }
        setFeatureState(r, d) {
          this._checkLoaded();
          const p = r.source, _ = r.sourceLayer, g = this.sourceCaches[p];
          if (g === void 0) return void this.fire(new c.j(new Error(`The source '${p}' does not exist in the map's style.`)));
          const T = g.getSource().type;
          T === "geojson" && _ ? this.fire(new c.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : T !== "vector" || _ ? (r.id === void 0 && this.fire(new c.j(new Error("The feature id parameter must be provided."))), g.setFeatureState(_, r.id, d)) : this.fire(new c.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(r, d) {
          this._checkLoaded();
          const p = r.source, _ = this.sourceCaches[p];
          if (_ === void 0) return void this.fire(new c.j(new Error(`The source '${p}' does not exist in the map's style.`)));
          const g = _.getSource().type, T = g === "vector" ? r.sourceLayer : void 0;
          g !== "vector" || T ? d && typeof r.id != "string" && typeof r.id != "number" ? this.fire(new c.j(new Error("A feature id is required to remove its specific state property."))) : _.removeFeatureState(T, r.id, d) : this.fire(new c.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(r) {
          this._checkLoaded();
          const d = r.source, p = r.sourceLayer, _ = this.sourceCaches[d];
          if (_ !== void 0) return _.getSource().type !== "vector" || p ? (r.id === void 0 && this.fire(new c.j(new Error("The feature id parameter must be provided."))), _.getFeatureState(p, r.id)) : void this.fire(new c.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new c.j(new Error(`The source '${d}' does not exist in the map's style.`)));
        }
        getTransition() {
          return c.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded) return;
          const r = c.aF(this.sourceCaches, (g) => g.serialize()), d = this._serializeByIds(this._order, !0), p = this.map.getTerrain() || void 0, _ = this.stylesheet;
          return c.aG({ version: _.version, name: _.name, metadata: _.metadata, light: _.light, sky: _.sky, center: _.center, zoom: _.zoom, bearing: _.bearing, pitch: _.pitch, sprite: _.sprite, glyphs: _.glyphs, transition: _.transition, sources: r, layers: d, terrain: p }, (g) => g !== void 0);
        }
        _updateLayer(r) {
          this._updatedLayers[r.id] = !0, r.source && !this._updatedSources[r.source] && this.sourceCaches[r.source].getSource().type !== "raster" && (this._updatedSources[r.source] = "reload", this.sourceCaches[r.source].pause()), this._serializedLayers = null, this._changed = !0;
        }
        _flattenAndSortRenderedFeatures(r) {
          const d = (T) => this._layers[T].type === "fill-extrusion", p = {}, _ = [];
          for (let T = this._order.length - 1; T >= 0; T--) {
            const S = this._order[T];
            if (d(S)) {
              p[S] = T;
              for (const I of r) {
                const D = I[S];
                if (D) for (const k of D) _.push(k);
              }
            }
          }
          _.sort((T, S) => S.intersectionZ - T.intersectionZ);
          const g = [];
          for (let T = this._order.length - 1; T >= 0; T--) {
            const S = this._order[T];
            if (d(S)) for (let I = _.length - 1; I >= 0; I--) {
              const D = _[I].feature;
              if (p[D.layer.id] < T) break;
              g.push(D), _.pop();
            }
            else for (const I of r) {
              const D = I[S];
              if (D) for (const k of D) g.push(k.feature);
            }
          }
          return g;
        }
        queryRenderedFeatures(r, d, p) {
          d && d.filter && this._validate(c.u.filter, "queryRenderedFeatures.filter", d.filter, null, d);
          const _ = {};
          if (d && d.layers) {
            if (!Array.isArray(d.layers)) return this.fire(new c.j(new Error("parameters.layers must be an Array."))), [];
            for (const S of d.layers) {
              const I = this._layers[S];
              if (!I) return this.fire(new c.j(new Error(`The layer '${S}' does not exist in the map's style and cannot be queried for features.`))), [];
              _[I.source] = !0;
            }
          }
          const g = [];
          d.availableImages = this._availableImages;
          const T = this._serializedAllLayers();
          for (const S in this.sourceCaches) d.layers && !_[S] || g.push(ks(this.sourceCaches[S], this._layers, T, r, d, p));
          return this.placement && g.push(function(S, I, D, k, N, H, q) {
            const K = {}, se = H.queryRenderedSymbols(k), oe = [];
            for (const ae of Object.keys(se).map(Number)) oe.push(q[ae]);
            oe.sort(Ns);
            for (const ae of oe) {
              const he = ae.featureIndex.lookupSymbolFeatures(se[ae.bucketInstanceId], I, ae.bucketIndex, ae.sourceLayerIndex, N.filter, N.layers, N.availableImages, S);
              for (const te in he) {
                const fe = K[te] = K[te] || [], ge = he[te];
                ge.sort((Te, Fe) => {
                  const Ve = ae.featureSortOrder;
                  if (Ve) {
                    const Ye = Ve.indexOf(Te.featureIndex);
                    return Ve.indexOf(Fe.featureIndex) - Ye;
                  }
                  return Fe.featureIndex - Te.featureIndex;
                });
                for (const Te of ge) fe.push(Te);
              }
            }
            for (const ae in K) K[ae].forEach((he) => {
              const te = he.feature, fe = D[S[ae].source].getFeatureState(te.layer["source-layer"], te.id);
              te.source = te.layer.source, te.layer["source-layer"] && (te.sourceLayer = te.layer["source-layer"]), te.state = fe;
            });
            return K;
          }(this._layers, T, this.sourceCaches, r, d, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(g);
        }
        querySourceFeatures(r, d) {
          d && d.filter && this._validate(c.u.filter, "querySourceFeatures.filter", d.filter, null, d);
          const p = this.sourceCaches[r];
          return p ? function(_, g) {
            const T = _.getRenderableIds().map((D) => _.getTileByID(D)), S = [], I = {};
            for (let D = 0; D < T.length; D++) {
              const k = T[D], N = k.tileID.canonical.key;
              I[N] || (I[N] = !0, k.querySourceFeatures(S, g));
            }
            return S;
          }(p, d) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(r, d = {}) {
          this._checkLoaded();
          const p = this.light.getLight();
          let _ = !1;
          for (const T in r) if (!c.aE(r[T], p[T])) {
            _ = !0;
            break;
          }
          if (!_) return;
          const g = { now: M.now(), transition: c.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(r, d), this.light.updateTransitions(g);
        }
        getSky() {
          var r;
          return (r = this.stylesheet) === null || r === void 0 ? void 0 : r.sky;
        }
        setSky(r, d = {}) {
          const p = this.getSky();
          let _ = !1;
          if (!r && !p) return;
          if (r && !p) _ = !0;
          else if (!r && p) _ = !0;
          else for (const T in r) if (!c.aE(r[T], p[T])) {
            _ = !0;
            break;
          }
          if (!_) return;
          const g = { now: M.now(), transition: c.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.stylesheet.sky = r, this.sky.setSky(r, d), this.sky.updateTransitions(g);
        }
        _validate(r, d, p, _, g = {}) {
          return (!g || g.validate !== !1) && _s(this, r.call(c.u, c.e({ key: d, style: this.serialize(), value: p, styleSpec: c.v }, _)));
        }
        _remove(r = !0) {
          this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Is().off(He, this._rtlPluginLoaded);
          for (const d in this._layers) this._layers[d].setEventedParent(null);
          for (const d in this.sourceCaches) {
            const p = this.sourceCaches[d];
            p.setEventedParent(null), p.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), r && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(r);
        }
        _clearSource(r) {
          this.sourceCaches[r].clearTiles();
        }
        _reloadSource(r) {
          this.sourceCaches[r].resume(), this.sourceCaches[r].reload();
        }
        _updateSources(r) {
          for (const d in this.sourceCaches) this.sourceCaches[d].update(r, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const r in this.sourceCaches) this._reloadSource(r);
        }
        _updatePlacement(r, d, p, _, g = !1) {
          let T = !1, S = !1;
          const I = {};
          for (const D of this._order) {
            const k = this._layers[D];
            if (k.type !== "symbol") continue;
            if (!I[k.source]) {
              const H = this.sourceCaches[k.source];
              I[k.source] = H.getRenderableIds(!0).map((q) => H.getTileByID(q)).sort((q, K) => K.tileID.overscaledZ - q.tileID.overscaledZ || (q.tileID.isLessThan(K.tileID) ? -1 : 1));
            }
            const N = this.crossTileSymbolIndex.addLayer(k, I[k.source], r.center.lng);
            T = T || N;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((g = g || this._layerOrderChanged || p === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(M.now(), r.zoom)) && (this.pauseablePlacement = new os(r, this.map.terrain, this._order, g, d, p, _, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, I), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(M.now()), S = !0), T && this.pauseablePlacement.placement.setStale()), S || T) for (const D of this._order) {
            const k = this._layers[D];
            k.type === "symbol" && this.placement.updateLayerOpacities(k, I[k.source]);
          }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(M.now());
        }
        _releaseSymbolFadeTiles() {
          for (const r in this.sourceCaches) this.sourceCaches[r].releaseSymbolFadeTiles();
        }
        getImages(r, d) {
          return c._(this, void 0, void 0, function* () {
            const p = yield this.imageManager.getImages(d.icons);
            this._updateTilesForChangedImages();
            const _ = this.sourceCaches[d.source];
            return _ && _.setDependencies(d.tileID.key, d.type, d.icons), p;
          });
        }
        getGlyphs(r, d) {
          return c._(this, void 0, void 0, function* () {
            const p = yield this.glyphManager.getGlyphs(d.stacks), _ = this.sourceCaches[d.source];
            return _ && _.setDependencies(d.tileID.key, d.type, [""]), p;
          });
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(r, d = {}) {
          this._checkLoaded(), r && this._validate(c.u.glyphs, "glyphs", r, null, d) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = r, this.glyphManager.entries = {}, this.glyphManager.setURL(r));
        }
        addSprite(r, d, p = {}, _) {
          this._checkLoaded();
          const g = [{ id: r, url: d }], T = [...We(this.stylesheet.sprite), ...g];
          this._validate(c.u.sprite, "sprite", T, null, p) || (this.stylesheet.sprite = T, this._loadSprite(g, !0, _));
        }
        removeSprite(r) {
          this._checkLoaded();
          const d = We(this.stylesheet.sprite);
          if (d.find((p) => p.id === r)) {
            if (this._spritesImagesIds[r]) for (const p of this._spritesImagesIds[r]) this.imageManager.removeImage(p), this._changedImages[p] = !0;
            d.splice(d.findIndex((p) => p.id === r), 1), this.stylesheet.sprite = d.length > 0 ? d : void 0, delete this._spritesImagesIds[r], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.k("data", { dataType: "style" }));
          } else this.fire(new c.j(new Error(`Sprite "${r}" doesn't exists on this map.`)));
        }
        getSprite() {
          return We(this.stylesheet.sprite);
        }
        setSprite(r, d = {}, p) {
          this._checkLoaded(), r && this._validate(c.u.sprite, "sprite", r, null, d) || (this.stylesheet.sprite = r, r ? this._loadSprite(r, !0, p) : (this._unloadSprite(), p && p(null)));
        }
      }
      var Xr = c.Y([{ name: "a_pos", type: "Int16", components: 2 }]);
      const ur = { prelude: Ht(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`), background: Ht(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: Ht(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Ht(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Ht("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Ht(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,get_elevation(floor(a_pos*0.5)),1);gl_Position=u_matrix*pos;}`), heatmapTexture: Ht(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Ht("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_anchor_pos;attribute vec2 a_placed;attribute vec2 a_box_real;uniform mat4 u_matrix;uniform vec2 u_pixel_extrude_scale;varying float v_placed;varying float v_notUsed;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Ht("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Ht("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: Ht(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), fillOutline: Ht(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillOutlinePattern: Ht(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillPattern: Ht(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Ht(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Ht(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Ht(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Ht(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: Ht(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Ht(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Ht(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Ht(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: Ht(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: Ht(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_tex;varying float v_fade_opacity;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Ht(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_data0;varying vec3 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Ht(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec4 v_data0;varying vec4 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Ht("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;varying vec2 v_texture_pos;varying float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture2D(u_texture,v_texture_pos);if (v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);gl_FragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {gl_FragColor=surface_color;}}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform mat4 u_fog_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Ht("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Ht("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);}"), sky: Ht("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform float u_horizon;uniform float u_sky_horizon_blend;void main() {float y=gl_FragCoord.y;if (y > u_horizon) {float blend=y-u_horizon;if (blend < u_sky_horizon_blend) {gl_FragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {gl_FragColor=u_sky_color;}}}", "attribute vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
      function Ht(y, r) {
        const d = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, p = r.match(/attribute ([\w]+) ([\w]+)/g), _ = y.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), g = r.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), T = g ? g.concat(_) : _, S = {};
        return { fragmentSource: y = y.replace(d, (I, D, k, N, H) => (S[H] = !0, D === "define" ? `
#ifndef HAS_UNIFORM_u_${H}
varying ${k} ${N} ${H};
#else
uniform ${k} ${N} u_${H};
#endif
` : `
#ifdef HAS_UNIFORM_u_${H}
    ${k} ${N} ${H} = u_${H};
#endif
`)), vertexSource: r = r.replace(d, (I, D, k, N, H) => {
          const q = N === "float" ? "vec2" : "vec4", K = H.match(/color/) ? "color" : q;
          return S[H] ? D === "define" ? `
#ifndef HAS_UNIFORM_u_${H}
uniform lowp float u_${H}_t;
attribute ${k} ${q} a_${H};
varying ${k} ${N} ${H};
#else
uniform ${k} ${N} u_${H};
#endif
` : K === "vec4" ? `
#ifndef HAS_UNIFORM_u_${H}
    ${H} = a_${H};
#else
    ${k} ${N} ${H} = u_${H};
#endif
` : `
#ifndef HAS_UNIFORM_u_${H}
    ${H} = unpack_mix_${K}(a_${H}, u_${H}_t);
#else
    ${k} ${N} ${H} = u_${H};
#endif
` : D === "define" ? `
#ifndef HAS_UNIFORM_u_${H}
uniform lowp float u_${H}_t;
attribute ${k} ${q} a_${H};
#else
uniform ${k} ${N} u_${H};
#endif
` : K === "vec4" ? `
#ifndef HAS_UNIFORM_u_${H}
    ${k} ${N} ${H} = a_${H};
#else
    ${k} ${N} ${H} = u_${H};
#endif
` : `
#ifndef HAS_UNIFORM_u_${H}
    ${k} ${N} ${H} = unpack_mix_${K}(a_${H}, u_${H}_t);
#else
    ${k} ${N} ${H} = u_${H};
#endif
`;
        }), staticAttributes: p, staticUniforms: T };
      }
      class va {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(r, d, p, _, g, T, S, I, D) {
          this.context = r;
          let k = this.boundPaintVertexBuffers.length !== _.length;
          for (let N = 0; !k && N < _.length; N++) this.boundPaintVertexBuffers[N] !== _[N] && (k = !0);
          !this.vao || this.boundProgram !== d || this.boundLayoutVertexBuffer !== p || k || this.boundIndexBuffer !== g || this.boundVertexOffset !== T || this.boundDynamicVertexBuffer !== S || this.boundDynamicVertexBuffer2 !== I || this.boundDynamicVertexBuffer3 !== D ? this.freshBind(d, p, _, g, T, S, I, D) : (r.bindVertexArray.set(this.vao), S && S.bind(), g && g.dynamicDraw && g.bind(), I && I.bind(), D && D.bind());
        }
        freshBind(r, d, p, _, g, T, S, I) {
          const D = r.numAttributes, k = this.context, N = k.gl;
          this.vao && this.destroy(), this.vao = k.createVertexArray(), k.bindVertexArray.set(this.vao), this.boundProgram = r, this.boundLayoutVertexBuffer = d, this.boundPaintVertexBuffers = p, this.boundIndexBuffer = _, this.boundVertexOffset = g, this.boundDynamicVertexBuffer = T, this.boundDynamicVertexBuffer2 = S, this.boundDynamicVertexBuffer3 = I, d.enableAttributes(N, r);
          for (const H of p) H.enableAttributes(N, r);
          T && T.enableAttributes(N, r), S && S.enableAttributes(N, r), I && I.enableAttributes(N, r), d.bind(), d.setVertexAttribPointers(N, r, g);
          for (const H of p) H.bind(), H.setVertexAttribPointers(N, r, g);
          T && (T.bind(), T.setVertexAttribPointers(N, r, g)), _ && _.bind(), S && (S.bind(), S.setVertexAttribPointers(N, r, g)), I && (I.bind(), I.setVertexAttribPointers(N, r, g)), k.currentNumAttributes = D;
        }
        destroy() {
          this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      const xa = (y, r, d, p, _) => ({ u_matrix: y, u_texture: 0, u_ele_delta: r, u_fog_matrix: d, u_fog_color: p ? p.properties.get("fog-color") : c.aM.white, u_fog_ground_blend: p ? p.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: p ? p.calculateFogBlendOpacity(_) : 0, u_horizon_color: p ? p.properties.get("horizon-color") : c.aM.white, u_horizon_fog_blend: p ? p.properties.get("horizon-fog-blend") : 1 });
      function G(y) {
        const r = [];
        for (let d = 0; d < y.length; d++) {
          if (y[d] === null) continue;
          const p = y[d].split(" ");
          r.push(p.pop());
        }
        return r;
      }
      class Z {
        constructor(r, d, p, _, g, T) {
          const S = r.gl;
          this.program = S.createProgram();
          const I = G(d.staticAttributes), D = p ? p.getBinderAttributes() : [], k = I.concat(D), N = ur.prelude.staticUniforms ? G(ur.prelude.staticUniforms) : [], H = d.staticUniforms ? G(d.staticUniforms) : [], q = p ? p.getBinderUniforms() : [], K = N.concat(H).concat(q), se = [];
          for (const Te of K) se.indexOf(Te) < 0 && se.push(Te);
          const oe = p ? p.defines() : [];
          g && oe.push("#define OVERDRAW_INSPECTOR;"), T && oe.push("#define TERRAIN3D;");
          const ae = oe.concat(ur.prelude.fragmentSource, d.fragmentSource).join(`
`), he = oe.concat(ur.prelude.vertexSource, d.vertexSource).join(`
`), te = S.createShader(S.FRAGMENT_SHADER);
          if (S.isContextLost()) return void (this.failedToCreate = !0);
          if (S.shaderSource(te, ae), S.compileShader(te), !S.getShaderParameter(te, S.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${S.getShaderInfoLog(te)}`);
          S.attachShader(this.program, te);
          const fe = S.createShader(S.VERTEX_SHADER);
          if (S.isContextLost()) return void (this.failedToCreate = !0);
          if (S.shaderSource(fe, he), S.compileShader(fe), !S.getShaderParameter(fe, S.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${S.getShaderInfoLog(fe)}`);
          S.attachShader(this.program, fe), this.attributes = {};
          const ge = {};
          this.numAttributes = k.length;
          for (let Te = 0; Te < this.numAttributes; Te++) k[Te] && (S.bindAttribLocation(this.program, Te, k[Te]), this.attributes[k[Te]] = Te);
          if (S.linkProgram(this.program), !S.getProgramParameter(this.program, S.LINK_STATUS)) throw new Error(`Program failed to link: ${S.getProgramInfoLog(this.program)}`);
          S.deleteShader(fe), S.deleteShader(te);
          for (let Te = 0; Te < se.length; Te++) {
            const Fe = se[Te];
            if (Fe && !ge[Fe]) {
              const Ve = S.getUniformLocation(this.program, Fe);
              Ve && (ge[Fe] = Ve);
            }
          }
          this.fixedUniforms = _(r, ge), this.terrainUniforms = ((Te, Fe) => ({ u_depth: new c.aH(Te, Fe.u_depth), u_terrain: new c.aH(Te, Fe.u_terrain), u_terrain_dim: new c.aI(Te, Fe.u_terrain_dim), u_terrain_matrix: new c.aJ(Te, Fe.u_terrain_matrix), u_terrain_unpack: new c.aK(Te, Fe.u_terrain_unpack), u_terrain_exaggeration: new c.aI(Te, Fe.u_terrain_exaggeration) }))(r, ge), this.binderUniforms = p ? p.getUniforms(r, ge) : [];
        }
        draw(r, d, p, _, g, T, S, I, D, k, N, H, q, K, se, oe, ae, he) {
          const te = r.gl;
          if (this.failedToCreate) return;
          if (r.program.set(this.program), r.setDepthMode(p), r.setStencilMode(_), r.setColorMode(g), r.setCullFace(T), I) {
            r.activeTexture.set(te.TEXTURE2), te.bindTexture(te.TEXTURE_2D, I.depthTexture), r.activeTexture.set(te.TEXTURE3), te.bindTexture(te.TEXTURE_2D, I.texture);
            for (const ge in this.terrainUniforms) this.terrainUniforms[ge].set(I[ge]);
          }
          for (const ge in this.fixedUniforms) this.fixedUniforms[ge].set(S[ge]);
          se && se.setUniforms(r, this.binderUniforms, q, { zoom: K });
          let fe = 0;
          switch (d) {
            case te.LINES:
              fe = 2;
              break;
            case te.TRIANGLES:
              fe = 3;
              break;
            case te.LINE_STRIP:
              fe = 1;
          }
          for (const ge of H.get()) {
            const Te = ge.vaos || (ge.vaos = {});
            (Te[D] || (Te[D] = new va())).bind(r, this, k, se ? se.getPaintVertexBuffers() : [], N, ge.vertexOffset, oe, ae, he), te.drawElements(d, ge.primitiveLength * fe, te.UNSIGNED_SHORT, ge.primitiveOffset * fe * 2);
          }
        }
      }
      function ce(y, r, d) {
        const p = 1 / Pt(d, 1, r.transform.tileZoom), _ = Math.pow(2, d.tileID.overscaledZ), g = d.tileSize * Math.pow(2, r.transform.tileZoom) / _, T = g * (d.tileID.canonical.x + d.tileID.wrap * _), S = g * d.tileID.canonical.y;
        return { u_image: 0, u_texsize: d.imageAtlasTexture.size, u_scale: [p, y.fromScale, y.toScale], u_fade: y.t, u_pixel_coord_upper: [T >> 16, S >> 16], u_pixel_coord_lower: [65535 & T, 65535 & S] };
      }
      const Me = (y, r, d, p) => {
        const _ = r.style.light, g = _.properties.get("position"), T = [g.x, g.y, g.z], S = function() {
          var D = new c.A(9);
          return c.A != Float32Array && (D[1] = 0, D[2] = 0, D[3] = 0, D[5] = 0, D[6] = 0, D[7] = 0), D[0] = 1, D[4] = 1, D[8] = 1, D;
        }();
        _.properties.get("anchor") === "viewport" && function(D, k) {
          var N = Math.sin(k), H = Math.cos(k);
          D[0] = H, D[1] = N, D[2] = 0, D[3] = -N, D[4] = H, D[5] = 0, D[6] = 0, D[7] = 0, D[8] = 1;
        }(S, -r.transform.angle), function(D, k, N) {
          var H = k[0], q = k[1], K = k[2];
          D[0] = H * N[0] + q * N[3] + K * N[6], D[1] = H * N[1] + q * N[4] + K * N[7], D[2] = H * N[2] + q * N[5] + K * N[8];
        }(T, T, S);
        const I = _.properties.get("color");
        return { u_matrix: y, u_lightpos: T, u_lightintensity: _.properties.get("intensity"), u_lightcolor: [I.r, I.g, I.b], u_vertical_gradient: +d, u_opacity: p };
      }, Ue = (y, r, d, p, _, g, T) => c.e(Me(y, r, d, p), ce(g, r, T), { u_height_factor: -Math.pow(2, _.overscaledZ) / T.tileSize / 8 }), lt = (y) => ({ u_matrix: y }), Dt = (y, r, d, p) => c.e(lt(y), ce(d, r, p)), $i = (y, r) => ({ u_matrix: y, u_world: r }), Gi = (y, r, d, p, _) => c.e(Dt(y, r, d, p), { u_world: _ }), as = (y, r, d, p) => {
        const _ = y.transform;
        let g, T;
        if (p.paint.get("circle-pitch-alignment") === "map") {
          const S = Pt(d, 1, _.zoom);
          g = !0, T = [S, S];
        } else g = !1, T = _.pixelsToGLUnits;
        return { u_camera_to_center_distance: _.cameraToCenterDistance, u_scale_with_map: +(p.paint.get("circle-pitch-scale") === "map"), u_matrix: y.translatePosMatrix(r.posMatrix, d, p.paint.get("circle-translate"), p.paint.get("circle-translate-anchor")), u_pitch_with_map: +g, u_device_pixel_ratio: y.pixelRatio, u_extrude_scale: T };
      }, Qi = (y, r, d) => ({ u_matrix: y, u_inv_matrix: r, u_camera_to_center_distance: d.cameraToCenterDistance, u_viewport_size: [d.width, d.height] }), wa = (y, r, d = 1) => ({ u_matrix: y, u_color: r, u_overlay: 0, u_overlay_scale: d }), Us = (y) => ({ u_matrix: y }), zs = (y, r, d, p) => ({ u_matrix: y, u_extrude_scale: Pt(r, 1, d), u_intensity: p }), pl = (y, r, d, p) => {
        const _ = c.H();
        c.aP(_, 0, y.width, y.height, 0, 0, 1);
        const g = y.context.gl;
        return { u_matrix: _, u_world: [g.drawingBufferWidth, g.drawingBufferHeight], u_image: d, u_color_ramp: p, u_opacity: r.paint.get("heatmap-opacity") };
      };
      function _l(y, r) {
        const d = Math.pow(2, r.canonical.z), p = r.canonical.y;
        return [new c.Z(0, p / d).toLngLat().lat, new c.Z(0, (p + 1) / d).toLngLat().lat];
      }
      const ml = (y, r, d, p) => {
        const _ = y.transform;
        return { u_matrix: $u(y, r, d, p), u_ratio: 1 / Pt(r, 1, _.zoom), u_device_pixel_ratio: y.pixelRatio, u_units_to_pixels: [1 / _.pixelsToGLUnits[0], 1 / _.pixelsToGLUnits[1]] };
      }, Hu = (y, r, d, p, _) => c.e(ml(y, r, d, _), { u_image: 0, u_image_height: p }), So = (y, r, d, p, _) => {
        const g = y.transform, T = ju(r, g);
        return { u_matrix: $u(y, r, d, _), u_texsize: r.imageAtlasTexture.size, u_ratio: 1 / Pt(r, 1, g.zoom), u_device_pixel_ratio: y.pixelRatio, u_image: 0, u_scale: [T, p.fromScale, p.toScale], u_fade: p.t, u_units_to_pixels: [1 / g.pixelsToGLUnits[0], 1 / g.pixelsToGLUnits[1]] };
      }, Rp = (y, r, d, p, _, g) => {
        const T = y.lineAtlas, S = ju(r, y.transform), I = d.layout.get("line-cap") === "round", D = T.getDash(p.from, I), k = T.getDash(p.to, I), N = D.width * _.fromScale, H = k.width * _.toScale;
        return c.e(ml(y, r, d, g), { u_patternscale_a: [S / N, -D.height / 2], u_patternscale_b: [S / H, -k.height / 2], u_sdfgamma: T.width / (256 * Math.min(N, H) * y.pixelRatio) / 2, u_image: 0, u_tex_y_a: D.y, u_tex_y_b: k.y, u_mix: _.t });
      };
      function ju(y, r) {
        return 1 / Pt(y, 1, r.tileZoom);
      }
      function $u(y, r, d, p) {
        return y.translatePosMatrix(p ? p.posMatrix : r.tileID.posMatrix, r, d.paint.get("line-translate"), d.paint.get("line-translate-anchor"));
      }
      const Mp = (y, r, d, p, _) => {
        return { u_matrix: y, u_tl_parent: r, u_scale_parent: d, u_buffer_scale: 1, u_fade_t: p.mix, u_opacity: p.opacity * _.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: _.paint.get("raster-brightness-min"), u_brightness_high: _.paint.get("raster-brightness-max"), u_saturation_factor: (T = _.paint.get("raster-saturation"), T > 0 ? 1 - 1 / (1.001 - T) : -T), u_contrast_factor: (g = _.paint.get("raster-contrast"), g > 0 ? 1 / (1 - g) : 1 + g), u_spin_weights: Pp(_.paint.get("raster-hue-rotate")) };
        var g, T;
      };
      function Pp(y) {
        y *= Math.PI / 180;
        const r = Math.sin(y), d = Math.cos(y);
        return [(2 * d + 1) / 3, (-Math.sqrt(3) * r - d + 1) / 3, (Math.sqrt(3) * r - d + 1) / 3];
      }
      const Gu = (y, r, d, p, _, g, T, S, I, D, k, N, H, q) => {
        const K = T.transform;
        return { u_is_size_zoom_constant: +(y === "constant" || y === "source"), u_is_size_feature_constant: +(y === "constant" || y === "camera"), u_size_t: r ? r.uSizeT : 0, u_size: r ? r.uSize : 0, u_camera_to_center_distance: K.cameraToCenterDistance, u_pitch: K.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +d, u_aspect_ratio: K.width / K.height, u_fade_change: T.options.fadeDuration ? T.symbolFadeChange : 1, u_matrix: S, u_label_plane_matrix: I, u_coord_matrix: D, u_is_text: +N, u_pitch_with_map: +p, u_is_along_line: _, u_is_variable_anchor: g, u_texsize: H, u_texture: 0, u_translation: k, u_pitched_scale: q };
      }, Aa = (y, r, d, p, _, g, T, S, I, D, k, N, H, q, K) => {
        const se = T.transform;
        return c.e(Gu(y, r, d, p, _, g, T, S, I, D, k, N, H, K), { u_gamma_scale: p ? Math.cos(se._pitch) * se.cameraToCenterDistance : 1, u_device_pixel_ratio: T.pixelRatio, u_is_halo: +q });
      }, Xc = (y, r, d, p, _, g, T, S, I, D, k, N, H, q) => c.e(Aa(y, r, d, p, _, g, T, S, I, D, k, !0, N, !0, q), { u_texsize_icon: H, u_texture_icon: 1 }), gl = (y, r, d) => ({ u_matrix: y, u_opacity: r, u_color: d }), Wc = (y, r, d, p, _, g) => c.e(function(T, S, I, D) {
        const k = I.imageManager.getPattern(T.from.toString()), N = I.imageManager.getPattern(T.to.toString()), { width: H, height: q } = I.imageManager.getPixelSize(), K = Math.pow(2, D.tileID.overscaledZ), se = D.tileSize * Math.pow(2, I.transform.tileZoom) / K, oe = se * (D.tileID.canonical.x + D.tileID.wrap * K), ae = se * D.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: k.tl, u_pattern_br_a: k.br, u_pattern_tl_b: N.tl, u_pattern_br_b: N.br, u_texsize: [H, q], u_mix: S.t, u_pattern_size_a: k.displaySize, u_pattern_size_b: N.displaySize, u_scale_a: S.fromScale, u_scale_b: S.toScale, u_tile_units_to_pixels: 1 / Pt(D, 1, I.transform.tileZoom), u_pixel_coord_upper: [oe >> 16, ae >> 16], u_pixel_coord_lower: [65535 & oe, 65535 & ae] };
      }(p, g, d, _), { u_matrix: y, u_opacity: r }), qc = { fillExtrusion: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_lightpos: new c.aN(y, r.u_lightpos), u_lightintensity: new c.aI(y, r.u_lightintensity), u_lightcolor: new c.aN(y, r.u_lightcolor), u_vertical_gradient: new c.aI(y, r.u_vertical_gradient), u_opacity: new c.aI(y, r.u_opacity) }), fillExtrusionPattern: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_lightpos: new c.aN(y, r.u_lightpos), u_lightintensity: new c.aI(y, r.u_lightintensity), u_lightcolor: new c.aN(y, r.u_lightcolor), u_vertical_gradient: new c.aI(y, r.u_vertical_gradient), u_height_factor: new c.aI(y, r.u_height_factor), u_image: new c.aH(y, r.u_image), u_texsize: new c.aO(y, r.u_texsize), u_pixel_coord_upper: new c.aO(y, r.u_pixel_coord_upper), u_pixel_coord_lower: new c.aO(y, r.u_pixel_coord_lower), u_scale: new c.aN(y, r.u_scale), u_fade: new c.aI(y, r.u_fade), u_opacity: new c.aI(y, r.u_opacity) }), fill: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix) }), fillPattern: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_image: new c.aH(y, r.u_image), u_texsize: new c.aO(y, r.u_texsize), u_pixel_coord_upper: new c.aO(y, r.u_pixel_coord_upper), u_pixel_coord_lower: new c.aO(y, r.u_pixel_coord_lower), u_scale: new c.aN(y, r.u_scale), u_fade: new c.aI(y, r.u_fade) }), fillOutline: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_world: new c.aO(y, r.u_world) }), fillOutlinePattern: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_world: new c.aO(y, r.u_world), u_image: new c.aH(y, r.u_image), u_texsize: new c.aO(y, r.u_texsize), u_pixel_coord_upper: new c.aO(y, r.u_pixel_coord_upper), u_pixel_coord_lower: new c.aO(y, r.u_pixel_coord_lower), u_scale: new c.aN(y, r.u_scale), u_fade: new c.aI(y, r.u_fade) }), circle: (y, r) => ({ u_camera_to_center_distance: new c.aI(y, r.u_camera_to_center_distance), u_scale_with_map: new c.aH(y, r.u_scale_with_map), u_pitch_with_map: new c.aH(y, r.u_pitch_with_map), u_extrude_scale: new c.aO(y, r.u_extrude_scale), u_device_pixel_ratio: new c.aI(y, r.u_device_pixel_ratio), u_matrix: new c.aJ(y, r.u_matrix) }), collisionBox: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_pixel_extrude_scale: new c.aO(y, r.u_pixel_extrude_scale) }), collisionCircle: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_inv_matrix: new c.aJ(y, r.u_inv_matrix), u_camera_to_center_distance: new c.aI(y, r.u_camera_to_center_distance), u_viewport_size: new c.aO(y, r.u_viewport_size) }), debug: (y, r) => ({ u_color: new c.aL(y, r.u_color), u_matrix: new c.aJ(y, r.u_matrix), u_overlay: new c.aH(y, r.u_overlay), u_overlay_scale: new c.aI(y, r.u_overlay_scale) }), clippingMask: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix) }), heatmap: (y, r) => ({ u_extrude_scale: new c.aI(y, r.u_extrude_scale), u_intensity: new c.aI(y, r.u_intensity), u_matrix: new c.aJ(y, r.u_matrix) }), heatmapTexture: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_world: new c.aO(y, r.u_world), u_image: new c.aH(y, r.u_image), u_color_ramp: new c.aH(y, r.u_color_ramp), u_opacity: new c.aI(y, r.u_opacity) }), hillshade: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_image: new c.aH(y, r.u_image), u_latrange: new c.aO(y, r.u_latrange), u_light: new c.aO(y, r.u_light), u_shadow: new c.aL(y, r.u_shadow), u_highlight: new c.aL(y, r.u_highlight), u_accent: new c.aL(y, r.u_accent) }), hillshadePrepare: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_image: new c.aH(y, r.u_image), u_dimension: new c.aO(y, r.u_dimension), u_zoom: new c.aI(y, r.u_zoom), u_unpack: new c.aK(y, r.u_unpack) }), line: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_ratio: new c.aI(y, r.u_ratio), u_device_pixel_ratio: new c.aI(y, r.u_device_pixel_ratio), u_units_to_pixels: new c.aO(y, r.u_units_to_pixels) }), lineGradient: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_ratio: new c.aI(y, r.u_ratio), u_device_pixel_ratio: new c.aI(y, r.u_device_pixel_ratio), u_units_to_pixels: new c.aO(y, r.u_units_to_pixels), u_image: new c.aH(y, r.u_image), u_image_height: new c.aI(y, r.u_image_height) }), linePattern: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_texsize: new c.aO(y, r.u_texsize), u_ratio: new c.aI(y, r.u_ratio), u_device_pixel_ratio: new c.aI(y, r.u_device_pixel_ratio), u_image: new c.aH(y, r.u_image), u_units_to_pixels: new c.aO(y, r.u_units_to_pixels), u_scale: new c.aN(y, r.u_scale), u_fade: new c.aI(y, r.u_fade) }), lineSDF: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_ratio: new c.aI(y, r.u_ratio), u_device_pixel_ratio: new c.aI(y, r.u_device_pixel_ratio), u_units_to_pixels: new c.aO(y, r.u_units_to_pixels), u_patternscale_a: new c.aO(y, r.u_patternscale_a), u_patternscale_b: new c.aO(y, r.u_patternscale_b), u_sdfgamma: new c.aI(y, r.u_sdfgamma), u_image: new c.aH(y, r.u_image), u_tex_y_a: new c.aI(y, r.u_tex_y_a), u_tex_y_b: new c.aI(y, r.u_tex_y_b), u_mix: new c.aI(y, r.u_mix) }), raster: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_tl_parent: new c.aO(y, r.u_tl_parent), u_scale_parent: new c.aI(y, r.u_scale_parent), u_buffer_scale: new c.aI(y, r.u_buffer_scale), u_fade_t: new c.aI(y, r.u_fade_t), u_opacity: new c.aI(y, r.u_opacity), u_image0: new c.aH(y, r.u_image0), u_image1: new c.aH(y, r.u_image1), u_brightness_low: new c.aI(y, r.u_brightness_low), u_brightness_high: new c.aI(y, r.u_brightness_high), u_saturation_factor: new c.aI(y, r.u_saturation_factor), u_contrast_factor: new c.aI(y, r.u_contrast_factor), u_spin_weights: new c.aN(y, r.u_spin_weights) }), symbolIcon: (y, r) => ({ u_is_size_zoom_constant: new c.aH(y, r.u_is_size_zoom_constant), u_is_size_feature_constant: new c.aH(y, r.u_is_size_feature_constant), u_size_t: new c.aI(y, r.u_size_t), u_size: new c.aI(y, r.u_size), u_camera_to_center_distance: new c.aI(y, r.u_camera_to_center_distance), u_pitch: new c.aI(y, r.u_pitch), u_rotate_symbol: new c.aH(y, r.u_rotate_symbol), u_aspect_ratio: new c.aI(y, r.u_aspect_ratio), u_fade_change: new c.aI(y, r.u_fade_change), u_matrix: new c.aJ(y, r.u_matrix), u_label_plane_matrix: new c.aJ(y, r.u_label_plane_matrix), u_coord_matrix: new c.aJ(y, r.u_coord_matrix), u_is_text: new c.aH(y, r.u_is_text), u_pitch_with_map: new c.aH(y, r.u_pitch_with_map), u_is_along_line: new c.aH(y, r.u_is_along_line), u_is_variable_anchor: new c.aH(y, r.u_is_variable_anchor), u_texsize: new c.aO(y, r.u_texsize), u_texture: new c.aH(y, r.u_texture), u_translation: new c.aO(y, r.u_translation), u_pitched_scale: new c.aI(y, r.u_pitched_scale) }), symbolSDF: (y, r) => ({ u_is_size_zoom_constant: new c.aH(y, r.u_is_size_zoom_constant), u_is_size_feature_constant: new c.aH(y, r.u_is_size_feature_constant), u_size_t: new c.aI(y, r.u_size_t), u_size: new c.aI(y, r.u_size), u_camera_to_center_distance: new c.aI(y, r.u_camera_to_center_distance), u_pitch: new c.aI(y, r.u_pitch), u_rotate_symbol: new c.aH(y, r.u_rotate_symbol), u_aspect_ratio: new c.aI(y, r.u_aspect_ratio), u_fade_change: new c.aI(y, r.u_fade_change), u_matrix: new c.aJ(y, r.u_matrix), u_label_plane_matrix: new c.aJ(y, r.u_label_plane_matrix), u_coord_matrix: new c.aJ(y, r.u_coord_matrix), u_is_text: new c.aH(y, r.u_is_text), u_pitch_with_map: new c.aH(y, r.u_pitch_with_map), u_is_along_line: new c.aH(y, r.u_is_along_line), u_is_variable_anchor: new c.aH(y, r.u_is_variable_anchor), u_texsize: new c.aO(y, r.u_texsize), u_texture: new c.aH(y, r.u_texture), u_gamma_scale: new c.aI(y, r.u_gamma_scale), u_device_pixel_ratio: new c.aI(y, r.u_device_pixel_ratio), u_is_halo: new c.aH(y, r.u_is_halo), u_translation: new c.aO(y, r.u_translation), u_pitched_scale: new c.aI(y, r.u_pitched_scale) }), symbolTextAndIcon: (y, r) => ({ u_is_size_zoom_constant: new c.aH(y, r.u_is_size_zoom_constant), u_is_size_feature_constant: new c.aH(y, r.u_is_size_feature_constant), u_size_t: new c.aI(y, r.u_size_t), u_size: new c.aI(y, r.u_size), u_camera_to_center_distance: new c.aI(y, r.u_camera_to_center_distance), u_pitch: new c.aI(y, r.u_pitch), u_rotate_symbol: new c.aH(y, r.u_rotate_symbol), u_aspect_ratio: new c.aI(y, r.u_aspect_ratio), u_fade_change: new c.aI(y, r.u_fade_change), u_matrix: new c.aJ(y, r.u_matrix), u_label_plane_matrix: new c.aJ(y, r.u_label_plane_matrix), u_coord_matrix: new c.aJ(y, r.u_coord_matrix), u_is_text: new c.aH(y, r.u_is_text), u_pitch_with_map: new c.aH(y, r.u_pitch_with_map), u_is_along_line: new c.aH(y, r.u_is_along_line), u_is_variable_anchor: new c.aH(y, r.u_is_variable_anchor), u_texsize: new c.aO(y, r.u_texsize), u_texsize_icon: new c.aO(y, r.u_texsize_icon), u_texture: new c.aH(y, r.u_texture), u_texture_icon: new c.aH(y, r.u_texture_icon), u_gamma_scale: new c.aI(y, r.u_gamma_scale), u_device_pixel_ratio: new c.aI(y, r.u_device_pixel_ratio), u_is_halo: new c.aH(y, r.u_is_halo), u_translation: new c.aO(y, r.u_translation), u_pitched_scale: new c.aI(y, r.u_pitched_scale) }), background: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_opacity: new c.aI(y, r.u_opacity), u_color: new c.aL(y, r.u_color) }), backgroundPattern: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_opacity: new c.aI(y, r.u_opacity), u_image: new c.aH(y, r.u_image), u_pattern_tl_a: new c.aO(y, r.u_pattern_tl_a), u_pattern_br_a: new c.aO(y, r.u_pattern_br_a), u_pattern_tl_b: new c.aO(y, r.u_pattern_tl_b), u_pattern_br_b: new c.aO(y, r.u_pattern_br_b), u_texsize: new c.aO(y, r.u_texsize), u_mix: new c.aI(y, r.u_mix), u_pattern_size_a: new c.aO(y, r.u_pattern_size_a), u_pattern_size_b: new c.aO(y, r.u_pattern_size_b), u_scale_a: new c.aI(y, r.u_scale_a), u_scale_b: new c.aI(y, r.u_scale_b), u_pixel_coord_upper: new c.aO(y, r.u_pixel_coord_upper), u_pixel_coord_lower: new c.aO(y, r.u_pixel_coord_lower), u_tile_units_to_pixels: new c.aI(y, r.u_tile_units_to_pixels) }), terrain: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_texture: new c.aH(y, r.u_texture), u_ele_delta: new c.aI(y, r.u_ele_delta), u_fog_matrix: new c.aJ(y, r.u_fog_matrix), u_fog_color: new c.aL(y, r.u_fog_color), u_fog_ground_blend: new c.aI(y, r.u_fog_ground_blend), u_fog_ground_blend_opacity: new c.aI(y, r.u_fog_ground_blend_opacity), u_horizon_color: new c.aL(y, r.u_horizon_color), u_horizon_fog_blend: new c.aI(y, r.u_horizon_fog_blend) }), terrainDepth: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_ele_delta: new c.aI(y, r.u_ele_delta) }), terrainCoords: (y, r) => ({ u_matrix: new c.aJ(y, r.u_matrix), u_texture: new c.aH(y, r.u_texture), u_terrain_coords_id: new c.aI(y, r.u_terrain_coords_id), u_ele_delta: new c.aI(y, r.u_ele_delta) }), sky: (y, r) => ({ u_sky_color: new c.aL(y, r.u_sky_color), u_horizon_color: new c.aL(y, r.u_horizon_color), u_horizon: new c.aI(y, r.u_horizon), u_sky_horizon_blend: new c.aI(y, r.u_sky_horizon_blend) }) };
      class Wr {
        constructor(r, d, p) {
          this.context = r;
          const _ = r.gl;
          this.buffer = _.createBuffer(), this.dynamicDraw = !!p, this.context.unbindVAO(), r.bindElementBuffer.set(this.buffer), _.bufferData(_.ELEMENT_ARRAY_BUFFER, d.arrayBuffer, this.dynamicDraw ? _.DYNAMIC_DRAW : _.STATIC_DRAW), this.dynamicDraw || delete d.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(r) {
          const d = this.context.gl;
          if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), d.bufferSubData(d.ELEMENT_ARRAY_BUFFER, 0, r.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Bp = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class Zc {
        constructor(r, d, p, _) {
          this.length = d.length, this.attributes = p, this.itemSize = d.bytesPerElement, this.dynamicDraw = _, this.context = r;
          const g = r.gl;
          this.buffer = g.createBuffer(), r.bindVertexBuffer.set(this.buffer), g.bufferData(g.ARRAY_BUFFER, d.arrayBuffer, this.dynamicDraw ? g.DYNAMIC_DRAW : g.STATIC_DRAW), this.dynamicDraw || delete d.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(r) {
          if (r.length !== this.length) throw new Error(`Length of new data is ${r.length}, which doesn't match current length of ${this.length}`);
          const d = this.context.gl;
          this.bind(), d.bufferSubData(d.ARRAY_BUFFER, 0, r.arrayBuffer);
        }
        enableAttributes(r, d) {
          for (let p = 0; p < this.attributes.length; p++) {
            const _ = d.attributes[this.attributes[p].name];
            _ !== void 0 && r.enableVertexAttribArray(_);
          }
        }
        setVertexAttribPointers(r, d, p) {
          for (let _ = 0; _ < this.attributes.length; _++) {
            const g = this.attributes[_], T = d.attributes[g.name];
            T !== void 0 && r.vertexAttribPointer(T, g.components, r[Bp[g.type]], !1, this.itemSize, g.offset + this.itemSize * (p || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const eo = /* @__PURE__ */ new WeakMap();
      function Pn(y) {
        var r;
        if (eo.has(y)) return eo.get(y);
        {
          const d = (r = y.getParameter(y.VERSION)) === null || r === void 0 ? void 0 : r.startsWith("WebGL 2.0");
          return eo.set(y, d), d;
        }
      }
      class qt {
        constructor(r) {
          this.gl = r.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        }
        get() {
          return this.current;
        }
        set(r) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class yl extends qt {
        getDefault() {
          return c.aM.transparent;
        }
        set(r) {
          const d = this.current;
          (r.r !== d.r || r.g !== d.g || r.b !== d.b || r.a !== d.a || this.dirty) && (this.gl.clearColor(r.r, r.g, r.b, r.a), this.current = r, this.dirty = !1);
        }
      }
      class Dp extends qt {
        getDefault() {
          return 1;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.clearDepth(r), this.current = r, this.dirty = !1);
        }
      }
      class Co extends qt {
        getDefault() {
          return 0;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.clearStencil(r), this.current = r, this.dirty = !1);
        }
      }
      class Op extends qt {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(r) {
          const d = this.current;
          (r[0] !== d[0] || r[1] !== d[1] || r[2] !== d[2] || r[3] !== d[3] || this.dirty) && (this.gl.colorMask(r[0], r[1], r[2], r[3]), this.current = r, this.dirty = !1);
        }
      }
      class Xu extends qt {
        getDefault() {
          return !0;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.depthMask(r), this.current = r, this.dirty = !1);
        }
      }
      class Fp extends qt {
        getDefault() {
          return 255;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.stencilMask(r), this.current = r, this.dirty = !1);
        }
      }
      class Wu extends qt {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(r) {
          const d = this.current;
          (r.func !== d.func || r.ref !== d.ref || r.mask !== d.mask || this.dirty) && (this.gl.stencilFunc(r.func, r.ref, r.mask), this.current = r, this.dirty = !1);
        }
      }
      class Kc extends qt {
        getDefault() {
          const r = this.gl;
          return [r.KEEP, r.KEEP, r.KEEP];
        }
        set(r) {
          const d = this.current;
          (r[0] !== d[0] || r[1] !== d[1] || r[2] !== d[2] || this.dirty) && (this.gl.stencilOp(r[0], r[1], r[2]), this.current = r, this.dirty = !1);
        }
      }
      class qu extends qt {
        getDefault() {
          return !1;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const d = this.gl;
          r ? d.enable(d.STENCIL_TEST) : d.disable(d.STENCIL_TEST), this.current = r, this.dirty = !1;
        }
      }
      class Zu extends qt {
        getDefault() {
          return [0, 1];
        }
        set(r) {
          const d = this.current;
          (r[0] !== d[0] || r[1] !== d[1] || this.dirty) && (this.gl.depthRange(r[0], r[1]), this.current = r, this.dirty = !1);
        }
      }
      class Ku extends qt {
        getDefault() {
          return !1;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const d = this.gl;
          r ? d.enable(d.DEPTH_TEST) : d.disable(d.DEPTH_TEST), this.current = r, this.dirty = !1;
        }
      }
      class Ju extends qt {
        getDefault() {
          return this.gl.LESS;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.depthFunc(r), this.current = r, this.dirty = !1);
        }
      }
      class to extends qt {
        getDefault() {
          return !1;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const d = this.gl;
          r ? d.enable(d.BLEND) : d.disable(d.BLEND), this.current = r, this.dirty = !1;
        }
      }
      class Yu extends qt {
        getDefault() {
          const r = this.gl;
          return [r.ONE, r.ZERO];
        }
        set(r) {
          const d = this.current;
          (r[0] !== d[0] || r[1] !== d[1] || this.dirty) && (this.gl.blendFunc(r[0], r[1]), this.current = r, this.dirty = !1);
        }
      }
      class kp extends qt {
        getDefault() {
          return c.aM.transparent;
        }
        set(r) {
          const d = this.current;
          (r.r !== d.r || r.g !== d.g || r.b !== d.b || r.a !== d.a || this.dirty) && (this.gl.blendColor(r.r, r.g, r.b, r.a), this.current = r, this.dirty = !1);
        }
      }
      class Qu extends qt {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.blendEquation(r), this.current = r, this.dirty = !1);
        }
      }
      class Ta extends qt {
        getDefault() {
          return !1;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const d = this.gl;
          r ? d.enable(d.CULL_FACE) : d.disable(d.CULL_FACE), this.current = r, this.dirty = !1;
        }
      }
      class Np extends qt {
        getDefault() {
          return this.gl.BACK;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.cullFace(r), this.current = r, this.dirty = !1);
        }
      }
      class bl extends qt {
        getDefault() {
          return this.gl.CCW;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.frontFace(r), this.current = r, this.dirty = !1);
        }
      }
      class Lp extends qt {
        getDefault() {
          return null;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.useProgram(r), this.current = r, this.dirty = !1);
        }
      }
      class Up extends qt {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.activeTexture(r), this.current = r, this.dirty = !1);
        }
      }
      class ed extends qt {
        getDefault() {
          const r = this.gl;
          return [0, 0, r.drawingBufferWidth, r.drawingBufferHeight];
        }
        set(r) {
          const d = this.current;
          (r[0] !== d[0] || r[1] !== d[1] || r[2] !== d[2] || r[3] !== d[3] || this.dirty) && (this.gl.viewport(r[0], r[1], r[2], r[3]), this.current = r, this.dirty = !1);
        }
      }
      class td extends qt {
        getDefault() {
          return null;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const d = this.gl;
          d.bindFramebuffer(d.FRAMEBUFFER, r), this.current = r, this.dirty = !1;
        }
      }
      class id extends qt {
        getDefault() {
          return null;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const d = this.gl;
          d.bindRenderbuffer(d.RENDERBUFFER, r), this.current = r, this.dirty = !1;
        }
      }
      class Jc extends qt {
        getDefault() {
          return null;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const d = this.gl;
          d.bindTexture(d.TEXTURE_2D, r), this.current = r, this.dirty = !1;
        }
      }
      class sd extends qt {
        getDefault() {
          return null;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const d = this.gl;
          d.bindBuffer(d.ARRAY_BUFFER, r), this.current = r, this.dirty = !1;
        }
      }
      class vl extends qt {
        getDefault() {
          return null;
        }
        set(r) {
          const d = this.gl;
          d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, r), this.current = r, this.dirty = !1;
        }
      }
      class an extends qt {
        getDefault() {
          return null;
        }
        set(r) {
          var d;
          if (r === this.current && !this.dirty) return;
          const p = this.gl;
          Pn(p) ? p.bindVertexArray(r) : (d = p.getExtension("OES_vertex_array_object")) === null || d === void 0 || d.bindVertexArrayOES(r), this.current = r, this.dirty = !1;
        }
      }
      class Yc extends qt {
        getDefault() {
          return 4;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const d = this.gl;
          d.pixelStorei(d.UNPACK_ALIGNMENT, r), this.current = r, this.dirty = !1;
        }
      }
      class Qc extends qt {
        getDefault() {
          return !1;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const d = this.gl;
          d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r), this.current = r, this.dirty = !1;
        }
      }
      class eh extends qt {
        getDefault() {
          return !1;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const d = this.gl;
          d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, r), this.current = r, this.dirty = !1;
        }
      }
      class xl extends qt {
        constructor(r, d) {
          super(r), this.context = r, this.parent = d;
        }
        getDefault() {
          return null;
        }
      }
      class th extends xl {
        setDirty() {
          this.dirty = !0;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const d = this.gl;
          d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, r, 0), this.current = r, this.dirty = !1;
        }
      }
      class io extends xl {
        set(r) {
          if (r === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const d = this.gl;
          d.framebufferRenderbuffer(d.FRAMEBUFFER, d.DEPTH_ATTACHMENT, d.RENDERBUFFER, r), this.current = r, this.dirty = !1;
        }
      }
      class ih extends xl {
        set(r) {
          if (r === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const d = this.gl;
          d.framebufferRenderbuffer(d.FRAMEBUFFER, d.DEPTH_STENCIL_ATTACHMENT, d.RENDERBUFFER, r), this.current = r, this.dirty = !1;
        }
      }
      class zp {
        constructor(r, d, p, _, g) {
          this.context = r, this.width = d, this.height = p;
          const T = r.gl, S = this.framebuffer = T.createFramebuffer();
          if (this.colorAttachment = new th(r, S), _) this.depthAttachment = g ? new ih(r, S) : new io(r, S);
          else if (g) throw new Error("Stencil cannot be set without depth");
          if (T.checkFramebufferStatus(T.FRAMEBUFFER) !== T.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
        }
        destroy() {
          const r = this.context.gl, d = this.colorAttachment.get();
          if (d && r.deleteTexture(d), this.depthAttachment) {
            const p = this.depthAttachment.get();
            p && r.deleteRenderbuffer(p);
          }
          r.deleteFramebuffer(this.framebuffer);
        }
      }
      class Oi {
        constructor(r, d, p) {
          this.blendFunction = r, this.blendColor = d, this.mask = p;
        }
      }
      Oi.Replace = [1, 0], Oi.disabled = new Oi(Oi.Replace, c.aM.transparent, [!1, !1, !1, !1]), Oi.unblended = new Oi(Oi.Replace, c.aM.transparent, [!0, !0, !0, !0]), Oi.alphaBlended = new Oi([1, 771], c.aM.transparent, [!0, !0, !0, !0]);
      class Vp {
        constructor(r) {
          var d, p;
          if (this.gl = r, this.clearColor = new yl(this), this.clearDepth = new Dp(this), this.clearStencil = new Co(this), this.colorMask = new Op(this), this.depthMask = new Xu(this), this.stencilMask = new Fp(this), this.stencilFunc = new Wu(this), this.stencilOp = new Kc(this), this.stencilTest = new qu(this), this.depthRange = new Zu(this), this.depthTest = new Ku(this), this.depthFunc = new Ju(this), this.blend = new to(this), this.blendFunc = new Yu(this), this.blendColor = new kp(this), this.blendEquation = new Qu(this), this.cullFace = new Ta(this), this.cullFaceSide = new Np(this), this.frontFace = new bl(this), this.program = new Lp(this), this.activeTexture = new Up(this), this.viewport = new ed(this), this.bindFramebuffer = new td(this), this.bindRenderbuffer = new id(this), this.bindTexture = new Jc(this), this.bindVertexBuffer = new sd(this), this.bindElementBuffer = new vl(this), this.bindVertexArray = new an(this), this.pixelStoreUnpack = new Yc(this), this.pixelStoreUnpackPremultiplyAlpha = new Qc(this), this.pixelStoreUnpackFlipY = new eh(this), this.extTextureFilterAnisotropic = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = r.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = r.getParameter(r.MAX_TEXTURE_SIZE), Pn(r)) {
            this.HALF_FLOAT = r.HALF_FLOAT;
            const _ = r.getExtension("EXT_color_buffer_half_float");
            this.RGBA16F = (d = r.RGBA16F) !== null && d !== void 0 ? d : _ == null ? void 0 : _.RGBA16F_EXT, this.RGB16F = (p = r.RGB16F) !== null && p !== void 0 ? p : _ == null ? void 0 : _.RGB16F_EXT, r.getExtension("EXT_color_buffer_float");
          } else {
            r.getExtension("EXT_color_buffer_half_float"), r.getExtension("OES_texture_half_float_linear");
            const _ = r.getExtension("OES_texture_half_float");
            this.HALF_FLOAT = _ == null ? void 0 : _.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }
        createIndexBuffer(r, d) {
          return new Wr(this, r, d);
        }
        createVertexBuffer(r, d, p) {
          return new Zc(this, r, d, p);
        }
        createRenderbuffer(r, d, p) {
          const _ = this.gl, g = _.createRenderbuffer();
          return this.bindRenderbuffer.set(g), _.renderbufferStorage(_.RENDERBUFFER, r, d, p), this.bindRenderbuffer.set(null), g;
        }
        createFramebuffer(r, d, p, _) {
          return new zp(this, r, d, p, _);
        }
        clear({ color: r, depth: d, stencil: p }) {
          const _ = this.gl;
          let g = 0;
          r && (g |= _.COLOR_BUFFER_BIT, this.clearColor.set(r), this.colorMask.set([!0, !0, !0, !0])), d !== void 0 && (g |= _.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(d), this.depthMask.set(!0)), p !== void 0 && (g |= _.STENCIL_BUFFER_BIT, this.clearStencil.set(p), this.stencilMask.set(255)), _.clear(g);
        }
        setCullFace(r) {
          r.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(r.mode), this.frontFace.set(r.frontFace));
        }
        setDepthMode(r) {
          r.func !== this.gl.ALWAYS || r.mask ? (this.depthTest.set(!0), this.depthFunc.set(r.func), this.depthMask.set(r.mask), this.depthRange.set(r.range)) : this.depthTest.set(!1);
        }
        setStencilMode(r) {
          r.test.func !== this.gl.ALWAYS || r.mask ? (this.stencilTest.set(!0), this.stencilMask.set(r.mask), this.stencilOp.set([r.fail, r.depthFail, r.pass]), this.stencilFunc.set({ func: r.test.func, ref: r.ref, mask: r.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(r) {
          c.aE(r.blendFunction, Oi.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(r.blendFunction), this.blendColor.set(r.blendColor)), this.colorMask.set(r.mask);
        }
        createVertexArray() {
          var r;
          return Pn(this.gl) ? this.gl.createVertexArray() : (r = this.gl.getExtension("OES_vertex_array_object")) === null || r === void 0 ? void 0 : r.createVertexArrayOES();
        }
        deleteVertexArray(r) {
          var d;
          return Pn(this.gl) ? this.gl.deleteVertexArray(r) : (d = this.gl.getExtension("OES_vertex_array_object")) === null || d === void 0 ? void 0 : d.deleteVertexArrayOES(r);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }
      class Bt {
        constructor(r, d, p) {
          this.func = r, this.mask = d, this.range = p;
        }
      }
      Bt.ReadOnly = !1, Bt.ReadWrite = !0, Bt.disabled = new Bt(519, Bt.ReadOnly, [0, 1]);
      const wl = 7680;
      class ci {
        constructor(r, d, p, _, g, T) {
          this.test = r, this.ref = d, this.mask = p, this.fail = _, this.depthFail = g, this.pass = T;
        }
      }
      ci.disabled = new ci({ func: 519, mask: 0 }, 0, 0, wl, wl, wl);
      class ei {
        constructor(r, d, p) {
          this.enable = r, this.mode = d, this.frontFace = p;
        }
      }
      let so;
      function Ea(y, r, d, p, _) {
        const g = y.context, T = g.gl, S = y.useProgram("collisionBox"), I = [];
        let D = 0, k = 0;
        for (let ae = 0; ae < p.length; ae++) {
          const he = p[ae], te = r.getTile(he).getBucket(d);
          if (!te) continue;
          const fe = _ ? te.textCollisionBox : te.iconCollisionBox, ge = te.collisionCircleArray;
          if (ge.length > 0) {
            const Te = c.H();
            c.aQ(Te, te.placementInvProjMatrix, y.transform.glCoordMatrix), c.aQ(Te, Te, te.placementViewportMatrix), I.push({ circleArray: ge, circleOffset: k, transform: he.posMatrix, invTransform: Te, coord: he }), D += ge.length / 4, k = D;
          }
          fe && S.draw(g, T.LINES, Bt.disabled, ci.disabled, y.colorModeForRenderPass(), ei.disabled, { u_matrix: he.posMatrix, u_pixel_extrude_scale: [1 / (N = y.transform).width, 1 / N.height] }, y.style.map.terrain && y.style.map.terrain.getTerrainData(he), d.id, fe.layoutVertexBuffer, fe.indexBuffer, fe.segments, null, y.transform.zoom, null, null, fe.collisionVertexBuffer);
        }
        var N;
        if (!_ || !I.length) return;
        const H = y.useProgram("collisionCircle"), q = new c.aR();
        q.resize(4 * D), q._trim();
        let K = 0;
        for (const ae of I) for (let he = 0; he < ae.circleArray.length / 4; he++) {
          const te = 4 * he, fe = ae.circleArray[te + 0], ge = ae.circleArray[te + 1], Te = ae.circleArray[te + 2], Fe = ae.circleArray[te + 3];
          q.emplace(K++, fe, ge, Te, Fe, 0), q.emplace(K++, fe, ge, Te, Fe, 1), q.emplace(K++, fe, ge, Te, Fe, 2), q.emplace(K++, fe, ge, Te, Fe, 3);
        }
        (!so || so.length < 2 * D) && (so = function(ae) {
          const he = 2 * ae, te = new c.aT();
          te.resize(he), te._trim();
          for (let fe = 0; fe < he; fe++) {
            const ge = 6 * fe;
            te.uint16[ge + 0] = 4 * fe + 0, te.uint16[ge + 1] = 4 * fe + 1, te.uint16[ge + 2] = 4 * fe + 2, te.uint16[ge + 3] = 4 * fe + 2, te.uint16[ge + 4] = 4 * fe + 3, te.uint16[ge + 5] = 4 * fe + 0;
          }
          return te;
        }(D));
        const se = g.createIndexBuffer(so, !0), oe = g.createVertexBuffer(q, c.aS.members, !0);
        for (const ae of I) {
          const he = Qi(ae.transform, ae.invTransform, y.transform);
          H.draw(g, T.TRIANGLES, Bt.disabled, ci.disabled, y.colorModeForRenderPass(), ei.disabled, he, y.style.map.terrain && y.style.map.terrain.getTerrainData(ae.coord), d.id, oe, se, c.a0.simpleSegment(0, 2 * ae.circleOffset, ae.circleArray.length, ae.circleArray.length / 2), null, y.transform.zoom, null, null, null);
        }
        oe.destroy(), se.destroy();
      }
      ei.disabled = new ei(!1, 1029, 2305), ei.backCCW = new ei(!0, 1029, 2305);
      const Sa = c.an(new Float32Array(16));
      function sh(y, r, d, p, _, g) {
        const { horizontalAlign: T, verticalAlign: S } = c.au(y);
        return new c.P((-(T - 0.5) * r / _ + p[0]) * g, (-(S - 0.5) * d / _ + p[1]) * g);
      }
      function ro(y, r, d, p, _, g) {
        const T = r.tileAnchorPoint.add(new c.P(r.translation[0], r.translation[1]));
        if (r.pitchWithMap) {
          let S = p.mult(g);
          d || (S = S.rotate(-_));
          const I = T.add(S);
          return re(I.x, I.y, r.labelPlaneMatrix, r.getElevation).point;
        }
        if (d) {
          const S = Be(r.tileAnchorPoint.x + 1, r.tileAnchorPoint.y, r).point.sub(y), I = Math.atan(S.y / S.x) + (S.x < 0 ? Math.PI : 0);
          return y.add(p.rotate(I));
        }
        return y.add(p);
      }
      function Io(y, r, d, p, _, g, T, S, I, D, k, N, H, q) {
        const K = y.text.placedSymbolArray, se = y.text.dynamicLayoutVertexArray, oe = y.icon.dynamicLayoutVertexArray, ae = {};
        se.clear();
        for (let he = 0; he < K.length; he++) {
          const te = K.get(he), fe = te.hidden || !te.crossTileID || y.allowVerticalPlacement && !te.placedOrientation ? null : p[te.crossTileID];
          if (fe) {
            const ge = new c.P(te.anchorX, te.anchorY), Te = { getElevation: q, width: _.width, height: _.height, labelPlaneMatrix: g, lineVertexArray: null, pitchWithMap: d, projection: k, projectionCache: null, tileAnchorPoint: ge, translation: N, unwrappedTileID: H }, Fe = d ? re(ge.x, ge.y, T, q) : Be(ge.x, ge.y, Te), Ve = z(_.cameraToCenterDistance, Fe.signedDistanceFromCamera);
            let Ye = c.ai(y.textSizeData, I, te) * Ve / c.ap;
            d && (Ye *= y.tilePixelRatio / S);
            const { width: st, height: Ze, anchor: Ge, textOffset: ut, textBoxScale: Et } = fe, Ke = sh(Ge, st, Ze, ut, Et, Ye), et = k.getPitchedTextCorrection(_, ge.add(new c.P(N[0], N[1])), H), At = ro(Fe.point, Te, r, Ke, _.angle, et), pi = y.allowVerticalPlacement && te.placedOrientation === c.ah.vertical ? Math.PI / 2 : 0;
            for (let Mt = 0; Mt < te.numGlyphs; Mt++) c.aj(se, At, pi);
            D && te.associatedIconIndex >= 0 && (ae[te.associatedIconIndex] = { shiftedAnchor: At, angle: pi });
          } else gt(te.numGlyphs, se);
        }
        if (D) {
          oe.clear();
          const he = y.icon.placedSymbolArray;
          for (let te = 0; te < he.length; te++) {
            const fe = he.get(te);
            if (fe.hidden) gt(fe.numGlyphs, oe);
            else {
              const ge = ae[te];
              if (ge) for (let Te = 0; Te < fe.numGlyphs; Te++) c.aj(oe, ge.shiftedAnchor, ge.angle);
              else gt(fe.numGlyphs, oe);
            }
          }
          y.icon.dynamicLayoutVertexBuffer.updateData(oe);
        }
        y.text.dynamicLayoutVertexBuffer.updateData(se);
      }
      function dr(y, r, d) {
        return d.iconsInText && r ? "symbolTextAndIcon" : y ? "symbolSDF" : "symbolIcon";
      }
      function rh(y, r, d, p, _, g, T, S, I, D, k, N) {
        const H = y.context, q = H.gl, K = y.transform, se = $r(), oe = S === "map", ae = I === "map", he = S !== "viewport" && d.layout.get("symbol-placement") !== "point", te = oe && !ae && !he, fe = !ae && he, ge = !d.layout.get("symbol-sort-key").isConstant();
        let Te = !1;
        const Fe = y.depthModeForSublayer(0, Bt.ReadOnly), Ve = d._unevaluatedLayout.hasValue("text-variable-anchor") || d._unevaluatedLayout.hasValue("text-variable-anchor-offset"), Ye = [], st = se.getCircleRadiusCorrection(K);
        for (const Ze of p) {
          const Ge = r.getTile(Ze), ut = Ge.getBucket(d);
          if (!ut) continue;
          const Et = _ ? ut.text : ut.icon;
          if (!Et || !Et.segments.get().length || !Et.hasVisibleVertices) continue;
          const Ke = Et.programConfigurations.get(d.id), et = _ || ut.sdfIcons, At = _ ? ut.textSizeData : ut.iconSizeData, pi = ae || K.pitch !== 0, Mt = y.useProgram(dr(et, _, ut), Ke), Ot = c.ag(At, K.zoom), _i = y.style.map.terrain && y.style.map.terrain.getTerrainData(Ze);
          let gs, Ir, mi, Vs, Ms = [0, 0], ys = null;
          if (_) Ir = Ge.glyphAtlasTexture, mi = q.LINEAR, gs = Ge.glyphAtlasTexture.size, ut.iconsInText && (Ms = Ge.imageAtlasTexture.size, ys = Ge.imageAtlasTexture, Vs = pi || y.options.rotating || y.options.zooming || At.kind === "composite" || At.kind === "camera" ? q.LINEAR : q.NEAREST);
          else {
            const Nt = d.layout.get("icon-size").constantOr(0) !== 1 || ut.iconsNeedLinear;
            Ir = Ge.imageAtlasTexture, mi = et || y.options.rotating || y.options.zooming || Nt || pi ? q.LINEAR : q.NEAREST, gs = Ge.imageAtlasTexture.size;
          }
          const Ps = Pt(Ge, 1, y.transform.zoom), Kr = fe ? Ze.posMatrix : Sa, $o = Er(Kr, ae, oe, y.transform, Ps), Vl = er(Kr, ae, oe, y.transform, Ps), Go = er(Ze.posMatrix, ae, oe, y.transform, Ps), _r = se.translatePosition(y.transform, Ge, g, T), Hl = Ve && ut.hasTextData(), Rh = d.layout.get("icon-text-fit") !== "none" && Hl && ut.hasIconData();
          if (he) {
            const Nt = y.style.map.terrain ? (Xo, Wo) => y.style.map.terrain.getElevation(Ze, Xo, Wo) : null, co = d.layout.get("text-rotation-alignment") === "map";
            W(ut, Ze.posMatrix, y, _, $o, Go, ae, D, co, se, Ze.toUnwrapped(), K.width, K.height, _r, Nt);
          }
          const mr = Ze.posMatrix, gr = _ && Ve || Rh, Bn = he || gr ? Sa : $o, Rr = Vl, ls = et && d.paint.get(_ ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let bs;
          bs = et ? ut.iconsInText ? Xc(At.kind, Ot, te, ae, he, gr, y, mr, Bn, Rr, _r, gs, Ms, st) : Aa(At.kind, Ot, te, ae, he, gr, y, mr, Bn, Rr, _r, _, gs, !0, st) : Gu(At.kind, Ot, te, ae, he, gr, y, mr, Bn, Rr, _r, _, gs, st);
          const sr = { program: Mt, buffers: Et, uniformValues: bs, atlasTexture: Ir, atlasTextureIcon: ys, atlasInterpolation: mi, atlasInterpolationIcon: Vs, isSDF: et, hasHalo: ls };
          if (ge && ut.canOverlap) {
            Te = !0;
            const Nt = Et.segments.get();
            for (const co of Nt) Ye.push({ segments: new c.a0([co]), sortKey: co.sortKey, state: sr, terrainData: _i });
          } else Ye.push({ segments: Et.segments, sortKey: 0, state: sr, terrainData: _i });
        }
        Te && Ye.sort((Ze, Ge) => Ze.sortKey - Ge.sortKey);
        for (const Ze of Ye) {
          const Ge = Ze.state;
          if (H.activeTexture.set(q.TEXTURE0), Ge.atlasTexture.bind(Ge.atlasInterpolation, q.CLAMP_TO_EDGE), Ge.atlasTextureIcon && (H.activeTexture.set(q.TEXTURE1), Ge.atlasTextureIcon && Ge.atlasTextureIcon.bind(Ge.atlasInterpolationIcon, q.CLAMP_TO_EDGE)), Ge.isSDF) {
            const ut = Ge.uniformValues;
            Ge.hasHalo && (ut.u_is_halo = 1, nh(Ge.buffers, Ze.segments, d, y, Ge.program, Fe, k, N, ut, Ze.terrainData)), ut.u_is_halo = 0;
          }
          nh(Ge.buffers, Ze.segments, d, y, Ge.program, Fe, k, N, Ge.uniformValues, Ze.terrainData);
        }
      }
      function nh(y, r, d, p, _, g, T, S, I, D) {
        const k = p.context;
        _.draw(k, k.gl.TRIANGLES, g, T, S, ei.disabled, I, D, d.id, y.layoutVertexBuffer, y.indexBuffer, r, d.paint, p.transform.zoom, y.programConfigurations.get(d.id), y.dynamicLayoutVertexBuffer, y.opacityVertexBuffer);
      }
      function oh(y, r, d, p) {
        const _ = y.context, g = _.gl, T = ci.disabled, S = new Oi([g.ONE, g.ONE], c.aM.transparent, [!0, !0, !0, !0]), I = r.getBucket(d);
        if (!I) return;
        const D = p.key;
        let k = d.heatmapFbos.get(D);
        k || (k = Ca(_, r.tileSize, r.tileSize), d.heatmapFbos.set(D, k)), _.bindFramebuffer.set(k.framebuffer), _.viewport.set([0, 0, r.tileSize, r.tileSize]), _.clear({ color: c.aM.transparent });
        const N = I.programConfigurations.get(d.id), H = y.useProgram("heatmap", N), q = y.style.map.terrain.getTerrainData(p);
        H.draw(_, g.TRIANGLES, Bt.disabled, T, S, ei.disabled, zs(p.posMatrix, r, y.transform.zoom, d.paint.get("heatmap-intensity")), q, d.id, I.layoutVertexBuffer, I.indexBuffer, I.segments, d.paint, y.transform.zoom, N);
      }
      function no(y, r, d) {
        const p = y.context, _ = p.gl;
        p.setColorMode(y.colorModeForRenderPass());
        const g = Ia(p, r), T = d.key, S = r.heatmapFbos.get(T);
        S && (p.activeTexture.set(_.TEXTURE0), _.bindTexture(_.TEXTURE_2D, S.colorAttachment.get()), p.activeTexture.set(_.TEXTURE1), g.bind(_.LINEAR, _.CLAMP_TO_EDGE), y.useProgram("heatmapTexture").draw(p, _.TRIANGLES, Bt.disabled, ci.disabled, y.colorModeForRenderPass(), ei.disabled, pl(y, r, 0, 1), null, r.id, y.rasterBoundsBuffer, y.quadTriangleIndexBuffer, y.rasterBoundsSegments, r.paint, y.transform.zoom), S.destroy(), r.heatmapFbos.delete(T));
      }
      function Ca(y, r, d) {
        var p, _;
        const g = y.gl, T = g.createTexture();
        g.bindTexture(g.TEXTURE_2D, T), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, g.LINEAR), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, g.LINEAR);
        const S = (p = y.HALF_FLOAT) !== null && p !== void 0 ? p : g.UNSIGNED_BYTE, I = (_ = y.RGBA16F) !== null && _ !== void 0 ? _ : g.RGBA;
        g.texImage2D(g.TEXTURE_2D, 0, I, r, d, 0, g.RGBA, S, null);
        const D = y.createFramebuffer(r, d, !1, !1);
        return D.colorAttachment.set(T), D;
      }
      function Ia(y, r) {
        return r.colorRampTexture || (r.colorRampTexture = new it(y, r.colorRamp, y.gl.RGBA)), r.colorRampTexture;
      }
      function Ro(y, r, d, p, _) {
        if (!d || !p || !p.imageAtlas) return;
        const g = p.imageAtlas.patternPositions;
        let T = g[d.to.toString()], S = g[d.from.toString()];
        if (!T && S && (T = S), !S && T && (S = T), !T || !S) {
          const I = _.getPaintProperty(r);
          T = g[I], S = g[I];
        }
        T && S && y.setConstantPatternPositions(T, S);
      }
      function Ra(y, r, d, p, _, g, T) {
        const S = y.context.gl, I = "fill-pattern", D = d.paint.get(I), k = D && D.constantOr(1), N = d.getCrossfadeParameters();
        let H, q, K, se, oe;
        T ? (q = k && !d.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", H = S.LINES) : (q = k ? "fillPattern" : "fill", H = S.TRIANGLES);
        const ae = D.constantOr(null);
        for (const he of p) {
          const te = r.getTile(he);
          if (k && !te.patternsLoaded()) continue;
          const fe = te.getBucket(d);
          if (!fe) continue;
          const ge = fe.programConfigurations.get(d.id), Te = y.useProgram(q, ge), Fe = y.style.map.terrain && y.style.map.terrain.getTerrainData(he);
          k && (y.context.activeTexture.set(S.TEXTURE0), te.imageAtlasTexture.bind(S.LINEAR, S.CLAMP_TO_EDGE), ge.updatePaintBuffers(N)), Ro(ge, I, ae, te, d);
          const Ve = Fe ? he : null, Ye = y.translatePosMatrix(Ve ? Ve.posMatrix : he.posMatrix, te, d.paint.get("fill-translate"), d.paint.get("fill-translate-anchor"));
          if (T) {
            se = fe.indexBuffer2, oe = fe.segments2;
            const st = [S.drawingBufferWidth, S.drawingBufferHeight];
            K = q === "fillOutlinePattern" && k ? Gi(Ye, y, N, te, st) : $i(Ye, st);
          } else se = fe.indexBuffer, oe = fe.segments, K = k ? Dt(Ye, y, N, te) : lt(Ye);
          Te.draw(y.context, H, _, y.stencilModeForClipping(he), g, ei.disabled, K, Fe, d.id, fe.layoutVertexBuffer, se, oe, d.paint, y.transform.zoom, ge);
        }
      }
      function Al(y, r, d, p, _, g, T) {
        const S = y.context, I = S.gl, D = "fill-extrusion-pattern", k = d.paint.get(D), N = k.constantOr(1), H = d.getCrossfadeParameters(), q = d.paint.get("fill-extrusion-opacity"), K = k.constantOr(null);
        for (const se of p) {
          const oe = r.getTile(se), ae = oe.getBucket(d);
          if (!ae) continue;
          const he = y.style.map.terrain && y.style.map.terrain.getTerrainData(se), te = ae.programConfigurations.get(d.id), fe = y.useProgram(N ? "fillExtrusionPattern" : "fillExtrusion", te);
          N && (y.context.activeTexture.set(I.TEXTURE0), oe.imageAtlasTexture.bind(I.LINEAR, I.CLAMP_TO_EDGE), te.updatePaintBuffers(H)), Ro(te, D, K, oe, d);
          const ge = y.translatePosMatrix(se.posMatrix, oe, d.paint.get("fill-extrusion-translate"), d.paint.get("fill-extrusion-translate-anchor")), Te = d.paint.get("fill-extrusion-vertical-gradient"), Fe = N ? Ue(ge, y, Te, q, se, H, oe) : Me(ge, y, Te, q);
          fe.draw(S, S.gl.TRIANGLES, _, g, T, ei.backCCW, Fe, he, d.id, ae.layoutVertexBuffer, ae.indexBuffer, ae.segments, d.paint, y.transform.zoom, te, y.style.map.terrain && ae.centroidVertexBuffer);
        }
      }
      function Mo(y, r, d, p, _, g, T) {
        const S = y.context, I = S.gl, D = d.fbo;
        if (!D) return;
        const k = y.useProgram("hillshade"), N = y.style.map.terrain && y.style.map.terrain.getTerrainData(r);
        S.activeTexture.set(I.TEXTURE0), I.bindTexture(I.TEXTURE_2D, D.colorAttachment.get()), k.draw(S, I.TRIANGLES, _, g, T, ei.disabled, ((H, q, K, se) => {
          const oe = K.paint.get("hillshade-shadow-color"), ae = K.paint.get("hillshade-highlight-color"), he = K.paint.get("hillshade-accent-color");
          let te = K.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          K.paint.get("hillshade-illumination-anchor") === "viewport" && (te -= H.transform.angle);
          const fe = !H.options.moving;
          return { u_matrix: se ? se.posMatrix : H.transform.calculatePosMatrix(q.tileID.toUnwrapped(), fe), u_image: 0, u_latrange: _l(0, q.tileID), u_light: [K.paint.get("hillshade-exaggeration"), te], u_shadow: oe, u_highlight: ae, u_accent: he };
        })(y, d, p, N ? r : null), N, p.id, y.rasterBoundsBuffer, y.quadTriangleIndexBuffer, y.rasterBoundsSegments);
      }
      function Po(y, r, d, p, _, g) {
        const T = y.context, S = T.gl, I = r.dem;
        if (I && I.data) {
          const D = I.dim, k = I.stride, N = I.getPixels();
          if (T.activeTexture.set(S.TEXTURE1), T.pixelStoreUnpackPremultiplyAlpha.set(!1), r.demTexture = r.demTexture || y.getTileTexture(k), r.demTexture) {
            const q = r.demTexture;
            q.update(N, { premultiply: !1 }), q.bind(S.NEAREST, S.CLAMP_TO_EDGE);
          } else r.demTexture = new it(T, N, S.RGBA, { premultiply: !1 }), r.demTexture.bind(S.NEAREST, S.CLAMP_TO_EDGE);
          T.activeTexture.set(S.TEXTURE0);
          let H = r.fbo;
          if (!H) {
            const q = new it(T, { width: D, height: D, data: null }, S.RGBA);
            q.bind(S.LINEAR, S.CLAMP_TO_EDGE), H = r.fbo = T.createFramebuffer(D, D, !0, !1), H.colorAttachment.set(q.texture);
          }
          T.bindFramebuffer.set(H.framebuffer), T.viewport.set([0, 0, D, D]), y.useProgram("hillshadePrepare").draw(T, S.TRIANGLES, p, _, g, ei.disabled, ((q, K) => {
            const se = K.stride, oe = c.H();
            return c.aP(oe, 0, c.X, -c.X, 0, 0, 1), c.J(oe, oe, [0, -c.X, 0]), { u_matrix: oe, u_image: 1, u_dimension: [se, se], u_zoom: q.overscaledZ, u_unpack: K.getUnpackVector() };
          })(r.tileID, I), null, d.id, y.rasterBoundsBuffer, y.quadTriangleIndexBuffer, y.rasterBoundsSegments), r.needsHillshadePrepare = !1;
        }
      }
      function rd(y, r, d, p, _, g) {
        const T = p.paint.get("raster-fade-duration");
        if (!g && T > 0) {
          const S = M.now(), I = (S - y.timeAdded) / T, D = r ? (S - r.timeAdded) / T : -1, k = d.getSource(), N = _.coveringZoomLevel({ tileSize: k.tileSize, roundZoom: k.roundZoom }), H = !r || Math.abs(r.tileID.overscaledZ - N) > Math.abs(y.tileID.overscaledZ - N), q = H && y.refreshedUponExpiration ? 1 : c.ac(H ? I : 1 - D, 0, 1);
          return y.refreshedUponExpiration && I >= 1 && (y.refreshedUponExpiration = !1), r ? { opacity: 1, mix: 1 - q } : { opacity: q, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const ah = new c.aM(1, 0, 0, 1), $t = new c.aM(0, 1, 0, 1), Tl = new c.aM(0, 0, 1, 1), Hp = new c.aM(1, 0, 1, 1), nd = new c.aM(0, 1, 1, 1);
      function Bo(y, r, d, p) {
        El(y, 0, r + d / 2, y.transform.width, d, p);
      }
      function od(y, r, d, p) {
        El(y, r - d / 2, 0, d, y.transform.height, p);
      }
      function El(y, r, d, p, _, g) {
        const T = y.context, S = T.gl;
        S.enable(S.SCISSOR_TEST), S.scissor(r * y.pixelRatio, d * y.pixelRatio, p * y.pixelRatio, _ * y.pixelRatio), T.clear({ color: g }), S.disable(S.SCISSOR_TEST);
      }
      function ad(y, r, d) {
        const p = y.context, _ = p.gl, g = d.posMatrix, T = y.useProgram("debug"), S = Bt.disabled, I = ci.disabled, D = y.colorModeForRenderPass(), k = "$debug", N = y.style.map.terrain && y.style.map.terrain.getTerrainData(d);
        p.activeTexture.set(_.TEXTURE0);
        const H = r.getTileByID(d.key).latestRawTileData, q = Math.floor((H && H.byteLength || 0) / 1024), K = r.getTile(d).tileSize, se = 512 / Math.min(K, 512) * (d.overscaledZ / y.transform.zoom) * 0.5;
        let oe = d.canonical.toString();
        d.overscaledZ !== d.canonical.z && (oe += ` => ${d.overscaledZ}`), function(ae, he) {
          ae.initDebugOverlayCanvas();
          const te = ae.debugOverlayCanvas, fe = ae.context.gl, ge = ae.debugOverlayCanvas.getContext("2d");
          ge.clearRect(0, 0, te.width, te.height), ge.shadowColor = "white", ge.shadowBlur = 2, ge.lineWidth = 1.5, ge.strokeStyle = "white", ge.textBaseline = "top", ge.font = "bold 36px Open Sans, sans-serif", ge.fillText(he, 5, 5), ge.strokeText(he, 5, 5), ae.debugOverlayTexture.update(te), ae.debugOverlayTexture.bind(fe.LINEAR, fe.CLAMP_TO_EDGE);
        }(y, `${oe} ${q}kB`), T.draw(p, _.TRIANGLES, S, I, Oi.alphaBlended, ei.disabled, wa(g, c.aM.transparent, se), null, k, y.debugBuffer, y.quadTriangleIndexBuffer, y.debugSegments), T.draw(p, _.LINE_STRIP, S, I, D, ei.disabled, wa(g, c.aM.red), N, k, y.debugBuffer, y.tileBorderIndexBuffer, y.debugSegments);
      }
      function ld(y, r, d) {
        const p = y.context, _ = p.gl, g = y.colorModeForRenderPass(), T = new Bt(_.LEQUAL, Bt.ReadWrite, y.depthRangeFor3D), S = y.useProgram("terrain"), I = r.getTerrainMesh();
        p.bindFramebuffer.set(null), p.viewport.set([0, 0, y.width, y.height]);
        for (const D of d) {
          const k = y.renderToTexture.getTexture(D), N = r.getTerrainData(D.tileID);
          p.activeTexture.set(_.TEXTURE0), _.bindTexture(_.TEXTURE_2D, k.texture);
          const H = y.transform.calculatePosMatrix(D.tileID.toUnwrapped()), q = r.getMeshFrameDelta(y.transform.zoom), K = y.transform.calculateFogMatrix(D.tileID.toUnwrapped()), se = xa(H, q, K, y.style.sky, y.transform.pitch);
          S.draw(p, _.TRIANGLES, T, ci.disabled, g, ei.backCCW, se, N, "terrain", I.vertexBuffer, I.indexBuffer, I.segments);
        }
      }
      class Sl {
        constructor(r, d, p) {
          this.vertexBuffer = r, this.indexBuffer = d, this.segments = p;
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
        }
      }
      class Cl {
        constructor(r, d) {
          this.context = new Vp(r), this.transform = d, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: c.an(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = xt.maxUnderzooming + xt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Qn();
        }
        resize(r, d, p) {
          if (this.width = Math.floor(r * p), this.height = Math.floor(d * p), this.pixelRatio = p, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const _ of this.style._order) this.style._layers[_].resize();
        }
        setup() {
          const r = this.context, d = new c.aX();
          d.emplaceBack(0, 0), d.emplaceBack(c.X, 0), d.emplaceBack(0, c.X), d.emplaceBack(c.X, c.X), this.tileExtentBuffer = r.createVertexBuffer(d, Xr.members), this.tileExtentSegments = c.a0.simpleSegment(0, 0, 4, 2);
          const p = new c.aX();
          p.emplaceBack(0, 0), p.emplaceBack(c.X, 0), p.emplaceBack(0, c.X), p.emplaceBack(c.X, c.X), this.debugBuffer = r.createVertexBuffer(p, Xr.members), this.debugSegments = c.a0.simpleSegment(0, 0, 4, 5);
          const _ = new c.$();
          _.emplaceBack(0, 0, 0, 0), _.emplaceBack(c.X, 0, c.X, 0), _.emplaceBack(0, c.X, 0, c.X), _.emplaceBack(c.X, c.X, c.X, c.X), this.rasterBoundsBuffer = r.createVertexBuffer(_, Hr.members), this.rasterBoundsSegments = c.a0.simpleSegment(0, 0, 4, 2);
          const g = new c.aX();
          g.emplaceBack(0, 0), g.emplaceBack(1, 0), g.emplaceBack(0, 1), g.emplaceBack(1, 1), this.viewportBuffer = r.createVertexBuffer(g, Xr.members), this.viewportSegments = c.a0.simpleSegment(0, 0, 4, 2);
          const T = new c.aZ();
          T.emplaceBack(0), T.emplaceBack(1), T.emplaceBack(3), T.emplaceBack(2), T.emplaceBack(0), this.tileBorderIndexBuffer = r.createIndexBuffer(T);
          const S = new c.aY();
          S.emplaceBack(0, 1, 2), S.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = r.createIndexBuffer(S);
          const I = this.context.gl;
          this.stencilClearMode = new ci({ func: I.ALWAYS, mask: 0 }, 0, 255, I.ZERO, I.ZERO, I.ZERO);
        }
        clearStencil() {
          const r = this.context, d = r.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          const p = c.H();
          c.aP(p, 0, this.width, this.height, 0, 0, 1), c.K(p, p, [d.drawingBufferWidth, d.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(r, d.TRIANGLES, Bt.disabled, this.stencilClearMode, Oi.disabled, ei.disabled, Us(p), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(r, d) {
          if (this.currentStencilSource === r.source || !r.isTileClipped() || !d || !d.length) return;
          this.currentStencilSource = r.source;
          const p = this.context, _ = p.gl;
          this.nextStencilID + d.length > 256 && this.clearStencil(), p.setColorMode(Oi.disabled), p.setDepthMode(Bt.disabled);
          const g = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const T of d) {
            const S = this._tileClippingMaskIDs[T.key] = this.nextStencilID++, I = this.style.map.terrain && this.style.map.terrain.getTerrainData(T);
            g.draw(p, _.TRIANGLES, Bt.disabled, new ci({ func: _.ALWAYS, mask: 0 }, S, 255, _.KEEP, _.KEEP, _.REPLACE), Oi.disabled, ei.disabled, Us(T.posMatrix), I, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const r = this.nextStencilID++, d = this.context.gl;
          return new ci({ func: d.NOTEQUAL, mask: 255 }, r, 255, d.KEEP, d.KEEP, d.REPLACE);
        }
        stencilModeForClipping(r) {
          const d = this.context.gl;
          return new ci({ func: d.EQUAL, mask: 255 }, this._tileClippingMaskIDs[r.key], 0, d.KEEP, d.KEEP, d.REPLACE);
        }
        stencilConfigForOverlap(r) {
          const d = this.context.gl, p = r.sort((T, S) => S.overscaledZ - T.overscaledZ), _ = p[p.length - 1].overscaledZ, g = p[0].overscaledZ - _ + 1;
          if (g > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + g > 256 && this.clearStencil();
            const T = {};
            for (let S = 0; S < g; S++) T[S + _] = new ci({ func: d.GEQUAL, mask: 255 }, S + this.nextStencilID, 255, d.KEEP, d.KEEP, d.REPLACE);
            return this.nextStencilID += g, [T, p];
          }
          return [{ [_]: ci.disabled }, p];
        }
        colorModeForRenderPass() {
          const r = this.context.gl;
          return this._showOverdrawInspector ? new Oi([r.CONSTANT_COLOR, r.ONE], new c.aM(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Oi.unblended : Oi.alphaBlended;
        }
        depthModeForSublayer(r, d, p) {
          if (!this.opaquePassEnabledForLayer()) return Bt.disabled;
          const _ = 1 - ((1 + this.currentLayer) * this.numSublayers + r) * this.depthEpsilon;
          return new Bt(p || this.context.gl.LEQUAL, d, [_, _]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(r, d) {
          this.style = r, this.options = d, this.lineAtlas = r.lineAtlas, this.imageManager = r.imageManager, this.glyphManager = r.glyphManager, this.symbolFadeChange = r.placement.symbolFadeChange(M.now()), this.imageManager.beginFrame();
          const p = this.style._order, _ = this.style.sourceCaches, g = {}, T = {}, S = {};
          for (const I in _) {
            const D = _[I];
            D.used && D.prepare(this.context), g[I] = D.getVisibleCoordinates(), T[I] = g[I].slice().reverse(), S[I] = D.getVisibleCoordinates(!0).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let I = 0; I < p.length; I++) if (this.style._layers[p[I]].is3D()) {
            this.opaquePassCutoff = I;
            break;
          }
          this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
          for (const I of p) {
            const D = this.style._layers[I];
            if (!D.hasOffscreenPass() || D.isHidden(this.transform.zoom)) continue;
            const k = T[D.source];
            (D.type === "custom" || k.length) && this.renderLayer(this, _[D.source], D, k);
          }
          if (this.context.bindFramebuffer.set(null), this.context.clear({ color: d.showOverdrawInspector ? c.aM.black : c.aM.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(I, D) {
            const k = I.context, N = k.gl, H = ((ae, he, te) => ({ u_sky_color: ae.properties.get("sky-color"), u_horizon_color: ae.properties.get("horizon-color"), u_horizon: (he.height / 2 + he.getHorizon()) * te, u_sky_horizon_blend: ae.properties.get("sky-horizon-blend") * he.height / 2 * te }))(D, I.style.map.transform, I.pixelRatio), q = new Bt(N.LEQUAL, Bt.ReadWrite, [0, 1]), K = ci.disabled, se = I.colorModeForRenderPass(), oe = I.useProgram("sky");
            if (!D.mesh) {
              const ae = new c.aX();
              ae.emplaceBack(-1, -1), ae.emplaceBack(1, -1), ae.emplaceBack(1, 1), ae.emplaceBack(-1, 1);
              const he = new c.aY();
              he.emplaceBack(0, 1, 2), he.emplaceBack(0, 2, 3), D.mesh = new Sl(k.createVertexBuffer(ae, Xr.members), k.createIndexBuffer(he), c.a0.simpleSegment(0, 0, ae.length, he.length));
            }
            oe.draw(k, N.TRIANGLES, q, K, se, ei.disabled, H, void 0, "sky", D.mesh.vertexBuffer, D.mesh.indexBuffer, D.mesh.segments);
          }(this, this.style.sky), this._showOverdrawInspector = d.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (r._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = p.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            const I = this.style._layers[p[this.currentLayer]], D = _[I.source], k = g[I.source];
            this._renderTileClippingMasks(I, k), this.renderLayer(this, D, I, k);
          }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < p.length; this.currentLayer++) {
            const I = this.style._layers[p[this.currentLayer]], D = _[I.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(I)) continue;
            const k = (I.type === "symbol" ? S : T)[I.source];
            this._renderTileClippingMasks(I, g[I.source]), this.renderLayer(this, D, I, k);
          }
          if (this.options.showTileBoundaries) {
            const I = function(D, k) {
              let N = null;
              const H = Object.values(D._layers).flatMap((oe) => oe.source && !oe.isHidden(k) ? [D.sourceCaches[oe.source]] : []), q = H.filter((oe) => oe.getSource().type === "vector"), K = H.filter((oe) => oe.getSource().type !== "vector"), se = (oe) => {
                (!N || N.getSource().maxzoom < oe.getSource().maxzoom) && (N = oe);
              };
              return q.forEach((oe) => se(oe)), N || K.forEach((oe) => se(oe)), N;
            }(this.style, this.transform.zoom);
            I && function(D, k, N) {
              for (let H = 0; H < N.length; H++) ad(D, k, N[H]);
            }(this, I, I.getVisibleCoordinates());
          }
          this.options.showPadding && function(I) {
            const D = I.transform.padding;
            Bo(I, I.transform.height - (D.top || 0), 3, ah), Bo(I, D.bottom || 0, 3, $t), od(I, D.left || 0, 3, Tl), od(I, I.transform.width - (D.right || 0), 3, Hp);
            const k = I.transform.centerPoint;
            (function(N, H, q, K) {
              El(N, H - 1, q - 10, 2, 20, K), El(N, H - 10, q - 1, 20, 2, K);
            })(I, k.x, I.transform.height - k.y, nd);
          }(this), this.context.setDefault();
        }
        maybeDrawDepthAndCoords(r) {
          if (!this.style || !this.style.map || !this.style.map.terrain) return;
          const d = this.terrainFacilitator.matrix, p = this.transform.modelViewProjectionMatrix;
          let _ = this.terrainFacilitator.dirty;
          _ || (_ = r ? !c.a_(d, p) : !c.a$(d, p)), _ || (_ = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), _ && (c.b0(d, p), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(g, T) {
            const S = g.context, I = S.gl, D = Oi.unblended, k = new Bt(I.LEQUAL, Bt.ReadWrite, [0, 1]), N = T.getTerrainMesh(), H = T.sourceCache.getRenderableTiles(), q = g.useProgram("terrainDepth");
            S.bindFramebuffer.set(T.getFramebuffer("depth").framebuffer), S.viewport.set([0, 0, g.width / devicePixelRatio, g.height / devicePixelRatio]), S.clear({ color: c.aM.transparent, depth: 1 });
            for (const K of H) {
              const se = T.getTerrainData(K.tileID), oe = { u_matrix: g.transform.calculatePosMatrix(K.tileID.toUnwrapped()), u_ele_delta: T.getMeshFrameDelta(g.transform.zoom) };
              q.draw(S, I.TRIANGLES, k, ci.disabled, D, ei.backCCW, oe, se, "terrain", N.vertexBuffer, N.indexBuffer, N.segments);
            }
            S.bindFramebuffer.set(null), S.viewport.set([0, 0, g.width, g.height]);
          }(this, this.style.map.terrain), function(g, T) {
            const S = g.context, I = S.gl, D = Oi.unblended, k = new Bt(I.LEQUAL, Bt.ReadWrite, [0, 1]), N = T.getTerrainMesh(), H = T.getCoordsTexture(), q = T.sourceCache.getRenderableTiles(), K = g.useProgram("terrainCoords");
            S.bindFramebuffer.set(T.getFramebuffer("coords").framebuffer), S.viewport.set([0, 0, g.width / devicePixelRatio, g.height / devicePixelRatio]), S.clear({ color: c.aM.transparent, depth: 1 }), T.coordsIndex = [];
            for (const se of q) {
              const oe = T.getTerrainData(se.tileID);
              S.activeTexture.set(I.TEXTURE0), I.bindTexture(I.TEXTURE_2D, H.texture);
              const ae = { u_matrix: g.transform.calculatePosMatrix(se.tileID.toUnwrapped()), u_terrain_coords_id: (255 - T.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: T.getMeshFrameDelta(g.transform.zoom) };
              K.draw(S, I.TRIANGLES, k, ci.disabled, D, ei.backCCW, ae, oe, "terrain", N.vertexBuffer, N.indexBuffer, N.segments), T.coordsIndex.push(se.tileID.key);
            }
            S.bindFramebuffer.set(null), S.viewport.set([0, 0, g.width, g.height]);
          }(this, this.style.map.terrain));
        }
        renderLayer(r, d, p, _) {
          if (!p.isHidden(this.transform.zoom) && (p.type === "background" || p.type === "custom" || (_ || []).length)) switch (this.id = p.id, p.type) {
            case "symbol":
              (function(g, T, S, I, D) {
                if (g.renderPass !== "translucent") return;
                const k = ci.disabled, N = g.colorModeForRenderPass();
                (S._unevaluatedLayout.hasValue("text-variable-anchor") || S._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(H, q, K, se, oe, ae, he, te, fe) {
                  const ge = q.transform, Te = $r(), Fe = oe === "map", Ve = ae === "map";
                  for (const Ye of H) {
                    const st = se.getTile(Ye), Ze = st.getBucket(K);
                    if (!Ze || !Ze.text || !Ze.text.segments.get().length) continue;
                    const Ge = c.ag(Ze.textSizeData, ge.zoom), ut = Pt(st, 1, q.transform.zoom), Et = Er(Ye.posMatrix, Ve, Fe, q.transform, ut), Ke = K.layout.get("icon-text-fit") !== "none" && Ze.hasIconData();
                    if (Ge) {
                      const et = Math.pow(2, ge.zoom - st.tileID.overscaledZ), At = q.style.map.terrain ? (Mt, Ot) => q.style.map.terrain.getElevation(Ye, Mt, Ot) : null, pi = Te.translatePosition(ge, st, he, te);
                      Io(Ze, Fe, Ve, fe, ge, Et, Ye.posMatrix, et, Ge, Ke, Te, pi, Ye.toUnwrapped(), At);
                    }
                  }
                }(I, g, S, T, S.layout.get("text-rotation-alignment"), S.layout.get("text-pitch-alignment"), S.paint.get("text-translate"), S.paint.get("text-translate-anchor"), D), S.paint.get("icon-opacity").constantOr(1) !== 0 && rh(g, T, S, I, !1, S.paint.get("icon-translate"), S.paint.get("icon-translate-anchor"), S.layout.get("icon-rotation-alignment"), S.layout.get("icon-pitch-alignment"), S.layout.get("icon-keep-upright"), k, N), S.paint.get("text-opacity").constantOr(1) !== 0 && rh(g, T, S, I, !0, S.paint.get("text-translate"), S.paint.get("text-translate-anchor"), S.layout.get("text-rotation-alignment"), S.layout.get("text-pitch-alignment"), S.layout.get("text-keep-upright"), k, N), T.map.showCollisionBoxes && (Ea(g, T, S, I, !0), Ea(g, T, S, I, !1));
              })(r, d, p, _, this.style.placement.variableOffsets);
              break;
            case "circle":
              (function(g, T, S, I) {
                if (g.renderPass !== "translucent") return;
                const D = S.paint.get("circle-opacity"), k = S.paint.get("circle-stroke-width"), N = S.paint.get("circle-stroke-opacity"), H = !S.layout.get("circle-sort-key").isConstant();
                if (D.constantOr(1) === 0 && (k.constantOr(1) === 0 || N.constantOr(1) === 0)) return;
                const q = g.context, K = q.gl, se = g.depthModeForSublayer(0, Bt.ReadOnly), oe = ci.disabled, ae = g.colorModeForRenderPass(), he = [];
                for (let te = 0; te < I.length; te++) {
                  const fe = I[te], ge = T.getTile(fe), Te = ge.getBucket(S);
                  if (!Te) continue;
                  const Fe = Te.programConfigurations.get(S.id), Ve = g.useProgram("circle", Fe), Ye = Te.layoutVertexBuffer, st = Te.indexBuffer, Ze = g.style.map.terrain && g.style.map.terrain.getTerrainData(fe), Ge = { programConfiguration: Fe, program: Ve, layoutVertexBuffer: Ye, indexBuffer: st, uniformValues: as(g, fe, ge, S), terrainData: Ze };
                  if (H) {
                    const ut = Te.segments.get();
                    for (const Et of ut) he.push({ segments: new c.a0([Et]), sortKey: Et.sortKey, state: Ge });
                  } else he.push({ segments: Te.segments, sortKey: 0, state: Ge });
                }
                H && he.sort((te, fe) => te.sortKey - fe.sortKey);
                for (const te of he) {
                  const { programConfiguration: fe, program: ge, layoutVertexBuffer: Te, indexBuffer: Fe, uniformValues: Ve, terrainData: Ye } = te.state;
                  ge.draw(q, K.TRIANGLES, se, oe, ae, ei.disabled, Ve, Ye, S.id, Te, Fe, te.segments, S.paint, g.transform.zoom, fe);
                }
              })(r, d, p, _);
              break;
            case "heatmap":
              (function(g, T, S, I) {
                if (S.paint.get("heatmap-opacity") === 0) return;
                const D = g.context;
                if (g.style.map.terrain) {
                  for (const k of I) {
                    const N = T.getTile(k);
                    T.hasRenderableParent(k) || (g.renderPass === "offscreen" ? oh(g, N, S, k) : g.renderPass === "translucent" && no(g, S, k));
                  }
                  D.viewport.set([0, 0, g.width, g.height]);
                } else g.renderPass === "offscreen" ? function(k, N, H, q) {
                  const K = k.context, se = K.gl, oe = ci.disabled, ae = new Oi([se.ONE, se.ONE], c.aM.transparent, [!0, !0, !0, !0]);
                  (function(he, te, fe) {
                    const ge = he.gl;
                    he.activeTexture.set(ge.TEXTURE1), he.viewport.set([0, 0, te.width / 4, te.height / 4]);
                    let Te = fe.heatmapFbos.get(c.aU);
                    Te ? (ge.bindTexture(ge.TEXTURE_2D, Te.colorAttachment.get()), he.bindFramebuffer.set(Te.framebuffer)) : (Te = Ca(he, te.width / 4, te.height / 4), fe.heatmapFbos.set(c.aU, Te));
                  })(K, k, H), K.clear({ color: c.aM.transparent });
                  for (let he = 0; he < q.length; he++) {
                    const te = q[he];
                    if (N.hasRenderableParent(te)) continue;
                    const fe = N.getTile(te), ge = fe.getBucket(H);
                    if (!ge) continue;
                    const Te = ge.programConfigurations.get(H.id), Fe = k.useProgram("heatmap", Te), { zoom: Ve } = k.transform;
                    Fe.draw(K, se.TRIANGLES, Bt.disabled, oe, ae, ei.disabled, zs(te.posMatrix, fe, Ve, H.paint.get("heatmap-intensity")), null, H.id, ge.layoutVertexBuffer, ge.indexBuffer, ge.segments, H.paint, k.transform.zoom, Te);
                  }
                  K.viewport.set([0, 0, k.width, k.height]);
                }(g, T, S, I) : g.renderPass === "translucent" && function(k, N) {
                  const H = k.context, q = H.gl;
                  H.setColorMode(k.colorModeForRenderPass());
                  const K = N.heatmapFbos.get(c.aU);
                  K && (H.activeTexture.set(q.TEXTURE0), q.bindTexture(q.TEXTURE_2D, K.colorAttachment.get()), H.activeTexture.set(q.TEXTURE1), Ia(H, N).bind(q.LINEAR, q.CLAMP_TO_EDGE), k.useProgram("heatmapTexture").draw(H, q.TRIANGLES, Bt.disabled, ci.disabled, k.colorModeForRenderPass(), ei.disabled, pl(k, N, 0, 1), null, N.id, k.viewportBuffer, k.quadTriangleIndexBuffer, k.viewportSegments, N.paint, k.transform.zoom));
                }(g, S);
              })(r, d, p, _);
              break;
            case "line":
              (function(g, T, S, I) {
                if (g.renderPass !== "translucent") return;
                const D = S.paint.get("line-opacity"), k = S.paint.get("line-width");
                if (D.constantOr(1) === 0 || k.constantOr(1) === 0) return;
                const N = g.depthModeForSublayer(0, Bt.ReadOnly), H = g.colorModeForRenderPass(), q = S.paint.get("line-dasharray"), K = S.paint.get("line-pattern"), se = K.constantOr(1), oe = S.paint.get("line-gradient"), ae = S.getCrossfadeParameters(), he = se ? "linePattern" : q ? "lineSDF" : oe ? "lineGradient" : "line", te = g.context, fe = te.gl;
                let ge = !0;
                for (const Te of I) {
                  const Fe = T.getTile(Te);
                  if (se && !Fe.patternsLoaded()) continue;
                  const Ve = Fe.getBucket(S);
                  if (!Ve) continue;
                  const Ye = Ve.programConfigurations.get(S.id), st = g.context.program.get(), Ze = g.useProgram(he, Ye), Ge = ge || Ze.program !== st, ut = g.style.map.terrain && g.style.map.terrain.getTerrainData(Te), Et = K.constantOr(null);
                  if (Et && Fe.imageAtlas) {
                    const At = Fe.imageAtlas, pi = At.patternPositions[Et.to.toString()], Mt = At.patternPositions[Et.from.toString()];
                    pi && Mt && Ye.setConstantPatternPositions(pi, Mt);
                  }
                  const Ke = ut ? Te : null, et = se ? So(g, Fe, S, ae, Ke) : q ? Rp(g, Fe, S, q, ae, Ke) : oe ? Hu(g, Fe, S, Ve.lineClipsArray.length, Ke) : ml(g, Fe, S, Ke);
                  if (se) te.activeTexture.set(fe.TEXTURE0), Fe.imageAtlasTexture.bind(fe.LINEAR, fe.CLAMP_TO_EDGE), Ye.updatePaintBuffers(ae);
                  else if (q && (Ge || g.lineAtlas.dirty)) te.activeTexture.set(fe.TEXTURE0), g.lineAtlas.bind(te);
                  else if (oe) {
                    const At = Ve.gradients[S.id];
                    let pi = At.texture;
                    if (S.gradientVersion !== At.version) {
                      let Mt = 256;
                      if (S.stepInterpolant) {
                        const Ot = T.getSource().maxzoom, _i = Te.canonical.z === Ot ? Math.ceil(1 << g.transform.maxZoom - Te.canonical.z) : 1;
                        Mt = c.ac(c.aV(Ve.maxLineLength / c.X * 1024 * _i), 256, te.maxTextureSize);
                      }
                      At.gradient = c.aW({ expression: S.gradientExpression(), evaluationKey: "lineProgress", resolution: Mt, image: At.gradient || void 0, clips: Ve.lineClipsArray }), At.texture ? At.texture.update(At.gradient) : At.texture = new it(te, At.gradient, fe.RGBA), At.version = S.gradientVersion, pi = At.texture;
                    }
                    te.activeTexture.set(fe.TEXTURE0), pi.bind(S.stepInterpolant ? fe.NEAREST : fe.LINEAR, fe.CLAMP_TO_EDGE);
                  }
                  Ze.draw(te, fe.TRIANGLES, N, g.stencilModeForClipping(Te), H, ei.disabled, et, ut, S.id, Ve.layoutVertexBuffer, Ve.indexBuffer, Ve.segments, S.paint, g.transform.zoom, Ye, Ve.layoutVertexBuffer2), ge = !1;
                }
              })(r, d, p, _);
              break;
            case "fill":
              (function(g, T, S, I) {
                const D = S.paint.get("fill-color"), k = S.paint.get("fill-opacity");
                if (k.constantOr(1) === 0) return;
                const N = g.colorModeForRenderPass(), H = S.paint.get("fill-pattern"), q = g.opaquePassEnabledForLayer() && !H.constantOr(1) && D.constantOr(c.aM.transparent).a === 1 && k.constantOr(0) === 1 ? "opaque" : "translucent";
                if (g.renderPass === q) {
                  const K = g.depthModeForSublayer(1, g.renderPass === "opaque" ? Bt.ReadWrite : Bt.ReadOnly);
                  Ra(g, T, S, I, K, N, !1);
                }
                if (g.renderPass === "translucent" && S.paint.get("fill-antialias")) {
                  const K = g.depthModeForSublayer(S.getPaintProperty("fill-outline-color") ? 2 : 0, Bt.ReadOnly);
                  Ra(g, T, S, I, K, N, !0);
                }
              })(r, d, p, _);
              break;
            case "fill-extrusion":
              (function(g, T, S, I) {
                const D = S.paint.get("fill-extrusion-opacity");
                if (D !== 0 && g.renderPass === "translucent") {
                  const k = new Bt(g.context.gl.LEQUAL, Bt.ReadWrite, g.depthRangeFor3D);
                  if (D !== 1 || S.paint.get("fill-extrusion-pattern").constantOr(1)) Al(g, T, S, I, k, ci.disabled, Oi.disabled), Al(g, T, S, I, k, g.stencilModeFor3D(), g.colorModeForRenderPass());
                  else {
                    const N = g.colorModeForRenderPass();
                    Al(g, T, S, I, k, ci.disabled, N);
                  }
                }
              })(r, d, p, _);
              break;
            case "hillshade":
              (function(g, T, S, I) {
                if (g.renderPass !== "offscreen" && g.renderPass !== "translucent") return;
                const D = g.context, k = g.depthModeForSublayer(0, Bt.ReadOnly), N = g.colorModeForRenderPass(), [H, q] = g.renderPass === "translucent" ? g.stencilConfigForOverlap(I) : [{}, I];
                for (const K of q) {
                  const se = T.getTile(K);
                  se.needsHillshadePrepare !== void 0 && se.needsHillshadePrepare && g.renderPass === "offscreen" ? Po(g, se, S, k, ci.disabled, N) : g.renderPass === "translucent" && Mo(g, K, se, S, k, H[K.overscaledZ], N);
                }
                D.viewport.set([0, 0, g.width, g.height]);
              })(r, d, p, _);
              break;
            case "raster":
              (function(g, T, S, I) {
                if (g.renderPass !== "translucent" || S.paint.get("raster-opacity") === 0 || !I.length) return;
                const D = g.context, k = D.gl, N = T.getSource(), H = g.useProgram("raster"), q = g.colorModeForRenderPass(), [K, se] = N instanceof Ar ? [{}, I] : g.stencilConfigForOverlap(I), oe = se[se.length - 1].overscaledZ, ae = !g.options.moving;
                for (const he of se) {
                  const te = g.depthModeForSublayer(he.overscaledZ - oe, S.paint.get("raster-opacity") === 1 ? Bt.ReadWrite : Bt.ReadOnly, k.LESS), fe = T.getTile(he);
                  fe.registerFadeDuration(S.paint.get("raster-fade-duration"));
                  const ge = T.findLoadedParent(he, 0), Te = T.findLoadedSibling(he), Fe = rd(fe, ge || Te || null, T, S, g.transform, g.style.map.terrain);
                  let Ve, Ye;
                  const st = S.paint.get("raster-resampling") === "nearest" ? k.NEAREST : k.LINEAR;
                  D.activeTexture.set(k.TEXTURE0), fe.texture.bind(st, k.CLAMP_TO_EDGE, k.LINEAR_MIPMAP_NEAREST), D.activeTexture.set(k.TEXTURE1), ge ? (ge.texture.bind(st, k.CLAMP_TO_EDGE, k.LINEAR_MIPMAP_NEAREST), Ve = Math.pow(2, ge.tileID.overscaledZ - fe.tileID.overscaledZ), Ye = [fe.tileID.canonical.x * Ve % 1, fe.tileID.canonical.y * Ve % 1]) : fe.texture.bind(st, k.CLAMP_TO_EDGE, k.LINEAR_MIPMAP_NEAREST), fe.texture.useMipmap && D.extTextureFilterAnisotropic && g.transform.pitch > 20 && k.texParameterf(k.TEXTURE_2D, D.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, D.extTextureFilterAnisotropicMax);
                  const Ze = g.style.map.terrain && g.style.map.terrain.getTerrainData(he), Ge = Ze ? he : null, ut = Ge ? Ge.posMatrix : g.transform.calculatePosMatrix(he.toUnwrapped(), ae), Et = Mp(ut, Ye || [0, 0], Ve || 1, Fe, S);
                  N instanceof Ar ? H.draw(D, k.TRIANGLES, te, ci.disabled, q, ei.disabled, Et, Ze, S.id, N.boundsBuffer, g.quadTriangleIndexBuffer, N.boundsSegments) : H.draw(D, k.TRIANGLES, te, K[he.overscaledZ], q, ei.disabled, Et, Ze, S.id, g.rasterBoundsBuffer, g.quadTriangleIndexBuffer, g.rasterBoundsSegments);
                }
              })(r, d, p, _);
              break;
            case "background":
              (function(g, T, S, I) {
                const D = S.paint.get("background-color"), k = S.paint.get("background-opacity");
                if (k === 0) return;
                const N = g.context, H = N.gl, q = g.transform, K = q.tileSize, se = S.paint.get("background-pattern");
                if (g.isPatternMissing(se)) return;
                const oe = !se && D.a === 1 && k === 1 && g.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (g.renderPass !== oe) return;
                const ae = ci.disabled, he = g.depthModeForSublayer(0, oe === "opaque" ? Bt.ReadWrite : Bt.ReadOnly), te = g.colorModeForRenderPass(), fe = g.useProgram(se ? "backgroundPattern" : "background"), ge = I || q.coveringTiles({ tileSize: K, terrain: g.style.map.terrain });
                se && (N.activeTexture.set(H.TEXTURE0), g.imageManager.bind(g.context));
                const Te = S.getCrossfadeParameters();
                for (const Fe of ge) {
                  const Ve = I ? Fe.posMatrix : g.transform.calculatePosMatrix(Fe.toUnwrapped()), Ye = se ? Wc(Ve, k, g, se, { tileID: Fe, tileSize: K }, Te) : gl(Ve, k, D), st = g.style.map.terrain && g.style.map.terrain.getTerrainData(Fe);
                  fe.draw(N, H.TRIANGLES, he, ae, te, ei.disabled, Ye, st, S.id, g.tileExtentBuffer, g.quadTriangleIndexBuffer, g.tileExtentSegments);
                }
              })(r, 0, p, _);
              break;
            case "custom":
              (function(g, T, S) {
                const I = g.context, D = S.implementation;
                if (g.renderPass === "offscreen") {
                  const k = D.prerender;
                  k && (g.setCustomLayerDefaults(), I.setColorMode(g.colorModeForRenderPass()), k.call(D, I.gl, g.transform.customLayerMatrix()), I.setDirty(), g.setBaseState());
                } else if (g.renderPass === "translucent") {
                  g.setCustomLayerDefaults(), I.setColorMode(g.colorModeForRenderPass()), I.setStencilMode(ci.disabled);
                  const k = D.renderingMode === "3d" ? new Bt(g.context.gl.LEQUAL, Bt.ReadWrite, g.depthRangeFor3D) : g.depthModeForSublayer(0, Bt.ReadOnly);
                  I.setDepthMode(k), D.render(I.gl, g.transform.customLayerMatrix(), { farZ: g.transform.farZ, nearZ: g.transform.nearZ, fov: g.transform._fov, modelViewProjectionMatrix: g.transform.modelViewProjectionMatrix, projectionMatrix: g.transform.projectionMatrix }), I.setDirty(), g.setBaseState(), I.bindFramebuffer.set(null);
                }
              })(r, 0, p);
          }
        }
        translatePosMatrix(r, d, p, _, g) {
          if (!p[0] && !p[1]) return r;
          const T = g ? _ === "map" ? this.transform.angle : 0 : _ === "viewport" ? -this.transform.angle : 0;
          if (T) {
            const D = Math.sin(T), k = Math.cos(T);
            p = [p[0] * k - p[1] * D, p[0] * D + p[1] * k];
          }
          const S = [g ? p[0] : Pt(d, p[0], this.transform.zoom), g ? p[1] : Pt(d, p[1], this.transform.zoom), 0], I = new Float32Array(16);
          return c.J(I, r, S), I;
        }
        saveTileTexture(r) {
          const d = this._tileTextures[r.size[0]];
          d ? d.push(r) : this._tileTextures[r.size[0]] = [r];
        }
        getTileTexture(r) {
          const d = this._tileTextures[r];
          return d && d.length > 0 ? d.pop() : null;
        }
        isPatternMissing(r) {
          if (!r) return !1;
          if (!r.from || !r.to) return !0;
          const d = this.imageManager.getPattern(r.from.toString()), p = this.imageManager.getPattern(r.to.toString());
          return !d || !p;
        }
        useProgram(r, d) {
          this.cache = this.cache || {};
          const p = r + (d ? d.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
          return this.cache[p] || (this.cache[p] = new Z(this.context, ur[r], d, qc[r], this._showOverdrawInspector, this.style.map.terrain)), this.cache[p];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const r = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(r.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new it(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: r, drawingBufferHeight: d } = this.context.gl;
          return this.width !== r || this.height !== d;
        }
      }
      class Do {
        constructor(r, d) {
          this.points = r, this.planes = d;
        }
        static fromInvProjectionMatrix(r, d, p) {
          const _ = Math.pow(2, p), g = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((S) => {
            const I = 1 / (S = c.af([], S, r))[3] / d * _;
            return c.b1(S, S, [I, I, 1 / S[3], I]);
          }), T = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((S) => {
            const I = function(H, q) {
              var K = q[0], se = q[1], oe = q[2], ae = K * K + se * se + oe * oe;
              return ae > 0 && (ae = 1 / Math.sqrt(ae)), H[0] = q[0] * ae, H[1] = q[1] * ae, H[2] = q[2] * ae, H;
            }([], function(H, q, K) {
              var se = q[0], oe = q[1], ae = q[2], he = K[0], te = K[1], fe = K[2];
              return H[0] = oe * fe - ae * te, H[1] = ae * he - se * fe, H[2] = se * te - oe * he, H;
            }([], nt([], g[S[0]], g[S[1]]), nt([], g[S[2]], g[S[1]]))), D = -((k = I)[0] * (N = g[S[1]])[0] + k[1] * N[1] + k[2] * N[2]);
            var k, N;
            return I.concat(D);
          });
          return new Do(g, T);
        }
      }
      class Oo {
        constructor(r, d) {
          this.min = r, this.max = d, this.center = function(p, _, g) {
            return p[0] = 0.5 * _[0], p[1] = 0.5 * _[1], p[2] = 0.5 * _[2], p;
          }([], function(p, _, g) {
            return p[0] = _[0] + g[0], p[1] = _[1] + g[1], p[2] = _[2] + g[2], p;
          }([], this.min, this.max));
        }
        quadrant(r) {
          const d = [r % 2 == 0, r < 2], p = Ne(this.min), _ = Ne(this.max);
          for (let g = 0; g < d.length; g++) p[g] = d[g] ? this.min[g] : this.center[g], _[g] = d[g] ? this.center[g] : this.max[g];
          return _[2] = this.max[2], new Oo(p, _);
        }
        distanceX(r) {
          return Math.max(Math.min(this.max[0], r[0]), this.min[0]) - r[0];
        }
        distanceY(r) {
          return Math.max(Math.min(this.max[1], r[1]), this.min[1]) - r[1];
        }
        intersects(r) {
          const d = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
          let p = !0;
          for (let _ = 0; _ < r.planes.length; _++) {
            const g = r.planes[_];
            let T = 0;
            for (let S = 0; S < d.length; S++) c.b2(g, d[S]) >= 0 && T++;
            if (T === 0) return 0;
            T !== d.length && (p = !1);
          }
          if (p) return 2;
          for (let _ = 0; _ < 3; _++) {
            let g = Number.MAX_VALUE, T = -Number.MAX_VALUE;
            for (let S = 0; S < r.points.length; S++) {
              const I = r.points[S][_] - this.min[_];
              g = Math.min(g, I), T = Math.max(T, I);
            }
            if (T < 0 || g > this.max[_] - this.min[_]) return 0;
          }
          return 1;
        }
      }
      class Fo {
        constructor(r = 0, d = 0, p = 0, _ = 0) {
          if (isNaN(r) || r < 0 || isNaN(d) || d < 0 || isNaN(p) || p < 0 || isNaN(_) || _ < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = r, this.bottom = d, this.left = p, this.right = _;
        }
        interpolate(r, d, p) {
          return d.top != null && r.top != null && (this.top = c.y.number(r.top, d.top, p)), d.bottom != null && r.bottom != null && (this.bottom = c.y.number(r.bottom, d.bottom, p)), d.left != null && r.left != null && (this.left = c.y.number(r.left, d.left, p)), d.right != null && r.right != null && (this.right = c.y.number(r.right, d.right, p)), this;
        }
        getCenter(r, d) {
          const p = c.ac((this.left + r - this.right) / 2, 0, r), _ = c.ac((this.top + d - this.bottom) / 2, 0, d);
          return new c.P(p, _);
        }
        equals(r) {
          return this.top === r.top && this.bottom === r.bottom && this.left === r.left && this.right === r.right;
        }
        clone() {
          return new Fo(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      const lh = 85.051129;
      class ko {
        constructor(r, d, p, _, g) {
          this.tileSize = 512, this._renderWorldCopies = g === void 0 || !!g, this._minZoom = r || 0, this._maxZoom = d || 22, this._minPitch = p ?? 0, this._maxPitch = _ ?? 60, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new c.N(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new Fo(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {}, this.minElevationForCurrentTile = 0;
        }
        clone() {
          const r = new ko(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return r.apply(this), r;
        }
        apply(r) {
          this.tileSize = r.tileSize, this.latRange = r.latRange, this.lngRange = r.lngRange, this.width = r.width, this.height = r.height, this._center = r._center, this._elevation = r._elevation, this.minElevationForCurrentTile = r.minElevationForCurrentTile, this.zoom = r.zoom, this.angle = r.angle, this._fov = r._fov, this._pitch = r._pitch, this._unmodified = r._unmodified, this._edgeInsets = r._edgeInsets.clone(), this._calcMatrices();
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(r) {
          this._minZoom !== r && (this._minZoom = r, this.zoom = Math.max(this.zoom, r));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(r) {
          this._maxZoom !== r && (this._maxZoom = r, this.zoom = Math.min(this.zoom, r));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(r) {
          this._minPitch !== r && (this._minPitch = r, this.pitch = Math.max(this.pitch, r));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(r) {
          this._maxPitch !== r && (this._maxPitch = r, this.pitch = Math.min(this.pitch, r));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(r) {
          r === void 0 ? r = !0 : r === null && (r = !1), this._renderWorldCopies = r;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new c.P(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(r) {
          const d = -c.b3(r, -180, 180) * Math.PI / 180;
          this.angle !== d && (this._unmodified = !1, this.angle = d, this._calcMatrices(), this.rotationMatrix = function() {
            var p = new c.A(4);
            return c.A != Float32Array && (p[1] = 0, p[2] = 0), p[0] = 1, p[3] = 1, p;
          }(), function(p, _, g) {
            var T = _[0], S = _[1], I = _[2], D = _[3], k = Math.sin(g), N = Math.cos(g);
            p[0] = T * N + I * k, p[1] = S * N + D * k, p[2] = T * -k + I * N, p[3] = S * -k + D * N;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(r) {
          const d = c.ac(r, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== d && (this._unmodified = !1, this._pitch = d, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(r) {
          r = Math.max(0.01, Math.min(60, r)), this._fov !== r && (this._unmodified = !1, this._fov = r / 180 * Math.PI, this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(r) {
          const d = Math.min(Math.max(r, this.minZoom), this.maxZoom);
          this._zoom !== d && (this._unmodified = !1, this._zoom = d, this.tileZoom = Math.max(0, Math.floor(d)), this.scale = this.zoomScale(d), this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        set center(r) {
          r.lat === this._center.lat && r.lng === this._center.lng || (this._unmodified = !1, this._center = r, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(r) {
          r !== this._elevation && (this._elevation = r, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(r) {
          this._edgeInsets.equals(r) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, r, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        isPaddingEqual(r) {
          return this._edgeInsets.equals(r);
        }
        interpolatePadding(r, d, p) {
          this._unmodified = !1, this._edgeInsets.interpolate(r, d, p), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(r) {
          const d = (r.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / r.tileSize));
          return Math.max(0, d);
        }
        getVisibleUnwrappedCoordinates(r) {
          const d = [new c.b4(0, r)];
          if (this._renderWorldCopies) {
            const p = this.pointCoordinate(new c.P(0, 0)), _ = this.pointCoordinate(new c.P(this.width, 0)), g = this.pointCoordinate(new c.P(this.width, this.height)), T = this.pointCoordinate(new c.P(0, this.height)), S = Math.floor(Math.min(p.x, _.x, g.x, T.x)), I = Math.floor(Math.max(p.x, _.x, g.x, T.x)), D = 1;
            for (let k = S - D; k <= I + D; k++) k !== 0 && d.push(new c.b4(k, r));
          }
          return d;
        }
        coveringTiles(r) {
          var d, p;
          let _ = this.coveringZoomLevel(r);
          const g = _;
          if (r.minzoom !== void 0 && _ < r.minzoom) return [];
          r.maxzoom !== void 0 && _ > r.maxzoom && (_ = r.maxzoom);
          const T = this.pointCoordinate(this.getCameraPoint()), S = c.Z.fromLngLat(this.center), I = Math.pow(2, _), D = [I * T.x, I * T.y, 0], k = [I * S.x, I * S.y, 0], N = Do.fromInvProjectionMatrix(this.invModelViewProjectionMatrix, this.worldSize, _);
          let H = r.minzoom || 0;
          !r.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (H = _);
          const q = r.terrain ? 2 / Math.min(this.tileSize, r.tileSize) * this.tileSize : 3, K = (te) => ({ aabb: new Oo([te * I, 0, 0], [(te + 1) * I, I, 0]), zoom: 0, x: 0, y: 0, wrap: te, fullyVisible: !1 }), se = [], oe = [], ae = _, he = r.reparseOverscaled ? g : _;
          if (this._renderWorldCopies) for (let te = 1; te <= 3; te++) se.push(K(-te)), se.push(K(te));
          for (se.push(K(0)); se.length > 0; ) {
            const te = se.pop(), fe = te.x, ge = te.y;
            let Te = te.fullyVisible;
            if (!Te) {
              const Ze = te.aabb.intersects(N);
              if (Ze === 0) continue;
              Te = Ze === 2;
            }
            const Fe = r.terrain ? D : k, Ve = te.aabb.distanceX(Fe), Ye = te.aabb.distanceY(Fe), st = Math.max(Math.abs(Ve), Math.abs(Ye));
            if (te.zoom === ae || st > q + (1 << ae - te.zoom) - 2 && te.zoom >= H) {
              const Ze = ae - te.zoom, Ge = D[0] - 0.5 - (fe << Ze), ut = D[1] - 0.5 - (ge << Ze);
              oe.push({ tileID: new c.S(te.zoom === ae ? he : te.zoom, te.wrap, te.zoom, fe, ge), distanceSq: mt([k[0] - 0.5 - fe, k[1] - 0.5 - ge]), tileDistanceToCamera: Math.sqrt(Ge * Ge + ut * ut) });
            } else for (let Ze = 0; Ze < 4; Ze++) {
              const Ge = (fe << 1) + Ze % 2, ut = (ge << 1) + (Ze >> 1), Et = te.zoom + 1;
              let Ke = te.aabb.quadrant(Ze);
              if (r.terrain) {
                const et = new c.S(Et, te.wrap, Et, Ge, ut), At = r.terrain.getMinMaxElevation(et), pi = (d = At.minElevation) !== null && d !== void 0 ? d : this.elevation, Mt = (p = At.maxElevation) !== null && p !== void 0 ? p : this.elevation;
                Ke = new Oo([Ke.min[0], Ke.min[1], pi], [Ke.max[0], Ke.max[1], Mt]);
              }
              se.push({ aabb: Ke, zoom: Et, x: Ge, y: ut, wrap: te.wrap, fullyVisible: Te });
            }
          }
          return oe.sort((te, fe) => te.distanceSq - fe.distanceSq).map((te) => te.tileID);
        }
        resize(r, d) {
          this.width = r, this.height = d, this.pixelsToGLUnits = [2 / r, -2 / d], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(r) {
          return Math.pow(2, r);
        }
        scaleZoom(r) {
          return Math.log(r) / Math.LN2;
        }
        project(r) {
          const d = c.ac(r.lat, -85.051129, lh);
          return new c.P(c.O(r.lng) * this.worldSize, c.Q(d) * this.worldSize);
        }
        unproject(r) {
          return new c.Z(r.x / this.worldSize, r.y / this.worldSize).toLngLat();
        }
        get point() {
          return this.project(this.center);
        }
        getCameraPosition() {
          return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
        }
        recalculateZoom(r) {
          const d = this.elevation, p = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, _ = this.pointLocation(this.centerPoint, r), g = r.getElevationForLngLatZoom(_, this.tileZoom);
          if (!(this.elevation - g)) return;
          const T = p + d - g, S = Math.cos(this._pitch) * this.cameraToCenterDistance / T / c.b5(1, _.lat), I = this.scaleZoom(S / this.tileSize);
          this._elevation = g, this._center = _, this.zoom = I;
        }
        setLocationAtPoint(r, d) {
          const p = this.pointCoordinate(d), _ = this.pointCoordinate(this.centerPoint), g = this.locationCoordinate(r), T = new c.Z(g.x - (p.x - _.x), g.y - (p.y - _.y));
          this.center = this.coordinateLocation(T), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        locationPoint(r, d) {
          return d ? this.coordinatePoint(this.locationCoordinate(r), d.getElevationForLngLatZoom(r, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(r));
        }
        pointLocation(r, d) {
          return this.coordinateLocation(this.pointCoordinate(r, d));
        }
        locationCoordinate(r) {
          return c.Z.fromLngLat(r);
        }
        coordinateLocation(r) {
          return r && r.toLngLat();
        }
        pointCoordinate(r, d) {
          if (d) {
            const H = d.pointCoordinate(r);
            if (H != null) return H;
          }
          const p = [r.x, r.y, 0, 1], _ = [r.x, r.y, 1, 1];
          c.af(p, p, this.pixelMatrixInverse), c.af(_, _, this.pixelMatrixInverse);
          const g = p[3], T = _[3], S = p[1] / g, I = _[1] / T, D = p[2] / g, k = _[2] / T, N = D === k ? 0 : (0 - D) / (k - D);
          return new c.Z(c.y.number(p[0] / g, _[0] / T, N) / this.worldSize, c.y.number(S, I, N) / this.worldSize);
        }
        coordinatePoint(r, d = 0, p = this.pixelMatrix) {
          const _ = [r.x * this.worldSize, r.y * this.worldSize, d, 1];
          return c.af(_, _, p), new c.P(_[0] / _[3], _[1] / _[3]);
        }
        getBounds() {
          const r = Math.max(0, this.height / 2 - this.getHorizon());
          return new Ie().extend(this.pointLocation(new c.P(0, r))).extend(this.pointLocation(new c.P(this.width, r))).extend(this.pointLocation(new c.P(this.width, this.height))).extend(this.pointLocation(new c.P(0, this.height)));
        }
        getMaxBounds() {
          return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new Ie([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }
        getHorizon() {
          return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
        }
        setMaxBounds(r) {
          r ? (this.lngRange = [r.getWest(), r.getEast()], this.latRange = [r.getSouth(), r.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-85.051129, lh]);
        }
        calculateTileMatrix(r) {
          const d = r.canonical, p = this.worldSize / this.zoomScale(d.z), _ = d.x + Math.pow(2, d.z) * r.wrap, g = c.an(new Float64Array(16));
          return c.J(g, g, [_ * p, d.y * p, 0]), c.K(g, g, [p / c.X, p / c.X, 1]), g;
        }
        calculatePosMatrix(r, d = !1) {
          const p = r.key, _ = d ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (_[p]) return _[p];
          const g = this.calculateTileMatrix(r);
          return c.L(g, d ? this.alignedModelViewProjectionMatrix : this.modelViewProjectionMatrix, g), _[p] = new Float32Array(g), _[p];
        }
        calculateFogMatrix(r) {
          const d = r.key, p = this._fogMatrixCache;
          if (p[d]) return p[d];
          const _ = this.calculateTileMatrix(r);
          return c.L(_, this.fogMatrix, _), p[d] = new Float32Array(_), p[d];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        getConstrained(r, d) {
          d = c.ac(+d, this.minZoom, this.maxZoom);
          const p = { center: new c.N(r.lng, r.lat), zoom: d };
          let _ = this.lngRange;
          if (!this._renderWorldCopies && _ === null) {
            const te = 179.9999999999;
            _ = [-te, te];
          }
          const g = this.tileSize * this.zoomScale(p.zoom);
          let T = 0, S = g, I = 0, D = g, k = 0, N = 0;
          const { x: H, y: q } = this.size;
          if (this.latRange) {
            const te = this.latRange;
            T = c.Q(te[1]) * g, S = c.Q(te[0]) * g, S - T < q && (k = q / (S - T));
          }
          _ && (I = c.b3(c.O(_[0]) * g, 0, g), D = c.b3(c.O(_[1]) * g, 0, g), D < I && (D += g), D - I < H && (N = H / (D - I)));
          const { x: K, y: se } = this.project.call({ worldSize: g }, r);
          let oe, ae;
          const he = Math.max(N || 0, k || 0);
          if (he) {
            const te = new c.P(N ? (D + I) / 2 : K, k ? (S + T) / 2 : se);
            return p.center = this.unproject.call({ worldSize: g }, te).wrap(), p.zoom += this.scaleZoom(he), p;
          }
          if (this.latRange) {
            const te = q / 2;
            se - te < T && (ae = T + te), se + te > S && (ae = S - te);
          }
          if (_) {
            const te = (I + D) / 2;
            let fe = K;
            this._renderWorldCopies && (fe = c.b3(K, te - g / 2, te + g / 2));
            const ge = H / 2;
            fe - ge < I && (oe = I + ge), fe + ge > D && (oe = D - ge);
          }
          if (oe !== void 0 || ae !== void 0) {
            const te = new c.P(oe ?? K, ae ?? se);
            p.center = this.unproject.call({ worldSize: g }, te).wrap();
          }
          return p;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining) return;
          this._constraining = !0;
          const r = this._unmodified, { center: d, zoom: p } = this.getConstrained(this.center, this.zoom);
          this.center = d, this.zoom = p, this._unmodified = r, this._constraining = !1;
        }
        _calcMatrices() {
          if (!this.height) return;
          const r = this.centerOffset, d = this.point.x, p = this.point.y;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = c.b5(1, this.center.lat) * this.worldSize;
          let _ = c.an(new Float64Array(16));
          c.K(_, _, [this.width / 2, -this.height / 2, 1]), c.J(_, _, [1, -1, 0]), this.labelPlaneMatrix = _, _ = c.an(new Float64Array(16)), c.K(_, _, [1, -1, 1]), c.J(_, _, [-1, -1, 0]), c.K(_, _, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = _;
          const g = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), T = Math.min(this.elevation, this.minElevationForCurrentTile), S = g - T * this._pixelPerMeter / Math.cos(this._pitch), I = T < 0 ? S : g, D = Math.PI / 2 + this._pitch, k = this._fov * (0.5 + r.y / this.height), N = Math.sin(k) * I / Math.sin(c.ac(Math.PI - D - k, 0.01, Math.PI - 0.01)), H = this.getHorizon(), q = 2 * Math.atan(H / this.cameraToCenterDistance) * (0.5 + r.y / (2 * H)), K = Math.sin(q) * I / Math.sin(c.ac(Math.PI - D - q, 0.01, Math.PI - 0.01)), se = Math.min(N, K);
          this.farZ = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * se + I), this.nearZ = this.height / 50, _ = new Float64Array(16), c.b6(_, this._fov, this.width / this.height, this.nearZ, this.farZ), _[8] = 2 * -r.x / this.width, _[9] = 2 * r.y / this.height, this.projectionMatrix = c.ae(_), c.K(_, _, [1, -1, 1]), c.J(_, _, [0, 0, -this.cameraToCenterDistance]), c.b7(_, _, this._pitch), c.ad(_, _, this.angle), c.J(_, _, [-d, -p, 0]), this.mercatorMatrix = c.K([], _, [this.worldSize, this.worldSize, this.worldSize]), c.K(_, _, [1, 1, this._pixelPerMeter]), this.pixelMatrix = c.L(new Float64Array(16), this.labelPlaneMatrix, _), c.J(_, _, [0, 0, -this.elevation]), this.modelViewProjectionMatrix = _, this.invModelViewProjectionMatrix = c.as([], _), this.fogMatrix = new Float64Array(16), c.b6(this.fogMatrix, this._fov, this.width / this.height, g, this.farZ), this.fogMatrix[8] = 2 * -r.x / this.width, this.fogMatrix[9] = 2 * r.y / this.height, c.K(this.fogMatrix, this.fogMatrix, [1, -1, 1]), c.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.cameraToCenterDistance]), c.b7(this.fogMatrix, this.fogMatrix, this._pitch), c.ad(this.fogMatrix, this.fogMatrix, this.angle), c.J(this.fogMatrix, this.fogMatrix, [-d, -p, 0]), c.K(this.fogMatrix, this.fogMatrix, [1, 1, this._pixelPerMeter]), c.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.elevation]), this.pixelMatrix3D = c.L(new Float64Array(16), this.labelPlaneMatrix, _);
          const oe = this.width % 2 / 2, ae = this.height % 2 / 2, he = Math.cos(this.angle), te = Math.sin(this.angle), fe = d - Math.round(d) + he * oe + te * ae, ge = p - Math.round(p) + he * ae + te * oe, Te = new Float64Array(_);
          if (c.J(Te, Te, [fe > 0.5 ? fe - 1 : fe, ge > 0.5 ? ge - 1 : ge, 0]), this.alignedModelViewProjectionMatrix = Te, _ = c.as(new Float64Array(16), this.pixelMatrix), !_) throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = _, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {};
        }
        maxPitchScaleFactor() {
          if (!this.pixelMatrixInverse) return 1;
          const r = this.pointCoordinate(new c.P(0, 0)), d = [r.x * this.worldSize, r.y * this.worldSize, 0, 1];
          return c.af(d, d, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }
        getCameraPoint() {
          const r = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new c.P(0, r));
        }
        getCameraQueryGeometry(r) {
          const d = this.getCameraPoint();
          if (r.length === 1) return [r[0], d];
          {
            let p = d.x, _ = d.y, g = d.x, T = d.y;
            for (const S of r) p = Math.min(p, S.x), _ = Math.min(_, S.y), g = Math.max(g, S.x), T = Math.max(T, S.y);
            return [new c.P(p, _), new c.P(g, _), new c.P(g, T), new c.P(p, T), new c.P(p, _)];
          }
        }
        lngLatToCameraDepth(r, d) {
          const p = this.locationCoordinate(r), _ = [p.x * this.worldSize, p.y * this.worldSize, d, 1];
          return c.af(_, _, this.modelViewProjectionMatrix), _[2] / _[3];
        }
      }
      function Ma(y, r) {
        let d, p = !1, _ = null, g = null;
        const T = () => {
          _ = null, p && (y.apply(g, d), _ = setTimeout(T, r), p = !1);
        };
        return (...S) => (p = !0, g = this, d = S, _ || T(), _);
      }
      class Il {
        constructor(r) {
          this._getCurrentHash = () => {
            const d = window.location.hash.replace("#", "");
            if (this._hashName) {
              let p;
              return d.split("&").map((_) => _.split("=")).forEach((_) => {
                _[0] === this._hashName && (p = _);
              }), (p && p[1] || "").split("/");
            }
            return d.split("/");
          }, this._onHashChange = () => {
            const d = this._getCurrentHash();
            if (d.length >= 3 && !d.some((p) => isNaN(p))) {
              const p = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(d[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+d[2], +d[1]], zoom: +d[0], bearing: p, pitch: +(d[4] || 0) }), !0;
            }
            return !1;
          }, this._updateHashUnthrottled = () => {
            const d = window.location.href.replace(/(#.*)?$/, this.getHashString());
            window.history.replaceState(window.history.state, null, d);
          }, this._removeHash = () => {
            const d = this._getCurrentHash();
            if (d.length === 0) return;
            const p = d.join("/");
            let _ = p;
            _.split("&").length > 0 && (_ = _.split("&")[0]), this._hashName && (_ = `${this._hashName}=${p}`);
            let g = window.location.hash.replace(_, "");
            g.startsWith("#&") ? g = g.slice(0, 1) + g.slice(2) : g === "#" && (g = "");
            let T = window.location.href.replace(/(#.+)?$/, g);
            T = T.replace("&&", "&"), window.history.replaceState(window.history.state, null, T);
          }, this._updateHash = Ma(this._updateHashUnthrottled, 300), this._hashName = r && encodeURIComponent(r);
        }
        addTo(r) {
          return this._map = r, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
        }
        getHashString(r) {
          const d = this._map.getCenter(), p = Math.round(100 * this._map.getZoom()) / 100, _ = Math.ceil((p * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), g = Math.pow(10, _), T = Math.round(d.lng * g) / g, S = Math.round(d.lat * g) / g, I = this._map.getBearing(), D = this._map.getPitch();
          let k = "";
          if (k += r ? `/${T}/${S}/${p}` : `${p}/${S}/${T}`, (I || D) && (k += "/" + Math.round(10 * I) / 10), D && (k += `/${Math.round(D)}`), this._hashName) {
            const N = this._hashName;
            let H = !1;
            const q = window.location.hash.slice(1).split("&").map((K) => {
              const se = K.split("=")[0];
              return se === N ? (H = !0, `${se}=${k}`) : K;
            }).filter((K) => K);
            return H || q.push(`${N}=${k}`), `#${q.join("&")}`;
          }
          return `#${k}`;
        }
      }
      const Rl = { linearity: 0.3, easing: c.b8(0, 0, 0.3, 1) }, ch = c.e({ deceleration: 2500, maxSpeed: 1400 }, Rl), jp = c.e({ deceleration: 20, maxSpeed: 1400 }, Rl), cd = c.e({ deceleration: 1e3, maxSpeed: 360 }, Rl), Ml = c.e({ deceleration: 1e3, maxSpeed: 90 }, Rl);
      class hh {
        constructor(r) {
          this._map = r, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(r) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: M.now(), settings: r });
        }
        _drainInertiaBuffer() {
          const r = this._inertiaBuffer, d = M.now();
          for (; r.length > 0 && d - r[0].time > 160; ) r.shift();
        }
        _onMoveEnd(r) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
          const d = { zoom: 0, bearing: 0, pitch: 0, pan: new c.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: g } of this._inertiaBuffer) d.zoom += g.zoomDelta || 0, d.bearing += g.bearingDelta || 0, d.pitch += g.pitchDelta || 0, g.panDelta && d.pan._add(g.panDelta), g.around && (d.around = g.around), g.pinchAround && (d.pinchAround = g.pinchAround);
          const p = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, _ = {};
          if (d.pan.mag()) {
            const g = Ba(d.pan.mag(), p, c.e({}, ch, r || {}));
            _.offset = d.pan.mult(g.amount / d.pan.mag()), _.center = this._map.transform.center, Pa(_, g);
          }
          if (d.zoom) {
            const g = Ba(d.zoom, p, jp);
            _.zoom = this._map.transform.zoom + g.amount, Pa(_, g);
          }
          if (d.bearing) {
            const g = Ba(d.bearing, p, cd);
            _.bearing = this._map.transform.bearing + c.ac(g.amount, -179, 179), Pa(_, g);
          }
          if (d.pitch) {
            const g = Ba(d.pitch, p, Ml);
            _.pitch = this._map.transform.pitch + g.amount, Pa(_, g);
          }
          if (_.zoom || _.bearing) {
            const g = d.pinchAround === void 0 ? d.around : d.pinchAround;
            _.around = g ? this._map.unproject(g) : this._map.getCenter();
          }
          return this.clear(), c.e(_, { noMoveStart: !0 });
        }
      }
      function Pa(y, r) {
        (!y.duration || y.duration < r.duration) && (y.duration = r.duration, y.easing = r.easing);
      }
      function Ba(y, r, d) {
        const { maxSpeed: p, linearity: _, deceleration: g } = d, T = c.ac(y * _ / (r / 1e3), -p, p), S = Math.abs(T) / (g * _);
        return { easing: d.easing, duration: 1e3 * S, amount: T * (S / 2) };
      }
      class ms extends c.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(r, d, p, _ = {}) {
          const g = P.mousePos(d.getCanvas(), p), T = d.unproject(g);
          super(r, c.e({ point: g, lngLat: T, originalEvent: p }, _)), this._defaultPrevented = !1, this.target = d;
        }
      }
      class oo extends c.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(r, d, p) {
          const _ = r === "touchend" ? p.changedTouches : p.touches, g = P.touchPos(d.getCanvasContainer(), _), T = g.map((I) => d.unproject(I)), S = g.reduce((I, D, k, N) => I.add(D.div(N.length)), new c.P(0, 0));
          super(r, { points: g, point: S, lngLats: T, lngLat: d.unproject(S), originalEvent: p }), this._defaultPrevented = !1;
        }
      }
      class hd extends c.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(r, d, p) {
          super(r, { originalEvent: p }), this._defaultPrevented = !1;
        }
      }
      class ud {
        constructor(r, d) {
          this._map = r, this._clickTolerance = d.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(r) {
          return this._firePreventable(new hd(r.type, this._map, r));
        }
        mousedown(r, d) {
          return this._mousedownPos = d, this._firePreventable(new ms(r.type, this._map, r));
        }
        mouseup(r) {
          this._map.fire(new ms(r.type, this._map, r));
        }
        click(r, d) {
          this._mousedownPos && this._mousedownPos.dist(d) >= this._clickTolerance || this._map.fire(new ms(r.type, this._map, r));
        }
        dblclick(r) {
          return this._firePreventable(new ms(r.type, this._map, r));
        }
        mouseover(r) {
          this._map.fire(new ms(r.type, this._map, r));
        }
        mouseout(r) {
          this._map.fire(new ms(r.type, this._map, r));
        }
        touchstart(r) {
          return this._firePreventable(new oo(r.type, this._map, r));
        }
        touchmove(r) {
          this._map.fire(new oo(r.type, this._map, r));
        }
        touchend(r) {
          this._map.fire(new oo(r.type, this._map, r));
        }
        touchcancel(r) {
          this._map.fire(new oo(r.type, this._map, r));
        }
        _firePreventable(r) {
          if (this._map.fire(r), r.defaultPrevented) return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class Fi {
        constructor(r) {
          this._map = r;
        }
        reset() {
          this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
        }
        mousemove(r) {
          this._map.fire(new ms(r.type, this._map, r));
        }
        mousedown() {
          this._delayContextMenu = !0, this._ignoreContextMenu = !1;
        }
        mouseup() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new ms("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(r) {
          this._delayContextMenu ? this._contextMenuEvent = r : this._ignoreContextMenu || this._map.fire(new ms(r.type, this._map, r)), this._map.listens("contextmenu") && r.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class Sr {
        constructor(r) {
          this._map = r;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(r) {
          return this.transform.pointLocation(c.P.convert(r), this._map.terrain);
        }
      }
      class tr {
        constructor(r, d) {
          this._map = r, this._tr = new Sr(r), this._el = r.getCanvasContainer(), this._container = r.getContainer(), this._clickTolerance = d.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(r, d) {
          this.isEnabled() && r.shiftKey && r.button === 0 && (P.disableDrag(), this._startPos = this._lastPos = d, this._active = !0);
        }
        mousemoveWindow(r, d) {
          if (!this._active) return;
          const p = d;
          if (this._lastPos.equals(p) || !this._box && p.dist(this._startPos) < this._clickTolerance) return;
          const _ = this._startPos;
          this._lastPos = p, this._box || (this._box = P.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", r));
          const g = Math.min(_.x, p.x), T = Math.max(_.x, p.x), S = Math.min(_.y, p.y), I = Math.max(_.y, p.y);
          P.setTransform(this._box, `translate(${g}px,${S}px)`), this._box.style.width = T - g + "px", this._box.style.height = I - S + "px";
        }
        mouseupWindow(r, d) {
          if (!this._active || r.button !== 0) return;
          const p = this._startPos, _ = d;
          if (this.reset(), P.suppressClick(), p.x !== _.x || p.y !== _.y) return this._map.fire(new c.k("boxzoomend", { originalEvent: r })), { cameraAnimation: (g) => g.fitScreenCoordinates(p, _, this._tr.bearing, { linear: !0 }) };
          this._fireEvent("boxzoomcancel", r);
        }
        keydown(r) {
          this._active && r.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", r));
        }
        reset() {
          this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (P.remove(this._box), this._box = null), P.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(r, d) {
          return this._map.fire(new c.k(r, { originalEvent: d }));
        }
      }
      function Da(y, r) {
        if (y.length !== r.length) throw new Error(`The number of touches and points are not equal - touches ${y.length}, points ${r.length}`);
        const d = {};
        for (let p = 0; p < y.length; p++) d[y[p].identifier] = r[p];
        return d;
      }
      class uh {
        constructor(r) {
          this.reset(), this.numTouches = r.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
        }
        touchstart(r, d, p) {
          (this.centroid || p.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = r.timeStamp), p.length === this.numTouches && (this.centroid = function(_) {
            const g = new c.P(0, 0);
            for (const T of _) g._add(T);
            return g.div(_.length);
          }(d), this.touches = Da(p, d)));
        }
        touchmove(r, d, p) {
          if (this.aborted || !this.centroid) return;
          const _ = Da(p, d);
          for (const g in this.touches) {
            const T = _[g];
            (!T || T.dist(this.touches[g]) > 30) && (this.aborted = !0);
          }
        }
        touchend(r, d, p) {
          if ((!this.centroid || r.timeStamp - this.startTime > 500) && (this.aborted = !0), p.length === 0) {
            const _ = !this.aborted && this.centroid;
            if (this.reset(), _) return _;
          }
        }
      }
      class Pl {
        constructor(r) {
          this.singleTap = new uh(r), this.numTaps = r.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(r, d, p) {
          this.singleTap.touchstart(r, d, p);
        }
        touchmove(r, d, p) {
          this.singleTap.touchmove(r, d, p);
        }
        touchend(r, d, p) {
          const _ = this.singleTap.touchend(r, d, p);
          if (_) {
            const g = r.timeStamp - this.lastTime < 500, T = !this.lastTap || this.lastTap.dist(_) < 30;
            if (g && T || this.reset(), this.count++, this.lastTime = r.timeStamp, this.lastTap = _, this.count === this.numTaps) return this.reset(), _;
          }
        }
      }
      class No {
        constructor(r) {
          this._tr = new Sr(r), this._zoomIn = new Pl({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Pl({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(r, d, p) {
          this._zoomIn.touchstart(r, d, p), this._zoomOut.touchstart(r, d, p);
        }
        touchmove(r, d, p) {
          this._zoomIn.touchmove(r, d, p), this._zoomOut.touchmove(r, d, p);
        }
        touchend(r, d, p) {
          const _ = this._zoomIn.touchend(r, d, p), g = this._zoomOut.touchend(r, d, p), T = this._tr;
          return _ ? (this._active = !0, r.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (S) => S.easeTo({ duration: 300, zoom: T.zoom + 1, around: T.unproject(_) }, { originalEvent: r }) }) : g ? (this._active = !0, r.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (S) => S.easeTo({ duration: 300, zoom: T.zoom - 1, around: T.unproject(g) }, { originalEvent: r }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class ln {
        constructor(r) {
          this._enabled = !!r.enable, this._moveStateManager = r.moveStateManager, this._clickTolerance = r.clickTolerance || 1, this._moveFunction = r.move, this._activateOnStart = !!r.activateOnStart, r.assignEvents(this), this.reset();
        }
        reset(r) {
          this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(r);
        }
        _move(...r) {
          const d = this._moveFunction(...r);
          if (d.bearingDelta || d.pitchDelta || d.around || d.panDelta) return this._active = !0, d;
        }
        dragStart(r, d) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(r) && (this._moveStateManager.startMove(r), this._lastPoint = d.length ? d[0] : d, this._activateOnStart && this._lastPoint && (this._active = !0));
        }
        dragMove(r, d) {
          if (!this.isEnabled()) return;
          const p = this._lastPoint;
          if (!p) return;
          if (r.preventDefault(), !this._moveStateManager.isValidMoveEvent(r)) return void this.reset(r);
          const _ = d.length ? d[0] : d;
          return !this._moved && _.dist(p) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = _, this._move(p, _));
        }
        dragEnd(r) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(r) && (this._moved && P.suppressClick(), this.reset(r));
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const dh = { 0: 1, 2: 2 };
      class Bl {
        constructor(r) {
          this._correctEvent = r.checkCorrectEvent;
        }
        startMove(r) {
          const d = P.mouseButton(r);
          this._eventButton = d;
        }
        endMove(r) {
          delete this._eventButton;
        }
        isValidStartEvent(r) {
          return this._correctEvent(r);
        }
        isValidMoveEvent(r) {
          return !function(d, p) {
            const _ = dh[p];
            return d.buttons === void 0 || (d.buttons & _) !== _;
          }(r, this._eventButton);
        }
        isValidEndEvent(r) {
          return P.mouseButton(r) === this._eventButton;
        }
      }
      class fh {
        constructor() {
          this._firstTouch = void 0;
        }
        _isOneFingerTouch(r) {
          return r.targetTouches.length === 1;
        }
        _isSameTouchEvent(r) {
          return r.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(r) {
          this._firstTouch = r.targetTouches[0].identifier;
        }
        endMove(r) {
          delete this._firstTouch;
        }
        isValidStartEvent(r) {
          return this._isOneFingerTouch(r);
        }
        isValidMoveEvent(r) {
          return this._isOneFingerTouch(r) && this._isSameTouchEvent(r);
        }
        isValidEndEvent(r) {
          return this._isOneFingerTouch(r) && this._isSameTouchEvent(r);
        }
      }
      const Dl = (y) => {
        y.mousedown = y.dragStart, y.mousemoveWindow = y.dragMove, y.mouseup = y.dragEnd, y.contextmenu = (r) => {
          r.preventDefault();
        };
      }, ph = ({ enable: y, clickTolerance: r, bearingDegreesPerPixelMoved: d = 0.8 }) => {
        const p = new Bl({ checkCorrectEvent: (_) => P.mouseButton(_) === 0 && _.ctrlKey || P.mouseButton(_) === 2 });
        return new ln({ clickTolerance: r, move: (_, g) => ({ bearingDelta: (g.x - _.x) * d }), moveStateManager: p, enable: y, assignEvents: Dl });
      }, _h = ({ enable: y, clickTolerance: r, pitchDegreesPerPixelMoved: d = -0.5 }) => {
        const p = new Bl({ checkCorrectEvent: (_) => P.mouseButton(_) === 0 && _.ctrlKey || P.mouseButton(_) === 2 });
        return new ln({ clickTolerance: r, move: (_, g) => ({ pitchDelta: (g.y - _.y) * d }), moveStateManager: p, enable: y, assignEvents: Dl });
      };
      class ao {
        constructor(r, d) {
          this._clickTolerance = r.clickTolerance || 1, this._map = d, this.reset();
        }
        reset() {
          this._active = !1, this._touches = {}, this._sum = new c.P(0, 0);
        }
        _shouldBePrevented(r) {
          return r < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
        }
        touchstart(r, d, p) {
          return this._calculateTransform(r, d, p);
        }
        touchmove(r, d, p) {
          if (this._active) {
            if (!this._shouldBePrevented(p.length)) return r.preventDefault(), this._calculateTransform(r, d, p);
            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", r);
          }
        }
        touchend(r, d, p) {
          this._calculateTransform(r, d, p), this._active && this._shouldBePrevented(p.length) && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(r, d, p) {
          p.length > 0 && (this._active = !0);
          const _ = Da(p, d), g = new c.P(0, 0), T = new c.P(0, 0);
          let S = 0;
          for (const D in _) {
            const k = _[D], N = this._touches[D];
            N && (g._add(k), T._add(k.sub(N)), S++, _[D] = k);
          }
          if (this._touches = _, this._shouldBePrevented(S) || !T.mag()) return;
          const I = T.div(S);
          return this._sum._add(I), this._sum.mag() < this._clickTolerance ? void 0 : { around: g.div(S), panDelta: I };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Ol {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1, delete this._firstTwoTouches;
        }
        touchstart(r, d, p) {
          this._firstTwoTouches || p.length < 2 || (this._firstTwoTouches = [p[0].identifier, p[1].identifier], this._start([d[0], d[1]]));
        }
        touchmove(r, d, p) {
          if (!this._firstTwoTouches) return;
          r.preventDefault();
          const [_, g] = this._firstTwoTouches, T = Oa(p, d, _), S = Oa(p, d, g);
          if (!T || !S) return;
          const I = this._aroundCenter ? null : T.add(S).div(2);
          return this._move([T, S], I, r);
        }
        touchend(r, d, p) {
          if (!this._firstTwoTouches) return;
          const [_, g] = this._firstTwoTouches, T = Oa(p, d, _), S = Oa(p, d, g);
          T && S || (this._active && P.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(r) {
          this._enabled = !0, this._aroundCenter = !!r && r.around === "center";
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function Oa(y, r, d) {
        for (let p = 0; p < y.length; p++) if (y[p].identifier === d) return r[p];
      }
      function mh(y, r) {
        return Math.log(y / r) / Math.LN2;
      }
      class gh extends Ol {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(r) {
          this._startDistance = this._distance = r[0].dist(r[1]);
        }
        _move(r, d) {
          const p = this._distance;
          if (this._distance = r[0].dist(r[1]), this._active || !(Math.abs(mh(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: mh(this._distance, p), pinchAround: d };
        }
      }
      function yh(y, r) {
        return 180 * y.angleWith(r) / Math.PI;
      }
      class bh extends Ol {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(r) {
          this._startVector = this._vector = r[0].sub(r[1]), this._minDiameter = r[0].dist(r[1]);
        }
        _move(r, d, p) {
          const _ = this._vector;
          if (this._vector = r[0].sub(r[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: yh(this._vector, _), pinchAround: d };
        }
        _isBelowThreshold(r) {
          this._minDiameter = Math.min(this._minDiameter, r.mag());
          const d = 25 / (Math.PI * this._minDiameter) * 360, p = yh(r, this._startVector);
          return Math.abs(p) < d;
        }
      }
      function Fl(y) {
        return Math.abs(y.y) > Math.abs(y.x);
      }
      class Lo extends Ol {
        constructor(r) {
          super(), this._currentTouchCount = 0, this._map = r;
        }
        reset() {
          super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(r, d, p) {
          super.touchstart(r, d, p), this._currentTouchCount = p.length;
        }
        _start(r) {
          this._lastPoints = r, Fl(r[0].sub(r[1])) && (this._valid = !1);
        }
        _move(r, d, p) {
          if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
          const _ = r[0].sub(this._lastPoints[0]), g = r[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(_, g, p.timeStamp), this._valid ? (this._lastPoints = r, this._active = !0, { pitchDelta: (_.y + g.y) / 2 * -0.5 }) : void 0;
        }
        gestureBeginsVertically(r, d, p) {
          if (this._valid !== void 0) return this._valid;
          const _ = r.mag() >= 2, g = d.mag() >= 2;
          if (!_ && !g) return;
          if (!_ || !g) return this._firstMove === void 0 && (this._firstMove = p), p - this._firstMove < 100 && void 0;
          const T = r.y > 0 == d.y > 0;
          return Fl(r) && Fl(d) && T;
        }
      }
      const dd = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class fr {
        constructor(r) {
          this._tr = new Sr(r);
          const d = dd;
          this._panStep = d.panStep, this._bearingStep = d.bearingStep, this._pitchStep = d.pitchStep, this._rotationDisabled = !1;
        }
        reset() {
          this._active = !1;
        }
        keydown(r) {
          if (r.altKey || r.ctrlKey || r.metaKey) return;
          let d = 0, p = 0, _ = 0, g = 0, T = 0;
          switch (r.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              d = 1;
              break;
            case 189:
            case 109:
            case 173:
              d = -1;
              break;
            case 37:
              r.shiftKey ? p = -1 : (r.preventDefault(), g = -1);
              break;
            case 39:
              r.shiftKey ? p = 1 : (r.preventDefault(), g = 1);
              break;
            case 38:
              r.shiftKey ? _ = 1 : (r.preventDefault(), T = -1);
              break;
            case 40:
              r.shiftKey ? _ = -1 : (r.preventDefault(), T = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (p = 0, _ = 0), { cameraAnimation: (S) => {
            const I = this._tr;
            S.easeTo({ duration: 300, easeId: "keyboardHandler", easing: qr, zoom: d ? Math.round(I.zoom) + d * (r.shiftKey ? 2 : 1) : I.zoom, bearing: I.bearing + p * this._bearingStep, pitch: I.pitch + _ * this._pitchStep, offset: [-g * this._panStep, -T * this._panStep], center: I.center }, { originalEvent: r });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function qr(y) {
        return y * (2 - y);
      }
      const vh = 4.000244140625;
      class Cr {
        constructor(r, d) {
          this._onTimeout = (p) => {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(p);
          }, this._map = r, this._tr = new Sr(r), this._triggerRenderFrame = d, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(r) {
          this._defaultZoomRate = r;
        }
        setWheelZoomRate(r) {
          this._wheelZoomRate = r;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(r) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!r && r.around === "center");
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        _shouldBePrevented(r) {
          return !!this._map.cooperativeGestures.isEnabled() && !(r.ctrlKey || this._map.cooperativeGestures.isBypassed(r));
        }
        wheel(r) {
          if (!this.isEnabled()) return;
          if (this._shouldBePrevented(r)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", r);
          let d = r.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * r.deltaY : r.deltaY;
          const p = M.now(), _ = p - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = p, d !== 0 && d % vh == 0 ? this._type = "wheel" : d !== 0 && Math.abs(d) < 4 ? this._type = "trackpad" : _ > 400 ? (this._type = null, this._lastValue = d, this._timeout = setTimeout(this._onTimeout, 40, r)) : this._type || (this._type = Math.abs(_ * d) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, d += this._lastValue)), r.shiftKey && d && (d /= 4), this._type && (this._lastWheelEvent = r, this._delta -= d, this._active || this._start(r)), r.preventDefault();
        }
        _start(r) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const d = P.mousePos(this._map.getCanvas(), r), p = this._tr;
          this._around = d.y > p.transform.height / 2 - p.transform.getHorizon() ? c.N.convert(this._aroundCenter ? p.center : p.unproject(d)) : c.N.convert(p.center), this._aroundPoint = p.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive())) return;
          const r = this._tr.transform;
          if (this._delta !== 0) {
            const I = this._type === "wheel" && Math.abs(this._delta) > vh ? this._wheelZoomRate : this._defaultZoomRate;
            let D = 2 / (1 + Math.exp(-Math.abs(this._delta * I)));
            this._delta < 0 && D !== 0 && (D = 1 / D);
            const k = typeof this._targetZoom == "number" ? r.zoomScale(this._targetZoom) : r.scale;
            this._targetZoom = Math.min(r.maxZoom, Math.max(r.minZoom, r.scaleZoom(k * D))), this._type === "wheel" && (this._startZoom = r.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const d = typeof this._targetZoom == "number" ? this._targetZoom : r.zoom, p = this._startZoom, _ = this._easing;
          let g, T = !1;
          const S = M.now() - this._lastWheelEventTime;
          if (this._type === "wheel" && p && _ && S) {
            const I = Math.min(S / 200, 1), D = _(I);
            g = c.y.number(p, d, D), I < 1 ? this._frameId || (this._frameId = !0) : T = !0;
          } else g = d, T = !0;
          return this._active = !0, T && (this._active = !1, this._finishTimeout = setTimeout(() => {
            this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !T, zoomDelta: g - r.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(r) {
          let d = c.b9;
          if (this._prevEase) {
            const p = this._prevEase, _ = (M.now() - p.start) / p.duration, g = p.easing(_ + 0.01) - p.easing(_), T = 0.27 / Math.sqrt(g * g + 1e-4) * 0.01, S = Math.sqrt(0.0729 - T * T);
            d = c.b8(T, S, 0.25, 1);
          }
          return this._prevEase = { start: M.now(), duration: r, easing: d }, d;
        }
        reset() {
          this._active = !1, this._zooming = !1, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }
      class lo {
        constructor(r, d) {
          this._clickZoom = r, this._tapZoom = d;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class $p {
        constructor(r) {
          this._tr = new Sr(r), this.reset();
        }
        reset() {
          this._active = !1;
        }
        dblclick(r, d) {
          return r.preventDefault(), { cameraAnimation: (p) => {
            p.easeTo({ duration: 300, zoom: this._tr.zoom + (r.shiftKey ? -1 : 1), around: this._tr.unproject(d) }, { originalEvent: r });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Gp {
        constructor() {
          this._tap = new Pl({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(r, d, p) {
          if (!this._swipePoint) if (this._tapTime) {
            const _ = d[0], g = r.timeStamp - this._tapTime < 500, T = this._tapPoint.dist(_) < 30;
            g && T ? p.length > 0 && (this._swipePoint = _, this._swipeTouch = p[0].identifier) : this.reset();
          } else this._tap.touchstart(r, d, p);
        }
        touchmove(r, d, p) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (p[0].identifier !== this._swipeTouch) return;
              const _ = d[0], g = _.y - this._swipePoint.y;
              return this._swipePoint = _, r.preventDefault(), this._active = !0, { zoomDelta: g / 128 };
            }
          } else this._tap.touchmove(r, d, p);
        }
        touchend(r, d, p) {
          if (this._tapTime) this._swipePoint && p.length === 0 && this.reset();
          else {
            const _ = this._tap.touchend(r, d, p);
            _ && (this._tapTime = r.timeStamp, this._tapPoint = _);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class fd {
        constructor(r, d, p) {
          this._el = r, this._mousePan = d, this._touchPan = p;
        }
        enable(r) {
          this._inertiaOptions = r || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class pd {
        constructor(r, d, p) {
          this._pitchWithRotate = r.pitchWithRotate, this._mouseRotate = d, this._mousePitch = p;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class xh {
        constructor(r, d, p, _) {
          this._el = r, this._touchZoom = d, this._touchRotate = p, this._tapDragZoom = _, this._rotationDisabled = !1, this._enabled = !0;
        }
        enable(r) {
          this._touchZoom.enable(r), this._rotationDisabled || this._touchRotate.enable(r), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      class Uo {
        constructor(r, d) {
          this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = r, this._options = d, this._enabled = !1;
        }
        isActive() {
          return !1;
        }
        reset() {
        }
        _setupUI() {
          if (this._container) return;
          const r = this._map.getCanvasContainer();
          r.classList.add("maplibregl-cooperative-gestures"), this._container = P.create("div", "maplibregl-cooperative-gesture-screen", r);
          let d = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
          this._bypassKey === "metaKey" && (d = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
          const p = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), _ = document.createElement("div");
          _.className = "maplibregl-desktop-message", _.textContent = d, this._container.appendChild(_);
          const g = document.createElement("div");
          g.className = "maplibregl-mobile-message", g.textContent = p, this._container.appendChild(g), this._container.setAttribute("aria-hidden", "true");
        }
        _destroyUI() {
          this._container && (P.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
        }
        enable() {
          this._setupUI(), this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this._destroyUI();
        }
        isEnabled() {
          return this._enabled;
        }
        isBypassed(r) {
          return r[this._bypassKey];
        }
        notifyGestureBlocked(r, d) {
          this._enabled && (this._map.fire(new c.k("cooperativegestureprevented", { gestureType: r, originalEvent: d })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
            this._container.classList.remove("maplibregl-show");
          }, 100));
        }
      }
      const pr = (y) => y.zoom || y.drag || y.pitch || y.rotate;
      class ot extends c.k {
      }
      function kl(y) {
        return y.panDelta && y.panDelta.mag() || y.zoomDelta || y.bearingDelta || y.pitchDelta;
      }
      class wh {
        constructor(r, d) {
          this.handleWindowEvent = (_) => {
            this.handleEvent(_, `${_.type}Window`);
          }, this.handleEvent = (_, g) => {
            if (_.type === "blur") return void this.stop(!0);
            this._updatingCamera = !0;
            const T = _.type === "renderFrame" ? void 0 : _, S = { needsRenderFrame: !1 }, I = {}, D = {}, k = _.touches, N = k ? this._getMapTouches(k) : void 0, H = N ? P.touchPos(this._map.getCanvas(), N) : P.mousePos(this._map.getCanvas(), _);
            for (const { handlerName: se, handler: oe, allowed: ae } of this._handlers) {
              if (!oe.isEnabled()) continue;
              let he;
              this._blockedByActive(D, ae, se) ? oe.reset() : oe[g || _.type] && (he = oe[g || _.type](_, H, N), this.mergeHandlerResult(S, I, he, se, T), he && he.needsRenderFrame && this._triggerRenderFrame()), (he || oe.isActive()) && (D[se] = oe);
            }
            const q = {};
            for (const se in this._previousActiveHandlers) D[se] || (q[se] = T);
            this._previousActiveHandlers = D, (Object.keys(q).length || kl(S)) && (this._changes.push([S, I, q]), this._triggerRenderFrame()), (Object.keys(D).length || kl(S)) && this._map._stop(!0), this._updatingCamera = !1;
            const { cameraAnimation: K } = S;
            K && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], K(this._map));
          }, this._map = r, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new hh(r), this._bearingSnap = d.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(d);
          const p = this._el;
          this._listeners = [[p, "touchstart", { passive: !0 }], [p, "touchmove", { passive: !1 }], [p, "touchend", void 0], [p, "touchcancel", void 0], [p, "mousedown", void 0], [p, "mousemove", void 0], [p, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [p, "mouseover", void 0], [p, "mouseout", void 0], [p, "dblclick", void 0], [p, "click", void 0], [p, "keydown", { capture: !1 }], [p, "keyup", void 0], [p, "wheel", { passive: !1 }], [p, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [_, g, T] of this._listeners) P.addEventListener(_, g, _ === document ? this.handleWindowEvent : this.handleEvent, T);
        }
        destroy() {
          for (const [r, d, p] of this._listeners) P.removeEventListener(r, d, r === document ? this.handleWindowEvent : this.handleEvent, p);
        }
        _addDefaultHandlers(r) {
          const d = this._map, p = d.getCanvasContainer();
          this._add("mapEvent", new ud(d, r));
          const _ = d.boxZoom = new tr(d, r);
          this._add("boxZoom", _), r.interactive && r.boxZoom && _.enable();
          const g = d.cooperativeGestures = new Uo(d, r.cooperativeGestures);
          this._add("cooperativeGestures", g), r.cooperativeGestures && g.enable();
          const T = new No(d), S = new $p(d);
          d.doubleClickZoom = new lo(S, T), this._add("tapZoom", T), this._add("clickZoom", S), r.interactive && r.doubleClickZoom && d.doubleClickZoom.enable();
          const I = new Gp();
          this._add("tapDragZoom", I);
          const D = d.touchPitch = new Lo(d);
          this._add("touchPitch", D), r.interactive && r.touchPitch && d.touchPitch.enable(r.touchPitch);
          const k = ph(r), N = _h(r);
          d.dragRotate = new pd(r, k, N), this._add("mouseRotate", k, ["mousePitch"]), this._add("mousePitch", N, ["mouseRotate"]), r.interactive && r.dragRotate && d.dragRotate.enable();
          const H = (({ enable: he, clickTolerance: te }) => {
            const fe = new Bl({ checkCorrectEvent: (ge) => P.mouseButton(ge) === 0 && !ge.ctrlKey });
            return new ln({ clickTolerance: te, move: (ge, Te) => ({ around: Te, panDelta: Te.sub(ge) }), activateOnStart: !0, moveStateManager: fe, enable: he, assignEvents: Dl });
          })(r), q = new ao(r, d);
          d.dragPan = new fd(p, H, q), this._add("mousePan", H), this._add("touchPan", q, ["touchZoom", "touchRotate"]), r.interactive && r.dragPan && d.dragPan.enable(r.dragPan);
          const K = new bh(), se = new gh();
          d.touchZoomRotate = new xh(p, se, K, I), this._add("touchRotate", K, ["touchPan", "touchZoom"]), this._add("touchZoom", se, ["touchPan", "touchRotate"]), r.interactive && r.touchZoomRotate && d.touchZoomRotate.enable(r.touchZoomRotate);
          const oe = d.scrollZoom = new Cr(d, () => this._triggerRenderFrame());
          this._add("scrollZoom", oe, ["mousePan"]), r.interactive && r.scrollZoom && d.scrollZoom.enable(r.scrollZoom);
          const ae = d.keyboard = new fr(d);
          this._add("keyboard", ae), r.interactive && r.keyboard && d.keyboard.enable(), this._add("blockableMapEvent", new Fi(d));
        }
        _add(r, d, p) {
          this._handlers.push({ handlerName: r, handler: d, allowed: p }), this._handlersById[r] = d;
        }
        stop(r) {
          if (!this._updatingCamera) {
            for (const { handler: d } of this._handlers) d.reset();
            this._inertia.clear(), this._fireEvents({}, {}, r), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: r } of this._handlers) if (r.isActive()) return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!pr(this._eventsInProgress) || this.isZooming();
        }
        _blockedByActive(r, d, p) {
          for (const _ in r) if (_ !== p && (!d || d.indexOf(_) < 0)) return !0;
          return !1;
        }
        _getMapTouches(r) {
          const d = [];
          for (const p of r) this._el.contains(p.target) && d.push(p);
          return d;
        }
        mergeHandlerResult(r, d, p, _, g) {
          if (!p) return;
          c.e(r, p);
          const T = { handlerName: _, originalEvent: p.originalEvent || g };
          p.zoomDelta !== void 0 && (d.zoom = T), p.panDelta !== void 0 && (d.drag = T), p.pitchDelta !== void 0 && (d.pitch = T), p.bearingDelta !== void 0 && (d.rotate = T);
        }
        _applyChanges() {
          const r = {}, d = {}, p = {};
          for (const [_, g, T] of this._changes) _.panDelta && (r.panDelta = (r.panDelta || new c.P(0, 0))._add(_.panDelta)), _.zoomDelta && (r.zoomDelta = (r.zoomDelta || 0) + _.zoomDelta), _.bearingDelta && (r.bearingDelta = (r.bearingDelta || 0) + _.bearingDelta), _.pitchDelta && (r.pitchDelta = (r.pitchDelta || 0) + _.pitchDelta), _.around !== void 0 && (r.around = _.around), _.pinchAround !== void 0 && (r.pinchAround = _.pinchAround), _.noInertia && (r.noInertia = _.noInertia), c.e(d, g), c.e(p, T);
          this._updateMapTransform(r, d, p), this._changes = [];
        }
        _updateMapTransform(r, d, p) {
          const _ = this._map, g = _._getTransformForUpdate(), T = _.terrain;
          if (!(kl(r) || T && this._terrainMovement)) return this._fireEvents(d, p, !0);
          let { panDelta: S, zoomDelta: I, bearingDelta: D, pitchDelta: k, around: N, pinchAround: H } = r;
          H !== void 0 && (N = H), _._stop(!0), N = N || _.transform.centerPoint;
          const q = g.pointLocation(S ? N.sub(S) : N);
          D && (g.bearing += D), k && (g.pitch += k), I && (g.zoom += I), T ? this._terrainMovement || !d.drag && !d.zoom ? d.drag && this._terrainMovement ? g.center = g.pointLocation(g.centerPoint.sub(S)) : g.setLocationAtPoint(q, N) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, g.setLocationAtPoint(q, N)) : g.setLocationAtPoint(q, N), _._applyUpdatedTransform(g), this._map._update(), r.noInertia || this._inertia.record(r), this._fireEvents(d, p, !0);
        }
        _fireEvents(r, d, p) {
          const _ = pr(this._eventsInProgress), g = pr(r), T = {};
          for (const N in r) {
            const { originalEvent: H } = r[N];
            this._eventsInProgress[N] || (T[`${N}start`] = H), this._eventsInProgress[N] = r[N];
          }
          !_ && g && this._fireEvent("movestart", g.originalEvent);
          for (const N in T) this._fireEvent(N, T[N]);
          g && this._fireEvent("move", g.originalEvent);
          for (const N in r) {
            const { originalEvent: H } = r[N];
            this._fireEvent(N, H);
          }
          const S = {};
          let I;
          for (const N in this._eventsInProgress) {
            const { handlerName: H, originalEvent: q } = this._eventsInProgress[N];
            this._handlersById[H].isActive() || (delete this._eventsInProgress[N], I = d[H] || q, S[`${N}end`] = I);
          }
          for (const N in S) this._fireEvent(N, S[N]);
          const D = pr(this._eventsInProgress), k = (_ || g) && !D;
          if (k && this._terrainMovement) {
            this._map._elevationFreeze = !1, this._terrainMovement = !1;
            const N = this._map._getTransformForUpdate();
            N.recalculateZoom(this._map.terrain), this._map._applyUpdatedTransform(N);
          }
          if (p && k) {
            this._updatingCamera = !0;
            const N = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), H = (q) => q !== 0 && -this._bearingSnap < q && q < this._bearingSnap;
            !N || !N.essential && M.prefersReducedMotion ? (this._map.fire(new c.k("moveend", { originalEvent: I })), H(this._map.getBearing()) && this._map.resetNorth()) : (H(N.bearing || this._map.getBearing()) && (N.bearing = 0), N.freezeElevation = !0, this._map.easeTo(N, { originalEvent: I })), this._updatingCamera = !1;
          }
        }
        _fireEvent(r, d) {
          this._map.fire(new c.k(r, d ? { originalEvent: d } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((r) => {
            delete this._frameId, this.handleEvent(new ot("renderFrame", { timeStamp: r })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      class _d extends c.E {
        constructor(r, d) {
          super(), this._renderFrameCallback = () => {
            const p = Math.min((M.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(p)), p < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = !1, this._zooming = !1, this.transform = r, this._bearingSnap = d.bearingSnap, this.on("moveend", () => {
            delete this._requestedCameraState;
          });
        }
        getCenter() {
          return new c.N(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(r, d) {
          return this.jumpTo({ center: r }, d);
        }
        panBy(r, d, p) {
          return r = c.P.convert(r).mult(-1), this.panTo(this.transform.center, c.e({ offset: r }, d), p);
        }
        panTo(r, d, p) {
          return this.easeTo(c.e({ center: r }, d), p);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(r, d) {
          return this.jumpTo({ zoom: r }, d), this;
        }
        zoomTo(r, d, p) {
          return this.easeTo(c.e({ zoom: r }, d), p);
        }
        zoomIn(r, d) {
          return this.zoomTo(this.getZoom() + 1, r, d), this;
        }
        zoomOut(r, d) {
          return this.zoomTo(this.getZoom() - 1, r, d), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(r, d) {
          return this.jumpTo({ bearing: r }, d), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(r, d) {
          return this.jumpTo({ padding: r }, d), this;
        }
        rotateTo(r, d, p) {
          return this.easeTo(c.e({ bearing: r }, d), p);
        }
        resetNorth(r, d) {
          return this.rotateTo(0, c.e({ duration: 1e3 }, r), d), this;
        }
        resetNorthPitch(r, d) {
          return this.easeTo(c.e({ bearing: 0, pitch: 0, duration: 1e3 }, r), d), this;
        }
        snapToNorth(r, d) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(r, d) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(r, d) {
          return this.jumpTo({ pitch: r }, d), this;
        }
        cameraForBounds(r, d) {
          r = Ie.convert(r).adjustAntiMeridian();
          const p = d && d.bearing || 0;
          return this._cameraForBoxAndBearing(r.getNorthWest(), r.getSouthEast(), p, d);
        }
        _cameraForBoxAndBearing(r, d, p, _) {
          const g = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (_ = c.e({ padding: g, offset: [0, 0], maxZoom: this.transform.maxZoom }, _)).padding == "number") {
            const Ze = _.padding;
            _.padding = { top: Ze, bottom: Ze, right: Ze, left: Ze };
          }
          _.padding = c.e(g, _.padding);
          const T = this.transform, S = T.padding, I = new Ie(r, d), D = T.project(I.getNorthWest()), k = T.project(I.getNorthEast()), N = T.project(I.getSouthEast()), H = T.project(I.getSouthWest()), q = c.ba(-p), K = D.rotate(q), se = k.rotate(q), oe = N.rotate(q), ae = H.rotate(q), he = new c.P(Math.max(K.x, se.x, ae.x, oe.x), Math.max(K.y, se.y, ae.y, oe.y)), te = new c.P(Math.min(K.x, se.x, ae.x, oe.x), Math.min(K.y, se.y, ae.y, oe.y)), fe = he.sub(te), ge = (T.width - (S.left + S.right + _.padding.left + _.padding.right)) / fe.x, Te = (T.height - (S.top + S.bottom + _.padding.top + _.padding.bottom)) / fe.y;
          if (Te < 0 || ge < 0) return void c.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const Fe = Math.min(T.scaleZoom(T.scale * Math.min(ge, Te)), _.maxZoom), Ve = c.P.convert(_.offset), Ye = new c.P((_.padding.left - _.padding.right) / 2, (_.padding.top - _.padding.bottom) / 2).rotate(c.ba(p)), st = Ve.add(Ye).mult(T.scale / T.zoomScale(Fe));
          return { center: T.unproject(D.add(N).div(2).sub(st)), zoom: Fe, bearing: p };
        }
        fitBounds(r, d, p) {
          return this._fitInternal(this.cameraForBounds(r, d), d, p);
        }
        fitScreenCoordinates(r, d, p, _, g) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(c.P.convert(r)), this.transform.pointLocation(c.P.convert(d)), p, _), _, g);
        }
        _fitInternal(r, d, p) {
          return r ? (delete (d = c.e(r, d)).padding, d.linear ? this.easeTo(d, p) : this.flyTo(d, p)) : this;
        }
        jumpTo(r, d) {
          this.stop();
          const p = this._getTransformForUpdate();
          let _ = !1, g = !1, T = !1;
          return "zoom" in r && p.zoom !== +r.zoom && (_ = !0, p.zoom = +r.zoom), r.center !== void 0 && (p.center = c.N.convert(r.center)), "bearing" in r && p.bearing !== +r.bearing && (g = !0, p.bearing = +r.bearing), "pitch" in r && p.pitch !== +r.pitch && (T = !0, p.pitch = +r.pitch), r.padding == null || p.isPaddingEqual(r.padding) || (p.padding = r.padding), this._applyUpdatedTransform(p), this.fire(new c.k("movestart", d)).fire(new c.k("move", d)), _ && this.fire(new c.k("zoomstart", d)).fire(new c.k("zoom", d)).fire(new c.k("zoomend", d)), g && this.fire(new c.k("rotatestart", d)).fire(new c.k("rotate", d)).fire(new c.k("rotateend", d)), T && this.fire(new c.k("pitchstart", d)).fire(new c.k("pitch", d)).fire(new c.k("pitchend", d)), this.fire(new c.k("moveend", d));
        }
        calculateCameraOptionsFromTo(r, d, p, _ = 0) {
          const g = c.Z.fromLngLat(r, d), T = c.Z.fromLngLat(p, _), S = T.x - g.x, I = T.y - g.y, D = T.z - g.z, k = Math.hypot(S, I, D);
          if (k === 0) throw new Error("Can't calculate camera options with same From and To");
          const N = Math.hypot(S, I), H = this.transform.scaleZoom(this.transform.cameraToCenterDistance / k / this.transform.tileSize), q = 180 * Math.atan2(S, -I) / Math.PI;
          let K = 180 * Math.acos(N / k) / Math.PI;
          return K = D < 0 ? 90 - K : 90 + K, { center: T.toLngLat(), zoom: H, pitch: K, bearing: q };
        }
        easeTo(r, d) {
          var p;
          this._stop(!1, r.easeId), ((r = c.e({ offset: [0, 0], duration: 500, easing: c.b9 }, r)).animate === !1 || !r.essential && M.prefersReducedMotion) && (r.duration = 0);
          const _ = this._getTransformForUpdate(), g = _.zoom, T = _.bearing, S = _.pitch, I = _.padding, D = "bearing" in r ? this._normalizeBearing(r.bearing, T) : T, k = "pitch" in r ? +r.pitch : S, N = "padding" in r ? r.padding : _.padding, H = c.P.convert(r.offset);
          let q = _.centerPoint.add(H);
          const K = _.pointLocation(q), { center: se, zoom: oe } = _.getConstrained(c.N.convert(r.center || K), (p = r.zoom) !== null && p !== void 0 ? p : g);
          this._normalizeCenter(se, _);
          const ae = _.project(K), he = _.project(se).sub(ae), te = _.zoomScale(oe - g);
          let fe, ge;
          r.around && (fe = c.N.convert(r.around), ge = _.locationPoint(fe));
          const Te = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || oe !== g, this._rotating = this._rotating || T !== D, this._pitching = this._pitching || k !== S, this._padding = !_.isPaddingEqual(N), this._easeId = r.easeId, this._prepareEase(d, r.noMoveStart, Te), this.terrain && this._prepareElevation(se), this._ease((Fe) => {
            if (this._zooming && (_.zoom = c.y.number(g, oe, Fe)), this._rotating && (_.bearing = c.y.number(T, D, Fe)), this._pitching && (_.pitch = c.y.number(S, k, Fe)), this._padding && (_.interpolatePadding(I, N, Fe), q = _.centerPoint.add(H)), this.terrain && !r.freezeElevation && this._updateElevation(Fe), fe) _.setLocationAtPoint(fe, ge);
            else {
              const Ve = _.zoomScale(_.zoom - g), Ye = oe > g ? Math.min(2, te) : Math.max(0.5, te), st = Math.pow(Ye, 1 - Fe), Ze = _.unproject(ae.add(he.mult(Fe * st)).mult(Ve));
              _.setLocationAtPoint(_.renderWorldCopies ? Ze.wrap() : Ze, q);
            }
            this._applyUpdatedTransform(_), this._fireMoveEvents(d);
          }, (Fe) => {
            this.terrain && r.freezeElevation && this._finalizeElevation(), this._afterEase(d, Fe);
          }, r), this;
        }
        _prepareEase(r, d, p = {}) {
          this._moving = !0, d || p.moving || this.fire(new c.k("movestart", r)), this._zooming && !p.zooming && this.fire(new c.k("zoomstart", r)), this._rotating && !p.rotating && this.fire(new c.k("rotatestart", r)), this._pitching && !p.pitching && this.fire(new c.k("pitchstart", r));
        }
        _prepareElevation(r) {
          this._elevationCenter = r, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(r, this.transform.tileZoom), this._elevationFreeze = !0;
        }
        _updateElevation(r) {
          this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          const d = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (r < 1 && d !== this._elevationTarget) {
            const p = this._elevationTarget - this._elevationStart;
            this._elevationStart += r * (p - (d - (p * r + this._elevationStart)) / (1 - r)), this._elevationTarget = d;
          }
          this.transform.elevation = c.y.number(this._elevationStart, this._elevationTarget, r);
        }
        _finalizeElevation() {
          this._elevationFreeze = !1, this.transform.recalculateZoom(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _elevateCameraIfInsideTerrain(r) {
          const d = r.getCameraPosition(), p = this.terrain.getElevationForLngLatZoom(d.lngLat, r.zoom);
          if (d.altitude < p) {
            const _ = this.calculateCameraOptionsFromTo(d.lngLat, p, r.center, r.elevation);
            return { pitch: _.pitch, zoom: _.zoom };
          }
          return {};
        }
        _applyUpdatedTransform(r) {
          const d = [];
          if (this.terrain && d.push((_) => this._elevateCameraIfInsideTerrain(_)), this.transformCameraUpdate && d.push((_) => this.transformCameraUpdate(_)), !d.length) return;
          const p = r.clone();
          for (const _ of d) {
            const g = p.clone(), { center: T, zoom: S, pitch: I, bearing: D, elevation: k } = _(g);
            T && (g.center = T), S !== void 0 && (g.zoom = S), I !== void 0 && (g.pitch = I), D !== void 0 && (g.bearing = D), k !== void 0 && (g.elevation = k), p.apply(g);
          }
          this.transform.apply(p);
        }
        _fireMoveEvents(r) {
          this.fire(new c.k("move", r)), this._zooming && this.fire(new c.k("zoom", r)), this._rotating && this.fire(new c.k("rotate", r)), this._pitching && this.fire(new c.k("pitch", r));
        }
        _afterEase(r, d) {
          if (this._easeId && d && this._easeId === d) return;
          delete this._easeId;
          const p = this._zooming, _ = this._rotating, g = this._pitching;
          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, p && this.fire(new c.k("zoomend", r)), _ && this.fire(new c.k("rotateend", r)), g && this.fire(new c.k("pitchend", r)), this.fire(new c.k("moveend", r));
        }
        flyTo(r, d) {
          var p;
          if (!r.essential && M.prefersReducedMotion) {
            const et = c.M(r, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(et, d);
          }
          this.stop(), r = c.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: c.b9 }, r);
          const _ = this._getTransformForUpdate(), g = _.zoom, T = _.bearing, S = _.pitch, I = _.padding, D = "bearing" in r ? this._normalizeBearing(r.bearing, T) : T, k = "pitch" in r ? +r.pitch : S, N = "padding" in r ? r.padding : _.padding, H = c.P.convert(r.offset);
          let q = _.centerPoint.add(H);
          const K = _.pointLocation(q), { center: se, zoom: oe } = _.getConstrained(c.N.convert(r.center || K), (p = r.zoom) !== null && p !== void 0 ? p : g);
          this._normalizeCenter(se, _);
          const ae = _.zoomScale(oe - g), he = _.project(K), te = _.project(se).sub(he);
          let fe = r.curve;
          const ge = Math.max(_.width, _.height), Te = ge / ae, Fe = te.mag();
          if ("minZoom" in r) {
            const et = c.ac(Math.min(r.minZoom, g, oe), _.minZoom, _.maxZoom), At = ge / _.zoomScale(et - g);
            fe = Math.sqrt(At / Fe * 2);
          }
          const Ve = fe * fe;
          function Ye(et) {
            const At = (Te * Te - ge * ge + (et ? -1 : 1) * Ve * Ve * Fe * Fe) / (2 * (et ? Te : ge) * Ve * Fe);
            return Math.log(Math.sqrt(At * At + 1) - At);
          }
          function st(et) {
            return (Math.exp(et) - Math.exp(-et)) / 2;
          }
          function Ze(et) {
            return (Math.exp(et) + Math.exp(-et)) / 2;
          }
          const Ge = Ye(!1);
          let ut = function(et) {
            return Ze(Ge) / Ze(Ge + fe * et);
          }, Et = function(et) {
            return ge * ((Ze(Ge) * (st(At = Ge + fe * et) / Ze(At)) - st(Ge)) / Ve) / Fe;
            var At;
          }, Ke = (Ye(!0) - Ge) / fe;
          if (Math.abs(Fe) < 1e-6 || !isFinite(Ke)) {
            if (Math.abs(ge - Te) < 1e-6) return this.easeTo(r, d);
            const et = Te < ge ? -1 : 1;
            Ke = Math.abs(Math.log(Te / ge)) / fe, Et = () => 0, ut = (At) => Math.exp(et * fe * At);
          }
          return r.duration = "duration" in r ? +r.duration : 1e3 * Ke / ("screenSpeed" in r ? +r.screenSpeed / fe : +r.speed), r.maxDuration && r.duration > r.maxDuration && (r.duration = 0), this._zooming = !0, this._rotating = T !== D, this._pitching = k !== S, this._padding = !_.isPaddingEqual(N), this._prepareEase(d, !1), this.terrain && this._prepareElevation(se), this._ease((et) => {
            const At = et * Ke, pi = 1 / ut(At);
            _.zoom = et === 1 ? oe : g + _.scaleZoom(pi), this._rotating && (_.bearing = c.y.number(T, D, et)), this._pitching && (_.pitch = c.y.number(S, k, et)), this._padding && (_.interpolatePadding(I, N, et), q = _.centerPoint.add(H)), this.terrain && !r.freezeElevation && this._updateElevation(et);
            const Mt = et === 1 ? se : _.unproject(he.add(te.mult(Et(At))).mult(pi));
            _.setLocationAtPoint(_.renderWorldCopies ? Mt.wrap() : Mt, q), this._applyUpdatedTransform(_), this._fireMoveEvents(d);
          }, () => {
            this.terrain && r.freezeElevation && this._finalizeElevation(), this._afterEase(d);
          }, r), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(r, d) {
          var p;
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const _ = this._onEaseEnd;
            delete this._onEaseEnd, _.call(this, d);
          }
          return r || (p = this.handlers) === null || p === void 0 || p.stop(!1), this;
        }
        _ease(r, d, p) {
          p.animate === !1 || p.duration === 0 ? (r(1), d()) : (this._easeStart = M.now(), this._easeOptions = p, this._onEaseFrame = r, this._onEaseEnd = d, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(r, d) {
          r = c.b3(r, -180, 180);
          const p = Math.abs(r - d);
          return Math.abs(r - 360 - d) < p && (r -= 360), Math.abs(r + 360 - d) < p && (r += 360), r;
        }
        _normalizeCenter(r, d) {
          if (!d.renderWorldCopies || d.lngRange) return;
          const p = r.lng - d.center.lng;
          r.lng += p > 180 ? -360 : p < -180 ? 360 : 0;
        }
        queryTerrainElevation(r) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(c.N.convert(r), this.transform.tileZoom) - this.transform.elevation : null;
        }
      }
      const zo = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
      class Vo {
        constructor(r = zo) {
          this._toggleAttribution = () => {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
          }, this._updateData = (d) => {
            !d || d.sourceDataType !== "metadata" && d.sourceDataType !== "visibility" && d.dataType !== "style" && d.type !== "terrain" || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
          }, this.options = r;
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(r) {
          return this._map = r, this._compact = this.options.compact, this._container = P.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = P.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = P.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          P.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(r, d) {
          const p = this._map._getUIString(`AttributionControl.${d}`);
          r.title = p, r.setAttribute("aria-label", p);
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let r = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? r = r.concat(this.options.customAttribution.map((_) => typeof _ != "string" ? "" : _)) : typeof this.options.customAttribution == "string" && r.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const _ = this._map.style.stylesheet;
            this.styleOwner = _.owner, this.styleId = _.id;
          }
          const d = this._map.style.sourceCaches;
          for (const _ in d) {
            const g = d[_];
            if (g.used || g.usedForTerrain) {
              const T = g.getSource();
              T.attribution && r.indexOf(T.attribution) < 0 && r.push(T.attribution);
            }
          }
          r = r.filter((_) => String(_).trim()), r.sort((_, g) => _.length - g.length), r = r.filter((_, g) => {
            for (let T = g + 1; T < r.length; T++) if (r[T].indexOf(_) >= 0) return !1;
            return !0;
          });
          const p = r.join(" | ");
          p !== this._attribHTML && (this._attribHTML = p, r.length ? (this._innerContainer.innerHTML = p, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
      }
      class Ah {
        constructor(r = {}) {
          this._updateCompact = () => {
            const d = this._container.children;
            if (d.length) {
              const p = d[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && p.classList.add("maplibregl-compact") : p.classList.remove("maplibregl-compact");
            }
          }, this.options = r;
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(r) {
          this._map = r, this._compact = this.options && this.options.compact, this._container = P.create("div", "maplibregl-ctrl");
          const d = P.create("a", "maplibregl-ctrl-logo");
          return d.target = "_blank", d.rel = "noopener nofollow", d.href = "https://maplibre.org/", d.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), d.setAttribute("rel", "noopener nofollow"), this._container.appendChild(d), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          P.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
        }
      }
      class kt {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        }
        add(r) {
          const d = ++this._id;
          return this._queue.push({ callback: r, id: d, cancelled: !1 }), d;
        }
        remove(r) {
          const d = this._currentlyRunning, p = d ? this._queue.concat(d) : this._queue;
          for (const _ of p) if (_.id === r) return void (_.cancelled = !0);
        }
        run(r = 0) {
          if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
          const d = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const p of d) if (!p.cancelled && (p.callback(r), this._cleared)) break;
          this._cleared = !1, this._currentlyRunning = !1;
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        }
      }
      var Th = c.Y([{ name: "a_pos3d", type: "Int16", components: 3 }]);
      class Xp extends c.E {
        constructor(r) {
          super(), this.sourceCache = r, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, r.usedForTerrain = !0, r.tileSize = this.tileSize * 2 ** this.deltaZoom;
        }
        destruct() {
          this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
        }
        update(r, d) {
          this.sourceCache.update(r, d), this._renderableTilesKeys = [];
          const p = {};
          for (const _ of r.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: d })) p[_.key] = !0, this._renderableTilesKeys.push(_.key), this._tiles[_.key] || (_.posMatrix = new Float64Array(16), c.aP(_.posMatrix, 0, c.X, 0, c.X, 0, 1), this._tiles[_.key] = new cr(_, this.tileSize));
          for (const _ in this._tiles) p[_] || delete this._tiles[_];
        }
        freeRtt(r) {
          for (const d in this._tiles) {
            const p = this._tiles[d];
            (!r || p.tileID.equals(r) || p.tileID.isChildOf(r) || r.isChildOf(p.tileID)) && (p.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((r) => this.getTileByID(r));
        }
        getTileByID(r) {
          return this._tiles[r];
        }
        getTerrainCoords(r) {
          const d = {};
          for (const p of this._renderableTilesKeys) {
            const _ = this._tiles[p].tileID;
            if (_.canonical.equals(r.canonical)) {
              const g = r.clone();
              g.posMatrix = new Float64Array(16), c.aP(g.posMatrix, 0, c.X, 0, c.X, 0, 1), d[p] = g;
            } else if (_.canonical.isChildOf(r.canonical)) {
              const g = r.clone();
              g.posMatrix = new Float64Array(16);
              const T = _.canonical.z - r.canonical.z, S = _.canonical.x - (_.canonical.x >> T << T), I = _.canonical.y - (_.canonical.y >> T << T), D = c.X >> T;
              c.aP(g.posMatrix, 0, D, 0, D, 0, 1), c.J(g.posMatrix, g.posMatrix, [-S * D, -I * D, 0]), d[p] = g;
            } else if (r.canonical.isChildOf(_.canonical)) {
              const g = r.clone();
              g.posMatrix = new Float64Array(16);
              const T = r.canonical.z - _.canonical.z, S = r.canonical.x - (r.canonical.x >> T << T), I = r.canonical.y - (r.canonical.y >> T << T), D = c.X >> T;
              c.aP(g.posMatrix, 0, c.X, 0, c.X, 0, 1), c.J(g.posMatrix, g.posMatrix, [S * D, I * D, 0]), c.K(g.posMatrix, g.posMatrix, [1 / 2 ** T, 1 / 2 ** T, 0]), d[p] = g;
            }
          }
          return d;
        }
        getSourceTile(r, d) {
          const p = this.sourceCache._source;
          let _ = r.overscaledZ - this.deltaZoom;
          if (_ > p.maxzoom && (_ = p.maxzoom), _ < p.minzoom) return null;
          this._sourceTileCache[r.key] || (this._sourceTileCache[r.key] = r.scaledTo(_).key);
          let g = this.sourceCache.getTileByID(this._sourceTileCache[r.key]);
          if ((!g || !g.dem) && d) for (; _ >= p.minzoom && (!g || !g.dem); ) g = this.sourceCache.getTileByID(r.scaledTo(_--).key);
          return g;
        }
        tilesAfterTime(r = Date.now()) {
          return Object.values(this._tiles).filter((d) => d.timeAdded >= r);
        }
      }
      class Eh {
        constructor(r, d, p) {
          this.painter = r, this.sourceCache = new Xp(d), this.options = p, this.exaggeration = typeof p.exaggeration == "number" ? p.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(r, d, p, _ = c.X) {
          var g;
          if (!(d >= 0 && d < _ && p >= 0 && p < _)) return 0;
          const T = this.getTerrainData(r), S = (g = T.tile) === null || g === void 0 ? void 0 : g.dem;
          if (!S) return 0;
          const I = function(K, se, oe) {
            var ae = se[0], he = se[1];
            return K[0] = oe[0] * ae + oe[4] * he + oe[12], K[1] = oe[1] * ae + oe[5] * he + oe[13], K;
          }([], [d / _ * c.X, p / _ * c.X], T.u_terrain_matrix), D = [I[0] * S.dim, I[1] * S.dim], k = Math.floor(D[0]), N = Math.floor(D[1]), H = D[0] - k, q = D[1] - N;
          return S.get(k, N) * (1 - H) * (1 - q) + S.get(k + 1, N) * H * (1 - q) + S.get(k, N + 1) * (1 - H) * q + S.get(k + 1, N + 1) * H * q;
        }
        getElevationForLngLatZoom(r, d) {
          if (!c.bb(d, r.wrap())) return 0;
          const { tileID: p, mercatorX: _, mercatorY: g } = this._getOverscaledTileIDFromLngLatZoom(r, d);
          return this.getElevation(p, _ % c.X, g % c.X, c.X);
        }
        getElevation(r, d, p, _ = c.X) {
          return this.getDEMElevation(r, d, p, _) * this.exaggeration;
        }
        getTerrainData(r) {
          if (!this._emptyDemTexture) {
            const _ = this.painter.context, g = new c.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new it(_, g, _.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new it(_, new c.R({ width: 1, height: 1 }), _.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(_.gl.NEAREST, _.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = c.an([]);
          }
          const d = this.sourceCache.getSourceTile(r, !0);
          if (d && d.dem && (!d.demTexture || d.needsTerrainPrepare)) {
            const _ = this.painter.context;
            d.demTexture = this.painter.getTileTexture(d.dem.stride), d.demTexture ? d.demTexture.update(d.dem.getPixels(), { premultiply: !1 }) : d.demTexture = new it(_, d.dem.getPixels(), _.gl.RGBA, { premultiply: !1 }), d.demTexture.bind(_.gl.NEAREST, _.gl.CLAMP_TO_EDGE), d.needsTerrainPrepare = !1;
          }
          const p = d && d + d.tileID.key + r.key;
          if (p && !this._demMatrixCache[p]) {
            const _ = this.sourceCache.sourceCache._source.maxzoom;
            let g = r.canonical.z - d.tileID.canonical.z;
            r.overscaledZ > r.canonical.z && (r.canonical.z >= _ ? g = r.canonical.z - _ : c.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const T = r.canonical.x - (r.canonical.x >> g << g), S = r.canonical.y - (r.canonical.y >> g << g), I = c.bc(new Float64Array(16), [1 / (c.X << g), 1 / (c.X << g), 0]);
            c.J(I, I, [T * c.X, S * c.X, 0]), this._demMatrixCache[r.key] = { matrix: I, coord: r };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: d && d.dem && d.dem.dim || 1, u_terrain_matrix: p ? this._demMatrixCache[r.key].matrix : this._emptyDemMatrix, u_terrain_unpack: d && d.dem && d.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (d && d.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: d };
        }
        getFramebuffer(r) {
          const d = this.painter, p = d.width / devicePixelRatio, _ = d.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === p && this._fbo.height === _ || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new it(d.context, { width: p, height: _, data: null }, d.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(d.context.gl.NEAREST, d.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new it(d.context, { width: p, height: _, data: null }, d.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(d.context.gl.NEAREST, d.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = d.context.createFramebuffer(p, _, !0, !1), this._fbo.depthAttachment.set(d.context.createRenderbuffer(d.context.gl.DEPTH_COMPONENT16, p, _))), this._fbo.colorAttachment.set(r === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const r = this.painter.context;
          if (this._coordsTexture) return this._coordsTexture;
          const d = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let g = 0, T = 0; g < this._coordsTextureSize; g++) for (let S = 0; S < this._coordsTextureSize; S++, T += 4) d[T + 0] = 255 & S, d[T + 1] = 255 & g, d[T + 2] = S >> 8 << 4 | g >> 8, d[T + 3] = 0;
          const p = new c.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(d.buffer)), _ = new it(r, p, r.gl.RGBA, { premultiply: !1 });
          return _.bind(r.gl.NEAREST, r.gl.CLAMP_TO_EDGE), this._coordsTexture = _, _;
        }
        pointCoordinate(r) {
          this.painter.maybeDrawDepthAndCoords(!0);
          const d = new Uint8Array(4), p = this.painter.context, _ = p.gl, g = Math.round(r.x * this.painter.pixelRatio / devicePixelRatio), T = Math.round(r.y * this.painter.pixelRatio / devicePixelRatio), S = Math.round(this.painter.height / devicePixelRatio);
          p.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), _.readPixels(g, S - T - 1, 1, 1, _.RGBA, _.UNSIGNED_BYTE, d), p.bindFramebuffer.set(null);
          const I = d[0] + (d[2] >> 4 << 8), D = d[1] + ((15 & d[2]) << 8), k = this.coordsIndex[255 - d[3]], N = k && this.sourceCache.getTileByID(k);
          if (!N) return null;
          const H = this._coordsTextureSize, q = (1 << N.tileID.canonical.z) * H;
          return new c.Z((N.tileID.canonical.x * H + I) / q + N.tileID.wrap, (N.tileID.canonical.y * H + D) / q, this.getElevation(N.tileID, I, D, H));
        }
        depthAtPoint(r) {
          const d = new Uint8Array(4), p = this.painter.context, _ = p.gl;
          return p.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), _.readPixels(r.x, this.painter.height / devicePixelRatio - r.y - 1, 1, 1, _.RGBA, _.UNSIGNED_BYTE, d), p.bindFramebuffer.set(null), (d[0] / 16777216 + d[1] / 65536 + d[2] / 256 + d[3]) / 256;
        }
        getTerrainMesh() {
          if (this._mesh) return this._mesh;
          const r = this.painter.context, d = new c.bd(), p = new c.aY(), _ = this.meshSize, g = c.X / _, T = _ * _;
          for (let N = 0; N <= _; N++) for (let H = 0; H <= _; H++) d.emplaceBack(H * g, N * g, 0);
          for (let N = 0; N < T; N += _ + 1) for (let H = 0; H < _; H++) p.emplaceBack(H + N, _ + H + N + 1, _ + H + N + 2), p.emplaceBack(H + N, _ + H + N + 2, H + N + 1);
          const S = d.length, I = S + 2 * (_ + 1);
          for (const N of [0, 1]) for (let H = 0; H <= _; H++) for (const q of [0, 1]) d.emplaceBack(H * g, N * c.X, q);
          for (let N = 0; N < 2 * _; N += 2) p.emplaceBack(I + N, I + N + 1, I + N + 3), p.emplaceBack(I + N, I + N + 3, I + N + 2), p.emplaceBack(S + N, S + N + 3, S + N + 1), p.emplaceBack(S + N, S + N + 2, S + N + 3);
          const D = d.length, k = D + 2 * (_ + 1);
          for (const N of [0, 1]) for (let H = 0; H <= _; H++) for (const q of [0, 1]) d.emplaceBack(N * c.X, H * g, q);
          for (let N = 0; N < 2 * _; N += 2) p.emplaceBack(D + N, D + N + 1, D + N + 3), p.emplaceBack(D + N, D + N + 3, D + N + 2), p.emplaceBack(k + N, k + N + 3, k + N + 1), p.emplaceBack(k + N, k + N + 2, k + N + 3);
          return this._mesh = new Sl(r.createVertexBuffer(d, Th.members), r.createIndexBuffer(p), c.a0.simpleSegment(0, 0, d.length, p.length)), this._mesh;
        }
        getMeshFrameDelta(r) {
          return 2 * Math.PI * c.be / Math.pow(2, r) / 5;
        }
        getMinTileElevationForLngLatZoom(r, d) {
          var p;
          const { tileID: _ } = this._getOverscaledTileIDFromLngLatZoom(r, d);
          return (p = this.getMinMaxElevation(_).minElevation) !== null && p !== void 0 ? p : 0;
        }
        getMinMaxElevation(r) {
          const d = this.getTerrainData(r).tile, p = { minElevation: null, maxElevation: null };
          return d && d.dem && (p.minElevation = d.dem.min * this.exaggeration, p.maxElevation = d.dem.max * this.exaggeration), p;
        }
        _getOverscaledTileIDFromLngLatZoom(r, d) {
          const p = c.Z.fromLngLat(r.wrap()), _ = (1 << d) * c.X, g = p.x * _, T = p.y * _, S = Math.floor(g / c.X), I = Math.floor(T / c.X);
          return { tileID: new c.S(d, 0, d, S, I), mercatorX: g, mercatorY: T };
        }
      }
      class Wp {
        constructor(r, d, p) {
          this._context = r, this._size = d, this._tileSize = p, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (const r of this._objects) r.texture.destroy(), r.fbo.destroy();
        }
        _createObject(r) {
          const d = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), p = new it(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return p.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), d.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), d.colorAttachment.set(p.texture), { id: r, fbo: d, texture: p, stamp: -1, inUse: !1 };
        }
        getObjectForId(r) {
          return this._objects[r];
        }
        useObject(r) {
          r.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((d) => r.id !== d), this._recentlyUsed.push(r.id);
        }
        stampObject(r) {
          r.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const d of this._recentlyUsed) if (!this._objects[d].inUse) return this._objects[d];
          if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
          const r = this._createObject(this._objects.length);
          return this._objects.push(r), r;
        }
        freeObject(r) {
          r.inUse = !1;
        }
        freeAllObjects() {
          for (const r of this._objects) this.freeObject(r);
        }
        isFull() {
          return !(this._objects.length < this._size) && this._objects.some((r) => !r.inUse) === !1;
        }
      }
      const Ho = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 };
      class md {
        constructor(r, d) {
          this.painter = r, this.terrain = d, this.pool = new Wp(r.context, 30, d.sourceCache.tileSize * d.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(r) {
          return this.pool.getObjectForId(r.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(r, d) {
          this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = r._order.filter((p) => !r._layers[p].isHidden(d)), this._coordsDescendingInv = {};
          for (const p in r.sourceCaches) {
            this._coordsDescendingInv[p] = {};
            const _ = r.sourceCaches[p].getVisibleCoordinates();
            for (const g of _) {
              const T = this.terrain.sourceCache.getTerrainCoords(g);
              for (const S in T) this._coordsDescendingInv[p][S] || (this._coordsDescendingInv[p][S] = []), this._coordsDescendingInv[p][S].push(T[S]);
            }
          }
          this._coordsDescendingInvStr = {};
          for (const p of r._order) {
            const _ = r._layers[p], g = _.source;
            if (Ho[_.type] && !this._coordsDescendingInvStr[g]) {
              this._coordsDescendingInvStr[g] = {};
              for (const T in this._coordsDescendingInv[g]) this._coordsDescendingInvStr[g][T] = this._coordsDescendingInv[g][T].map((S) => S.key).sort().join();
            }
          }
          for (const p of this._renderableTiles) for (const _ in this._coordsDescendingInvStr) {
            const g = this._coordsDescendingInvStr[_][p.tileID.key];
            g && g !== p.rttCoords[_] && (p.rtt = []);
          }
        }
        renderLayer(r) {
          if (r.isHidden(this.painter.transform.zoom)) return !1;
          const d = r.type, p = this.painter, _ = this._renderableLayerIds[this._renderableLayerIds.length - 1] === r.id;
          if (Ho[d] && (this._prevType && Ho[this._prevType] || this._stacks.push([]), this._prevType = d, this._stacks[this._stacks.length - 1].push(r.id), !_)) return !0;
          if (Ho[this._prevType] || Ho[d] && _) {
            this._prevType = d;
            const g = this._stacks.length - 1, T = this._stacks[g] || [];
            for (const S of this._renderableTiles) {
              if (this.pool.isFull() && (ld(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(S), S.rtt[g]) {
                const D = this.pool.getObjectForId(S.rtt[g].id);
                if (D.stamp === S.rtt[g].stamp) {
                  this.pool.useObject(D);
                  continue;
                }
              }
              const I = this.pool.getOrCreateFreeObject();
              this.pool.useObject(I), this.pool.stampObject(I), S.rtt[g] = { id: I.id, stamp: I.stamp }, p.context.bindFramebuffer.set(I.fbo.framebuffer), p.context.clear({ color: c.aM.transparent, stencil: 0 }), p.currentStencilSource = void 0;
              for (let D = 0; D < T.length; D++) {
                const k = p.style._layers[T[D]], N = k.source ? this._coordsDescendingInv[k.source][S.tileID.key] : [S.tileID];
                p.context.viewport.set([0, 0, I.fbo.width, I.fbo.height]), p._renderTileClippingMasks(k, N), p.renderLayer(p, p.style.sourceCaches[k.source], k, N), k.source && (S.rttCoords[k.source] = this._coordsDescendingInvStr[k.source][S.tileID.key]);
              }
            }
            return ld(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), Ho[d];
          }
          return !1;
        }
      }
      const Sh = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, gd = x, qp = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: zo, maplibreLogo: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, refreshExpiredTiles: !0, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], zoom: 0, bearing: 0, pitch: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: c.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0 }, Ch = (y) => {
        y.touchstart = y.dragStart, y.touchmoveWindow = y.dragMove, y.touchend = y.dragEnd;
      }, Zp = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
      class Kp {
        constructor(r, d, p = !1) {
          this.mousedown = (T) => {
            this.startMouse(c.e({}, T, { ctrlKey: !0, preventDefault: () => T.preventDefault() }), P.mousePos(this.element, T)), P.addEventListener(window, "mousemove", this.mousemove), P.addEventListener(window, "mouseup", this.mouseup);
          }, this.mousemove = (T) => {
            this.moveMouse(T, P.mousePos(this.element, T));
          }, this.mouseup = (T) => {
            this.mouseRotate.dragEnd(T), this.mousePitch && this.mousePitch.dragEnd(T), this.offTemp();
          }, this.touchstart = (T) => {
            T.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = P.touchPos(this.element, T.targetTouches)[0], this.startTouch(T, this._startPos), P.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), P.addEventListener(window, "touchend", this.touchend));
          }, this.touchmove = (T) => {
            T.targetTouches.length !== 1 ? this.reset() : (this._lastPos = P.touchPos(this.element, T.targetTouches)[0], this.moveTouch(T, this._lastPos));
          }, this.touchend = (T) => {
            T.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10;
          const _ = r.dragRotate._mouseRotate.getClickTolerance(), g = r.dragRotate._mousePitch.getClickTolerance();
          this.element = d, this.mouseRotate = ph({ clickTolerance: _, enable: !0 }), this.touchRotate = (({ enable: T, clickTolerance: S, bearingDegreesPerPixelMoved: I = 0.8 }) => {
            const D = new fh();
            return new ln({ clickTolerance: S, move: (k, N) => ({ bearingDelta: (N.x - k.x) * I }), moveStateManager: D, enable: T, assignEvents: Ch });
          })({ clickTolerance: _, enable: !0 }), this.map = r, p && (this.mousePitch = _h({ clickTolerance: g, enable: !0 }), this.touchPitch = (({ enable: T, clickTolerance: S, pitchDegreesPerPixelMoved: I = -0.5 }) => {
            const D = new fh();
            return new ln({ clickTolerance: S, move: (k, N) => ({ pitchDelta: (N.y - k.y) * I }), moveStateManager: D, enable: T, assignEvents: Ch });
          })({ clickTolerance: g, enable: !0 })), P.addEventListener(d, "mousedown", this.mousedown), P.addEventListener(d, "touchstart", this.touchstart, { passive: !1 }), P.addEventListener(d, "touchcancel", this.reset);
        }
        startMouse(r, d) {
          this.mouseRotate.dragStart(r, d), this.mousePitch && this.mousePitch.dragStart(r, d), P.disableDrag();
        }
        startTouch(r, d) {
          this.touchRotate.dragStart(r, d), this.touchPitch && this.touchPitch.dragStart(r, d), P.disableDrag();
        }
        moveMouse(r, d) {
          const p = this.map, { bearingDelta: _ } = this.mouseRotate.dragMove(r, d) || {};
          if (_ && p.setBearing(p.getBearing() + _), this.mousePitch) {
            const { pitchDelta: g } = this.mousePitch.dragMove(r, d) || {};
            g && p.setPitch(p.getPitch() + g);
          }
        }
        moveTouch(r, d) {
          const p = this.map, { bearingDelta: _ } = this.touchRotate.dragMove(r, d) || {};
          if (_ && p.setBearing(p.getBearing() + _), this.touchPitch) {
            const { pitchDelta: g } = this.touchPitch.dragMove(r, d) || {};
            g && p.setPitch(p.getPitch() + g);
          }
        }
        off() {
          const r = this.element;
          P.removeEventListener(r, "mousedown", this.mousedown), P.removeEventListener(r, "touchstart", this.touchstart, { passive: !1 }), P.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), P.removeEventListener(window, "touchend", this.touchend), P.removeEventListener(r, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          P.enableDrag(), P.removeEventListener(window, "mousemove", this.mousemove), P.removeEventListener(window, "mouseup", this.mouseup), P.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), P.removeEventListener(window, "touchend", this.touchend);
        }
      }
      let ir;
      function fi(y, r, d) {
        const p = new c.N(y.lng, y.lat);
        if (y = new c.N(y.lng, y.lat), r) {
          const _ = new c.N(y.lng - 360, y.lat), g = new c.N(y.lng + 360, y.lat), T = d.locationPoint(y).distSqr(r);
          d.locationPoint(_).distSqr(r) < T ? y = _ : d.locationPoint(g).distSqr(r) < T && (y = g);
        }
        for (; Math.abs(y.lng - d.center.lng) > 180; ) {
          const _ = d.locationPoint(y);
          if (_.x >= 0 && _.y >= 0 && _.x <= d.width && _.y <= d.height) break;
          y.lng > d.center.lng ? y.lng -= 360 : y.lng += 360;
        }
        return y.lng !== p.lng && d.locationPoint(y).y > d.height / 2 - d.getHorizon() ? y : p;
      }
      const jo = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function Nl(y, r, d) {
        const p = y.classList;
        for (const _ in jo) p.remove(`maplibregl-${d}-anchor-${_}`);
        p.add(`maplibregl-${d}-anchor-${r}`);
      }
      class Ll extends c.E {
        constructor(r) {
          if (super(), this._onKeyPress = (d) => {
            const p = d.code, _ = d.charCode || d.keyCode;
            p !== "Space" && p !== "Enter" && _ !== 32 && _ !== 13 || this.togglePopup();
          }, this._onMapClick = (d) => {
            const p = d.originalEvent.target, _ = this._element;
            this._popup && (p === _ || _.contains(p)) && this.togglePopup();
          }, this._update = (d) => {
            var p;
            if (!this._map) return;
            const _ = this._map.loaded() && !this._map.isMoving();
            ((d == null ? void 0 : d.type) === "terrain" || (d == null ? void 0 : d.type) === "render" && !_) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? fi(this._lngLat, this._flatPos, this._map.transform) : (p = this._lngLat) === null || p === void 0 ? void 0 : p.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
            let g = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? g = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (g = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let T = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? T = "rotateX(0deg)" : this._pitchAlignment === "map" && (T = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || d && d.type !== "moveend" || (this._pos = this._pos.round()), P.setTransform(this._element, `${jo[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${T} ${g}`), M.frameAsync(new AbortController()).then(() => {
              this._updateOpacity(d && d.type === "moveend");
            }).catch(() => {
            });
          }, this._onMove = (d) => {
            if (!this._isDragging) {
              const p = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = d.point.dist(this._pointerdownPos) >= p;
            }
            this._isDragging && (this._pos = d.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new c.k("dragstart"))), this.fire(new c.k("drag")));
          }, this._onUp = () => {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new c.k("dragend")), this._state = "inactive";
          }, this._addDragHandler = (d) => {
            this._element.contains(d.originalEvent.target) && (d.preventDefault(), this._positionDelta = d.point.sub(this._pos).add(this._offset), this._pointerdownPos = d.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, this._anchor = r && r.anchor || "center", this._color = r && r.color || "#3FB1CE", this._scale = r && r.scale || 1, this._draggable = r && r.draggable || !1, this._clickTolerance = r && r.clickTolerance || 0, this._subpixelPositioning = r && r.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = r && r.rotation || 0, this._rotationAlignment = r && r.rotationAlignment || "auto", this._pitchAlignment = r && r.pitchAlignment && r.pitchAlignment !== "auto" ? r.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(r == null ? void 0 : r.opacity, r == null ? void 0 : r.opacityWhenCovered), r && r.element) this._element = r.element, this._offset = c.P.convert(r && r.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = P.create("div");
            const d = P.createNS("http://www.w3.org/2000/svg", "svg"), p = 41, _ = 27;
            d.setAttributeNS(null, "display", "block"), d.setAttributeNS(null, "height", `${p}px`), d.setAttributeNS(null, "width", `${_}px`), d.setAttributeNS(null, "viewBox", `0 0 ${_} ${p}`);
            const g = P.createNS("http://www.w3.org/2000/svg", "g");
            g.setAttributeNS(null, "stroke", "none"), g.setAttributeNS(null, "stroke-width", "1"), g.setAttributeNS(null, "fill", "none"), g.setAttributeNS(null, "fill-rule", "evenodd");
            const T = P.createNS("http://www.w3.org/2000/svg", "g");
            T.setAttributeNS(null, "fill-rule", "nonzero");
            const S = P.createNS("http://www.w3.org/2000/svg", "g");
            S.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), S.setAttributeNS(null, "fill", "#000000");
            const I = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const ae of I) {
              const he = P.createNS("http://www.w3.org/2000/svg", "ellipse");
              he.setAttributeNS(null, "opacity", "0.04"), he.setAttributeNS(null, "cx", "10.5"), he.setAttributeNS(null, "cy", "5.80029008"), he.setAttributeNS(null, "rx", ae.rx), he.setAttributeNS(null, "ry", ae.ry), S.appendChild(he);
            }
            const D = P.createNS("http://www.w3.org/2000/svg", "g");
            D.setAttributeNS(null, "fill", this._color);
            const k = P.createNS("http://www.w3.org/2000/svg", "path");
            k.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), D.appendChild(k);
            const N = P.createNS("http://www.w3.org/2000/svg", "g");
            N.setAttributeNS(null, "opacity", "0.25"), N.setAttributeNS(null, "fill", "#000000");
            const H = P.createNS("http://www.w3.org/2000/svg", "path");
            H.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), N.appendChild(H);
            const q = P.createNS("http://www.w3.org/2000/svg", "g");
            q.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), q.setAttributeNS(null, "fill", "#FFFFFF");
            const K = P.createNS("http://www.w3.org/2000/svg", "g");
            K.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const se = P.createNS("http://www.w3.org/2000/svg", "circle");
            se.setAttributeNS(null, "fill", "#000000"), se.setAttributeNS(null, "opacity", "0.25"), se.setAttributeNS(null, "cx", "5.5"), se.setAttributeNS(null, "cy", "5.5"), se.setAttributeNS(null, "r", "5.4999962");
            const oe = P.createNS("http://www.w3.org/2000/svg", "circle");
            oe.setAttributeNS(null, "fill", "#FFFFFF"), oe.setAttributeNS(null, "cx", "5.5"), oe.setAttributeNS(null, "cy", "5.5"), oe.setAttributeNS(null, "r", "5.4999962"), K.appendChild(se), K.appendChild(oe), T.appendChild(S), T.appendChild(D), T.appendChild(N), T.appendChild(q), T.appendChild(K), d.appendChild(T), d.setAttributeNS(null, "height", p * this._scale + "px"), d.setAttributeNS(null, "width", _ * this._scale + "px"), this._element.appendChild(d), this._offset = c.P.convert(r && r.offset || [0, -14]);
          }
          if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (d) => {
            d.preventDefault();
          }), this._element.addEventListener("mousedown", (d) => {
            d.preventDefault();
          }), Nl(this._element, this._anchor, "marker"), r && r.className) for (const d of r.className.split(" ")) this._element.classList.add(d);
          this._popup = null;
        }
        addTo(r) {
          return this.remove(), this._map = r, this._element.setAttribute("aria-label", r._getUIString("Marker.Title")), r.getCanvasContainer().appendChild(this._element), r.on("move", this._update), r.on("moveend", this._update), r.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), P.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(r) {
          return this._lngLat = c.N.convert(r), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(r) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), r) {
            if (!("offset" in r.options)) {
              const _ = Math.abs(13.5) / Math.SQRT2;
              r.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [_, -1 * (38.1 - 13.5 + _)], "bottom-right": [-_, -1 * (38.1 - 13.5 + _)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            this._popup = r, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        setSubpixelPositioning(r) {
          return this._subpixelPositioning = r, this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const r = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered ? this : r ? (r.isOpen() ? r.remove() : (r.setLngLat(this._lngLat), r.addTo(this._map)), this) : this;
        }
        _updateOpacity(r = !1) {
          var d, p;
          if (!(!((d = this._map) === null || d === void 0) && d.terrain)) return void (this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
          if (r) this._opacityTimeout = null;
          else {
            if (this._opacityTimeout) return;
            this._opacityTimeout = setTimeout(() => {
              this._opacityTimeout = null;
            }, 100);
          }
          const _ = this._map, g = _.terrain.depthAtPoint(this._pos), T = _.terrain.getElevationForLngLatZoom(this._lngLat, _.transform.tileZoom);
          if (_.transform.lngLatToCameraDepth(this._lngLat, T) - g < 6e-3) return void (this._element.style.opacity = this._opacity);
          const S = -this._offset.y / _.transform._pixelPerMeter, I = Math.sin(_.getPitch() * Math.PI / 180) * S, D = _.terrain.depthAtPoint(new c.P(this._pos.x, this._pos.y - this._offset.y)), k = _.transform.lngLatToCameraDepth(this._lngLat, T + I) - D > 6e-3;
          !((p = this._popup) === null || p === void 0) && p.isOpen() && k && this._popup.remove(), this._element.style.opacity = k ? this._opacityWhenCovered : this._opacity;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(r) {
          return this._offset = c.P.convert(r), this._update(), this;
        }
        addClassName(r) {
          this._element.classList.add(r);
        }
        removeClassName(r) {
          this._element.classList.remove(r);
        }
        toggleClassName(r) {
          return this._element.classList.toggle(r);
        }
        setDraggable(r) {
          return this._draggable = !!r, this._map && (r ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(r) {
          return this._rotation = r || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(r) {
          return this._rotationAlignment = r || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(r) {
          return this._pitchAlignment = r && r !== "auto" ? r : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(r, d) {
          return r === void 0 && d === void 0 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), r !== void 0 && (this._opacity = r), d !== void 0 && (this._opacityWhenCovered = d), this._map && this._updateOpacity(!0), this;
        }
      }
      const yd = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
      let Fa = 0, ka = !1;
      const Zr = { maxWidth: 100, unit: "metric" };
      function Na(y, r, d) {
        const p = d && d.maxWidth || 100, _ = y._container.clientHeight / 2, g = y.unproject([0, _]), T = y.unproject([p, _]), S = g.distanceTo(T);
        if (d && d.unit === "imperial") {
          const I = 3.2808 * S;
          I > 5280 ? ht(r, p, I / 5280, y._getUIString("ScaleControl.Miles")) : ht(r, p, I, y._getUIString("ScaleControl.Feet"));
        } else d && d.unit === "nautical" ? ht(r, p, S / 1852, y._getUIString("ScaleControl.NauticalMiles")) : S >= 1e3 ? ht(r, p, S / 1e3, y._getUIString("ScaleControl.Kilometers")) : ht(r, p, S, y._getUIString("ScaleControl.Meters"));
      }
      function ht(y, r, d, p) {
        const _ = function(g) {
          const T = Math.pow(10, `${Math.floor(g)}`.length - 1);
          let S = g / T;
          return S = S >= 10 ? 10 : S >= 5 ? 5 : S >= 3 ? 3 : S >= 2 ? 2 : S >= 1 ? 1 : function(I) {
            const D = Math.pow(10, Math.ceil(-Math.log(I) / Math.LN10));
            return Math.round(I * D) / D;
          }(S), T * S;
        }(d);
        y.style.width = r * (_ / d) + "px", y.innerHTML = `${_}&nbsp;${p}`;
      }
      const vt = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1 }, Ul = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function zl(y) {
        if (y) {
          if (typeof y == "number") {
            const r = Math.round(Math.abs(y) / Math.SQRT2);
            return { center: new c.P(0, 0), top: new c.P(0, y), "top-left": new c.P(r, r), "top-right": new c.P(-r, r), bottom: new c.P(0, -y), "bottom-left": new c.P(r, -r), "bottom-right": new c.P(-r, -r), left: new c.P(y, 0), right: new c.P(-y, 0) };
          }
          if (y instanceof c.P || Array.isArray(y)) {
            const r = c.P.convert(y);
            return { center: r, top: r, "top-left": r, "top-right": r, bottom: r, "bottom-left": r, "bottom-right": r, left: r, right: r };
          }
          return { center: c.P.convert(y.center || [0, 0]), top: c.P.convert(y.top || [0, 0]), "top-left": c.P.convert(y["top-left"] || [0, 0]), "top-right": c.P.convert(y["top-right"] || [0, 0]), bottom: c.P.convert(y.bottom || [0, 0]), "bottom-left": c.P.convert(y["bottom-left"] || [0, 0]), "bottom-right": c.P.convert(y["bottom-right"] || [0, 0]), left: c.P.convert(y.left || [0, 0]), right: c.P.convert(y.right || [0, 0]) };
        }
        return zl(new c.P(0, 0));
      }
      const Ih = x;
      u.AJAXError = c.bh, u.Evented = c.E, u.LngLat = c.N, u.MercatorCoordinate = c.Z, u.Point = c.P, u.addProtocol = c.bi, u.config = c.a, u.removeProtocol = c.bj, u.AttributionControl = Vo, u.BoxZoomHandler = tr, u.CanvasSource = Ls, u.CooperativeGesturesHandler = Uo, u.DoubleClickZoomHandler = lo, u.DragPanHandler = fd, u.DragRotateHandler = pd, u.EdgeInsets = Fo, u.FullscreenControl = class extends c.E {
        constructor(y = {}) {
          super(), this._onFullscreenChange = () => {
            var r;
            let d = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
            for (; !((r = d == null ? void 0 : d.shadowRoot) === null || r === void 0) && r.fullscreenElement; ) d = d.shadowRoot.fullscreenElement;
            d === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = !1, y && y.container && (y.container instanceof HTMLElement ? this._container = y.container : c.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(y) {
          return this._map = y, this._container || (this._container = this._map.getContainer()), this._controlContainer = P.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          P.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          const y = this._fullscreenButton = P.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
          P.create("span", "maplibregl-ctrl-icon", y).setAttribute("aria-hidden", "true"), y.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          const y = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", y), this._fullscreenButton.title = y;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new c.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new c.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
        }
      }, u.GeoJSONSource = Ji, u.GeolocateControl = class extends c.E {
        constructor(y) {
          super(), this._onSuccess = (r) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(r)) return this._setErrorState(), this.fire(new c.k("outofmaxbounds", r)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = r, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(r), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(r), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new c.k("geolocate", r)), this._finish();
            }
          }, this._updateCamera = (r) => {
            const d = new c.N(r.coords.longitude, r.coords.latitude), p = r.coords.accuracy, _ = this._map.getBearing(), g = c.e({ bearing: _ }, this.options.fitBoundsOptions), T = Ie.fromLngLat(d, p);
            this._map.fitBounds(T, g, { geolocateSource: !0 });
          }, this._updateMarker = (r) => {
            if (r) {
              const d = new c.N(r.coords.longitude, r.coords.latitude);
              this._accuracyCircleMarker.setLngLat(d).addTo(this._map), this._userLocationDotMarker.setLngLat(d).addTo(this._map), this._accuracy = r.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onZoom = () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, this._onError = (r) => {
            if (this._map) {
              if (this.options.trackUserLocation) if (r.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                const d = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = d, this._geolocateButton.setAttribute("aria-label", d), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (r.code === 3 && ka) return;
                this._setErrorState();
              }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new c.k("error", r)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, this._setupUI = () => {
            this._map && (this._container.addEventListener("contextmenu", (r) => r.preventDefault()), this._geolocateButton = P.create("button", "maplibregl-ctrl-geolocate", this._container), P.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
          }, this._finishSetupUI = (r) => {
            if (this._map) {
              if (r === !1) {
                c.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const d = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = !0, this._geolocateButton.title = d, this._geolocateButton.setAttribute("aria-label", d);
              } else {
                const d = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.disabled = !1, this._geolocateButton.title = d, this._geolocateButton.setAttribute("aria-label", d);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = P.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Ll({ element: this._dotElement }), this._circleElement = P.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ll({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (d) => {
                d.geolocateSource || this._watchState !== "ACTIVE_LOCK" || d.originalEvent && d.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new c.k("trackuserlocationend")), this.fire(new c.k("userlocationlostfocus")));
              });
            }
          }, this.options = c.e({}, yd, y);
        }
        onAdd(y) {
          return this._map = y, this._container = P.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
            return c._(this, arguments, void 0, function* (r = !1) {
              if (ir !== void 0 && !r) return ir;
              if (window.navigator.permissions === void 0) return ir = !!window.navigator.geolocation, ir;
              try {
                ir = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
              } catch {
                ir = !!window.navigator.geolocation;
              }
              return ir;
            });
          }().then((r) => this._finishSetupUI(r)), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), P.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Fa = 0, ka = !1;
        }
        _isOutOfMapMaxBounds(y) {
          const r = this._map.getMaxBounds(), d = y.coords;
          return r && (d.longitude < r.getWest() || d.longitude > r.getEast() || d.latitude < r.getSouth() || d.latitude > r.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadius() {
          const y = this._map.getBounds(), r = y.getSouthEast(), d = y.getNorthEast(), p = r.distanceTo(d), _ = Math.ceil(this._accuracy / (p / this._map._container.clientHeight) * 2);
          this._circleElement.style.width = `${_}px`, this._circleElement.style.height = `${_}px`;
        }
        trigger() {
          if (!this._setup) return c.w("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new c.k("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                Fa--, ka = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new c.k("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new c.k("trackuserlocationstart")), this.fire(new c.k("userlocationfocus"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let y;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Fa++, Fa > 1 ? (y = { maximumAge: 6e5, timeout: 0 }, ka = !0) : (y = this.options.positionOptions, ka = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, y);
            }
          } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, u.Hash = Il, u.ImageSource = Ar, u.KeyboardHandler = fr, u.LngLatBounds = Ie, u.LogoControl = Ah, u.Map = class extends _d {
        constructor(y) {
          c.bf.mark(c.bg.create);
          const r = Object.assign(Object.assign({}, qp), y);
          if (r.minZoom != null && r.maxZoom != null && r.minZoom > r.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
          if (r.minPitch != null && r.maxPitch != null && r.minPitch > r.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
          if (r.minPitch != null && r.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (r.maxPitch != null && r.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (super(new ko(r.minZoom, r.maxZoom, r.minPitch, r.maxPitch, r.renderWorldCopies), { bearingSnap: r.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new kt(), this._controls = [], this._mapId = c.a4(), this._contextLost = (d) => {
            d.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new c.k("webglcontextlost", { originalEvent: d }));
          }, this._contextRestored = (d) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new c.k("webglcontextrestored", { originalEvent: d }));
          }, this._onMapScroll = (d) => {
            if (d.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = r.interactive, this._maxTileCacheSize = r.maxTileCacheSize, this._maxTileCacheZoomLevels = r.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = r.failIfMajorPerformanceCaveat === !0, this._preserveDrawingBuffer = r.preserveDrawingBuffer === !0, this._antialias = r.antialias === !0, this._trackResize = r.trackResize === !0, this._bearingSnap = r.bearingSnap, this._refreshExpiredTiles = r.refreshExpiredTiles === !0, this._fadeDuration = r.fadeDuration, this._crossSourceCollisions = r.crossSourceCollisions === !0, this._collectResourceTiming = r.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Sh), r.locale), this._clickTolerance = r.clickTolerance, this._overridePixelRatio = r.pixelRatio, this._maxCanvasSize = r.maxCanvasSize, this.transformCameraUpdate = r.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = r.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Ee.addThrottleControl(() => this.isMoving()), this._requestManager = new Oe(r.transformRequest), typeof r.container == "string") {
            if (this._container = document.getElementById(r.container), !this._container) throw new Error(`Container '${r.container}' not found.`);
          } else {
            if (!(r.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = r.container;
          }
          if (r.maxBounds && this.setMaxBounds(r.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)).on("moveend", () => this._update(!1)).on("zoom", () => this._update(!0)).on("terrain", () => {
            this.painter.terrainFacilitator.dirty = !0, this._update(!0);
          }).once("idle", () => {
            this._idleTriggered = !0;
          }), typeof window < "u") {
            addEventListener("online", this._onWindowOnline, !1);
            let d = !1;
            const p = Ma((_) => {
              this._trackResize && !this._removed && (this.resize(_), this.redraw());
            }, 50);
            this._resizeObserver = new ResizeObserver((_) => {
              d ? p(_) : d = !0;
            }), this._resizeObserver.observe(this._container);
          }
          this.handlers = new wh(this, r), this._hash = r.hash && new Il(typeof r.hash == "string" && r.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: r.center, zoom: r.zoom, bearing: r.bearing, pitch: r.pitch }), r.bounds && (this.resize(), this.fitBounds(r.bounds, c.e({}, r.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = r.localIdeographFontFamily, this._validateStyle = r.validateStyle, r.style && this.setStyle(r.style, { localIdeographFontFamily: r.localIdeographFontFamily }), r.attributionControl && this.addControl(new Vo(typeof r.attributionControl == "boolean" ? void 0 : r.attributionControl)), r.maplibreLogo && this.addControl(new Ah(), r.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (d) => {
            this._update(d.dataType === "style"), this.fire(new c.k(`${d.dataType}data`, d));
          }), this.on("dataloading", (d) => {
            this.fire(new c.k(`${d.dataType}dataloading`, d));
          }), this.on("dataabort", (d) => {
            this.fire(new c.k("sourcedataabort", d));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(y, r) {
          if (r === void 0 && (r = y.getDefaultPosition ? y.getDefaultPosition() : "top-right"), !y || !y.onAdd) return this.fire(new c.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const d = y.onAdd(this);
          this._controls.push(y);
          const p = this._controlPositions[r];
          return r.indexOf("bottom") !== -1 ? p.insertBefore(d, p.firstChild) : p.appendChild(d), this;
        }
        removeControl(y) {
          if (!y || !y.onRemove) return this.fire(new c.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const r = this._controls.indexOf(y);
          return r > -1 && this._controls.splice(r, 1), y.onRemove(this), this;
        }
        hasControl(y) {
          return this._controls.indexOf(y) > -1;
        }
        calculateCameraOptionsFromTo(y, r, d, p) {
          return p == null && this.terrain && (p = this.terrain.getElevationForLngLatZoom(d, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(y, r, d, p);
        }
        resize(y) {
          var r;
          const d = this._containerDimensions(), p = d[0], _ = d[1], g = this._getClampedPixelRatio(p, _);
          if (this._resizeCanvas(p, _, g), this.painter.resize(p, _, g), this.painter.overLimit()) {
            const S = this.painter.context.gl;
            this._maxCanvasSize = [S.drawingBufferWidth, S.drawingBufferHeight];
            const I = this._getClampedPixelRatio(p, _);
            this._resizeCanvas(p, _, I), this.painter.resize(p, _, I);
          }
          this.transform.resize(p, _), (r = this._requestedCameraState) === null || r === void 0 || r.resize(p, _);
          const T = !this._moving;
          return T && (this.stop(), this.fire(new c.k("movestart", y)).fire(new c.k("move", y))), this.fire(new c.k("resize", y)), T && this.fire(new c.k("moveend", y)), this;
        }
        _getClampedPixelRatio(y, r) {
          const { 0: d, 1: p } = this._maxCanvasSize, _ = this.getPixelRatio(), g = y * _, T = r * _;
          return Math.min(g > d ? d / g : 1, T > p ? p / T : 1) * _;
        }
        getPixelRatio() {
          var y;
          return (y = this._overridePixelRatio) !== null && y !== void 0 ? y : devicePixelRatio;
        }
        setPixelRatio(y) {
          this._overridePixelRatio = y, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(y) {
          return this.transform.setMaxBounds(Ie.convert(y)), this._update();
        }
        setMinZoom(y) {
          if ((y = y ?? -2) >= -2 && y <= this.transform.maxZoom) return this.transform.minZoom = y, this._update(), this.getZoom() < y && this.setZoom(y), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(y) {
          if ((y = y ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = y, this._update(), this.getZoom() > y && this.setZoom(y), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(y) {
          if ((y = y ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (y >= 0 && y <= this.transform.maxPitch) return this.transform.minPitch = y, this._update(), this.getPitch() < y && this.setPitch(y), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(y) {
          if ((y = y ?? 60) > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (y >= this.transform.minPitch) return this.transform.maxPitch = y, this._update(), this.getPitch() > y && this.setPitch(y), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(y) {
          return this.transform.renderWorldCopies = y, this._update();
        }
        project(y) {
          return this.transform.locationPoint(c.N.convert(y), this.style && this.terrain);
        }
        unproject(y) {
          return this.transform.pointLocation(c.P.convert(y), this.terrain);
        }
        isMoving() {
          var y;
          return this._moving || ((y = this.handlers) === null || y === void 0 ? void 0 : y.isMoving());
        }
        isZooming() {
          var y;
          return this._zooming || ((y = this.handlers) === null || y === void 0 ? void 0 : y.isZooming());
        }
        isRotating() {
          var y;
          return this._rotating || ((y = this.handlers) === null || y === void 0 ? void 0 : y.isRotating());
        }
        _createDelegatedListener(y, r, d) {
          if (y === "mouseenter" || y === "mouseover") {
            let p = !1;
            return { layers: r, listener: d, delegates: { mousemove: (g) => {
              const T = r.filter((I) => this.getLayer(I)), S = T.length !== 0 ? this.queryRenderedFeatures(g.point, { layers: T }) : [];
              S.length ? p || (p = !0, d.call(this, new ms(y, this, g.originalEvent, { features: S }))) : p = !1;
            }, mouseout: () => {
              p = !1;
            } } };
          }
          if (y === "mouseleave" || y === "mouseout") {
            let p = !1;
            return { layers: r, listener: d, delegates: { mousemove: (T) => {
              const S = r.filter((I) => this.getLayer(I));
              (S.length !== 0 ? this.queryRenderedFeatures(T.point, { layers: S }) : []).length ? p = !0 : p && (p = !1, d.call(this, new ms(y, this, T.originalEvent)));
            }, mouseout: (T) => {
              p && (p = !1, d.call(this, new ms(y, this, T.originalEvent)));
            } } };
          }
          {
            const p = (_) => {
              const g = r.filter((S) => this.getLayer(S)), T = g.length !== 0 ? this.queryRenderedFeatures(_.point, { layers: g }) : [];
              T.length && (_.features = T, d.call(this, _), delete _.features);
            };
            return { layers: r, listener: d, delegates: { [y]: p } };
          }
        }
        _saveDelegatedListener(y, r) {
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[y] = this._delegatedListeners[y] || [], this._delegatedListeners[y].push(r);
        }
        _removeDelegatedListener(y, r, d) {
          if (!this._delegatedListeners || !this._delegatedListeners[y]) return;
          const p = this._delegatedListeners[y];
          for (let _ = 0; _ < p.length; _++) {
            const g = p[_];
            if (g.listener === d && g.layers.length === r.length && g.layers.every((T) => r.includes(T))) {
              for (const T in g.delegates) this.off(T, g.delegates[T]);
              return void p.splice(_, 1);
            }
          }
        }
        on(y, r, d) {
          if (d === void 0) return super.on(y, r);
          const p = this._createDelegatedListener(y, typeof r == "string" ? [r] : r, d);
          this._saveDelegatedListener(y, p);
          for (const _ in p.delegates) this.on(_, p.delegates[_]);
          return this;
        }
        once(y, r, d) {
          if (d === void 0) return super.once(y, r);
          const p = typeof r == "string" ? [r] : r, _ = this._createDelegatedListener(y, p, d);
          for (const g in _.delegates) {
            const T = _.delegates[g];
            _.delegates[g] = (...S) => {
              this._removeDelegatedListener(y, p, d), T(...S);
            };
          }
          this._saveDelegatedListener(y, _);
          for (const g in _.delegates) this.once(g, _.delegates[g]);
          return this;
        }
        off(y, r, d) {
          return d === void 0 ? super.off(y, r) : (this._removeDelegatedListener(y, typeof r == "string" ? [r] : r, d), this);
        }
        queryRenderedFeatures(y, r) {
          if (!this.style) return [];
          let d;
          const p = y instanceof c.P || Array.isArray(y), _ = p ? y : [[0, 0], [this.transform.width, this.transform.height]];
          if (r = r || (p ? {} : y) || {}, _ instanceof c.P || typeof _[0] == "number") d = [c.P.convert(_)];
          else {
            const g = c.P.convert(_[0]), T = c.P.convert(_[1]);
            d = [g, new c.P(T.x, g.y), T, new c.P(g.x, T.y), g];
          }
          return this.style.queryRenderedFeatures(d, r, this.transform);
        }
        querySourceFeatures(y, r) {
          return this.style.querySourceFeatures(y, r);
        }
        setStyle(y, r) {
          return (r = c.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, r)).diff !== !1 && r.localIdeographFontFamily === this._localIdeographFontFamily && this.style && y ? (this._diffStyle(y, r), this) : (this._localIdeographFontFamily = r.localIdeographFontFamily, this._updateStyle(y, r));
        }
        setTransformRequest(y) {
          return this._requestManager.setTransformRequest(y), this;
        }
        _getUIString(y) {
          const r = this._locale[y];
          if (r == null) throw new Error(`Missing UI string '${y}'`);
          return r;
        }
        _updateStyle(y, r) {
          if (r.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(y, r));
          const d = this.style && r.transformStyle ? this.style.serialize() : void 0;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!y)), y ? (this.style = new Eo(this, r || {}), this.style.setEventedParent(this, { style: this.style }), typeof y == "string" ? this.style.loadURL(y, r, d) : this.style.loadJSON(y, r, d), this) : (delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new Eo(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(y, r) {
          if (typeof y == "string") {
            const d = this._requestManager.transformRequest(y, "Style");
            c.h(d, new AbortController()).then((p) => {
              this._updateDiff(p.data, r);
            }).catch((p) => {
              p && this.fire(new c.j(p));
            });
          } else typeof y == "object" && this._updateDiff(y, r);
        }
        _updateDiff(y, r) {
          try {
            this.style.setState(y, r) && this._update(!0);
          } catch (d) {
            c.w(`Unable to perform style diff: ${d.message || d.error || d}.  Rebuilding the style from scratch.`), this._updateStyle(y, r);
          }
        }
        getStyle() {
          if (this.style) return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : c.w("There is no style added to the map.");
        }
        addSource(y, r) {
          return this._lazyInitEmptyStyle(), this.style.addSource(y, r), this._update(!0);
        }
        isSourceLoaded(y) {
          const r = this.style && this.style.sourceCaches[y];
          if (r !== void 0) return r.loaded();
          this.fire(new c.j(new Error(`There is no source with ID '${y}'`)));
        }
        setTerrain(y) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), y) {
            const r = this.style.sourceCaches[y.source];
            if (!r) throw new Error(`cannot load terrain, because there exists no source with ID: ${y.source}`);
            this.terrain === null && r.reload();
            for (const d in this.style._layers) {
              const p = this.style._layers[d];
              p.type === "hillshade" && p.source === y.source && c.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
            }
            this.terrain = new Eh(this.painter, r, y), this.painter.renderToTexture = new md(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (d) => {
              d.dataType === "style" ? this.terrain.sourceCache.freeRtt() : d.dataType === "source" && d.tile && (d.sourceId !== y.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(d.tile.tileID));
            }, this.style.on("data", this._terrainDataCallback);
          } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
          return this.fire(new c.k("terrain", { terrain: y })), this;
        }
        getTerrain() {
          var y, r;
          return (r = (y = this.terrain) === null || y === void 0 ? void 0 : y.options) !== null && r !== void 0 ? r : null;
        }
        areTilesLoaded() {
          const y = this.style && this.style.sourceCaches;
          for (const r in y) {
            const d = y[r]._tiles;
            for (const p in d) {
              const _ = d[p];
              if (_.state !== "loaded" && _.state !== "errored") return !1;
            }
          }
          return !0;
        }
        removeSource(y) {
          return this.style.removeSource(y), this._update(!0);
        }
        getSource(y) {
          return this.style.getSource(y);
        }
        addImage(y, r, d = {}) {
          const { pixelRatio: p = 1, sdf: _ = !1, stretchX: g, stretchY: T, content: S, textFitWidth: I, textFitHeight: D } = d;
          if (this._lazyInitEmptyStyle(), !(r instanceof HTMLImageElement || c.b(r))) {
            if (r.width === void 0 || r.height === void 0) return this.fire(new c.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: k, height: N, data: H } = r, q = r;
              return this.style.addImage(y, { data: new c.R({ width: k, height: N }, new Uint8Array(H)), pixelRatio: p, stretchX: g, stretchY: T, content: S, textFitWidth: I, textFitHeight: D, sdf: _, version: 0, userImage: q }), q.onAdd && q.onAdd(this, y), this;
            }
          }
          {
            const { width: k, height: N, data: H } = M.getImageData(r);
            this.style.addImage(y, { data: new c.R({ width: k, height: N }, H), pixelRatio: p, stretchX: g, stretchY: T, content: S, textFitWidth: I, textFitHeight: D, sdf: _, version: 0 });
          }
        }
        updateImage(y, r) {
          const d = this.style.getImage(y);
          if (!d) return this.fire(new c.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const p = r instanceof HTMLImageElement || c.b(r) ? M.getImageData(r) : r, { width: _, height: g, data: T } = p;
          if (_ === void 0 || g === void 0) return this.fire(new c.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (_ !== d.data.width || g !== d.data.height) return this.fire(new c.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const S = !(r instanceof HTMLImageElement || c.b(r));
          return d.data.replace(T, S), this.style.updateImage(y, d), this;
        }
        getImage(y) {
          return this.style.getImage(y);
        }
        hasImage(y) {
          return y ? !!this.style.getImage(y) : (this.fire(new c.j(new Error("Missing required image id"))), !1);
        }
        removeImage(y) {
          this.style.removeImage(y);
        }
        loadImage(y) {
          return Ee.getImage(this._requestManager.transformRequest(y, "Image"), new AbortController());
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(y, r) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(y, r), this._update(!0);
        }
        moveLayer(y, r) {
          return this.style.moveLayer(y, r), this._update(!0);
        }
        removeLayer(y) {
          return this.style.removeLayer(y), this._update(!0);
        }
        getLayer(y) {
          return this.style.getLayer(y);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(y, r, d) {
          return this.style.setLayerZoomRange(y, r, d), this._update(!0);
        }
        setFilter(y, r, d = {}) {
          return this.style.setFilter(y, r, d), this._update(!0);
        }
        getFilter(y) {
          return this.style.getFilter(y);
        }
        setPaintProperty(y, r, d, p = {}) {
          return this.style.setPaintProperty(y, r, d, p), this._update(!0);
        }
        getPaintProperty(y, r) {
          return this.style.getPaintProperty(y, r);
        }
        setLayoutProperty(y, r, d, p = {}) {
          return this.style.setLayoutProperty(y, r, d, p), this._update(!0);
        }
        getLayoutProperty(y, r) {
          return this.style.getLayoutProperty(y, r);
        }
        setGlyphs(y, r = {}) {
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(y, r), this._update(!0);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(y, r, d = {}) {
          return this._lazyInitEmptyStyle(), this.style.addSprite(y, r, d, (p) => {
            p || this._update(!0);
          }), this;
        }
        removeSprite(y) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(y), this._update(!0);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(y, r = {}) {
          return this._lazyInitEmptyStyle(), this.style.setSprite(y, r, (d) => {
            d || this._update(!0);
          }), this;
        }
        setLight(y, r = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(y, r), this._update(!0);
        }
        getLight() {
          return this.style.getLight();
        }
        setSky(y) {
          return this._lazyInitEmptyStyle(), this.style.setSky(y), this._update(!0);
        }
        getSky() {
          return this.style.getSky();
        }
        setFeatureState(y, r) {
          return this.style.setFeatureState(y, r), this._update();
        }
        removeFeatureState(y, r) {
          return this.style.removeFeatureState(y, r), this._update();
        }
        getFeatureState(y) {
          return this.style.getFeatureState(y);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let y = 0, r = 0;
          return this._container && (y = this._container.clientWidth || 400, r = this._container.clientHeight || 300), [y, r];
        }
        _setupContainer() {
          const y = this._container;
          y.classList.add("maplibregl-map");
          const r = this._canvasContainer = P.create("div", "maplibregl-canvas-container", y);
          this._interactive && r.classList.add("maplibregl-interactive"), this._canvas = P.create("canvas", "maplibregl-canvas", r), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
          const d = this._containerDimensions(), p = this._getClampedPixelRatio(d[0], d[1]);
          this._resizeCanvas(d[0], d[1], p);
          const _ = this._controlContainer = P.create("div", "maplibregl-control-container", y), g = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((T) => {
            g[T] = P.create("div", `maplibregl-ctrl-${T} `, _);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _resizeCanvas(y, r, d) {
          this._canvas.width = Math.floor(d * y), this._canvas.height = Math.floor(d * r), this._canvas.style.width = `${y}px`, this._canvas.style.height = `${r}px`;
        }
        _setupPainter() {
          const y = { alpha: !0, stencil: !0, depth: !0, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 };
          let r = null;
          this._canvas.addEventListener("webglcontextcreationerror", (p) => {
            r = { requestedAttributes: y }, p && (r.statusMessage = p.statusMessage, r.type = p.type);
          }, { once: !0 });
          const d = this._canvas.getContext("webgl2", y) || this._canvas.getContext("webgl", y);
          if (!d) {
            const p = "Failed to initialize WebGL";
            throw r ? (r.message = p, new Error(JSON.stringify(r))) : new Error(p);
          }
          this.painter = new Cl(d, this.transform), j.testSupport(d);
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(y) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || y, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(y) {
          return this._update(), this._renderTaskQueue.add(y);
        }
        _cancelRenderFrame(y) {
          this._renderTaskQueue.remove(y);
        }
        _render(y) {
          const r = this._idleTriggered ? this._fadeDuration : 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(y), this._removed) return;
          let d = !1;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const _ = this.transform.zoom, g = M.now();
            this.style.zoomHistory.update(_, g);
            const T = new c.z(_, { now: g, fadeDuration: r, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), S = T.crossFadingFactor();
            S === 1 && S === this._crossFadingFactor || (d = !0, this._crossFadingFactor = S), this.style.update(T);
          }
          this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, r, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: r, showPadding: this.showPadding }), this.fire(new c.k("render")), this.loaded() && !this._loaded && (this._loaded = !0, c.bf.mark(c.bg.load), this.fire(new c.k("load"))), this.style && (this.style.hasTransitions() || d) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          const p = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return p || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new c.k("idle")), !this._loaded || this._fullyLoaded || p || (this._fullyLoaded = !0, c.bf.mark(c.bg.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
        }
        remove() {
          var y;
          this._hash && this._hash.remove();
          for (const d of this._controls) d.onRemove(this);
          this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Ee.removeThrottleControl(this._imageQueueHandle), (y = this._resizeObserver) === null || y === void 0 || y.disconnect();
          const r = this.painter.context.gl.getExtension("WEBGL_lose_context");
          r != null && r.loseContext && r.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), P.remove(this._canvasContainer), P.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), c.bf.clearMetrics(), this._removed = !0, this.fire(new c.k("remove"));
        }
        triggerRepaint() {
          this.style && !this._frameRequest && (this._frameRequest = new AbortController(), M.frameAsync(this._frameRequest).then((y) => {
            c.bf.frame(y), this._frameRequest = null, this._render(y);
          }).catch(() => {
          }));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(y) {
          this._showTileBoundaries !== y && (this._showTileBoundaries = y, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(y) {
          this._showPadding !== y && (this._showPadding = y, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(y) {
          this._showCollisionBoxes !== y && (this._showCollisionBoxes = y, y ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(y) {
          this._showOverdrawInspector !== y && (this._showOverdrawInspector = y, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(y) {
          this._repaint !== y && (this._repaint = y, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(y) {
          this._vertices = y, this._update();
        }
        get version() {
          return gd;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
      }, u.MapMouseEvent = ms, u.MapTouchEvent = oo, u.MapWheelEvent = hd, u.Marker = Ll, u.NavigationControl = class {
        constructor(y) {
          this._updateZoomButtons = () => {
            const r = this._map.getZoom(), d = r === this._map.getMaxZoom(), p = r === this._map.getMinZoom();
            this._zoomInButton.disabled = d, this._zoomOutButton.disabled = p, this._zoomInButton.setAttribute("aria-disabled", d.toString()), this._zoomOutButton.setAttribute("aria-disabled", p.toString());
          }, this._rotateCompassArrow = () => {
            const r = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._compassIcon.style.transform = r;
          }, this._setButtonTitle = (r, d) => {
            const p = this._map._getUIString(`NavigationControl.${d}`);
            r.title = p, r.setAttribute("aria-label", p);
          }, this.options = c.e({}, Zp, y), this._container = P.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (r) => r.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (r) => this._map.zoomIn({}, { originalEvent: r })), P.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (r) => this._map.zoomOut({}, { originalEvent: r })), P.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (r) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: r }) : this._map.resetNorth({}, { originalEvent: r });
          }), this._compassIcon = P.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        onAdd(y) {
          return this._map = y, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Kp(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          P.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(y, r) {
          const d = P.create("button", y, this._container);
          return d.type = "button", d.addEventListener("click", r), d;
        }
      }, u.Popup = class extends c.E {
        constructor(y) {
          super(), this.remove = () => (this._content && P.remove(this._content), this._container && (P.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new c.k("close"))), this), this._onMouseUp = (r) => {
            this._update(r.point);
          }, this._onMouseMove = (r) => {
            this._update(r.point);
          }, this._onDrag = (r) => {
            this._update(r.point);
          }, this._update = (r) => {
            var d;
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
            if (!this._container) {
              if (this._container = P.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = P.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const S of this.options.className.split(" ")) this._container.classList.add(S);
              this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? fi(this._lngLat, this._flatPos, this._map.transform) : (d = this._lngLat) === null || d === void 0 ? void 0 : d.wrap(), this._trackPointer && !r) return;
            const p = this._flatPos = this._pos = this._trackPointer && r ? r : this._map.project(this._lngLat);
            this._map.terrain && (this._flatPos = this._trackPointer && r ? r : this._map.transform.locationPoint(this._lngLat));
            let _ = this.options.anchor;
            const g = zl(this.options.offset);
            if (!_) {
              const S = this._container.offsetWidth, I = this._container.offsetHeight;
              let D;
              D = p.y + g.bottom.y < I ? ["top"] : p.y > this._map.transform.height - I ? ["bottom"] : [], p.x < S / 2 ? D.push("left") : p.x > this._map.transform.width - S / 2 && D.push("right"), _ = D.length === 0 ? "bottom" : D.join("-");
            }
            let T = p.add(g[_]);
            this.options.subpixelPositioning || (T = T.round()), P.setTransform(this._container, `${jo[_]} translate(${T.x}px,${T.y}px)`), Nl(this._container, _, "popup");
          }, this._onClose = () => {
            this.remove();
          }, this.options = c.e(Object.create(vt), y);
        }
        addTo(y) {
          return this._map && this.remove(), this._map = y, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new c.k("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(y) {
          return this._lngLat = c.N.convert(y), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(y) {
          return this.setDOMContent(document.createTextNode(y));
        }
        setHTML(y) {
          const r = document.createDocumentFragment(), d = document.createElement("body");
          let p;
          for (d.innerHTML = y; p = d.firstChild, p; ) r.appendChild(p);
          return this.setDOMContent(r);
        }
        getMaxWidth() {
          var y;
          return (y = this._container) === null || y === void 0 ? void 0 : y.style.maxWidth;
        }
        setMaxWidth(y) {
          return this.options.maxWidth = y, this._update(), this;
        }
        setDOMContent(y) {
          if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else this._content = P.create("div", "maplibregl-popup-content", this._container);
          return this._content.appendChild(y), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(y) {
          return this._container && this._container.classList.add(y), this;
        }
        removeClassName(y) {
          return this._container && this._container.classList.remove(y), this;
        }
        setOffset(y) {
          return this.options.offset = y, this._update(), this;
        }
        toggleClassName(y) {
          if (this._container) return this._container.classList.toggle(y);
        }
        setSubpixelPositioning(y) {
          this.options.subpixelPositioning = y;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = P.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;
          const y = this._container.querySelector(Ul);
          y && y.focus();
        }
      }, u.RasterDEMTileSource = oi, u.RasterTileSource = zt, u.ScaleControl = class {
        constructor(y) {
          this._onMove = () => {
            Na(this._map, this._container, this.options);
          }, this.setUnit = (r) => {
            this.options.unit = r, Na(this._map, this._container, this.options);
          }, this.options = Object.assign(Object.assign({}, Zr), y);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(y) {
          return this._map = y, this._container = P.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", y.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          P.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }
      }, u.ScrollZoomHandler = Cr, u.Style = Eo, u.TerrainControl = class {
        constructor(y) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
          }, this.options = y;
        }
        onAdd(y) {
          return this._map = y, this._container = P.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = P.create("button", "maplibregl-ctrl-terrain", this._container), P.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          P.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
        }
      }, u.TwoFingersTouchPitchHandler = Lo, u.TwoFingersTouchRotateHandler = bh, u.TwoFingersTouchZoomHandler = gh, u.TwoFingersTouchZoomRotateHandler = xh, u.VectorTileSource = Sn, u.VideoSource = Cn, u.addSourceType = (y, r) => c._(void 0, void 0, void 0, function* () {
        if (In(y)) throw new Error(`A source type called "${y}" already exists.`);
        ((d, p) => {
          Jn[d] = p;
        })(y, r);
      }), u.clearPrewarmedResources = function() {
        const y = Qt;
        y && (y.isPreloaded() && y.numActive() === 1 ? (y.release(or), Qt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, u.getMaxParallelImageRequests = function() {
        return c.a.MAX_PARALLEL_IMAGE_REQUESTS;
      }, u.getRTLTextPluginStatus = function() {
        return Is().getRTLTextPluginStatus();
      }, u.getVersion = function() {
        return Ih;
      }, u.getWorkerCount = function() {
        return ar.workerCount;
      }, u.getWorkerUrl = function() {
        return c.a.WORKER_URL;
      }, u.importScriptInWorkers = function(y) {
        return Vr().broadcast("IS", y);
      }, u.prewarm = function() {
        ni().acquire(or);
      }, u.setMaxParallelImageRequests = function(y) {
        c.a.MAX_PARALLEL_IMAGE_REQUESTS = y;
      }, u.setRTLTextPlugin = function(y, r) {
        return Is().setRTLTextPlugin(y, r);
      }, u.setWorkerCount = function(y) {
        ar.workerCount = y;
      }, u.setWorkerUrl = function(y) {
        c.a.WORKER_URL = y;
      };
    });
    var l = i;
    return l;
  });
})(V1);
var Hg = V1.exports;
const QS = /* @__PURE__ */ z1(Hg), eC = /* @__PURE__ */ U1({
  __proto__: null,
  default: QS
}, [Hg]), tC = /* @__PURE__ */ function() {
  let t;
  function e() {
    return eC;
  }
  return {
    getInstance() {
      return t = e(), t;
    }
  };
}(), iC = "https://api.olamaps.io/tiles/vector/v1/styles/default-light-standard/style.json?key=0.4.0", sC = "https://api.olamaps.io/tiles/vector/v1/3dtiles/tileset.json", rC = (t) => `<svg width="108" height="18" viewBox="0 0 108 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M31.0629 8.9393L34.6986 15.7293H38.2743L31.0629 2.2793L23.8516 15.7293H27.4273L31.0629 8.9393Z" fill="${t}"/><path d="M19.2265 12.5798L19.2365 2.25977H16.0703V15.7298H22.163L23.851 12.5798H19.2265Z" fill="${t}"/><path d="M7.22135 1.7793C5.79466 1.77733 4.39943 2.19909 3.21222 2.99123C2.025 3.78337 1.09915 4.91029 0.551806 6.22939C0.00446369 7.5485 -0.139771 9.00051 0.137352 10.4017C0.414475 11.8029 1.1005 13.0903 2.10863 14.1011C3.11676 15.1118 4.40168 15.8004 5.80082 16.0798C7.19996 16.3592 8.65043 16.2168 9.96872 15.6707C11.287 15.1245 12.4139 14.1991 13.2067 13.0116C13.9995 11.824 14.4227 10.4277 14.4227 8.9993C14.4227 7.08617 13.6643 5.25125 12.3141 3.89753C10.9639 2.5438 9.13219 1.78195 7.22135 1.7793ZM7.22135 12.8893C6.45207 12.8933 5.69892 12.6685 5.05735 12.2435C4.41579 11.8184 3.91469 11.2123 3.61755 10.5019C3.32041 9.79141 3.24061 9.00864 3.38827 8.25274C3.53592 7.49684 3.90438 6.80184 4.44695 6.25581C4.98952 5.70978 5.68178 5.3373 6.43601 5.18558C7.19023 5.03385 7.97246 5.10971 8.68358 5.40354C9.3947 5.69737 10.0027 6.19594 10.4305 6.83607C10.8583 7.4762 11.0867 8.22908 11.0867 8.9993C11.0867 9.51015 10.9862 10.016 10.791 10.4879C10.5957 10.9599 10.3095 11.3887 9.94873 11.7499C9.58794 12.1112 9.15963 12.3977 8.68823 12.5932C8.21684 12.7887 7.71161 12.8893 7.20138 12.8893H7.22135Z" fill="${t}"/><path d="M55.5634 4.82953V4.33953L50.4296 15.7295H49.4308L44.3768 4.33953V4.82953L43.9773 15.7295H42.9785L43.438 2.26953H44.5766L49.7104 13.8095C49.8003 14.0495 49.9102 14.2895 49.9801 14.5095C50.0543 14.2675 50.1513 14.0332 50.2698 13.8095L55.3437 2.26953H56.4723L56.9318 15.7295H55.933L55.5634 4.82953Z" fill="${t}"/><path d="M60.3287 15.7495H59.25L65.2428 2.26953H66.5513L72.5441 15.7495H71.4254L69.6875 11.8395H62.0666L60.3287 15.7495ZM66.4614 4.54953C66.2216 3.96953 66.0019 3.41953 65.8621 3.01953C65.7322 3.41953 65.5125 4.01953 65.2928 4.54953L62.4462 10.9095H69.288L66.4614 4.54953Z" fill="${t}"/><path d="M79.1611 2.14062C82.6669 2.14062 84.4048 3.62063 84.4048 6.62063C84.4048 9.62063 82.6669 11.0706 79.211 11.0706H75.9949V15.5906H74.9961V2.14062H79.1611ZM79.1611 10.1406C82.0077 10.1406 83.436 8.97062 83.416 6.61062C83.396 4.25062 82.0077 3.06062 79.1411 3.06062H75.9949V10.1406H79.1611Z" fill="${t}"/><path d="M95.1406 3.9293C93.7557 3.25763 92.2346 2.91539 90.6959 2.9293C88.8481 2.9293 87.6995 4.0193 87.6995 5.2293C87.6995 6.8693 88.5984 7.3593 91.6248 8.3693C94.6511 9.3793 95.9995 10.3693 95.9995 12.3693C95.9995 14.9993 93.942 15.9293 91.6947 15.9293C89.6115 15.9429 87.5948 15.1964 86.0215 13.8293L86.5009 13.0693C87.9375 14.3316 89.7833 15.0282 91.6947 15.0293C93.902 15.0293 95.0007 14.1193 95.0007 12.4893C95.0007 10.8593 94.1617 10.2093 90.9356 9.1293C88.069 8.1793 86.7007 7.5993 86.7007 5.2793C86.7007 3.3993 88.2488 2.0293 90.6959 2.0293C92.3497 2.03153 93.9817 2.40754 95.4702 3.1293L95.1406 3.9293Z" fill="${t}"/></svg>`;
async function Bu(t, e, i, s) {
  return s._parse(t, e, i, s);
}
function Ai(t, e) {
  if (!t)
    throw new Error(e || "loader assertion failed.");
}
const fp = (
  // @ts-ignore process does not exist on browser
  !!(typeof process != "object" || String(process) !== "[object process]" || process.browser)
), Ib = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
Ib && parseFloat(Ib[1]);
const Hd = globalThis, rc = globalThis.process || {}, nC = globalThis.navigator || {};
function j1(t) {
  var s, o;
  if (typeof window < "u" && ((s = window.process) == null ? void 0 : s.type) === "renderer" || typeof process < "u" && ((o = process.versions) != null && o.electron))
    return !0;
  const i = typeof navigator < "u" && navigator.userAgent;
  return !!(i && i.indexOf("Electron") >= 0);
}
function ya() {
  return !// @ts-expect-error
  (typeof process == "object" && String(process) === "[object process]" && !(process != null && process.browser)) || j1();
}
function oC(t) {
  return ya() ? j1() ? "Electron" : (nC.userAgent || "").indexOf("Edge") > -1 ? "Edge" : globalThis.chrome ? "Chrome" : globalThis.safari ? "Safari" : globalThis.mozInnerScreenX ? "Firefox" : "Unknown" : "Node";
}
const $1 = "4.0.7";
function aC(t) {
  try {
    const e = window[t], i = "__storage_test__";
    return e.setItem(i, i), e.removeItem(i), e;
  } catch {
    return null;
  }
}
class lC {
  constructor(e, i, s = "sessionStorage") {
    this.storage = aC(s), this.id = e, this.config = i, this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(e) {
    if (Object.assign(this.config, e), this.storage) {
      const i = JSON.stringify(this.config);
      this.storage.setItem(this.id, i);
    }
  }
  // Get config from persistent store, if available
  _loadConfiguration() {
    let e = {};
    if (this.storage) {
      const i = this.storage.getItem(this.id);
      e = i ? JSON.parse(i) : {};
    }
    return Object.assign(this.config, e), this;
  }
}
function cC(t) {
  let e;
  return t < 10 ? e = `${t.toFixed(2)}ms` : t < 100 ? e = `${t.toFixed(1)}ms` : t < 1e3 ? e = `${t.toFixed(0)}ms` : e = `${(t / 1e3).toFixed(2)}s`, e;
}
function hC(t, e = 8) {
  const i = Math.max(e - t.length, 0);
  return `${" ".repeat(i)}${t}`;
}
var Cf;
(function(t) {
  t[t.BLACK = 30] = "BLACK", t[t.RED = 31] = "RED", t[t.GREEN = 32] = "GREEN", t[t.YELLOW = 33] = "YELLOW", t[t.BLUE = 34] = "BLUE", t[t.MAGENTA = 35] = "MAGENTA", t[t.CYAN = 36] = "CYAN", t[t.WHITE = 37] = "WHITE", t[t.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", t[t.BRIGHT_RED = 91] = "BRIGHT_RED", t[t.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", t[t.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", t[t.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", t[t.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", t[t.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", t[t.BRIGHT_WHITE = 97] = "BRIGHT_WHITE";
})(Cf || (Cf = {}));
const uC = 10;
function Rb(t) {
  return typeof t != "string" ? t : (t = t.toUpperCase(), Cf[t] || Cf.WHITE);
}
function dC(t, e, i) {
  return !ya && typeof t == "string" && (e && (t = `\x1B[${Rb(e)}m${t}\x1B[39m`), i && (t = `\x1B[${Rb(i) + uC}m${t}\x1B[49m`)), t;
}
function fC(t, e = ["constructor"]) {
  const i = Object.getPrototypeOf(t), s = Object.getOwnPropertyNames(i), o = t;
  for (const l of s) {
    const u = o[l];
    typeof u == "function" && (e.find((c) => l === c) || (o[l] = u.bind(t)));
  }
}
function jg(t, e) {
  if (!t)
    throw new Error("Assertion failed");
}
function nc() {
  var e, i, s;
  let t;
  if (ya() && Hd.performance)
    t = (i = (e = Hd == null ? void 0 : Hd.performance) == null ? void 0 : e.now) == null ? void 0 : i.call(e);
  else if ("hrtime" in rc) {
    const o = (s = rc == null ? void 0 : rc.hrtime) == null ? void 0 : s.call(rc);
    t = o[0] * 1e3 + o[1] / 1e6;
  } else
    t = Date.now();
  return t;
}
const oc = {
  debug: ya() && console.debug || console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
}, pC = {
  enabled: !0,
  level: 0
};
function ac() {
}
const Mb = {}, Pb = { once: !0 };
class Hc {
  constructor({ id: e } = { id: "" }) {
    this.VERSION = $1, this._startTs = nc(), this._deltaTs = nc(), this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = e, this.userData = {}, this._storage = new lC(`__probe-${this.id}__`, pC), this.timeStamp(`${this.id} started`), fC(this), Object.seal(this);
  }
  set level(e) {
    this.setLevel(e);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  /** @return milliseconds, with fractions */
  getTotal() {
    return Number((nc() - this._startTs).toPrecision(10));
  }
  /** @return milliseconds, with fractions */
  getDelta() {
    return Number((nc() - this._deltaTs).toPrecision(10));
  }
  /** @deprecated use logLevel */
  set priority(e) {
    this.level = e;
  }
  /** @deprecated use logLevel */
  get priority() {
    return this.level;
  }
  /** @deprecated use logLevel */
  getPriority() {
    return this.level;
  }
  // Configure
  enable(e = !0) {
    return this._storage.setConfiguration({ enabled: e }), this;
  }
  setLevel(e) {
    return this._storage.setConfiguration({ level: e }), this;
  }
  /** return the current status of the setting */
  get(e) {
    return this._storage.config[e];
  }
  // update the status of the setting
  set(e, i) {
    this._storage.setConfiguration({ [e]: i });
  }
  /** Logs the current settings as a table */
  settings() {
    console.table ? console.table(this._storage.config) : console.log(this._storage.config);
  }
  // Unconditional logging
  assert(e, i) {
    if (!e)
      throw new Error(i || "Assertion failed");
  }
  warn(e) {
    return this._getLogFunction(0, e, oc.warn, arguments, Pb);
  }
  error(e) {
    return this._getLogFunction(0, e, oc.error, arguments);
  }
  /** Print a deprecation warning */
  deprecated(e, i) {
    return this.warn(`\`${e}\` is deprecated and will be removed in a later version. Use \`${i}\` instead`);
  }
  /** Print a removal warning */
  removed(e, i) {
    return this.error(`\`${e}\` has been removed. Use \`${i}\` instead`);
  }
  probe(e, i) {
    return this._getLogFunction(e, i, oc.log, arguments, {
      time: !0,
      once: !0
    });
  }
  log(e, i) {
    return this._getLogFunction(e, i, oc.debug, arguments);
  }
  info(e, i) {
    return this._getLogFunction(e, i, console.info, arguments);
  }
  once(e, i) {
    return this._getLogFunction(e, i, oc.debug || oc.info, arguments, Pb);
  }
  /** Logs an object as a table */
  table(e, i, s) {
    return i ? this._getLogFunction(e, i, console.table || ac, s && [s], {
      tag: mC(i)
    }) : ac;
  }
  time(e, i) {
    return this._getLogFunction(e, i, console.time ? console.time : console.info);
  }
  timeEnd(e, i) {
    return this._getLogFunction(e, i, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(e, i) {
    return this._getLogFunction(e, i, console.timeStamp || ac);
  }
  group(e, i, s = { collapsed: !1 }) {
    const o = Bb({ logLevel: e, message: i, opts: s }), { collapsed: l } = s;
    return o.method = (l ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(o);
  }
  groupCollapsed(e, i, s = {}) {
    return this.group(e, i, Object.assign({}, s, { collapsed: !0 }));
  }
  groupEnd(e) {
    return this._getLogFunction(e, "", console.groupEnd || ac);
  }
  // EXPERIMENTAL
  withGroup(e, i, s) {
    this.group(e, i)();
    try {
      s();
    } finally {
      this.groupEnd(e)();
    }
  }
  trace() {
    console.trace && console.trace();
  }
  // PRIVATE METHODS
  /** Deduces log level from a variety of arguments */
  _shouldLog(e) {
    return this.isEnabled() && this.getLevel() >= G1(e);
  }
  _getLogFunction(e, i, s, o, l) {
    if (this._shouldLog(e)) {
      l = Bb({ logLevel: e, message: i, args: o, opts: l }), s = s || l.method, jg(s), l.total = this.getTotal(), l.delta = this.getDelta(), this._deltaTs = nc();
      const u = l.tag || l.message;
      if (l.once && u)
        if (!Mb[u])
          Mb[u] = nc();
        else
          return ac;
      return i = _C(this.id, l.message, l), s.bind(console, i, ...l.args);
    }
    return ac;
  }
}
Hc.VERSION = $1;
function G1(t) {
  if (!t)
    return 0;
  let e;
  switch (typeof t) {
    case "number":
      e = t;
      break;
    case "object":
      e = t.logLevel || t.priority || 0;
      break;
    default:
      return 0;
  }
  return jg(Number.isFinite(e) && e >= 0), e;
}
function Bb(t) {
  const { logLevel: e, message: i } = t;
  t.logLevel = G1(e);
  const s = t.args ? Array.from(t.args) : [];
  for (; s.length && s.shift() !== i; )
    ;
  switch (typeof e) {
    case "string":
    case "function":
      i !== void 0 && s.unshift(i), t.message = e;
      break;
    case "object":
      Object.assign(t, e);
      break;
  }
  typeof t.message == "function" && (t.message = t.message());
  const o = typeof t.message;
  return jg(o === "string" || o === "object"), Object.assign(t, { args: s }, t.opts);
}
function _C(t, e, i) {
  if (typeof e == "string") {
    const s = i.time ? hC(cC(i.total)) : "";
    e = i.time ? `${t}: ${s}  ${e}` : `${t}: ${e}`, e = dC(e, i.color, i.background);
  }
  return e;
}
function mC(t) {
  for (const e in t)
    for (const i in t[e])
      return i || "untitled";
  return "empty";
}
globalThis.probe = {};
const X1 = new Hc({ id: "@probe.gl/log" }), z_ = "4.3.1", gC = z_[0] >= "0" && z_[0] <= "9" ? `v${z_}` : "";
function yC() {
  const t = new Hc({ id: "loaders.gl" });
  return globalThis.loaders = globalThis.loaders || {}, globalThis.loaders.log = t, globalThis.loaders.version = gC, globalThis.probe = globalThis.probe || {}, globalThis.probe.loaders = t, t;
}
const bC = yC();
function vC(t, e) {
  return W1(t || {}, e);
}
function W1(t, e, i = 0) {
  if (i > 3)
    return e;
  const s = { ...t };
  for (const [o, l] of Object.entries(e))
    l && typeof l == "object" && !Array.isArray(l) ? s[o] = W1(s[o] || {}, e[o], i + 1) : s[o] = e[o];
  return s;
}
function xC(t) {
  var e;
  globalThis.loaders || (globalThis.loaders = {}), (e = globalThis.loaders).modules || (e.modules = {}), Object.assign(globalThis.loaders.modules, t);
}
function wC(t) {
  var i, s;
  return ((s = (i = globalThis.loaders) == null ? void 0 : i.modules) == null ? void 0 : s[t]) || null;
}
const AC = "latest";
function TC() {
  var t;
  return (t = globalThis._loadersgl_) != null && t.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.3.1"), globalThis._loadersgl_.version;
}
const q1 = TC();
function wo(t, e) {
  if (!t)
    throw new Error(e || "loaders.gl assertion failed.");
}
const rn = (
  // @ts-ignore process.browser
  typeof process != "object" || String(process) !== "[object process]" || process.browser
), $g = typeof importScripts == "function", EC = typeof window < "u" && typeof window.orientation < "u", Db = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
Db && parseFloat(Db[1]);
class SC {
  constructor(e, i) {
    O(this, "name");
    O(this, "workerThread");
    O(this, "isRunning", !0);
    /** Promise that resolves when Job is done */
    O(this, "result");
    O(this, "_resolve", () => {
    });
    O(this, "_reject", () => {
    });
    this.name = e, this.workerThread = i, this.result = new Promise((s, o) => {
      this._resolve = s, this._reject = o;
    });
  }
  /**
   * Send a message to the job's worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   */
  postMessage(e, i) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      // Lets worker ignore unrelated messages
      type: e,
      payload: i
    });
  }
  /**
   * Call to resolve the `result` Promise with the supplied value
   */
  done(e) {
    wo(this.isRunning), this.isRunning = !1, this._resolve(e);
  }
  /**
   * Call to reject the `result` Promise with the supplied error
   */
  error(e) {
    wo(this.isRunning), this.isRunning = !1, this._reject(e);
  }
}
class V_ {
  terminate() {
  }
}
const H_ = /* @__PURE__ */ new Map();
function CC(t) {
  wo(t.source && !t.url || !t.source && t.url);
  let e = H_.get(t.source || t.url);
  return e || (t.url && (e = IC(t.url), H_.set(t.url, e)), t.source && (e = Z1(t.source), H_.set(t.source, e))), wo(e), e;
}
function IC(t) {
  if (!t.startsWith("http"))
    return t;
  const e = RC(t);
  return Z1(e);
}
function Z1(t) {
  const e = new Blob([t], { type: "application/javascript" });
  return URL.createObjectURL(e);
}
function RC(t) {
  return `try {
  importScripts('${t}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}
function K1(t, e = !0, i) {
  const s = i || /* @__PURE__ */ new Set();
  if (t) {
    if (Ob(t))
      s.add(t);
    else if (Ob(t.buffer))
      s.add(t.buffer);
    else if (!ArrayBuffer.isView(t)) {
      if (e && typeof t == "object")
        for (const o in t)
          K1(t[o], e, s);
    }
  }
  return i === void 0 ? Array.from(s) : [];
}
function Ob(t) {
  return t ? t instanceof ArrayBuffer || typeof MessagePort < "u" && t instanceof MessagePort || typeof ImageBitmap < "u" && t instanceof ImageBitmap || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas : !1;
}
const j_ = () => {
};
class $m {
  constructor(e) {
    O(this, "name");
    O(this, "source");
    O(this, "url");
    O(this, "terminated", !1);
    O(this, "worker");
    O(this, "onMessage");
    O(this, "onError");
    O(this, "_loadableURL", "");
    const { name: i, source: s, url: o } = e;
    wo(s || o), this.name = i, this.source = s, this.url = o, this.onMessage = j_, this.onError = (l) => console.log(l), this.worker = rn ? this._createBrowserWorker() : this._createNodeWorker();
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return typeof Worker < "u" && rn || typeof V_ < "u" && !rn;
  }
  /**
   * Terminate this worker thread
   * @note Can free up significant memory
   */
  destroy() {
    this.onMessage = j_, this.onError = j_, this.worker.terminate(), this.terminated = !0;
  }
  get isRunning() {
    return !!this.onMessage;
  }
  /**
   * Send a message to this worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   * @param transferList If not supplied, calculated automatically by traversing data
   */
  postMessage(e, i) {
    i = i || K1(e), this.worker.postMessage(e, i);
  }
  // PRIVATE
  /**
   * Generate a standard Error from an ErrorEvent
   * @param event
   */
  _getErrorFromErrorEvent(e) {
    let i = "Failed to load ";
    return i += `worker ${this.name} from ${this.url}. `, e.message && (i += `${e.message} in `), e.lineno && (i += `:${e.lineno}:${e.colno}`), new Error(i);
  }
  /**
   * Creates a worker thread on the browser
   */
  _createBrowserWorker() {
    this._loadableURL = CC({ source: this.source, url: this.url });
    const e = new Worker(this._loadableURL, { name: this.name });
    return e.onmessage = (i) => {
      i.data ? this.onMessage(i.data) : this.onError(new Error("No data received"));
    }, e.onerror = (i) => {
      this.onError(this._getErrorFromErrorEvent(i)), this.terminated = !0;
    }, e.onmessageerror = (i) => console.error(i), e;
  }
  /**
   * Creates a worker thread in node.js
   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
   */
  _createNodeWorker() {
    let e;
    if (this.url) {
      const s = this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`;
      e = new V_(s, { eval: !1 });
    } else if (this.source)
      e = new V_(this.source, { eval: !0 });
    else
      throw new Error("no worker");
    return e.on("message", (i) => {
      this.onMessage(i);
    }), e.on("error", (i) => {
      this.onError(i);
    }), e.on("exit", (i) => {
    }), e;
  }
}
class MC {
  /**
   * @param processor - worker function
   * @param maxConcurrency - max count of workers
   */
  constructor(e) {
    O(this, "name", "unnamed");
    O(this, "source");
    // | Function;
    O(this, "url");
    O(this, "maxConcurrency", 1);
    O(this, "maxMobileConcurrency", 1);
    O(this, "onDebug", () => {
    });
    O(this, "reuseWorkers", !0);
    O(this, "props", {});
    O(this, "jobQueue", []);
    O(this, "idleQueue", []);
    O(this, "count", 0);
    O(this, "isDestroyed", !1);
    this.source = e.source, this.url = e.url, this.setProps(e);
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return $m.isSupported();
  }
  /**
   * Terminates all workers in the pool
   * @note Can free up significant memory
   */
  destroy() {
    this.idleQueue.forEach((e) => e.destroy()), this.isDestroyed = !0;
  }
  setProps(e) {
    this.props = { ...this.props, ...e }, e.name !== void 0 && (this.name = e.name), e.maxConcurrency !== void 0 && (this.maxConcurrency = e.maxConcurrency), e.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = e.maxMobileConcurrency), e.reuseWorkers !== void 0 && (this.reuseWorkers = e.reuseWorkers), e.onDebug !== void 0 && (this.onDebug = e.onDebug);
  }
  async startJob(e, i = (o, l, u) => o.done(u), s = (o, l) => o.error(l)) {
    const o = new Promise((l) => (this.jobQueue.push({ name: e, onMessage: i, onError: s, onStart: l }), this));
    return this._startQueuedJob(), await o;
  }
  // PRIVATE
  /**
   * Starts first queued job if worker is available or can be created
   * Called when job is started and whenever a worker returns to the idleQueue
   */
  async _startQueuedJob() {
    if (!this.jobQueue.length)
      return;
    const e = this._getAvailableWorker();
    if (!e)
      return;
    const i = this.jobQueue.shift();
    if (i) {
      this.onDebug({
        message: "Starting job",
        name: i.name,
        workerThread: e,
        backlog: this.jobQueue.length
      });
      const s = new SC(i.name, e);
      e.onMessage = (o) => i.onMessage(s, o.type, o.payload), e.onError = (o) => i.onError(s, o), i.onStart(s);
      try {
        await s.result;
      } catch (o) {
        console.error(`Worker exception: ${o}`);
      } finally {
        this.returnWorkerToQueue(e);
      }
    }
  }
  /**
   * Returns a worker to the idle queue
   * Destroys the worker if
   *  - pool is destroyed
   *  - if this pool doesn't reuse workers
   *  - if maxConcurrency has been lowered
   * @param worker
   */
  returnWorkerToQueue(e) {
    // Workers on Node.js prevent the process from exiting.
    // Until we figure out how to close them before exit, we always destroy them
    !rn || // If the pool is destroyed, there is no reason to keep the worker around
    this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
    !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
    this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob();
  }
  /**
   * Returns idle worker or creates new worker if maxConcurrency has not been reached
   */
  _getAvailableWorker() {
    if (this.idleQueue.length > 0)
      return this.idleQueue.shift() || null;
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const e = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new $m({ name: e, source: this.source, url: this.url });
    }
    return null;
  }
  _getMaxConcurrency() {
    return EC ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
const PC = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: !0,
  onDebug: () => {
  }
}, ca = class ca {
  /** get global instance with WorkerFarm.getWorkerFarm() */
  constructor(e) {
    O(this, "props");
    O(this, "workerPools", /* @__PURE__ */ new Map());
    this.props = { ...PC }, this.setProps(e), this.workerPools = /* @__PURE__ */ new Map();
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return $m.isSupported();
  }
  /** Get the singleton instance of the global worker farm */
  static getWorkerFarm(e = {}) {
    return ca._workerFarm = ca._workerFarm || new ca({}), ca._workerFarm.setProps(e), ca._workerFarm;
  }
  /**
   * Terminate all workers in the farm
   * @note Can free up significant memory
   */
  destroy() {
    for (const e of this.workerPools.values())
      e.destroy();
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Set props used when initializing worker pools
   * @param props
   */
  setProps(e) {
    this.props = { ...this.props, ...e };
    for (const i of this.workerPools.values())
      i.setProps(this._getWorkerPoolProps());
  }
  /**
   * Returns a worker pool for the specified worker
   * @param options - only used first time for a specific worker name
   * @param options.name - the name of the worker - used to identify worker pool
   * @param options.url -
   * @param options.source -
   * @example
   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
   */
  getWorkerPool(e) {
    const { name: i, source: s, url: o } = e;
    let l = this.workerPools.get(i);
    return l || (l = new MC({
      name: i,
      source: s,
      url: o
    }), l.setProps(this._getWorkerPoolProps()), this.workerPools.set(i, l)), l;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
};
// singleton
O(ca, "_workerFarm");
let If = ca;
function BC(t, e = {}) {
  const i = e[t.id] || {}, s = rn ? `${t.id}-worker.js` : `${t.id}-worker-node.js`;
  let o = i.workerUrl;
  if (!o && t.id === "compression" && (o = e.workerUrl), e._workerType === "test" && (rn ? o = `modules/${t.module}/dist/${s}` : o = `modules/${t.module}/src/workers/${t.id}-worker-node.ts`), !o) {
    let l = t.version;
    l === "latest" && (l = AC);
    const u = l ? `@${l}` : "";
    o = `https://unpkg.com/@loaders.gl/${t.module}${u}/dist/${s}`;
  }
  return wo(o), o;
}
function DC(t, e = q1) {
  wo(t, "no worker provided");
  const i = t.version;
  return !(!e || !i);
}
const $_ = {};
async function sl(t, e = null, i = {}, s = null) {
  return e && (t = OC(t, e, i, s)), $_[t] = // eslint-disable-next-line @typescript-eslint/no-misused-promises
  $_[t] || FC(t), await $_[t];
}
function OC(t, e, i = {}, s = null) {
  if (!i.useLocalLibraries && t.startsWith("http"))
    return t;
  s = s || t;
  const o = i.modules || {};
  return o[s] ? o[s] : rn ? i.CDN ? (wo(i.CDN.startsWith("http")), `${i.CDN}/${e}@${q1}/dist/libs/${s}`) : $g ? `../src/libs/${s}` : `modules/${e}/src/libs/${s}` : `modules/${e}/dist/libs/${s}`;
}
async function FC(t) {
  if (t.endsWith("wasm"))
    return await NC(t);
  if (!rn)
    try {
      const { requireFromFile: i } = globalThis.loaders || {};
      return await (i == null ? void 0 : i(t));
    } catch (i) {
      return console.error(i), null;
    }
  if ($g)
    return importScripts(t);
  const e = await LC(t);
  return kC(e, t);
}
function kC(t, e) {
  if (!rn) {
    const { requireFromString: s } = globalThis.loaders || {};
    return s == null ? void 0 : s(t, e);
  }
  if ($g)
    return eval.call(globalThis, t), null;
  const i = document.createElement("script");
  i.id = e;
  try {
    i.appendChild(document.createTextNode(t));
  } catch {
    i.text = t;
  }
  return document.body.appendChild(i), null;
}
async function NC(t) {
  const { readFileAsArrayBuffer: e } = globalThis.loaders || {};
  return rn || !e || t.startsWith("http") ? await (await fetch(t)).arrayBuffer() : await e(t);
}
async function LC(t) {
  const { readFileAsText: e } = globalThis.loaders || {};
  return rn || !e || t.startsWith("http") ? await (await fetch(t)).text() : await e(t);
}
function UC(t, e) {
  return !If.isSupported() || !rn && !(e != null && e._nodeWorkers) ? !1 : t.worker && (e == null ? void 0 : e.worker);
}
async function zC(t, e, i, s, o) {
  const l = t.id, u = BC(t, i), x = If.getWorkerFarm(i).getWorkerPool({ name: l, url: u });
  i = JSON.parse(JSON.stringify(i)), s = JSON.parse(JSON.stringify(s || {}));
  const w = await x.startJob(
    "process-on-worker",
    // @ts-expect-error
    VC.bind(null, o)
    // eslint-disable-line @typescript-eslint/no-misused-promises
  );
  return w.postMessage("process", {
    // @ts-ignore
    input: e,
    options: i,
    context: s
  }), await (await w.result).result;
}
async function VC(t, e, i, s) {
  switch (i) {
    case "done":
      e.done(s);
      break;
    case "error":
      e.error(new Error(s.error));
      break;
    case "process":
      const { id: o, input: l, options: u } = s;
      try {
        const c = await t(l, u);
        e.postMessage("done", { id: o, result: c });
      } catch (c) {
        const x = c instanceof Error ? c.message : "unknown error";
        e.postMessage("error", { id: o, error: x });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${i}`);
  }
}
function HC(t, e = 5) {
  return typeof t == "string" ? t.slice(0, e) : ArrayBuffer.isView(t) ? Fb(t.buffer, t.byteOffset, e) : t instanceof ArrayBuffer ? Fb(t, 0, e) : "";
}
function Fb(t, e, i) {
  if (t.byteLength <= e + i)
    return "";
  const s = new DataView(t);
  let o = "";
  for (let l = 0; l < i; l++)
    o += String.fromCharCode(s.getUint8(e + l));
  return o;
}
function jC(t) {
  try {
    return JSON.parse(t);
  } catch {
    throw new Error(`Failed to parse JSON from data starting with "${HC(t)}"`);
  }
}
function $C(t, e, i) {
  if (i = i || t.byteLength, t.byteLength < i || e.byteLength < i)
    return !1;
  const s = new Uint8Array(t), o = new Uint8Array(e);
  for (let l = 0; l < s.length; ++l)
    if (s[l] !== o[l])
      return !1;
  return !0;
}
function GC(...t) {
  return XC(t);
}
function XC(t) {
  const e = t.map((l) => l instanceof ArrayBuffer ? new Uint8Array(l) : l), i = e.reduce((l, u) => l + u.byteLength, 0), s = new Uint8Array(i);
  let o = 0;
  for (const l of e)
    s.set(l, o), o += l.byteLength;
  return s.buffer;
}
function Gg(t, e, i) {
  const s = i !== void 0 ? new Uint8Array(t).subarray(e, e + i) : new Uint8Array(t).subarray(e);
  return new Uint8Array(s).buffer;
}
function Du(t, e) {
  return Ai(t >= 0), Ai(e > 0), t + (e - 1) & ~(e - 1);
}
function WC(t, e, i) {
  let s;
  if (t instanceof ArrayBuffer)
    s = new Uint8Array(t);
  else {
    const o = t.byteOffset, l = t.byteLength;
    s = new Uint8Array(t.buffer || t.arrayBuffer, o, l);
  }
  return e.set(s, i), i + Du(s.byteLength, 4);
}
async function qC(t) {
  const e = [];
  for await (const i of t)
    e.push(i);
  return GC(...e);
}
function kb() {
  let t;
  if (typeof window < "u" && window.performance)
    t = window.performance.now();
  else if (typeof process < "u" && process.hrtime) {
    const e = process.hrtime();
    t = e[0] * 1e3 + e[1] / 1e6;
  } else
    t = Date.now();
  return t;
}
class Nb {
  constructor(e, i) {
    this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = e, this.type = i, this.reset();
  }
  reset() {
    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;
  }
  setSampleSize(e) {
    return this.sampleSize = e, this;
  }
  /** Call to increment count (+1) */
  incrementCount() {
    return this.addCount(1), this;
  }
  /** Call to decrement count (-1) */
  decrementCount() {
    return this.subtractCount(1), this;
  }
  /** Increase count */
  addCount(e) {
    return this._count += e, this._samples++, this._checkSampling(), this;
  }
  /** Decrease count */
  subtractCount(e) {
    return this._count -= e, this._samples++, this._checkSampling(), this;
  }
  /** Add an arbitrary timing and bump the count */
  addTime(e) {
    return this._time += e, this.lastTiming = e, this._samples++, this._checkSampling(), this;
  }
  /** Start a timer */
  timeStart() {
    return this._startTime = kb(), this._timerPending = !0, this;
  }
  /** End a timer. Adds to time and bumps the timing count. */
  timeEnd() {
    return this._timerPending ? (this.addTime(kb() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  /** Calculate average time / count for the previous window */
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  /** Calculate counts per second for the previous window */
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  /** Calculate average time / count */
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  /** Calculate counts per second */
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  _checkSampling() {
    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);
  }
}
class jc {
  constructor(e) {
    this.stats = {}, this.id = e.id, this.stats = {}, this._initializeStats(e.stats), Object.seal(this);
  }
  /** Acquire a stat. Create if it doesn't exist. */
  get(e, i = "count") {
    return this._getOrCreate({ name: e, type: i });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  /** Reset all stats */
  reset() {
    for (const e of Object.values(this.stats))
      e.reset();
    return this;
  }
  forEach(e) {
    for (const i of Object.values(this.stats))
      e(i);
  }
  getTable() {
    const e = {};
    return this.forEach((i) => {
      e[i.name] = {
        time: i.time || 0,
        count: i.count || 0,
        average: i.getAverageTime() || 0,
        hz: i.getHz() || 0
      };
    }), e;
  }
  _initializeStats(e = []) {
    e.forEach((i) => this._getOrCreate(i));
  }
  _getOrCreate(e) {
    const { name: i, type: s } = e;
    let o = this.stats[i];
    return o || (e instanceof Nb ? o = e : o = new Nb(i, s), this.stats[i] = o), o;
  }
}
const ZC = "Queued Requests", KC = "Active Requests", JC = "Cancelled Requests", YC = "Queued Requests Ever", QC = "Active Requests Ever", e2 = {
  id: "request-scheduler",
  /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */
  throttleRequests: !0,
  /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */
  maxRequests: 6,
  /**
   * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have
   * been added to the queue for this amount of time.
   */
  debounceTime: 0
};
class t2 {
  constructor(e = {}) {
    O(this, "props");
    O(this, "stats");
    O(this, "activeRequestCount", 0);
    /** Tracks the number of active requests and prioritizes/cancels queued requests. */
    O(this, "requestQueue", []);
    O(this, "requestMap", /* @__PURE__ */ new Map());
    O(this, "updateTimer", null);
    this.props = { ...e2, ...e }, this.stats = new jc({ id: this.props.id }), this.stats.get(ZC), this.stats.get(KC), this.stats.get(JC), this.stats.get(YC), this.stats.get(QC);
  }
  /**
   * Called by an application that wants to issue a request, without having it deeply queued by the browser
   *
   * When the returned promise resolved, it is OK for the application to issue a request.
   * The promise resolves to an object that contains a `done` method.
   * When the application's request has completed (or failed), the application must call the `done` function
   *
   * @param handle
   * @param getPriority will be called when request "slots" open up,
   *    allowing the caller to update priority or cancel the request
   *    Highest priority executes first, priority < 0 cancels the request
   * @returns a promise
   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,
   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).
   *     In this case the application should not issue the request
   */
  scheduleRequest(e, i = () => 0) {
    if (!this.props.throttleRequests)
      return Promise.resolve({ done: () => {
      } });
    if (this.requestMap.has(e))
      return this.requestMap.get(e);
    const s = { handle: e, priority: 0, getPriority: i }, o = new Promise((l) => (s.resolve = l, s));
    return this.requestQueue.push(s), this.requestMap.set(e, o), this._issueNewRequests(), o;
  }
  // PRIVATE
  _issueRequest(e) {
    const { handle: i, resolve: s } = e;
    let o = !1;
    const l = () => {
      o || (o = !0, this.requestMap.delete(i), this.activeRequestCount--, this._issueNewRequests());
    };
    return this.activeRequestCount++, s ? s({ done: l }) : Promise.resolve({ done: l });
  }
  /** We check requests asynchronously, to prevent multiple updates */
  _issueNewRequests() {
    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);
  }
  /** Refresh all requests  */
  _issueNewRequestsAsync() {
    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = null;
    const e = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (e !== 0) {
      this._updateAllRequests();
      for (let i = 0; i < e; ++i) {
        const s = this.requestQueue.shift();
        s && this._issueRequest(s);
      }
    }
  }
  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */
  _updateAllRequests() {
    const e = this.requestQueue;
    for (let i = 0; i < e.length; ++i) {
      const s = e[i];
      this._updateRequest(s) || (e.splice(i, 1), this.requestMap.delete(s.handle), i--);
    }
    e.sort((i, s) => i.priority - s.priority);
  }
  /** Update a single request by calling the callback */
  _updateRequest(e) {
    return e.priority = e.getPriority(e.handle), e.priority < 0 ? (e.resolve(null), !1) : !0;
  }
}
let i2 = "";
const Lb = {};
function s2(t) {
  for (const e in Lb)
    if (t.startsWith(e)) {
      const i = Lb[e];
      t = t.replace(e, i);
    }
  return !t.startsWith("http://") && !t.startsWith("https://") && (t = `${i2}${t}`), t;
}
function r2(t) {
  return t && typeof t == "object" && t.isBuffer;
}
function J1(t) {
  if (r2(t))
    return t;
  if (t instanceof ArrayBuffer)
    return t;
  if (ArrayBuffer.isView(t))
    return t.byteOffset === 0 && t.byteLength === t.buffer.byteLength ? t.buffer : t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
  if (typeof t == "string") {
    const e = t;
    return new TextEncoder().encode(e).buffer;
  }
  if (t && typeof t == "object" && t._toArrayBuffer)
    return t._toArrayBuffer();
  throw new Error("toArrayBuffer");
}
function n2() {
  var e;
  if (typeof process < "u" && typeof process.cwd < "u")
    return process.cwd();
  const t = (e = window.location) == null ? void 0 : e.pathname;
  return (t == null ? void 0 : t.slice(0, t.lastIndexOf("/") + 1)) || "";
}
function Y1(t) {
  const e = t ? t.lastIndexOf("/") : -1;
  return e >= 0 ? t.substr(e + 1) : "";
}
function Xg(t) {
  const e = t ? t.lastIndexOf("/") : -1;
  return e >= 0 ? t.substr(0, e) : "";
}
function o2(...t) {
  const e = [];
  for (let l = 0; l < t.length; l++)
    e[l] = t[l];
  let i = "", s = !1, o;
  for (let l = e.length - 1; l >= -1 && !s; l--) {
    let u;
    l >= 0 ? u = e[l] : (o === void 0 && (o = n2()), u = o), u.length !== 0 && (i = `${u}/${i}`, s = u.charCodeAt(0) === nu);
  }
  return i = a2(i, !s), s ? `/${i}` : i.length > 0 ? i : ".";
}
const nu = 47, G_ = 46;
function a2(t, e) {
  let i = "", s = -1, o = 0, l, u = !1;
  for (let c = 0; c <= t.length; ++c) {
    if (c < t.length)
      l = t.charCodeAt(c);
    else {
      if (l === nu)
        break;
      l = nu;
    }
    if (l === nu) {
      if (!(s === c - 1 || o === 1)) if (s !== c - 1 && o === 2) {
        if (i.length < 2 || !u || i.charCodeAt(i.length - 1) !== G_ || i.charCodeAt(i.length - 2) !== G_) {
          if (i.length > 2) {
            const x = i.length - 1;
            let w = x;
            for (; w >= 0 && i.charCodeAt(w) !== nu; --w)
              ;
            if (w !== x) {
              i = w === -1 ? "" : i.slice(0, w), s = c, o = 0, u = !1;
              continue;
            }
          } else if (i.length === 2 || i.length === 1) {
            i = "", s = c, o = 0, u = !1;
            continue;
          }
        }
        e && (i.length > 0 ? i += "/.." : i = "..", u = !0);
      } else {
        const x = t.slice(s + 1, c);
        i.length > 0 ? i += `/${x}` : i = x, u = !1;
      }
      s = c, o = 0;
    } else l === G_ && o !== -1 ? ++o : o = -1;
  }
  return i;
}
const l2 = (t) => typeof t == "boolean", uu = (t) => typeof t == "function", Ou = (t) => t !== null && typeof t == "object", Ub = (t) => Ou(t) && t.constructor === {}.constructor, c2 = (t) => !!t && typeof t[Symbol.iterator] == "function", h2 = (t) => t && typeof t[Symbol.asyncIterator] == "function", hl = (t) => typeof Response < "u" && t instanceof Response || t && t.arrayBuffer && t.text && t.json, ul = (t) => typeof Blob < "u" && t instanceof Blob, u2 = (t) => t && typeof t == "object" && t.isBuffer, d2 = (t) => typeof ReadableStream < "u" && t instanceof ReadableStream || Ou(t) && uu(t.tee) && uu(t.cancel) && uu(t.getReader), f2 = (t) => Ou(t) && uu(t.read) && uu(t.pipe) && l2(t.readable), Q1 = (t) => d2(t) || f2(t);
class p2 extends Error {
  constructor(i, s) {
    super(i);
    /** A best effort reason for why the fetch failed */
    O(this, "reason");
    /** The URL that failed to load. Empty string if not available. */
    O(this, "url");
    /** The Response object, if any. */
    O(this, "response");
    this.reason = s.reason, this.url = s.url, this.response = s.response;
  }
}
const _2 = /^data:([-\w.]+\/[-\w.+]+)(;|,)/, m2 = /^([-\w.]+\/[-\w.+]+)/;
function zb(t, e) {
  return t.toLowerCase() === e.toLowerCase();
}
function g2(t) {
  const e = m2.exec(t);
  return e ? e[1] : t;
}
function Vb(t) {
  const e = _2.exec(t);
  return e ? e[1] : "";
}
const ew = /\?.*/;
function y2(t) {
  const e = t.match(ew);
  return e && e[0];
}
function Wg(t) {
  return t.replace(ew, "");
}
function b2(t) {
  if (t.length < 50)
    return t;
  const e = t.slice(t.length - 15);
  return `${t.substr(0, 32)}...${e}`;
}
function pp(t) {
  return hl(t) ? t.url : ul(t) ? t.name || "" : typeof t == "string" ? t : "";
}
function qg(t) {
  if (hl(t)) {
    const e = t, i = e.headers.get("content-type") || "", s = Wg(e.url);
    return g2(i) || Vb(s);
  }
  return ul(t) ? t.type || "" : typeof t == "string" ? Vb(t) : "";
}
function v2(t) {
  return hl(t) ? t.headers["content-length"] || -1 : ul(t) ? t.size : typeof t == "string" ? t.length : t instanceof ArrayBuffer || ArrayBuffer.isView(t) ? t.byteLength : -1;
}
async function tw(t) {
  if (hl(t))
    return t;
  const e = {}, i = v2(t);
  i >= 0 && (e["content-length"] = String(i));
  const s = pp(t), o = qg(t);
  o && (e["content-type"] = o);
  const l = await A2(t);
  l && (e["x-first-bytes"] = l), typeof t == "string" && (t = new TextEncoder().encode(t));
  const u = new Response(t, { headers: e });
  return Object.defineProperty(u, "url", { value: s }), u;
}
async function x2(t) {
  if (!t.ok)
    throw await w2(t);
}
async function w2(t) {
  const e = b2(t.url);
  let i = `Failed to fetch resource (${t.status}) ${t.statusText}: ${e}`;
  i = i.length > 100 ? `${i.slice(0, 100)}...` : i;
  const s = {
    reason: t.statusText,
    url: t.url,
    response: t
  };
  try {
    const o = t.headers.get("Content-Type");
    s.reason = !t.bodyUsed && (o != null && o.includes("application/json")) ? await t.json() : await t.text();
  } catch {
  }
  return new p2(i, s);
}
async function A2(t) {
  if (typeof t == "string")
    return `data:,${t.slice(0, 5)}`;
  if (t instanceof Blob) {
    const i = t.slice(0, 5);
    return await new Promise((s) => {
      const o = new FileReader();
      o.onload = (l) => {
        var u;
        return s((u = l == null ? void 0 : l.target) == null ? void 0 : u.result);
      }, o.readAsDataURL(i);
    });
  }
  if (t instanceof ArrayBuffer) {
    const i = t.slice(0, 5);
    return `data:base64,${T2(i)}`;
  }
  return null;
}
function T2(t) {
  let e = "";
  const i = new Uint8Array(t);
  for (let s = 0; s < i.byteLength; s++)
    e += String.fromCharCode(i[s]);
  return btoa(e);
}
function E2(t) {
  return !S2(t) && !C2(t);
}
function S2(t) {
  return t.startsWith("http:") || t.startsWith("https:");
}
function C2(t) {
  return t.startsWith("data:");
}
async function Hb(t, e) {
  var i, s;
  if (typeof t == "string") {
    const o = s2(t);
    return E2(o) && (i = globalThis.loaders) != null && i.fetchNode ? (s = globalThis.loaders) == null ? void 0 : s.fetchNode(o, e) : await fetch(o, e);
  }
  return await tw(t);
}
const jb = new Hc({ id: "loaders.gl" });
class I2 {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
}
class R2 {
  constructor() {
    O(this, "console");
    this.console = console;
  }
  log(...e) {
    return this.console.log.bind(this.console, ...e);
  }
  info(...e) {
    return this.console.info.bind(this.console, ...e);
  }
  warn(...e) {
    return this.console.warn.bind(this.console, ...e);
  }
  error(...e) {
    return this.console.error.bind(this.console, ...e);
  }
}
const iw = {
  // baseUri
  fetch: null,
  mimeType: void 0,
  nothrow: !1,
  log: new R2(),
  // A probe.gl compatible (`log.log()()` syntax) that just logs to console
  useLocalLibraries: !1,
  CDN: "https://unpkg.com/@loaders.gl",
  worker: !0,
  // By default, use worker if provided by loader.
  maxConcurrency: 3,
  // How many worker instances should be created for each loader.
  maxMobileConcurrency: 1,
  // How many worker instances should be created for each loader on mobile devices.
  reuseWorkers: fp,
  // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)
  _nodeWorkers: !1,
  // By default do not support node workers
  _workerType: "",
  // 'test' to use locally generated workers
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: !1,
  // TODO - currently only implemented for parseInBatches, adds initial metadata batch,
  transforms: []
}, M2 = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  // Warn if fetch options are used on top-level
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};
function sw() {
  globalThis.loaders = globalThis.loaders || {};
  const { loaders: t } = globalThis;
  return t._state || (t._state = {}), t._state;
}
function rw() {
  const t = sw();
  return t.globalOptions = t.globalOptions || { ...iw }, t.globalOptions;
}
function P2(t, e, i, s) {
  return i = i || [], i = Array.isArray(i) ? i : [i], B2(t, i), O2(e, t, s);
}
function B2(t, e) {
  $b(t, null, iw, M2, e);
  for (const i of e) {
    const s = t && t[i.id] || {}, o = i.options && i.options[i.id] || {}, l = i.deprecatedOptions && i.deprecatedOptions[i.id] || {};
    $b(s, i.id, o, l, e);
  }
}
function $b(t, e, i, s, o) {
  const l = e || "Top level", u = e ? `${e}.` : "";
  for (const c in t) {
    const x = !e && Ou(t[c]), w = c === "baseUri" && !e, C = c === "workerUrl" && e;
    if (!(c in i) && !w && !C) {
      if (c in s)
        jb.warn(`${l} loader option '${u}${c}' no longer supported, use '${s[c]}'`)();
      else if (!x) {
        const M = D2(c, o);
        jb.warn(`${l} loader option '${u}${c}' not recognized. ${M}`)();
      }
    }
  }
}
function D2(t, e) {
  const i = t.toLowerCase();
  let s = "";
  for (const o of e)
    for (const l in o.options) {
      if (t === l)
        return `Did you mean '${o.id}.${l}'?`;
      const u = l.toLowerCase();
      (i.startsWith(u) || u.startsWith(i)) && (s = s || `Did you mean '${o.id}.${l}'?`);
    }
  return s;
}
function O2(t, e, i) {
  const o = { ...t.options || {} };
  return F2(o, i), o.log === null && (o.log = new I2()), Gb(o, rw()), Gb(o, e), o;
}
function Gb(t, e) {
  for (const i in e)
    if (i in e) {
      const s = e[i];
      Ub(s) && Ub(t[i]) ? t[i] = {
        ...t[i],
        ...e[i]
      } : t[i] = e[i];
    }
}
function F2(t, e) {
  e && !("baseUri" in t) && (t.baseUri = e);
}
function Zg(t) {
  return t ? (Array.isArray(t) && (t = t[0]), Array.isArray(t == null ? void 0 : t.extensions)) : !1;
}
function Kg(t) {
  Ai(t, "null loader"), Ai(Zg(t), "invalid loader");
  let e;
  return Array.isArray(t) && (e = t[1], t = t[0], t = {
    ...t,
    options: { ...t.options, ...e }
  }), (t != null && t.parseTextSync || t != null && t.parseText) && (t.text = !0), t.text || (t.binary = !0), t;
}
const nw = () => {
  const t = sw();
  return t.loaderRegistry = t.loaderRegistry || [], t.loaderRegistry;
};
function k2(t) {
  const e = nw();
  t = Array.isArray(t) ? t : [t];
  for (const i of t) {
    const s = Kg(i);
    e.find((o) => s === o) || e.unshift(s);
  }
}
function N2() {
  return nw();
}
const L2 = /\.([^.]+)$/;
async function U2(t, e = [], i, s) {
  if (!ow(t))
    return null;
  let o = Xb(t, e, { ...i, nothrow: !0 }, s);
  if (o)
    return o;
  if (ul(t) && (t = await t.slice(0, 10).arrayBuffer(), o = Xb(t, e, i, s)), !o && !(i != null && i.nothrow))
    throw new Error(aw(t));
  return o;
}
function Xb(t, e = [], i, s) {
  if (!ow(t))
    return null;
  if (e && !Array.isArray(e))
    return Kg(e);
  let o = [];
  e && (o = o.concat(e)), i != null && i.ignoreRegisteredLoaders || o.push(...N2()), V2(o);
  const l = z2(t, o, i, s);
  if (!l && !(i != null && i.nothrow))
    throw new Error(aw(t));
  return l;
}
function z2(t, e, i, s) {
  const o = pp(t), l = qg(t), u = Wg(o) || (s == null ? void 0 : s.url);
  let c = null, x = "";
  return i != null && i.mimeType && (c = X_(e, i == null ? void 0 : i.mimeType), x = `match forced by supplied MIME type ${i == null ? void 0 : i.mimeType}`), c = c || H2(e, u), x = x || (c ? `matched url ${u}` : ""), c = c || X_(e, l), x = x || (c ? `matched MIME type ${l}` : ""), c = c || $2(e, t), x = x || (c ? `matched initial data ${lw(t)}` : ""), i != null && i.fallbackMimeType && (c = c || X_(e, i == null ? void 0 : i.fallbackMimeType), x = x || (c ? `matched fallback MIME type ${l}` : "")), x && bC.log(1, `selectLoader selected ${c == null ? void 0 : c.name}: ${x}.`), c;
}
function ow(t) {
  return !(t instanceof Response && t.status === 204);
}
function aw(t) {
  const e = pp(t), i = qg(t);
  let s = "No valid loader found (";
  s += e ? `${Y1(e)}, ` : "no url provided, ", s += `MIME type: ${i ? `"${i}"` : "not provided"}, `;
  const o = t ? lw(t) : "";
  return s += o ? ` first bytes: "${o}"` : "first bytes: not available", s += ")", s;
}
function V2(t) {
  for (const e of t)
    Kg(e);
}
function H2(t, e) {
  const i = e && L2.exec(e), s = i && i[1];
  return s ? j2(t, s) : null;
}
function j2(t, e) {
  e = e.toLowerCase();
  for (const i of t)
    for (const s of i.extensions)
      if (s.toLowerCase() === e)
        return i;
  return null;
}
function X_(t, e) {
  var i;
  for (const s of t)
    if ((i = s.mimeTypes) != null && i.some((o) => zb(e, o)) || zb(e, `application/x.${s.id}`))
      return s;
  return null;
}
function $2(t, e) {
  if (!e)
    return null;
  for (const i of t)
    if (typeof e == "string") {
      if (G2(e, i))
        return i;
    } else if (ArrayBuffer.isView(e)) {
      if (Wb(e.buffer, e.byteOffset, i))
        return i;
    } else if (e instanceof ArrayBuffer && Wb(e, 0, i))
      return i;
  return null;
}
function G2(t, e) {
  return e.testText ? e.testText(t) : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((s) => t.startsWith(s));
}
function Wb(t, e, i) {
  return (Array.isArray(i.tests) ? i.tests : [i.tests]).some((o) => X2(t, e, i, o));
}
function X2(t, e, i, s) {
  if (s instanceof ArrayBuffer)
    return $C(s, t, s.byteLength);
  switch (typeof s) {
    case "function":
      return s(t);
    case "string":
      const o = Gm(t, e, s.length);
      return s === o;
    default:
      return !1;
  }
}
function lw(t, e = 5) {
  return typeof t == "string" ? t.slice(0, e) : ArrayBuffer.isView(t) ? Gm(t.buffer, t.byteOffset, e) : t instanceof ArrayBuffer ? Gm(t, 0, e) : "";
}
function Gm(t, e, i) {
  if (t.byteLength < e + i)
    return "";
  const s = new DataView(t);
  let o = "";
  for (let l = 0; l < i; l++)
    o += String.fromCharCode(s.getUint8(e + l));
  return o;
}
const W2 = 256 * 1024;
function* q2(t, e) {
  const i = (e == null ? void 0 : e.chunkSize) || W2;
  let s = 0;
  const o = new TextEncoder();
  for (; s < t.length; ) {
    const l = Math.min(t.length - s, i), u = t.slice(s, s + l);
    s += l, yield o.encode(u);
  }
}
const Z2 = 256 * 1024;
function* K2(t, e = {}) {
  const { chunkSize: i = Z2 } = e;
  let s = 0;
  for (; s < t.byteLength; ) {
    const o = Math.min(t.byteLength - s, i), l = new ArrayBuffer(o), u = new Uint8Array(t, s, o);
    new Uint8Array(l).set(u), s += o, yield l;
  }
}
const J2 = 1024 * 1024;
async function* Y2(t, e) {
  const i = (e == null ? void 0 : e.chunkSize) || J2;
  let s = 0;
  for (; s < t.size; ) {
    const o = s + i, l = await t.slice(s, o).arrayBuffer();
    s = o, yield l;
  }
}
function qb(t, e) {
  return fp ? Q2(t, e) : eI(t);
}
async function* Q2(t, e) {
  const i = t.getReader();
  let s;
  try {
    for (; ; ) {
      const o = s || i.read();
      e != null && e._streamReadAhead && (s = i.read());
      const { done: l, value: u } = await o;
      if (l)
        return;
      yield J1(u);
    }
  } catch {
    i.releaseLock();
  }
}
async function* eI(t, e) {
  for await (const i of t)
    yield J1(i);
}
function tI(t, e) {
  if (typeof t == "string")
    return q2(t, e);
  if (t instanceof ArrayBuffer)
    return K2(t, e);
  if (ul(t))
    return Y2(t, e);
  if (Q1(t))
    return qb(t, e);
  if (hl(t))
    return qb(t.body, e);
  throw new Error("makeIterator");
}
const cw = "Cannot convert supplied data type";
function iI(t, e, i) {
  if (e.text && typeof t == "string")
    return t;
  if (u2(t) && (t = t.buffer), t instanceof ArrayBuffer) {
    const s = t;
    return e.text && !e.binary ? new TextDecoder("utf8").decode(s) : s;
  }
  if (ArrayBuffer.isView(t)) {
    if (e.text && !e.binary)
      return new TextDecoder("utf8").decode(t);
    let s = t.buffer;
    const o = t.byteLength || t.length;
    return (t.byteOffset !== 0 || o !== s.byteLength) && (s = s.slice(t.byteOffset, t.byteOffset + o)), s;
  }
  throw new Error(cw);
}
async function sI(t, e, i) {
  const s = t instanceof ArrayBuffer || ArrayBuffer.isView(t);
  if (typeof t == "string" || s)
    return iI(t, e);
  if (ul(t) && (t = await tw(t)), hl(t)) {
    const o = t;
    return await x2(o), e.binary ? await o.arrayBuffer() : await o.text();
  }
  if (Q1(t) && (t = tI(t, i)), c2(t) || h2(t))
    return qC(t);
  throw new Error(cw);
}
function hw(t, e) {
  const i = rw(), s = t || i;
  return typeof s.fetch == "function" ? s.fetch : Ou(s.fetch) ? (o) => Hb(o, s.fetch) : e != null && e.fetch ? e == null ? void 0 : e.fetch : Hb;
}
function rI(t, e, i) {
  if (i)
    return i;
  const s = {
    fetch: hw(e, t),
    ...t
  };
  if (s.url) {
    const o = Wg(s.url);
    s.baseUrl = o, s.queryString = y2(s.url), s.filename = Y1(o), s.baseUrl = Xg(o);
  }
  return Array.isArray(s.loaders) || (s.loaders = null), s;
}
function nI(t, e) {
  if (t && !Array.isArray(t))
    return t;
  let i;
  if (t && (i = Array.isArray(t) ? t : [t]), e && e.loaders) {
    const s = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
    i = i ? [...i, ...s] : s;
  }
  return i && i.length ? i : void 0;
}
async function Rf(t, e, i, s) {
  e && !Array.isArray(e) && !Zg(e) && (s = void 0, i = e, e = void 0), t = await t, i = i || {};
  const o = pp(t), u = nI(e, s), c = await U2(t, u, i);
  return c ? (i = P2(i, c, u, o), s = rI(
    // @ts-expect-error
    { url: o, _parse: Rf, loaders: u },
    i,
    s || null
  ), await oI(c, t, i, s)) : null;
}
async function oI(t, e, i, s) {
  if (DC(t), i = vC(t.options, i), hl(e)) {
    const l = e, { ok: u, redirected: c, status: x, statusText: w, type: C, url: M } = l, P = Object.fromEntries(l.headers.entries());
    s.response = { headers: P, ok: u, redirected: c, status: x, statusText: w, type: C, url: M };
  }
  e = await sI(e, t, i);
  const o = t;
  if (o.parseTextSync && typeof e == "string")
    return o.parseTextSync(e, i, s);
  if (UC(t, i))
    return await zC(t, e, i, s, Rf);
  if (o.parseText && typeof e == "string")
    return await o.parseText(e, i, s);
  if (o.parse)
    return await o.parse(e, i, s);
  throw wo(!o.parseSync), new Error(`${t.id} loader - no parser found and worker is disabled`);
}
function aI(t) {
  switch (t.constructor) {
    case Int8Array:
      return "int8";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int16Array:
      return "int16";
    case Uint16Array:
      return "uint16";
    case Int32Array:
      return "int32";
    case Uint32Array:
      return "uint32";
    case Float32Array:
      return "float32";
    case Float64Array:
      return "float64";
    default:
      return "null";
  }
}
function uw(t) {
  let e = 1 / 0, i = 1 / 0, s = 1 / 0, o = -1 / 0, l = -1 / 0, u = -1 / 0;
  const c = t.POSITION ? t.POSITION.value : [], x = c && c.length;
  for (let w = 0; w < x; w += 3) {
    const C = c[w], M = c[w + 1], P = c[w + 2];
    e = C < e ? C : e, i = M < i ? M : i, s = P < s ? P : s, o = C > o ? C : o, l = M > l ? M : l, u = P > u ? P : u;
  }
  return [
    [e, i, s],
    [o, l, u]
  ];
}
function lI(t, e, i) {
  const s = aI(e.value), o = i || cI(e);
  return {
    name: t,
    type: { type: "fixed-size-list", listSize: e.size, children: [{ name: "value", type: s }] },
    nullable: !1,
    metadata: o
  };
}
function cI(t) {
  const e = {};
  return "byteOffset" in t && (e.byteOffset = t.byteOffset.toString(10)), "byteStride" in t && (e.byteStride = t.byteStride.toString(10)), "normalized" in t && (e.normalized = t.normalized.toString()), e;
}
async function pa(t, e, i, s) {
  let o, l;
  !Array.isArray(e) && !Zg(e) ? (o = [], l = e) : (o = e, l = i);
  const u = hw(l);
  let c = t;
  return typeof t == "string" && (c = await u(t)), ul(t) && (c = await u(t)), Array.isArray(o) ? await Rf(c, o, l) : await Rf(c, o, l);
}
const hI = "4.3.1";
var L1;
const uI = (L1 = globalThis.loaders) == null ? void 0 : L1.parseImageNode, Xm = typeof Image < "u", Wm = typeof ImageBitmap < "u", dI = !!uI, qm = fp ? !0 : dI;
function fI(t) {
  switch (t) {
    case "auto":
      return Wm || Xm || qm;
    case "imagebitmap":
      return Wm;
    case "image":
      return Xm;
    case "data":
      return qm;
    default:
      throw new Error(`@loaders.gl/images: image ${t} not supported in this environment`);
  }
}
function pI() {
  if (Wm)
    return "imagebitmap";
  if (Xm)
    return "image";
  if (qm)
    return "data";
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
function _I(t) {
  const e = mI(t);
  if (!e)
    throw new Error("Not an image");
  return e;
}
function dw(t) {
  switch (_I(t)) {
    case "data":
      return t;
    case "image":
    case "imagebitmap":
      const e = document.createElement("canvas"), i = e.getContext("2d");
      if (!i)
        throw new Error("getImageData");
      return e.width = t.width, e.height = t.height, i.drawImage(t, 0, 0), i.getImageData(0, 0, t.width, t.height);
    default:
      throw new Error("getImageData");
  }
}
function mI(t) {
  return typeof ImageBitmap < "u" && t instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && t instanceof Image ? "image" : t && typeof t == "object" && t.data && t.width && t.height ? "data" : null;
}
const gI = /^data:image\/svg\+xml/, yI = /\.svg((\?|#).*)?$/;
function Jg(t) {
  return t && (gI.test(t) || yI.test(t));
}
function bI(t, e) {
  if (Jg(e)) {
    let s = new TextDecoder().decode(t);
    try {
      typeof unescape == "function" && typeof encodeURIComponent == "function" && (s = unescape(encodeURIComponent(s)));
    } catch (l) {
      throw new Error(l.message);
    }
    return `data:image/svg+xml;base64,${btoa(s)}`;
  }
  return fw(t, e);
}
function fw(t, e) {
  if (Jg(e))
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  return new Blob([new Uint8Array(t)]);
}
async function pw(t, e, i) {
  const s = bI(t, i), o = self.URL || self.webkitURL, l = typeof s != "string" && o.createObjectURL(s);
  try {
    return await vI(l || s, e);
  } finally {
    l && o.revokeObjectURL(l);
  }
}
async function vI(t, e) {
  const i = new Image();
  return i.src = t, e.image && e.image.decode && i.decode ? (await i.decode(), i) : await new Promise((s, o) => {
    try {
      i.onload = () => s(i), i.onerror = (l) => {
        const u = l instanceof Error ? l.message : "error";
        o(new Error(u));
      };
    } catch (l) {
      o(l);
    }
  });
}
const xI = {};
let Zb = !0;
async function wI(t, e, i) {
  let s;
  Jg(i) ? s = await pw(t, e, i) : s = fw(t, i);
  const o = e && e.imagebitmap;
  return await AI(s, o);
}
async function AI(t, e = null) {
  if ((TI(e) || !Zb) && (e = null), e)
    try {
      return await createImageBitmap(t, e);
    } catch (i) {
      console.warn(i), Zb = !1;
    }
  return await createImageBitmap(t);
}
function TI(t) {
  for (const e in t || xI)
    return !1;
  return !0;
}
function EI(t) {
  return !RI(t, "ftyp", 4) || !(t[8] & 96) ? null : SI(t);
}
function SI(t) {
  switch (CI(t, 8, 12).replace("\0", " ").trim()) {
    case "avif":
    case "avis":
      return { extension: "avif", mimeType: "image/avif" };
    default:
      return null;
  }
}
function CI(t, e, i) {
  return String.fromCharCode(...t.slice(e, i));
}
function II(t) {
  return [...t].map((e) => e.charCodeAt(0));
}
function RI(t, e, i = 0) {
  const s = II(e);
  for (let o = 0; o < s.length; ++o)
    if (s[o] !== t[o + i])
      return !1;
  return !0;
}
const Gn = !1, du = !0;
function Yg(t) {
  const e = Fu(t);
  return PI(e) || OI(e) || BI(e) || DI(e) || MI(e);
}
function MI(t) {
  const e = new Uint8Array(t instanceof DataView ? t.buffer : t), i = EI(e);
  return i ? {
    mimeType: i.mimeType,
    // TODO - decode width and height
    width: 0,
    height: 0
  } : null;
}
function PI(t) {
  const e = Fu(t);
  return e.byteLength >= 24 && e.getUint32(0, Gn) === 2303741511 ? {
    mimeType: "image/png",
    width: e.getUint32(16, Gn),
    height: e.getUint32(20, Gn)
  } : null;
}
function BI(t) {
  const e = Fu(t);
  return e.byteLength >= 10 && e.getUint32(0, Gn) === 1195984440 ? {
    mimeType: "image/gif",
    width: e.getUint16(6, du),
    height: e.getUint16(8, du)
  } : null;
}
function DI(t) {
  const e = Fu(t);
  return e.byteLength >= 14 && e.getUint16(0, Gn) === 16973 && e.getUint32(2, du) === e.byteLength ? {
    mimeType: "image/bmp",
    width: e.getUint32(18, du),
    height: e.getUint32(22, du)
  } : null;
}
function OI(t) {
  const e = Fu(t);
  if (!(e.byteLength >= 3 && e.getUint16(0, Gn) === 65496 && e.getUint8(2) === 255))
    return null;
  const { tableMarkers: s, sofMarkers: o } = FI();
  let l = 2;
  for (; l + 9 < e.byteLength; ) {
    const u = e.getUint16(l, Gn);
    if (o.has(u))
      return {
        mimeType: "image/jpeg",
        height: e.getUint16(l + 5, Gn),
        // Number of lines
        width: e.getUint16(l + 7, Gn)
        // Number of pixels per line
      };
    if (!s.has(u))
      return null;
    l += 2, l += e.getUint16(l, Gn);
  }
  return null;
}
function FI() {
  const t = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let i = 65504; i < 65520; ++i)
    t.add(i);
  return { tableMarkers: t, sofMarkers: /* @__PURE__ */ new Set([
    65472,
    65473,
    65474,
    65475,
    65477,
    65478,
    65479,
    65481,
    65482,
    65483,
    65485,
    65486,
    65487,
    65502
  ]) };
}
function Fu(t) {
  if (t instanceof DataView)
    return t;
  if (ArrayBuffer.isView(t))
    return new DataView(t.buffer);
  if (t instanceof ArrayBuffer)
    return new DataView(t);
  throw new Error("toDataView");
}
async function kI(t, e) {
  var o;
  const { mimeType: i } = Yg(t) || {}, s = (o = globalThis.loaders) == null ? void 0 : o.parseImageNode;
  return Ai(s), await s(t, i);
}
async function NI(t, e, i) {
  e = e || {};
  const o = (e.image || {}).type || "auto", { url: l } = i || {}, u = LI(o);
  let c;
  switch (u) {
    case "imagebitmap":
      c = await wI(t, e, l);
      break;
    case "image":
      c = await pw(t, e, l);
      break;
    case "data":
      c = await kI(t);
      break;
    default:
      Ai(!1);
  }
  return o === "data" && (c = dw(c)), c;
}
function LI(t) {
  switch (t) {
    case "auto":
    case "data":
      return pI();
    default:
      return fI(t), t;
  }
}
const UI = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"], zI = [
  "image/png",
  "image/jpeg",
  "image/gif",
  "image/webp",
  "image/avif",
  "image/bmp",
  "image/vnd.microsoft.icon",
  "image/svg+xml"
], VI = {
  image: {
    type: "auto",
    decode: !0
    // if format is HTML
  }
  // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
}, _w = {
  dataType: null,
  batchType: null,
  id: "image",
  module: "images",
  name: "Images",
  version: hI,
  mimeTypes: zI,
  extensions: UI,
  parse: NI,
  // TODO: byteOffset, byteLength;
  tests: [(t) => !!Yg(new DataView(t))],
  options: VI
}, W_ = {};
function HI(t) {
  if (W_[t] === void 0) {
    const e = fp ? $I(t) : jI(t);
    W_[t] = e;
  }
  return W_[t];
}
function jI(t) {
  var o, l;
  const e = ["image/png", "image/jpeg", "image/gif"], i = ((o = globalThis.loaders) == null ? void 0 : o.imageFormatsNode) || e;
  return !!((l = globalThis.loaders) == null ? void 0 : l.parseImageNode) && i.includes(t);
}
function $I(t) {
  switch (t) {
    case "image/avif":
    case "image/webp":
      return GI(t);
    default:
      return !0;
  }
}
function GI(t) {
  try {
    return document.createElement("canvas").toDataURL(t).indexOf(`data:${t}`) === 0;
  } catch {
    return !1;
  }
}
const Jt = new Hc({ id: "deck" });
let Zm = {};
function XI(t) {
  Zm = t;
}
function qs(t, e, i, s) {
  Jt.level > 0 && Zm[t] && Zm[t].call(null, e, i, s);
}
function WI(t) {
  const e = t[0], i = t[t.length - 1];
  return e === "{" && i === "}" || e === "[" && i === "]";
}
const qI = {
  dataType: null,
  batchType: null,
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: WI,
  parseTextSync: JSON.parse
};
function ZI() {
  const t = "9.0.35", e = globalThis.deck && globalThis.deck.VERSION;
  if (e && e !== t)
    throw new Error(`deck.gl - multiple versions detected: ${e} vs ${t}`);
  return e || (Jt.log(1, `deck.gl ${t}`)(), globalThis.deck = {
    ...globalThis.deck,
    VERSION: t,
    version: t,
    log: Jt,
    // experimental
    _registerLoggers: XI
  }, k2([
    qI,
    // @ts-expect-error non-standard Loader format
    [_w, { imagebitmap: { premultiplyAlpha: "none" } }]
  ])), t;
}
const KI = ZI();
function Qa(t, e) {
  if (!t)
    throw new Error(e || "shadertools: assertion failed.");
}
const q_ = {
  number: {
    type: "number",
    validate(t, e) {
      return Number.isFinite(t) && typeof e == "object" && (e.max === void 0 || t <= e.max) && (e.min === void 0 || t >= e.min);
    }
  },
  array: {
    type: "array",
    validate(t, e) {
      return Array.isArray(t) || ArrayBuffer.isView(t);
    }
  }
};
function JI(t) {
  const e = {};
  for (const [i, s] of Object.entries(t))
    e[i] = QI(s);
  return e;
}
function YI(t, e, i) {
  const s = {};
  for (const [o, l] of Object.entries(e))
    t && o in t && !l.private ? (l.validate && Qa(l.validate(t[o], l), `${i}: invalid ${o}`), s[o] = t[o]) : s[o] = l.value;
  return s;
}
function QI(t) {
  let e = Kb(t);
  if (e !== "object")
    return { value: t, ...q_[e], type: e };
  if (typeof t == "object")
    return t ? t.type !== void 0 ? { ...t, ...q_[t.type], type: t.type } : t.value === void 0 ? { type: "object", value: t } : (e = Kb(t.value), { ...t, ...q_[e], type: e }) : { type: "object", value: null };
  throw new Error("props");
}
function Kb(t) {
  return Array.isArray(t) || ArrayBuffer.isView(t) ? "array" : typeof t;
}
const eR = `#ifdef MODULE_LOGDEPTH
logdepth_adjustPosition(gl_Position);
#endif
`, tR = `#ifdef MODULE_MATERIAL
gl_FragColor = material_filterColor(gl_FragColor);
#endif
#ifdef MODULE_LIGHTING
gl_FragColor = lighting_filterColor(gl_FragColor);
#endif
#ifdef MODULE_FOG
gl_FragColor = fog_filterColor(gl_FragColor);
#endif
#ifdef MODULE_PICKING
gl_FragColor = picking_filterHighlightColor(gl_FragColor);
gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif
#ifdef MODULE_LOGDEPTH
logdepth_setFragDepth();
#endif
`, iR = {
  vertex: eR,
  fragment: tR
}, Jb = /void\s+main\s*\([^)]*\)\s*\{\n?/, Yb = /}\n?[^{}]*$/, Z_ = [], bf = "__LUMA_INJECT_DECLARATIONS__";
function sR(t) {
  const e = { vertex: {}, fragment: {} };
  for (const i in t) {
    let s = t[i];
    const o = rR(i);
    typeof s == "string" && (s = {
      order: 0,
      injection: s
    }), e[o][i] = s;
  }
  return e;
}
function rR(t) {
  const e = t.slice(0, 2);
  switch (e) {
    case "vs":
      return "vertex";
    case "fs":
      return "fragment";
    default:
      throw new Error(e);
  }
}
function Mf(t, e, i, s = !1) {
  const o = e === "vertex";
  for (const l in i) {
    const u = i[l];
    u.sort((x, w) => x.order - w.order), Z_.length = u.length;
    for (let x = 0, w = u.length; x < w; ++x)
      Z_[x] = u[x].injection;
    const c = `${Z_.join(`
`)}
`;
    switch (l) {
      case "vs:#decl":
        o && (t = t.replace(bf, c));
        break;
      case "vs:#main-start":
        o && (t = t.replace(Jb, (x) => x + c));
        break;
      case "vs:#main-end":
        o && (t = t.replace(Yb, (x) => c + x));
        break;
      case "fs:#decl":
        o || (t = t.replace(bf, c));
        break;
      case "fs:#main-start":
        o || (t = t.replace(Jb, (x) => x + c));
        break;
      case "fs:#main-end":
        o || (t = t.replace(Yb, (x) => c + x));
        break;
      default:
        t = t.replace(l, (x) => x + c);
    }
  }
  return t = t.replace(bf, ""), s && (t = t.replace(/\}\s*$/, (l) => l + iR[e])), t;
}
let nR = 1;
class el {
  constructor(e) {
    O(this, "name");
    O(this, "vs");
    O(this, "fs");
    O(this, "getModuleUniforms");
    O(this, "dependencies");
    O(this, "deprecations");
    O(this, "defines");
    O(this, "injections");
    O(this, "uniforms", {});
    O(this, "uniformTypes", {});
    const { name: i, vs: s, fs: o, dependencies: l = [], uniformTypes: u = {}, uniformPropTypes: c = {}, getUniforms: x, deprecations: w = [], defines: C = {}, inject: M = {} } = e;
    Qa(typeof i == "string"), this.name = i, this.vs = s, this.fs = o, this.getModuleUniforms = x, this.dependencies = el.instantiateModules(l), this.deprecations = this._parseDeprecationDefinitions(w), this.defines = C, this.injections = sR(M), this.uniformTypes = u, c && (this.uniforms = JI(c));
  }
  static instantiateModules(e) {
    return e.map((i) => {
      if (i instanceof el)
        return i;
      Qa(typeof i != "string", `Shader module use by name is deprecated. Import shader module '${JSON.stringify(i)}' and use it directly.`), i.name || (console.warn("shader module has no name"), i.name = `shader-module-${nR++}`);
      const s = new el(i);
      return s.dependencies = el.instantiateModules(i.dependencies || []), s;
    });
  }
  // Extracts the source code chunk for the specified shader type from the named shader module
  getModuleSource(e) {
    let i;
    switch (e) {
      case "vertex":
        i = this.vs || "";
        break;
      case "fragment":
        i = this.fs || "";
        break;
      default:
        Qa(!1);
    }
    const s = this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
    return `// ----- MODULE ${this.name} ---------------

#define MODULE_${s}
${i}

`;
  }
  getUniforms(e, i) {
    return this.getModuleUniforms ? this.getModuleUniforms(e, i) : YI(e, this.uniforms, this.name);
  }
  getDefines() {
    return this.defines;
  }
  // Warn about deprecated uniforms or functions
  checkDeprecations(e, i) {
    this.deprecations.forEach((s) => {
      var o;
      (o = s.regex) != null && o.test(e) && (s.deprecated ? i.deprecated(s.old, s.new)() : i.removed(s.old, s.new)());
    });
  }
  _parseDeprecationDefinitions(e) {
    return e.forEach((i) => {
      switch (i.type) {
        case "function":
          i.regex = new RegExp(`\\b${i.old}\\(`);
          break;
        default:
          i.regex = new RegExp(`${i.type} ${i.old};`);
      }
    }), e;
  }
  _defaultGetUniforms(e = {}) {
    const i = {}, s = this.uniforms;
    for (const o in s) {
      const l = s[o];
      o in e && !l.private ? (l.validate && Qa(l.validate(e[o], l), `${this.name}: invalid ${o}`), i[o] = e[o]) : i[o] = l.value;
    }
    return i;
  }
}
function Qb(t) {
  if (t.source && t.platformInfo.type === "webgpu")
    return { ...t, vs: void 0, fs: void 0 };
  if (!t.vs)
    throw new Error("no vertex shader");
  const e = ev(t.platformInfo, t.vs);
  let i;
  return t.fs && (i = ev(t.platformInfo, t.fs)), { ...t, vs: e, fs: i };
}
function ev(t, e) {
  if (typeof e == "string")
    return e;
  switch (t.type) {
    case "webgpu":
      if (e != null && e.wgsl)
        return e.wgsl;
      throw new Error("WebGPU does not support GLSL shaders");
    default:
      if (e != null && e.glsl)
        return e.glsl;
      throw new Error("WebGL does not support WGSL shaders");
  }
}
function _p(t) {
  const e = el.instantiateModules(t);
  return oR(e);
}
function oR(t) {
  const e = {}, i = {};
  return mw({ modules: t, level: 0, moduleMap: e, moduleDepth: i }), Object.keys(i).sort((s, o) => i[o] - i[s]).map((s) => e[s]);
}
function mw(t) {
  const { modules: e, level: i, moduleMap: s, moduleDepth: o } = t;
  if (i >= 5)
    throw new Error("Possible loop in shader dependency graph");
  for (const l of e)
    s[l.name] = l, (o[l.name] === void 0 || o[l.name] < i) && (o[l.name] = i);
  for (const l of e)
    l.dependencies && mw({ modules: l.dependencies, level: i + 1, moduleMap: s, moduleDepth: o });
}
function aR(t) {
  switch (t == null ? void 0 : t.gpu.toLowerCase()) {
    case "apple":
      return `#define APPLE_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    case "nvidia":
      return `#define NVIDIA_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
    case "intel":
      return `#define INTEL_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    case "amd":
      return `#define AMD_GPU
`;
    default:
      return `#define DEFAULT_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
  }
}
function lR(t, e) {
  var s;
  if (Number(((s = t.match(/^#version[ \t]+(\d+)/m)) == null ? void 0 : s[1]) || 100) !== 300)
    throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
  switch (e) {
    case "vertex":
      return t = tv(t, cR), t;
    case "fragment":
      return t = tv(t, hR), t;
    default:
      throw new Error(e);
  }
}
const gw = [
  // Fix poorly formatted version directive
  [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, `#version 300 es
`],
  // The individual `texture...()` functions were replaced with `texture()` overloads
  [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
  [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
], cR = [
  ...gw,
  // `attribute` keyword replaced with `in`
  [Km("attribute"), "in $1"],
  // `varying` keyword replaced with `out`
  [Km("varying"), "out $1"]
], hR = [
  ...gw,
  // `varying` keyword replaced with `in`
  [Km("varying"), "in $1"]
];
function tv(t, e) {
  for (const [i, s] of e)
    t = t.replace(i, s);
  return t;
}
function Km(t) {
  return new RegExp(`\\b${t}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
}
function yw(t, e) {
  let i = "";
  for (const s in t) {
    const o = t[s];
    if (i += `void ${o.signature} {
`, o.header && (i += `  ${o.header}`), e[s]) {
      const l = e[s];
      l.sort((u, c) => u.order - c.order);
      for (const u of l)
        i += `  ${u.injection}
`;
    }
    o.footer && (i += `  ${o.footer}`), i += `}
`;
  }
  return i;
}
function bw(t) {
  const e = { vertex: {}, fragment: {} };
  for (const i of t) {
    let s, o;
    typeof i != "string" ? (s = i, o = s.hook) : (s = {}, o = i), o = o.trim();
    const [l, u] = o.split(":"), c = o.replace(/\(.+/, ""), x = Object.assign(s, { signature: u });
    switch (l) {
      case "vs":
        e.vertex[c] = x;
        break;
      case "fs":
        e.fragment[c] = x;
        break;
      default:
        throw new Error(l);
    }
  }
  return e;
}
function uR(t, e) {
  return {
    name: dR(t, e),
    language: "glsl",
    version: fR(t)
  };
}
function dR(t, e = "unnamed") {
  const s = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(t);
  return s ? s[1] : e;
}
function fR(t) {
  let e = 100;
  const i = t.match(/[^\s]+/g);
  if (i && i.length >= 2 && i[0] === "#version") {
    const s = parseInt(i[1], 10);
    Number.isFinite(s) && (e = s);
  }
  if (e !== 100 && e !== 300)
    throw new Error(`Invalid GLSL version ${e}`);
  return e;
}
const vw = `

${bf}
`, pR = `precision highp float;
`;
function _R(t) {
  const e = _p(t.modules || []);
  return {
    source: Jm(t.platformInfo, {
      ...t,
      source: t.source,
      stage: "vertex",
      modules: e
    }),
    getUniforms: Qg(e)
  };
}
function mR(t) {
  const e = _p(t.modules || []);
  return {
    vs: Jm(t.platformInfo, {
      ...t,
      source: t.vs,
      stage: "vertex",
      modules: e
    }),
    fs: Jm(t.platformInfo, {
      ...t,
      source: t.fs,
      stage: "fragment",
      modules: e
    }),
    getUniforms: Qg(e)
  };
}
function gR(t) {
  const { vs: e, fs: i } = t, s = _p(t.modules || []);
  return {
    vs: iv(t.platformInfo, {
      ...t,
      source: e,
      stage: "vertex",
      modules: s
    }),
    fs: iv(t.platformInfo, {
      ...t,
      source: i,
      stage: "fragment",
      modules: s
    }),
    getUniforms: Qg(s)
  };
}
function Jm(t, e) {
  const {
    // id,
    source: i,
    stage: s,
    modules: o,
    // defines = {},
    hookFunctions: l = [],
    inject: u = {},
    log: c
  } = e;
  Qa(typeof i == "string", "shader source must be a string");
  const x = i;
  let w = "";
  const C = bw(l), M = {}, P = {}, j = {};
  for (const Q in u) {
    const _e = typeof u[Q] == "string" ? { injection: u[Q], order: 0 } : u[Q], me = /^(v|f)s:(#)?([\w-]+)$/.exec(Q);
    if (me) {
      const we = me[2], Ee = me[3];
      we ? Ee === "decl" ? P[Q] = [_e] : j[Q] = [_e] : M[Q] = [_e];
    } else
      j[Q] = [_e];
  }
  const Y = t.type !== "webgpu" ? o : [];
  for (const Q of Y) {
    c && Q.checkDeprecations(x, c);
    const _e = Q.getModuleSource(s, "wgsl");
    w += _e;
    const me = Q.injections[s];
    for (const we in me) {
      const Ee = /^(v|f)s:#([\w-]+)$/.exec(we);
      if (Ee) {
        const Ne = Ee[2] === "decl" ? P : j;
        Ne[we] = Ne[we] || [], Ne[we].push(me[we]);
      } else
        M[we] = M[we] || [], M[we].push(me[we]);
    }
  }
  return w += vw, w = Mf(w, s, P), w += yw(C[s], M), w += x, w = Mf(w, s, j), w;
}
function iv(t, e) {
  const { id: i, source: s, stage: o, language: l = "glsl", modules: u, defines: c = {}, hookFunctions: x = [], inject: w = {}, prologue: C = !0, log: M } = e;
  Qa(typeof s == "string", "shader source must be a string");
  const P = l === "glsl" ? uR(s).version : -1, j = t.shaderLanguageVersion, Y = P === 100 ? "#version 100" : "#version 300 es", _e = s.split(`
`).slice(1).join(`
`), me = {};
  u.forEach((nt) => {
    Object.assign(me, nt.getDefines());
  }), Object.assign(me, c);
  let we = "";
  switch (l) {
    case "wgsl":
      break;
    case "glsl":
      we = C ? `${Y}

// ----- PROLOGUE -------------------------
${yR({ id: i, source: s, stage: o })}
${`#define SHADER_TYPE_${o.toUpperCase()}`}
${aR(t)}
${o === "fragment" ? pR : ""}

// ----- APPLICATION DEFINES -------------------------

${bR(me)}

` : `${Y}
`;
      break;
  }
  const Ee = bw(x), Oe = {}, Ne = {}, ze = {};
  for (const nt in w) {
    const mt = typeof w[nt] == "string" ? { injection: w[nt], order: 0 } : w[nt], We = /^(v|f)s:(#)?([\w-]+)$/.exec(nt);
    if (We) {
      const at = We[2], it = We[3];
      at ? it === "decl" ? Ne[nt] = [mt] : ze[nt] = [mt] : Oe[nt] = [mt];
    } else
      ze[nt] = [mt];
  }
  for (const nt of u) {
    M && nt.checkDeprecations(_e, M);
    const mt = nt.getModuleSource(o);
    we += mt;
    const We = nt.injections[o];
    for (const at in We) {
      const it = /^(v|f)s:#([\w-]+)$/.exec(at);
      if (it) {
        const Rt = it[2] === "decl" ? Ne : ze;
        Rt[at] = Rt[at] || [], Rt[at].push(We[at]);
      } else
        Oe[at] = Oe[at] || [], Oe[at].push(We[at]);
    }
  }
  return we += "// ----- MAIN SHADER SOURCE -------------------------", we += vw, we = Mf(we, o, Ne), we += yw(Ee[o], Oe), we += _e, we = Mf(we, o, ze), l === "glsl" && P !== j && (we = lR(we, o)), we.trim();
}
function Qg(t) {
  return function(i) {
    const s = {};
    for (const o of t) {
      const l = o.getUniforms(i, s);
      Object.assign(s, l);
    }
    return s;
  };
}
function yR(t) {
  const { id: e, source: i, stage: s } = t;
  return e && i.indexOf("SHADER_NAME") === -1 ? `
#define SHADER_NAME ${e}_${s}

` : "";
}
function bR(t = {}) {
  let e = "";
  for (const i in t) {
    const s = t[i];
    (s || Number.isFinite(s)) && (e += `#define ${i.toUpperCase()} ${t[i]}
`);
  }
  return e;
}
const Ja = class Ja {
  constructor() {
    /** Hook functions */
    O(this, "_hookFunctions", []);
    /** Shader modules */
    O(this, "_defaultModules", []);
  }
  /**
   * A default shader assembler instance - the natural place to register default modules and hooks
   * @returns
   */
  static getDefaultShaderAssembler() {
    return Ja.defaultShaderAssembler = Ja.defaultShaderAssembler || new Ja(), Ja.defaultShaderAssembler;
  }
  /**
   * Add a default module that does not have to be provided with every call to assembleShaders()
   */
  addDefaultModule(e) {
    this._defaultModules.find((i) => i.name === (typeof e == "string" ? e : e.name)) || this._defaultModules.push(e);
  }
  /**
   * Remove a default module
   */
  removeDefaultModule(e) {
    const i = typeof e == "string" ? e : e.name;
    this._defaultModules = this._defaultModules.filter((s) => s.name !== i);
  }
  /**
   * Register a shader hook
   * @param hook
   * @param opts
   */
  addShaderHook(e, i) {
    i && (e = Object.assign(i, { hook: e })), this._hookFunctions.push(e);
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleShader(e) {
    const i = this._getModuleList(e.modules), s = this._hookFunctions, o = Qb(e);
    return { ..._R({
      platformInfo: e.platformInfo,
      ...o,
      modules: i,
      hookFunctions: s
    }), modules: i };
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleShaderPair(e) {
    const i = Qb(e), s = this._getModuleList(e.modules), o = this._hookFunctions, { platformInfo: l } = e;
    return { ...e.platformInfo.shaderLanguage === "wgsl" ? mR({ platformInfo: l, ...i, modules: s, hookFunctions: o }) : gR({ platformInfo: l, ...i, modules: s, hookFunctions: o }), modules: s };
  }
  /**
   * Dedupe and combine with default modules
   */
  _getModuleList(e = []) {
    const i = new Array(this._defaultModules.length + e.length), s = {};
    let o = 0;
    for (let l = 0, u = this._defaultModules.length; l < u; ++l) {
      const c = this._defaultModules[l], x = c.name;
      i[o++] = c, s[x] = !0;
    }
    for (let l = 0, u = e.length; l < u; ++l) {
      const c = e[l], x = c.name;
      s[x] || (i[o++] = c, s[x] = !0);
    }
    return i.length = o, el.instantiateModules(i);
  }
};
/** Default ShaderAssembler instance */
O(Ja, "defaultShaderAssembler");
let Pf = Ja;
const vR = `out vec4 transform_output;
void main() {
transform_output = vec4(0);
}`, xR = `#version 300 es
${vR}`;
function wR(t) {
  const { input: e, inputChannels: i, output: s } = {};
  if (!e)
    return xR;
  if (!i)
    throw new Error("inputChannels");
  const o = AR(i), l = TR(e, i);
  return `#version 300 es
in ${o} ${e};
out vec4 ${s};
void main() {
  ${s} = ${l};
}`;
}
function AR(t) {
  switch (t) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`invalid channels: ${t}`);
  }
}
function TR(t, e) {
  switch (e) {
    case 1:
      return `vec4(${t}, 0.0, 0.0, 1.0)`;
    case 2:
      return `vec4(${t}, 0.0, 1.0)`;
    case 3:
      return `vec4(${t}, 1.0)`;
    case 4:
      return t;
    default:
      throw new Error(`invalid channels: ${e}`);
  }
}
const $e = new Hc({ id: "luma.gl" });
class ER {
  constructor() {
    O(this, "stats", /* @__PURE__ */ new Map());
  }
  getStats(e) {
    return this.get(e);
  }
  get(e) {
    return this.stats.has(e) || this.stats.set(e, new jc({ id: e })), this.stats.get(e);
  }
}
const ey = new ER();
function SR() {
  const t = "9.0.27", e = "set luma.log.level=1 (or higher) to trace rendering";
  if (globalThis.luma && globalThis.luma.VERSION !== t)
    throw new Error(`luma.gl - multiple VERSIONs detected: ${globalThis.luma.VERSION} vs ${t}`);
  return globalThis.luma || (ya() && $e.log(1, `${t} - ${e}`)(), globalThis.luma = globalThis.luma || {
    VERSION: t,
    version: t,
    log: $e,
    // A global stats object that various components can add information to
    // E.g. see webgl/resource.js
    stats: ey
  }), t;
}
const CR = SR();
function IR(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView) ? t : null;
}
function xu(t) {
  return Array.isArray(t) ? t.length === 0 || typeof t[0] == "number" ? t : null : IR(t);
}
const K_ = {};
function ba(t = "id") {
  K_[t] = K_[t] || 1;
  const e = K_[t]++;
  return `${t}-${e}`;
}
function Bf(t) {
  let e = !0;
  for (const i in t) {
    e = !1;
    break;
  }
  return e;
}
var jm;
let vi = (jm = class {
  /**
   * Create a new Resource. Called from Subclass
   */
  constructor(e, i, s) {
    /** props.id, for debugging. */
    O(this, "id");
    O(this, "props");
    O(this, "userData", {});
    O(this, "_device");
    /** Whether this resource has been destroyed */
    O(this, "destroyed", !1);
    /** For resources that allocate GPU memory */
    O(this, "allocatedBytes", 0);
    /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created "sub" resources. */
    O(this, "_attachedResources", /* @__PURE__ */ new Set());
    if (!e)
      throw new Error("no device");
    this._device = e, this.props = RR(i, s);
    const o = this.props.id !== "undefined" ? this.props.id : ba(this[Symbol.toStringTag]);
    this.props.id = o, this.id = o, this.userData = this.props.userData || {}, this.addStats();
  }
  /**
   * destroy can be called on any resource to release it before it is garbage collected.
   */
  destroy() {
    this.destroyResource();
  }
  /** @deprecated Use destroy() */
  delete() {
    return this.destroy(), this;
  }
  toString() {
    return `${this[Symbol.toStringTag] || this.constructor.name}(${this.id})`;
  }
  /**
   * Combines a map of user props and default props, only including props from defaultProps
   * @returns returns a map of overridden default props
   */
  getProps() {
    return this.props;
  }
  // ATTACHED RESOURCES
  /**
   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed
   * Called automatically when sub resources are auto created but can be called by application
   */
  attachResource(e) {
    this._attachedResources.add(e);
  }
  /**
   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.
   */
  detachResource(e) {
    this._attachedResources.delete(e);
  }
  /**
   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.
   */
  destroyAttachedResource(e) {
    this._attachedResources.delete(e) && e.destroy();
  }
  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */
  destroyAttachedResources() {
    for (const e of Object.values(this._attachedResources))
      e.destroy();
    this._attachedResources = /* @__PURE__ */ new Set();
  }
  // PROTECTED METHODS
  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */
  destroyResource() {
    this.destroyAttachedResources(), this.removeStats(), this.destroyed = !0;
  }
  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */
  removeStats() {
    const e = this._device.statsManager.getStats("Resource Counts"), i = this[Symbol.toStringTag];
    e.get(`${i}s Active`).decrementCount();
  }
  /** Called by subclass to track memory allocations */
  trackAllocatedMemory(e, i = this[Symbol.toStringTag]) {
    const s = this._device.statsManager.getStats("Resource Counts");
    s.get("GPU Memory").addCount(e), s.get(`${i} Memory`).addCount(e), this.allocatedBytes = e;
  }
  /** Called by subclass to track memory deallocations */
  trackDeallocatedMemory(e = this[Symbol.toStringTag]) {
    const i = this._device.statsManager.getStats("Resource Counts");
    i.get("GPU Memory").subtractCount(this.allocatedBytes), i.get(`${e} Memory`).subtractCount(this.allocatedBytes), this.allocatedBytes = 0;
  }
  /** Called by resource constructor to track object creation */
  addStats() {
    const e = this._device.statsManager.getStats("Resource Counts"), i = this[Symbol.toStringTag];
    e.get("Resources Created").incrementCount(), e.get(`${i}s Created`).incrementCount(), e.get(`${i}s Active`).incrementCount();
  }
}, /** Default properties for resource */
O(jm, "defaultProps", {
  id: "undefined",
  handle: void 0,
  userData: void 0
}), jm);
function RR(t, e) {
  const i = { ...e };
  for (const s in t)
    t[s] !== void 0 && (i[s] = t[s]);
  return i;
}
const Os = class Os extends vi {
  constructor(i, s) {
    const o = { ...s };
    (s.usage || 0) & Os.INDEX && !s.indexType && (s.data instanceof Uint32Array ? o.indexType = "uint32" : s.data instanceof Uint16Array && (o.indexType = "uint16"));
    super(i, o, Os.defaultProps);
    /** The usage with which this buffer was created */
    O(this, "usage");
    /** For index buffers, whether indices are 16 or 32 bit */
    O(this, "indexType");
    /** "Time" of last update */
    O(this, "updateTimestamp");
    /** A partial CPU-side copy of the data in this buffer, for debugging purposes */
    O(this, "debugData", new ArrayBuffer(0));
    this.usage = s.usage || 0, this.indexType = o.indexType, this.updateTimestamp = i.incrementTimestamp();
  }
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  /** Read data synchronously. @note WebGL2 only */
  readSyncWebGL(i, s) {
    throw new Error("not implemented");
  }
  /** This doesn't handle partial non-zero offset updates correctly */
  _setDebugData(i, s, o) {
    const l = ArrayBuffer.isView(i) ? i.buffer : i, u = Math.min(i ? i.byteLength : o, Os.DEBUG_DATA_MAX_LENGTH);
    i === null ? this.debugData = new ArrayBuffer(u) : s === 0 && o === i.byteLength ? this.debugData = l.slice(0, u) : this.debugData = l.slice(s, s + u);
  }
};
O(Os, "defaultProps", {
  ...vi.defaultProps,
  usage: 0,
  // Buffer.COPY_DST | Buffer.COPY_SRC
  byteLength: 0,
  byteOffset: 0,
  data: null,
  indexType: "uint16",
  mappedAtCreation: !1
}), // Usage Flags
O(Os, "MAP_READ", 1), O(Os, "MAP_WRITE", 2), O(Os, "COPY_SRC", 4), O(Os, "COPY_DST", 8), /** Index buffer */
O(Os, "INDEX", 16), /** Vertex buffer */
O(Os, "VERTEX", 32), /** Uniform buffer */
O(Os, "UNIFORM", 64), /** Storage buffer */
O(Os, "STORAGE", 128), O(Os, "INDIRECT", 256), O(Os, "QUERY_RESOLVE", 512), // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
/** Max amount of debug data saved. Two vec4's */
O(Os, "DEBUG_DATA_MAX_LENGTH", 32);
let Vi = Os;
function xw(t) {
  const e = sv[t], i = MR(e), s = t.includes("norm"), o = !s && !t.startsWith("float"), l = t.startsWith("s");
  return {
    dataType: sv[t],
    byteLength: i,
    integer: o,
    signed: l,
    normalized: s
  };
}
function MR(t) {
  return PR[t];
}
const sv = {
  uint8: "uint8",
  sint8: "sint8",
  unorm8: "uint8",
  snorm8: "sint8",
  uint16: "uint16",
  sint16: "sint16",
  unorm16: "uint16",
  snorm16: "sint16",
  float16: "float16",
  float32: "float32",
  uint32: "uint32",
  sint32: "sint32"
}, PR = {
  uint8: 1,
  sint8: 1,
  uint16: 2,
  sint16: 2,
  float16: 2,
  float32: 4,
  uint32: 4,
  sint32: 4
}, BR = [
  "bc1",
  "bc2",
  "bc3",
  "bc4",
  "bc5",
  "bc6",
  "bc7",
  "etc1",
  "etc2",
  "eac",
  "atc",
  "astc",
  "pvrtc"
], DR = /^(rg?b?a?)([0-9]*)([a-z]*)(-srgb)?(-webgl|-unsized)?$/;
function OR(t) {
  return BR.some((e) => t.startsWith(e));
}
function ww(t) {
  const e = DR.exec(t);
  if (e) {
    const [, i, s, o, l, u] = e;
    if (i) {
      const c = `${o}${s}`, x = xw(c);
      return {
        format: i,
        components: i.length,
        // dataType - overwritten by decodedType
        srgb: l === "-srgb",
        unsized: u === "-unsized",
        webgl: u === "-webgl",
        ...x
      };
    }
  }
  return kR(t);
}
const FR = {
  // Packed 16 bit formats
  "rgba4unorm-webgl": { format: "rgba", bpp: 2 },
  "rgb565unorm-webgl": { format: "rgb", bpp: 2 },
  "rgb5a1unorm-webgl": { format: "rgba", bbp: 2 },
  // Packed 32 bit formats
  rgb9e5ufloat: { format: "rgb", bbp: 4 },
  rg11b10ufloat: { format: "rgb", bbp: 4 },
  rgb10a2unorm: { format: "rgba", bbp: 4 },
  "rgb10a2uint-webgl": { format: "rgba", bbp: 4 },
  // Depth/stencil
  stencil8: { components: 1, bpp: 1, a: "stencil" },
  depth16unorm: { components: 1, bpp: 2, a: "depth" },
  depth24plus: { components: 1, bpp: 3, a: "depth" },
  depth32float: { components: 1, bpp: 4, a: "depth" },
  "depth24plus-stencil8": { components: 2, bpp: 4, a: "depth-stencil" },
  // "depth24unorm-stencil8" feature
  "depth24unorm-stencil8": { components: 2, bpp: 4, a: "depth-stencil" },
  // "depth32float-stencil8" feature
  "depth32float-stencil8": { components: 2, bpp: 4, a: "depth-stencil" }
};
function kR(t) {
  var i;
  const e = FR[t];
  if (!e)
    throw new Error(`Unknown format ${t}`);
  return {
    format: e.format || "",
    components: e.components || ((i = e.format) == null ? void 0 : i.length) || 1,
    byteLength: e.bpp || 1,
    srgb: !1,
    unsized: !1
  };
}
class NR {
}
class LR {
  constructor(e = [], i) {
    O(this, "features");
    O(this, "disabledFeatures");
    this.features = new Set(e), this.disabledFeatures = i || {};
  }
  *[Symbol.iterator]() {
    yield* this.features;
  }
  has(e) {
    return !this.disabledFeatures[e] && this.features.has(e);
  }
}
const bu = class bu {
  constructor(e) {
    /** id of this device, primarily for debugging */
    O(this, "id");
    /** A copy of the device props  */
    O(this, "props");
    /** Available for the application to store data on the device */
    O(this, "userData", {});
    /** stats */
    O(this, "statsManager", ey);
    /** Used by other luma.gl modules to store data on the device */
    O(this, "_lumaData", {});
    O(this, "timestamp", 0);
    this.props = { ...bu.defaultProps, ...e }, this.id = this.props.id || ba(this[Symbol.toStringTag].toLowerCase());
  }
  get [Symbol.toStringTag]() {
    return "Device";
  }
  /** Check if a specific texture format is GPU compressed */
  isTextureFormatCompressed(e) {
    return OR(e);
  }
  /**
   * Trigger device loss.
   * @returns `true` if context loss could actually be triggered.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    return !1;
  }
  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
  getCanvasContext() {
    if (!this.canvasContext)
      throw new Error("Device has no CanvasContext");
    return this.canvasContext;
  }
  createTexture(e) {
    return (e instanceof Promise || typeof e == "string") && (e = { data: e }), this._createTexture(e);
  }
  createCommandEncoder(e = {}) {
    throw new Error("not implemented");
  }
  // WebGL specific HACKS - enables app to remove webgl import
  // Use until we have a better way to handle these
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToArrayWebGL(e, i) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToBufferWebGL(e, i) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  setParametersWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  getParametersWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  withParametersWebGL(e, i) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use clear arguments in RenderPass */
  clearWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use for debugging only */
  resetWebGL() {
    throw new Error("not implemented");
  }
  /** A monotonic counter for tracking buffer and texture updates */
  incrementTimestamp() {
    return this.timestamp++;
  }
  // Error Handling
  /** Report unhandled device errors */
  onError(e) {
    this.props.onError(e);
  }
  // IMPLEMENTATION
  _getBufferProps(e) {
    (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) && (e = { data: e });
    const i = { ...e };
    return (e.usage || 0) & Vi.INDEX && !e.indexType && (e.data instanceof Uint32Array ? i.indexType = "uint32" : e.data instanceof Uint16Array ? i.indexType = "uint16" : $e.warn("indices buffer content must be of integer type")()), i;
  }
};
O(bu, "defaultProps", {
  id: null,
  canvas: null,
  container: null,
  manageState: !0,
  width: 800,
  // width are height are only used by headless gl
  height: 600,
  requestMaxLimits: !0,
  debug: !!$e.get("debug"),
  // Instrument context (at the expense of performance)
  spector: !!($e.get("spector") || $e.get("spectorjs")),
  // Initialize the SpectorJS WebGL debugger
  break: [],
  // TODO - Change these after confirming things work as expected
  initalizeFeatures: !0,
  disabledFeatures: {
    "compilation-status-async-webgl": !0
  },
  // alpha: undefined,
  // depth: undefined,
  // stencil: undefined,
  // antialias: undefined,
  // premultipliedAlpha: undefined,
  // preserveDrawingBuffer: undefined,
  // failIfMajorPerformanceCaveat: undefined
  gl: null,
  // Callbacks
  onError: (e) => $e.error(e.message)
}), O(bu, "VERSION", CR);
let Bc = bu;
function ri(t, e) {
  if (!t)
    throw new Error(e || "luma.gl: assertion failed.");
}
const qh = /* @__PURE__ */ new Map(), Tc = class Tc {
  static registerDevices(e) {
    for (const i of e)
      ri(i.type && i.isSupported && i.create), qh.set(i.type, i);
  }
  static getAvailableDevices() {
    return Array.from(qh).map((e) => e.type);
  }
  static getSupportedDevices() {
    return Array.from(qh).filter((e) => e.isSupported()).map((e) => e.type);
  }
  static setDefaultDeviceProps(e) {
    Object.assign(Bc.defaultProps, e);
  }
  /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */
  static async attachDevice(e) {
    const i = rv(e.devices) || qh;
    if (e.handle instanceof WebGL2RenderingContext) {
      const s = i.get("webgl");
      if (s)
        return await s.attach(e.handle);
    }
    if (e.handle === null) {
      const s = i.get("unknown");
      if (s)
        return await s.attach(null);
    }
    throw new Error("Failed to attach device. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.");
  }
  /** Creates a device. Asynchronously. */
  static async createDevice(e = {}) {
    var l, u;
    e = { ...Tc.defaultProps, ...e }, e.gl && (e.type = "webgl");
    const i = rv(e.devices) || qh;
    let s, o;
    switch (e.type) {
      case "webgpu":
        if (s = i.get("webgpu"), s)
          return await s.create(e);
        break;
      case "webgl":
        if (o = i.get("webgl"), o)
          return await o.create(e);
        break;
      case "unknown":
        const c = i.get("unknown");
        if (c)
          return await c.create(e);
        break;
      case "best-available":
        if (s = i.get("webgpu"), (l = s == null ? void 0 : s.isSupported) != null && l.call(s))
          return await s.create(e);
        if (o = i.get("webgl"), (u = o == null ? void 0 : o.isSupported) != null && u.call(o))
          return await o.create(e);
        break;
    }
    throw new Error("No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.");
  }
  static enforceWebGL2(e = !0) {
    const i = HTMLCanvasElement.prototype;
    if (!e && i.originalGetContext) {
      i.getContext = i.originalGetContext, i.originalGetContext = void 0;
      return;
    }
    i.originalGetContext = i.getContext, i.getContext = function(s, o) {
      return s === "webgl" || s === "experimental-webgl" ? this.originalGetContext("webgl2", o) : this.originalGetContext(s, o);
    };
  }
};
O(Tc, "defaultProps", {
  ...Bc.defaultProps,
  type: "best-available",
  devices: void 0
}), /** Global stats for all devices */
O(Tc, "stats", ey), /** Global log */
O(Tc, "log", $e);
let Ec = Tc;
function rv(t) {
  if (!t || (t == null ? void 0 : t.length) === 0)
    return null;
  const e = /* @__PURE__ */ new Map();
  for (const i of t)
    e.set(i.type, i);
  return e;
}
const UR = ya() && typeof document < "u", mp = () => UR && document.readyState === "complete", zR = {
  canvas: null,
  width: 800,
  // width are height are only used by headless gl
  height: 600,
  useDevicePixels: !0,
  autoResize: !0,
  container: null,
  visible: !0,
  colorSpace: "srgb",
  alphaMode: "opaque"
};
class ty {
  constructor(e) {
    O(this, "id");
    O(this, "props");
    O(this, "canvas");
    O(this, "htmlCanvas");
    O(this, "offscreenCanvas");
    O(this, "type");
    O(this, "width", 1);
    O(this, "height", 1);
    O(this, "resizeObserver");
    /** State used by luma.gl classes: TODO - move to canvasContext*/
    O(this, "_canvasSizeInfo", { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 });
    if (this.props = { ...zR, ...e }, e = this.props, !ya()) {
      this.id = "node-canvas-context", this.type = "node", this.width = this.props.width, this.height = this.props.height, this.canvas = null;
      return;
    }
    if (e.canvas)
      typeof e.canvas == "string" ? this.canvas = jR(e.canvas) : this.canvas = e.canvas;
    else {
      const i = $R(e), s = HR((e == null ? void 0 : e.container) || null);
      s.insertBefore(i, s.firstChild), this.canvas = i, e != null && e.visible || (this.canvas.style.visibility = "hidden");
    }
    this.canvas instanceof HTMLCanvasElement ? (this.id = this.canvas.id, this.type = "html-canvas", this.htmlCanvas = this.canvas) : (this.id = "offscreen-canvas", this.type = "offscreen-canvas", this.offscreenCanvas = this.canvas), this.canvas instanceof HTMLCanvasElement && e.autoResize && (this.resizeObserver = new ResizeObserver((i) => {
      for (const s of i)
        s.target === this.canvas && this.update();
    }), this.resizeObserver.observe(this.canvas));
  }
  /** Check if the DOM is loaded */
  static get isPageLoaded() {
    return mp();
  }
  /**
   * Returns the current DPR, if props.useDevicePixels is true
   * Device refers to physical
   */
  getDevicePixelRatio(e) {
    return typeof OffscreenCanvas < "u" && this.canvas instanceof OffscreenCanvas || (e = e === void 0 ? this.props.useDevicePixels : e, !e || e <= 0) ? 1 : e === !0 ? typeof window < "u" && window.devicePixelRatio || 1 : e;
  }
  /**
   * Returns the size of drawing buffer in device pixels.
   * @note This can be different from the 'CSS' size of a canvas, and also from the
   * canvas' internal drawing buffer size (.width, .height).
   * This is the size required to cover the canvas, adjusted for DPR
   */
  getPixelSize() {
    switch (this.type) {
      case "node":
        return [this.width, this.height];
      case "offscreen-canvas":
        return [this.canvas.width, this.canvas.height];
      case "html-canvas":
        const e = this.getDevicePixelRatio(), i = this.canvas;
        return i.parentElement ? [i.clientWidth * e, i.clientHeight * e] : [this.canvas.width, this.canvas.height];
      default:
        throw new Error(this.type);
    }
  }
  getAspect() {
    const [e, i] = this.getPixelSize();
    return e / i;
  }
  /**
   * Returns multiplier need to convert CSS size to Device size
   */
  cssToDeviceRatio() {
    try {
      const [e] = this.getDrawingBufferSize(), { clientWidth: i } = this._canvasSizeInfo;
      return i ? e / i : 1;
    } catch {
      return 1;
    }
  }
  /**
   * Maps CSS pixel position to device pixel position
   */
  cssToDevicePixels(e, i = !0) {
    const s = this.cssToDeviceRatio(), [o, l] = this.getDrawingBufferSize();
    return GR(e, s, o, l, i);
  }
  /**
   * Use devicePixelRatio to set canvas width and height
   * @note this is a raw port of luma.gl v8 code. Might be worth a review
   */
  setDevicePixelRatio(e, i = {}) {
    if (!this.htmlCanvas)
      return;
    let s = "width" in i ? i.width : this.htmlCanvas.clientWidth, o = "height" in i ? i.height : this.htmlCanvas.clientHeight;
    (!s || !o) && ($e.log(1, "Canvas clientWidth/clientHeight is 0")(), e = 1, s = this.htmlCanvas.width || 1, o = this.htmlCanvas.height || 1);
    const l = this._canvasSizeInfo;
    if (l.clientWidth !== s || l.clientHeight !== o || l.devicePixelRatio !== e) {
      let u = e;
      const c = Math.floor(s * u), x = Math.floor(o * u);
      this.htmlCanvas.width = c, this.htmlCanvas.height = x;
      const [w, C] = this.getDrawingBufferSize();
      (w !== c || C !== x) && (u = Math.min(w / s, C / o), this.htmlCanvas.width = Math.floor(s * u), this.htmlCanvas.height = Math.floor(o * u), $e.warn("Device pixel ratio clamped")()), this._canvasSizeInfo.clientWidth = s, this._canvasSizeInfo.clientHeight = o, this._canvasSizeInfo.devicePixelRatio = e;
    }
  }
  // PRIVATE
  /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */
  getDrawingBufferSize() {
    const e = this.device.gl;
    if (!e)
      throw new Error("canvas size");
    return [e.drawingBufferWidth, e.drawingBufferHeight];
  }
  /**
   * Allows subclass constructor to override the canvas id for auto created canvases.
   * This can really help when debugging DOM in apps that create multiple devices
   */
  _setAutoCreatedCanvasId(e) {
    var i;
    ((i = this.htmlCanvas) == null ? void 0 : i.id) === "lumagl-auto-created-canvas" && (this.htmlCanvas.id = e);
  }
}
/**
 * Get a 'lazy' promise that resolves when the DOM is loaded.
 * @note Since there may be limitations on number of `load` event listeners,
 * it is recommended avoid calling this function until actually needed.
 * I.e. don't call it until you know that you will be looking up a string in the DOM.
 */
O(ty, "pageLoaded", VR());
function VR() {
  return mp() || typeof window > "u" ? Promise.resolve() : new Promise((t) => {
    window.addEventListener("load", () => t());
  });
}
function HR(t) {
  if (typeof t == "string") {
    const e = document.getElementById(t);
    if (!e && !mp())
      throw new Error(`Accessing '${t}' before page was loaded`);
    if (!e)
      throw new Error(`${t} is not an HTML element`);
    return e;
  } else if (t)
    return t;
  return document.body;
}
function jR(t) {
  const e = document.getElementById(t);
  if (!e && !mp())
    throw new Error(`Accessing '${t}' before page was loaded`);
  if (!(e instanceof HTMLCanvasElement))
    throw new Error("Object is not a canvas element");
  return e;
}
function $R(t) {
  const { width: e, height: i } = t, s = document.createElement("canvas");
  return s.id = "lumagl-auto-created-canvas", s.width = e || 1, s.height = i || 1, s.style.width = Number.isFinite(e) ? `${e}px` : "100%", s.style.height = Number.isFinite(i) ? `${i}px` : "100%", s;
}
function GR(t, e, i, s, o) {
  const l = t, u = nv(l[0], e, i);
  let c = ov(l[1], e, s, o), x = nv(l[0] + 1, e, i);
  const w = x === i - 1 ? x : x - 1;
  x = ov(l[1] + 1, e, s, o);
  let C;
  return o ? (x = x === 0 ? x : x + 1, C = c, c = x) : C = x === s - 1 ? x : x - 1, {
    x: u,
    y: c,
    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
    width: Math.max(w - u + 1, 1),
    height: Math.max(C - c + 1, 1)
  };
}
function nv(t, e, i) {
  return Math.min(Math.round(t * e), i - 1);
}
function ov(t, e, i, s) {
  return s ? Math.max(0, i - 1 - Math.round(t * e)) : Math.min(Math.round(t * e), i - 1);
}
const go = class go extends vi {
  /** Do not use directly. Create with device.createTexture() */
  constructor(i, s, o = go.defaultProps) {
    super(i, s, o);
    /** dimension of this texture */
    O(this, "dimension");
    /** format of this texture */
    O(this, "format");
    /** width in pixels of this texture */
    O(this, "width");
    /** height in pixels of this texture */
    O(this, "height");
    /** depth of this texture */
    O(this, "depth");
    /** "Time" of last update. Monotonically increasing timestamp */
    O(this, "updateTimestamp");
    this.dimension = this.props.dimension, this.format = this.props.format, this.width = this.props.width, this.height = this.props.height, this.depth = this.props.depth, this.updateTimestamp = i.incrementTimestamp();
  }
  get [Symbol.toStringTag]() {
    return "Texture";
  }
};
O(go, "defaultProps", {
  ...vi.defaultProps,
  data: null,
  dimension: "2d",
  format: "rgba8unorm",
  width: void 0,
  height: void 0,
  depth: 1,
  mipmaps: !0,
  // type: undefined,
  compressed: !1,
  // mipLevels: 1,
  usage: 0,
  // usage: GPUTextureUsage.COPY_DST
  mipLevels: void 0,
  samples: void 0,
  type: void 0,
  sampler: {},
  view: void 0
}), O(go, "COPY_SRC", 1), O(go, "COPY_DST", 2), O(go, "TEXTURE_BINDING", 4), O(go, "STORAGE_BINDING", 8), O(go, "RENDER_ATTACHMENT", 16);
let Ur = go;
const Yf = class Yf extends vi {
  get [Symbol.toStringTag]() {
    return "TextureView";
  }
  /** Should not be constructed directly. Use `texture.createView(props)` */
  constructor(e, i) {
    super(e, i, Yf.defaultProps);
  }
};
O(Yf, "defaultProps", {
  ...vi.defaultProps,
  format: void 0,
  dimension: void 0,
  aspect: "all",
  baseMipLevel: 0,
  mipLevelCount: void 0,
  baseArrayLayer: 0,
  arrayLayerCount: void 0
});
let Df = Yf;
function XR(t, e, i) {
  let s = "";
  const o = e.split(/\r?\n/), l = t.slice().sort((u, c) => u.lineNum - c.lineNum);
  switch ((i == null ? void 0 : i.showSourceCode) || "no") {
    case "all":
      let u = 0;
      for (let c = 1; c <= o.length; c++)
        for (s += Aw(o[c - 1], c, i); l.length > u && l[u].lineNum === c; ) {
          const x = l[u++];
          s += av(x, o, x.lineNum, {
            ...i,
            inlineSource: !1
          });
        }
      return s;
    case "issues":
    case "no":
      for (const c of t)
        s += av(c, o, c.lineNum, {
          inlineSource: (i == null ? void 0 : i.showSourceCode) !== "no"
        });
      return s;
  }
}
function av(t, e, i, s) {
  if (s != null && s.inlineSource) {
    const o = WR(e, i), l = t.linePos > 0 ? `${" ".repeat(t.linePos + 5)}^^^
` : "";
    return `
${o}${l}${t.type.toUpperCase()}: ${t.message}

`;
  }
  return s != null && s.html ? `<div class='luma-compiler-log-error' style="color:red;"><b> ${t.type.toUpperCase()}: ${t.message}</b></div>` : `${t.type.toUpperCase()}: ${t.message}`;
}
function WR(t, e, i) {
  let s = "";
  for (let o = e - 2; o <= e; o++) {
    const l = t[o - 1];
    l !== void 0 && (s += Aw(l, e, i));
  }
  return s;
}
function Aw(t, e, i) {
  const s = i != null && i.html ? ZR(t) : t;
  return `${qR(String(e), 4)}: ${s}${i != null && i.html ? "<br/>" : `
`}`;
}
function qR(t, e) {
  let i = "";
  for (let s = t.length; s < e; ++s)
    i += " ";
  return i + t;
}
function ZR(t) {
  return t.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
}
function Tw(t, e) {
  return {
    name: KR(t, e),
    language: "glsl",
    version: JR(t)
  };
}
function KR(t, e = "unnamed") {
  const s = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(t);
  return s ? s[1] : e;
}
function JR(t) {
  let e = 100;
  const i = t.match(/[^\s]+/g);
  if (i && i.length >= 2 && i[0] === "#version") {
    const s = parseInt(i[1], 10);
    Number.isFinite(s) && (e = s);
  }
  return e;
}
const Qf = class Qf extends vi {
  /** Create a new Shader instance */
  constructor(i, s) {
    super(i, { id: YR(s), ...s }, Qf.defaultProps);
    /** The stage of this shader */
    O(this, "stage");
    /** The source code of this shader */
    O(this, "source");
    /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */
    O(this, "compilationStatus", "pending");
    this.stage = this.props.stage, this.source = this.props.source;
  }
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  /** Get compiler log synchronously (WebGL only) */
  getCompilationInfoSync() {
    return null;
  }
  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */
  getTranslatedSource() {
    return null;
  }
  // PORTABLE HELPERS
  /** In browser logging of errors */
  async debugShader(i = this.props.debug) {
    switch (i) {
      case "never":
        return;
      case "errors":
        if (this.compilationStatus === "success")
          return;
        break;
    }
    const s = await this.getCompilationInfo();
    this.props.debug === "warnings" && (s == null ? void 0 : s.length) === 0 || this._displayShaderLog(s);
  }
  // PRIVATE
  /** In-browser UI logging of errors */
  _displayShaderLog(i) {
    var w;
    if (typeof document > "u" || !(document != null && document.createElement))
      return;
    const s = Tw(this.source).name, o = `${this.stage} ${s}`;
    let l = XR(i, this.source, { showSourceCode: "all", html: !0 });
    const u = this.getTranslatedSource();
    u && (l += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${u}</pre></code>`);
    const c = document.createElement("Button");
    c.innerHTML = `
<h1>Shader Compilation Error in ${o}</h1><br /><br />
<code style="user-select:text;"><pre>
${l}
</pre></code>`, c.style.top = "10px", c.style.left = "10px", c.style.position = "absolute", c.style.zIndex = "9999", c.style.width = "100%", c.style.textAlign = "left", document.body.appendChild(c);
    const x = document.getElementsByClassName("luma-compiler-log-error");
    (w = x[0]) != null && w.scrollIntoView && x[0].scrollIntoView(), c.onclick = () => {
      const C = `data:text/plain,${encodeURIComponent(this.source)}`;
      navigator.clipboard.writeText(C);
    };
  }
};
O(Qf, "defaultProps", {
  ...vi.defaultProps,
  language: "auto",
  stage: void 0,
  source: "",
  sourceMap: null,
  entryPoint: "main",
  debug: "errors"
});
let Of = Qf;
function YR(t) {
  return Tw(t.source).name || t.id || ba(`unnamed ${t.stage}-shader`);
}
const ep = class ep extends vi {
  get [Symbol.toStringTag]() {
    return "Sampler";
  }
  constructor(e, i) {
    super(e, i, ep.defaultProps);
  }
};
O(ep, "defaultProps", {
  ...vi.defaultProps,
  type: "color-sampler",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge",
  addressModeW: "clamp-to-edge",
  magFilter: "nearest",
  minFilter: "nearest",
  mipmapFilter: "nearest",
  lodMinClamp: 0,
  lodMaxClamp: 32,
  // Per WebGPU spec
  compare: "less-equal",
  maxAnisotropy: 1
});
let Ff = ep;
const tp = class tp extends vi {
  constructor(i, s = {}) {
    super(i, s, tp.defaultProps);
    /** Width of all attachments in this framebuffer */
    O(this, "width");
    /** Height of all attachments in this framebuffer */
    O(this, "height");
    /** Color attachments */
    O(this, "colorAttachments", []);
    /** Depth-stencil attachment, if provided */
    O(this, "depthStencilAttachment", null);
    this.width = this.props.width, this.height = this.props.height;
  }
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  resize(i) {
    let s = !i;
    if (i) {
      const [o, l] = Array.isArray(i) ? i : [i.width, i.height];
      s = s || l !== this.height || o !== this.width, this.width = o, this.height = l;
    }
    s && ($e.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)(), this.resizeAttachments(this.width, this.height));
  }
  /** Auto creates any textures */
  autoCreateAttachmentTextures() {
    if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment)
      throw new Error("Framebuffer has noattachments");
    this.colorAttachments = this.props.colorAttachments.map((s) => {
      if (typeof s == "string") {
        const o = this.createColorTexture(s);
        return this.attachResource(o), o.view;
      }
      return s instanceof Ur ? s.view : s;
    });
    const i = this.props.depthStencilAttachment;
    if (i)
      if (typeof i == "string") {
        const s = this.createDepthStencilTexture(i);
        this.attachResource(s), this.depthStencilAttachment = s.view;
      } else i instanceof Ur ? this.depthStencilAttachment = i.view : this.depthStencilAttachment = i;
  }
  /** Create a color texture */
  createColorTexture(i) {
    return this.device.createTexture({
      id: "color-attachment",
      usage: Ur.RENDER_ATTACHMENT,
      format: i,
      width: this.width,
      height: this.height
    });
  }
  /** Create depth stencil texture */
  createDepthStencilTexture(i) {
    return this.device.createTexture({
      id: "depth-stencil-attachment",
      usage: Ur.RENDER_ATTACHMENT,
      format: i,
      width: this.width,
      height: this.height
    });
  }
  /**
   * Default implementation of resize
   * Creates new textures with correct size for all attachments.
   * and destroys existing textures if owned
   */
  resizeAttachments(i, s) {
    for (let o = 0; o < this.colorAttachments.length; ++o)
      if (this.colorAttachments[o]) {
        const l = this.device._createTexture({
          ...this.colorAttachments[o].props,
          width: i,
          height: s
        });
        this.destroyAttachedResource(this.colorAttachments[o]), this.colorAttachments[o] = l.view, this.attachResource(l.view);
      }
    if (this.depthStencilAttachment) {
      const o = this.device._createTexture({
        ...this.depthStencilAttachment.props,
        width: i,
        height: s
      });
      this.destroyAttachedResource(this.depthStencilAttachment), this.depthStencilAttachment = o.view, this.attachResource(o);
    }
  }
};
O(tp, "defaultProps", {
  ...vi.defaultProps,
  width: 1,
  height: 1,
  colorAttachments: [],
  // ['rgba8unorm'],
  depthStencilAttachment: null
  // 'depth24plus-stencil8'
});
let kf = tp;
const ip = class ip extends vi {
  constructor(i, s) {
    super(i, s, ip.defaultProps);
    /** The merged layout */
    O(this, "shaderLayout");
    /** Buffer map describing buffer interleaving etc */
    O(this, "bufferLayout");
    /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */
    O(this, "linkStatus", "pending");
    /** The hash of the pipeline */
    O(this, "hash", "");
    this.shaderLayout = this.props.shaderLayout, this.bufferLayout = this.props.bufferLayout || [];
  }
  get [Symbol.toStringTag]() {
    return "RenderPipeline";
  }
  // DEPRECATED METHODS
  /**
   * Uniforms
   * @deprecated Use uniforms buffers
   * @note textures, samplers and uniform buffers should be set via `setBindings()`, these are not considered uniforms.
   * @note In WebGL uniforms have a performance penalty, they are reset before each call to enable pipeline sharing.
   */
  setUniformsWebGL(i) {
    throw new Error("Use uniform blocks");
  }
};
O(ip, "defaultProps", {
  ...vi.defaultProps,
  vs: null,
  vertexEntryPoint: "vertexMain",
  vsConstants: {},
  fs: null,
  fragmentEntryPoint: "fragmentMain",
  fsConstants: {},
  shaderLayout: null,
  bufferLayout: [],
  topology: "triangle-list",
  parameters: {},
  // isInstanced: false,
  // instanceCount: 0,
  // vertexCount: 0,
  bindings: {},
  uniforms: {}
});
let Dc = ip;
const sp = class sp extends vi {
  get [Symbol.toStringTag]() {
    return "RenderPass";
  }
  constructor(e, i) {
    super(e, i, sp.defaultProps);
  }
};
/** Default properties for RenderPass */
O(sp, "defaultProps", {
  ...vi.defaultProps,
  framebuffer: null,
  parameters: void 0,
  clearColor: [0, 0, 0, 0],
  clearDepth: 1,
  clearStencil: 0,
  depthReadOnly: !1,
  stencilReadOnly: !1,
  discard: !1,
  occlusionQuerySet: void 0,
  timestampQuerySet: void 0,
  beginTimestampIndex: void 0,
  endTimestampIndex: void 0
});
let Ym = sp;
const rp = class rp extends vi {
  constructor(i, s) {
    super(i, s, rp.defaultProps);
    O(this, "hash", "");
  }
  get [Symbol.toStringTag]() {
    return "ComputePipeline";
  }
};
O(rp, "defaultProps", {
  ...vi.defaultProps,
  shader: void 0,
  entryPoint: void 0,
  constants: {},
  shaderLayout: void 0
});
let Nf = rp;
const np = class np extends vi {
  get [Symbol.toStringTag]() {
    return "CommandEncoder";
  }
  constructor(e, i) {
    super(e, i, np.defaultProps);
  }
};
O(np, "defaultProps", {
  ...vi.defaultProps,
  measureExecutionTime: void 0
});
let Qm = np;
const op = class op extends vi {
  get [Symbol.toStringTag]() {
    return "CommandBuffer";
  }
  constructor(e, i) {
    super(e, i, op.defaultProps);
  }
};
O(op, "defaultProps", {
  ...vi.defaultProps
});
let eg = op;
function QR(t) {
  const [e, i] = tM[t], s = e === "i32" || e === "u32", o = e !== "u32", l = iM[e] * i, u = eM(e, i);
  return {
    dataType: e,
    components: i,
    defaultVertexFormat: u,
    byteLength: l,
    integer: s,
    signed: o
  };
}
function eM(t, e) {
  let i;
  switch (t) {
    case "f32":
      i = "float32";
      break;
    case "i32":
      i = "sint32";
      break;
    case "u32":
      i = "uint32";
      break;
    case "f16":
      return e <= 2 ? "float16x2" : "float16x4";
  }
  return e === 1 ? i : `${i}x${e}`;
}
const tM = {
  f32: ["f32", 1],
  "vec2<f32>": ["f32", 2],
  "vec3<f32>": ["f32", 3],
  "vec4<f32>": ["f32", 4],
  f16: ["f16", 1],
  "vec2<f16>": ["f16", 2],
  "vec3<f16>": ["f16", 3],
  "vec4<f16>": ["f16", 4],
  i32: ["i32", 1],
  "vec2<i32>": ["i32", 2],
  "vec3<i32>": ["i32", 3],
  "vec4<i32>": ["i32", 4],
  u32: ["u32", 1],
  "vec2<u32>": ["u32", 2],
  "vec3<u32>": ["u32", 3],
  "vec4<u32>": ["u32", 4]
}, iM = {
  f32: 4,
  f16: 2,
  i32: 4,
  u32: 4
  // 'bool-webgl': 4,
};
function Ew(t) {
  let e;
  t.endsWith("-webgl") && (t.replace("-webgl", ""), e = !0);
  const [i, s] = t.split("x"), o = i, l = s ? parseInt(s) : 1, u = xw(o), c = {
    type: o,
    components: l,
    byteLength: u.byteLength * l,
    integer: u.integer,
    signed: u.signed,
    normalized: u.normalized
  };
  return e && (c.webglOnly = !0), c;
}
function Sw(t, e) {
  const i = {};
  for (const s of t.attributes)
    i[s.name] = rM(t, e, s.name);
  return i;
}
function sM(t, e, i = 16) {
  const s = Sw(t, e), o = new Array(i).fill(null);
  for (const l of Object.values(s))
    o[l.location] = l;
  return o;
}
function rM(t, e, i) {
  const s = nM(t, i), o = oM(e, i);
  if (!s)
    return null;
  const l = QR(s.type), u = (o == null ? void 0 : o.vertexFormat) || l.defaultVertexFormat, c = Ew(u);
  return {
    attributeName: (o == null ? void 0 : o.attributeName) || s.name,
    bufferName: (o == null ? void 0 : o.bufferName) || s.name,
    location: s.location,
    shaderType: s.type,
    shaderDataType: l.dataType,
    shaderComponents: l.components,
    vertexFormat: u,
    bufferDataType: c.type,
    bufferComponents: c.components,
    // normalized is a property of the buffer's vertex format
    normalized: c.normalized,
    // integer is a property of the shader declaration
    integer: l.integer,
    stepMode: (o == null ? void 0 : o.stepMode) || s.stepMode,
    byteOffset: (o == null ? void 0 : o.byteOffset) || 0,
    byteStride: (o == null ? void 0 : o.byteStride) || 0
  };
}
function nM(t, e) {
  const i = t.attributes.find((s) => s.name === e);
  return i || $e.warn(`shader layout attribute "${e}" not present in shader`), i || null;
}
function oM(t, e) {
  aM(t);
  let i = lM(t, e);
  return i || (i = cM(t, e), i) ? i : ($e.warn(`layout for attribute "${e}" not present in buffer layout`), null);
}
function aM(t) {
  for (const e of t)
    (e.attributes && e.format || !e.attributes && !e.format) && $e.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
}
function lM(t, e) {
  for (const i of t)
    if (i.format && i.name === e)
      return {
        attributeName: i.name,
        bufferName: e,
        stepMode: i.stepMode,
        vertexFormat: i.format,
        // If offset is needed, use `attributes` field.
        byteOffset: 0,
        byteStride: i.byteStride || 0
      };
  return null;
}
function cM(t, e) {
  var i;
  for (const s of t) {
    let o = s.byteStride;
    if (typeof s.byteStride != "number")
      for (const u of s.attributes || []) {
        const c = Ew(u.format);
        o += c.byteLength;
      }
    const l = (i = s.attributes) == null ? void 0 : i.find((u) => u.attribute === e);
    if (l)
      return {
        attributeName: l.attribute,
        bufferName: s.name,
        stepMode: s.stepMode,
        vertexFormat: l.format,
        byteOffset: l.byteOffset,
        byteStride: o
      };
  }
  return null;
}
function hM(t, e) {
  const i = {
    ...t,
    attributes: t.attributes.map((s) => ({ ...s }))
  };
  for (const s of (e == null ? void 0 : e.attributes) || []) {
    const o = i.attributes.find((l) => l.name === s.name);
    o ? (o.type = s.type || o.type, o.stepMode = s.stepMode || o.stepMode) : $e.warn(`shader layout attribute ${s.name} not present in shader`);
  }
  return i;
}
const ap = class ap extends vi {
  constructor(i, s) {
    super(i, s, ap.defaultProps);
    /** Max number of vertex attributes */
    O(this, "maxVertexAttributes");
    /** Attribute infos indexed by location - TODO only needed by webgl module? */
    O(this, "attributeInfos");
    /** Index buffer */
    O(this, "indexBuffer", null);
    /** Attributes indexed by buffer slot */
    O(this, "attributes");
    this.maxVertexAttributes = i.limits.maxVertexAttributes, this.attributes = new Array(this.maxVertexAttributes).fill(null), this.attributeInfos = sM(s.renderPipeline.shaderLayout, s.renderPipeline.bufferLayout, this.maxVertexAttributes);
  }
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  // DEPRECATED METHODS
  /** @deprecated Set constant attributes (WebGL only) */
  setConstantWebGL(i, s) {
    throw new Error("constant attributes not supported");
  }
};
O(ap, "defaultProps", {
  ...vi.defaultProps,
  renderPipeline: null
});
let tg = ap;
const lp = class lp extends vi {
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  constructor(e, i) {
    super(e, i, lp.defaultProps);
  }
};
O(lp, "defaultProps", {
  ...vi.defaultProps,
  layout: void 0,
  buffers: {}
});
let ig = lp;
const cp = class cp extends vi {
  get [Symbol.toStringTag]() {
    return "QuerySet";
  }
  constructor(e, i) {
    super(e, i, cp.defaultProps);
  }
};
O(cp, "defaultProps", {
  ...vi.defaultProps,
  type: void 0,
  count: void 0
});
let sg = cp;
const uM = {
  f32: { type: "f32", components: 1 },
  i32: { type: "i32", components: 1 },
  u32: { type: "u32", components: 1 },
  // 'bool-webgl': {type: 'bool-webgl', components: 1},
  "vec2<f32>": { type: "f32", components: 2 },
  "vec3<f32>": { type: "f32", components: 3 },
  "vec4<f32>": { type: "f32", components: 4 },
  "vec2<i32>": { type: "i32", components: 2 },
  "vec3<i32>": { type: "i32", components: 3 },
  "vec4<i32>": { type: "i32", components: 4 },
  "vec2<u32>": { type: "u32", components: 2 },
  "vec3<u32>": { type: "u32", components: 3 },
  "vec4<u32>": { type: "u32", components: 4 },
  "mat2x2<f32>": { type: "f32", components: 4 },
  "mat2x3<f32>": { type: "f32", components: 6 },
  "mat2x4<f32>": { type: "f32", components: 8 },
  "mat3x2<f32>": { type: "f32", components: 6 },
  "mat3x3<f32>": { type: "f32", components: 9 },
  "mat3x4<f32>": { type: "f32", components: 12 },
  "mat4x2<f32>": { type: "f32", components: 8 },
  "mat4x3<f32>": { type: "f32", components: 12 },
  "mat4x4<f32>": { type: "f32", components: 16 }
};
function dM(t) {
  const e = uM[t];
  return ri(t), e;
}
function fM(t, e) {
  switch (e) {
    case 1:
      return t;
    case 2:
      return t + t % 2;
    default:
      return t + (4 - t % 4) % 4;
  }
}
let jd;
function Cw(t) {
  return (!jd || jd.byteLength < t) && (jd = new ArrayBuffer(t)), jd;
}
function pM(t, e) {
  const i = Cw(t.BYTES_PER_ELEMENT * e);
  return new t(i, 0, e);
}
function _M(t) {
  const { target: e, source: i, start: s = 0, count: o = 1 } = t, l = i.length, u = o * l;
  let c = 0;
  for (let x = s; c < l; c++)
    e[x++] = i[c];
  for (; c < u; )
    c < u - c ? (e.copyWithin(s + c, s, s + c), c *= 2) : (e.copyWithin(s + c, s, s + u - c), c = u);
  return t.target;
}
const lv = 1024;
class mM {
  /** Create a new UniformBufferLayout given a map of attributes. */
  constructor(e) {
    O(this, "layout", {});
    /** number of bytes needed for buffer allocation */
    O(this, "byteLength");
    let i = 0;
    for (const [o, l] of Object.entries(e)) {
      const u = dM(l), { type: c, components: x } = u;
      i = fM(i, x);
      const w = i;
      i += x, this.layout[o] = { type: c, size: x, offset: w };
    }
    i += (4 - i % 4) % 4;
    const s = i * 4;
    this.byteLength = Math.max(s, lv);
  }
  /** Get the data for the complete buffer */
  getData(e) {
    const i = Math.max(this.byteLength, lv), s = Cw(i), o = {
      i32: new Int32Array(s),
      u32: new Uint32Array(s),
      f32: new Float32Array(s),
      // TODO not implemented
      f16: new Uint16Array(s)
    };
    for (const [l, u] of Object.entries(e)) {
      const c = this.layout[l];
      if (!c) {
        $e.warn(`Supplied uniform value ${l} not present in uniform block layout`)();
        continue;
      }
      const { type: x, size: w, offset: C } = c, M = o[x];
      if (w === 1) {
        if (typeof u != "number" && typeof u != "boolean") {
          $e.warn(`Supplied value for single component uniform ${l} is not a number: ${u}`)();
          continue;
        }
        M[C] = Number(u);
      } else {
        const P = xu(u);
        if (!P) {
          $e.warn(`Supplied value for multi component / array uniform ${l} is not a numeric array: ${u}`)();
          continue;
        }
        M.set(P, C);
      }
    }
    return new Uint8Array(s);
  }
  /** Does this layout have a field with specified name */
  has(e) {
    return !!this.layout[e];
  }
  /** Get offset and size for a field with specified name */
  get(e) {
    return this.layout[e];
  }
}
function gM(t, e, i = 16) {
  if (t !== e)
    return !1;
  const s = xu(t);
  if (!s)
    return !1;
  const o = xu(e);
  if (o && s.length === o.length) {
    for (let l = 0; l < s.length; ++l)
      if (o[l] !== s[l])
        return !1;
  }
  return !0;
}
function yM(t) {
  const e = xu(t);
  return e ? e.slice() : t;
}
class bM {
  constructor(e) {
    O(this, "name");
    O(this, "uniforms", {});
    O(this, "modifiedUniforms", {});
    O(this, "modified", !0);
    O(this, "bindingLayout", {});
    O(this, "needsRedraw", "initialized");
    var i;
    if (this.name = e == null ? void 0 : e.name, e != null && e.name && (e != null && e.shaderLayout)) {
      const s = (i = e == null ? void 0 : e.shaderLayout.bindings) == null ? void 0 : i.find((l) => l.type === "uniform" && l.name === (e == null ? void 0 : e.name));
      if (!s)
        throw new Error(e == null ? void 0 : e.name);
      const o = s;
      for (const l of o.uniforms || [])
        this.bindingLayout[l.name] = l;
    }
  }
  /** Set a map of uniforms */
  setUniforms(e) {
    for (const [i, s] of Object.entries(e))
      this._setUniform(i, s), this.needsRedraw || this.setNeedsRedraw(`${this.name}.${i}=${s}`);
  }
  setNeedsRedraw(e) {
    this.needsRedraw = this.needsRedraw || e;
  }
  /** Returns all uniforms */
  getAllUniforms() {
    return this.modifiedUniforms = {}, this.needsRedraw = !1, this.uniforms || {};
  }
  /** Set a single uniform */
  _setUniform(e, i) {
    gM(this.uniforms[e], i) || (this.uniforms[e] = yM(i), this.modifiedUniforms[e] = !0, this.modified = !0);
  }
}
class vM {
  /**
   * Create a new UniformStore instance
   * @param blocks
   */
  constructor(e) {
    /** Stores the uniform values for each uniform block */
    O(this, "uniformBlocks", /* @__PURE__ */ new Map());
    /** Can generate data for a uniform buffer for each block from data */
    O(this, "uniformBufferLayouts", /* @__PURE__ */ new Map());
    /** Actual buffer for the blocks */
    O(this, "uniformBuffers", /* @__PURE__ */ new Map());
    for (const [i, s] of Object.entries(e)) {
      const o = i, l = new mM(s.uniformTypes || {});
      this.uniformBufferLayouts.set(o, l);
      const u = new bM({ name: i });
      u.setUniforms(s.defaultUniforms || {}), this.uniformBlocks.set(o, u);
    }
  }
  /** Destroy any managed uniform buffers */
  destroy() {
    for (const e of this.uniformBuffers.values())
      e.destroy();
  }
  /**
   * Set uniforms
   * Makes all properties partial
   */
  setUniforms(e) {
    for (const [i, s] of Object.entries(e))
      this.uniformBlocks.get(i).setUniforms(s);
    this.updateUniformBuffers();
  }
  /** Get the required minimum length of the uniform buffer */
  getUniformBufferByteLength(e) {
    return this.uniformBufferLayouts.get(e).byteLength;
  }
  /** Get formatted binary memory that can be uploaded to a buffer */
  getUniformBufferData(e) {
    const i = this.uniformBlocks.get(e).getAllUniforms();
    return this.uniformBufferLayouts.get(e).getData(i);
  }
  /**
   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
   * The new buffer is initialized with current / supplied values
   */
  createUniformBuffer(e, i, s) {
    s && this.setUniforms(s);
    const o = this.getUniformBufferByteLength(i), l = e.createBuffer({
      usage: Vi.UNIFORM | Vi.COPY_DST,
      byteLength: o
    }), u = this.getUniformBufferData(i);
    return l.write(u), l;
  }
  /** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */
  getManagedUniformBuffer(e, i) {
    if (!this.uniformBuffers.get(i)) {
      const s = this.getUniformBufferByteLength(i), o = e.createBuffer({
        usage: Vi.UNIFORM | Vi.COPY_DST,
        byteLength: s
      });
      this.uniformBuffers.set(i, o);
    }
    return this.uniformBuffers.get(i);
  }
  /** Updates all uniform buffers where values have changed */
  updateUniformBuffers() {
    let e = !1;
    for (const i of this.uniformBlocks.keys()) {
      const s = this.updateUniformBuffer(i);
      e || (e = s);
    }
    return e && $e.log(3, `UniformStore.updateUniformBuffers(): ${e}`)(), e;
  }
  /** Update one uniform buffer. Only updates if values have changed */
  updateUniformBuffer(e) {
    const i = this.uniformBlocks.get(e), s = this.uniformBuffers.get(e);
    let o = !1;
    if (s && i.needsRedraw) {
      o || (o = i.needsRedraw);
      const l = this.getUniformBufferData(e);
      this.uniformBuffers.get(e).write(l);
      const c = this.uniformBlocks.get(e).getAllUniforms();
      $e.log(4, `Writing to uniform buffer ${String(e)}`, l, c)();
    }
    return o;
  }
}
function Iw(t) {
  const e = ArrayBuffer.isView(t) ? t.constructor : t;
  switch (e) {
    case Float32Array:
      return "float32";
    case Uint16Array:
      return "uint16";
    case Uint32Array:
      return "uint32";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int8Array:
      return "sint8";
    case Int16Array:
      return "sint16";
    case Int32Array:
      return "sint32";
    default:
      throw new Error(e.constructor.name);
  }
}
function Rw(t) {
  switch (t) {
    case "float32":
      return Float32Array;
    case "uint32":
      return Uint32Array;
    case "sint32":
      return Int32Array;
    case "uint16":
    case "unorm16":
      return Uint16Array;
    case "sint16":
    case "snorm16":
      return Int16Array;
    case "uint8":
    case "unorm8":
      return Uint8Array;
    case "sint8":
    case "snorm8":
      return Int8Array;
    default:
      throw new Error(t);
  }
}
function xM(t, e, i) {
  if (!e || e > 4)
    throw new Error(`size ${e}`);
  const s = e;
  let o = Iw(t);
  if (o === "uint8" && i && s === 1)
    return "unorm8-webgl";
  if (o === "uint8" && i && s === 3)
    return "unorm8x3-webgl";
  if (o === "uint8" || o === "sint8") {
    if (s === 1 || s === 3)
      throw new Error(`size: ${e}`);
    return i && (o = o.replace("int", "norm")), `${o}x${s}`;
  }
  if (o === "uint16" || o === "sint16") {
    if (s === 1 || s === 3)
      throw new Error(`size: ${e}`);
    return i && (o = o.replace("int", "norm")), `${o}x${s}`;
  }
  return s === 1 ? o : `${o}x${s}`;
}
function wM(t) {
  return xu(t) !== null || typeof t == "number" || typeof t == "boolean";
}
function iy(t) {
  const e = { bindings: {}, uniforms: {} };
  return Object.keys(t).forEach((i) => {
    const s = t[i];
    wM(s) ? e.uniforms[i] = s : e.bindings[i] = s;
  }), e;
}
function AM(t, e, i) {
  const { removedProps: s = {}, deprecatedProps: o = {}, replacedProps: l = {} } = i;
  for (const c in s)
    if (c in e) {
      const w = s[c] ? `${t}.${s[c]}` : "N/A";
      $e.removed(`${t}.${c}`, w)();
    }
  for (const c in o)
    if (c in e) {
      const x = o[c];
      $e.deprecated(`${t}.${c}`, `${t}.${x}`)();
    }
  let u = null;
  for (const [c, x] of Object.entries(l))
    c in e && ($e.deprecated(`${t}.${c}`, `${t}.${x}`)(), u = u || Object.assign({}, e), u[x] = e[c], delete u[c]);
  return u || e;
}
let TM = "";
async function EM(t, e) {
  return await new Promise((i, s) => {
    try {
      const o = new Image();
      o.onload = () => i(o), o.onerror = () => s(new Error(`Could not load image ${t}.`)), o.crossOrigin = (e == null ? void 0 : e.crossOrigin) || "anonymous", o.src = t.startsWith("http") ? t : TM + t;
    } catch (o) {
      s(o);
    }
  });
}
async function Mw(t, e) {
  const i = document.getElementsByTagName("head")[0];
  if (!i)
    throw new Error("loadScript");
  const s = document.createElement("script");
  return s.setAttribute("type", "text/javascript"), s.setAttribute("src", t), new Promise((o, l) => {
    s.onload = o, s.onerror = (u) => l(new Error(`Unable to load script '${t}': ${u}`)), i.appendChild(s);
  });
}
function rg(t, e, i) {
  if (t === e)
    return !0;
  if (!i || !t || !e)
    return !1;
  if (Array.isArray(t)) {
    if (!Array.isArray(e) || t.length !== e.length)
      return !1;
    for (let s = 0; s < t.length; s++)
      if (!rg(t[s], e[s], i - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof t == "object" && typeof e == "object") {
    const s = Object.keys(t), o = Object.keys(e);
    if (s.length !== o.length)
      return !1;
    for (const l of s)
      if (!e.hasOwnProperty(l) || !rg(t[l], e[l], i - 1))
        return !1;
    return !0;
  }
  return !1;
}
function SM(t) {
  return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(t) : setTimeout(t, 1e3 / 60);
}
function CM(t) {
  return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(t) : clearTimeout(t);
}
class IM {
  constructor() {
    this.constants = /* @__PURE__ */ new Map(), this.aliases = /* @__PURE__ */ new Map(), this.structs = /* @__PURE__ */ new Map();
  }
}
class To {
  constructor() {
  }
  get isAstNode() {
    return !0;
  }
  get astNodeType() {
    return "";
  }
  evaluate(e) {
    throw new Error("Cannot evaluate node");
  }
  evaluateString(e) {
    return this.evaluate(e).toString();
  }
  search(e) {
  }
  searchBlock(e, i) {
    if (e) {
      i(Lf.instance);
      for (const s of e)
        s instanceof Array ? this.searchBlock(s, i) : s.search(i);
      i(Uf.instance);
    }
  }
}
class Lf extends To {
}
Lf.instance = new Lf();
class Uf extends To {
}
Uf.instance = new Uf();
class Ni extends To {
  constructor() {
    super();
  }
}
class ng extends Ni {
  constructor(e, i, s, o, l, u) {
    super(), this.calls = /* @__PURE__ */ new Set(), this.name = e, this.args = i, this.returnType = s, this.body = o, this.startLine = l, this.endLine = u;
  }
  get astNodeType() {
    return "function";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class RM extends Ni {
  constructor(e) {
    super(), this.expression = e;
  }
  get astNodeType() {
    return "staticAssert";
  }
  search(e) {
    this.expression.search(e);
  }
}
class MM extends Ni {
  constructor(e, i) {
    super(), this.condition = e, this.body = i;
  }
  get astNodeType() {
    return "while";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e);
  }
}
class PM extends Ni {
  constructor(e) {
    super(), this.body = e;
  }
  get astNodeType() {
    return "continuing";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class BM extends Ni {
  constructor(e, i, s, o) {
    super(), this.init = e, this.condition = i, this.increment = s, this.body = o;
  }
  get astNodeType() {
    return "for";
  }
  search(e) {
    var i, s, o;
    (i = this.init) === null || i === void 0 || i.search(e), (s = this.condition) === null || s === void 0 || s.search(e), (o = this.increment) === null || o === void 0 || o.search(e), this.searchBlock(this.body, e);
  }
}
class Ka extends Ni {
  constructor(e, i, s, o, l) {
    super(), this.name = e, this.type = i, this.storage = s, this.access = o, this.value = l;
  }
  get astNodeType() {
    return "var";
  }
  search(e) {
    var i;
    e(this), (i = this.value) === null || i === void 0 || i.search(e);
  }
}
class Pw extends Ni {
  constructor(e, i, s) {
    super(), this.name = e, this.type = i, this.value = s;
  }
  get astNodeType() {
    return "override";
  }
  search(e) {
    var i;
    (i = this.value) === null || i === void 0 || i.search(e);
  }
}
class og extends Ni {
  constructor(e, i, s, o, l) {
    super(), this.name = e, this.type = i, this.storage = s, this.access = o, this.value = l;
  }
  get astNodeType() {
    return "let";
  }
  search(e) {
    var i;
    e(this), (i = this.value) === null || i === void 0 || i.search(e);
  }
}
class cv extends Ni {
  constructor(e, i, s, o, l) {
    super(), this.name = e, this.type = i, this.storage = s, this.access = o, this.value = l;
  }
  get astNodeType() {
    return "const";
  }
  evaluate(e) {
    return this.value.evaluate(e);
  }
  search(e) {
    var i;
    e(this), (i = this.value) === null || i === void 0 || i.search(e);
  }
}
var Oc;
(function(t) {
  t.increment = "++", t.decrement = "--";
})(Oc || (Oc = {}));
(function(t) {
  function e(i) {
    const s = i;
    if (s == "parse")
      throw new Error("Invalid value for IncrementOperator");
    return t[s];
  }
  t.parse = e;
})(Oc || (Oc = {}));
class DM extends Ni {
  constructor(e, i) {
    super(), this.operator = e, this.variable = i;
  }
  get astNodeType() {
    return "increment";
  }
  search(e) {
    this.variable.search(e);
  }
}
var wu;
(function(t) {
  t.assign = "=", t.addAssign = "+=", t.subtractAssin = "-=", t.multiplyAssign = "*=", t.divideAssign = "/=", t.moduloAssign = "%=", t.andAssign = "&=", t.orAssign = "|=", t.xorAssign = "^=", t.shiftLeftAssign = "<<=", t.shiftRightAssign = ">>=";
})(wu || (wu = {}));
(function(t) {
  function e(i) {
    const s = i;
    if (s == "parse")
      throw new Error("Invalid value for AssignOperator");
    return s;
  }
  t.parse = e;
})(wu || (wu = {}));
class OM extends Ni {
  constructor(e, i, s) {
    super(), this.operator = e, this.variable = i, this.value = s;
  }
  get astNodeType() {
    return "assign";
  }
  search(e) {
    this.variable.search(e), this.value.search(e);
  }
}
class Bw extends Ni {
  constructor(e, i) {
    super(), this.name = e, this.args = i;
  }
  get astNodeType() {
    return "call";
  }
  search(e) {
    for (const i of this.args)
      i.search(e);
    e(this);
  }
}
class FM extends Ni {
  constructor(e, i) {
    super(), this.body = e, this.continuing = i;
  }
  get astNodeType() {
    return "loop";
  }
}
class kM extends Ni {
  constructor(e, i) {
    super(), this.condition = e, this.body = i;
  }
  get astNodeType() {
    return "body";
  }
}
class NM extends Ni {
  constructor(e, i, s, o) {
    super(), this.condition = e, this.body = i, this.elseif = s, this.else = o;
  }
  get astNodeType() {
    return "if";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e), this.searchBlock(this.elseif, e), this.searchBlock(this.else, e);
  }
}
class LM extends Ni {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "return";
  }
  search(e) {
    var i;
    (i = this.value) === null || i === void 0 || i.search(e);
  }
}
class UM extends Ni {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "enable";
  }
}
class zM extends Ni {
  constructor(e) {
    super(), this.extensions = e;
  }
  get astNodeType() {
    return "requires";
  }
}
class VM extends Ni {
  constructor(e, i) {
    super(), this.severity = e, this.rule = i;
  }
  get astNodeType() {
    return "diagnostic";
  }
}
class Dw extends Ni {
  constructor(e, i) {
    super(), this.name = e, this.type = i;
  }
  get astNodeType() {
    return "alias";
  }
}
class HM extends Ni {
  constructor() {
    super();
  }
  get astNodeType() {
    return "discard";
  }
}
class jM extends Ni {
  constructor() {
    super();
  }
  get astNodeType() {
    return "break";
  }
}
class $M extends Ni {
  constructor() {
    super();
  }
  get astNodeType() {
    return "continue";
  }
}
class dl extends Ni {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "type";
  }
  get isStruct() {
    return !1;
  }
  get isArray() {
    return !1;
  }
}
class Za extends dl {
  constructor(e, i, s, o) {
    super(e), this.members = i, this.startLine = s, this.endLine = o;
  }
  get astNodeType() {
    return "struct";
  }
  get isStruct() {
    return !0;
  }
  /// Return the index of the member with the given name, or -1 if not found.
  getMemberIndex(e) {
    for (let i = 0; i < this.members.length; i++)
      if (this.members[i].name == e)
        return i;
    return -1;
  }
}
class Ow extends dl {
  constructor(e, i, s) {
    super(e), this.format = i, this.access = s;
  }
  get astNodeType() {
    return "template";
  }
}
class GM extends dl {
  constructor(e, i, s, o) {
    super(e), this.storage = i, this.type = s, this.access = o;
  }
  get astNodeType() {
    return "pointer";
  }
}
class Fw extends dl {
  constructor(e, i, s, o) {
    super(e), this.attributes = i, this.format = s, this.count = o;
  }
  get astNodeType() {
    return "array";
  }
  get isArray() {
    return !0;
  }
}
class ou extends dl {
  constructor(e, i, s) {
    super(e), this.format = i, this.access = s;
  }
  get astNodeType() {
    return "sampler";
  }
}
class Kn extends To {
  constructor() {
    super();
  }
}
class XM extends Kn {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "stringExpr";
  }
  toString() {
    return this.value;
  }
  evaluateString() {
    return this.value;
  }
}
class mc extends Kn {
  constructor(e, i) {
    super(), this.type = e, this.args = i;
  }
  get astNodeType() {
    return "createExpr";
  }
  search(e) {
    if (e(this), this.args)
      for (const i of this.args)
        i.search(e);
  }
  evaluate(e) {
    return this.args[0].evaluate(e);
  }
}
class kw extends Kn {
  constructor(e, i) {
    super(), this.name = e, this.args = i;
  }
  get astNodeType() {
    return "callExpr";
  }
  evaluate(e) {
    switch (this.name) {
      case "abs":
        return Math.abs(this.args[0].evaluate(e));
      case "acos":
        return Math.acos(this.args[0].evaluate(e));
      case "acosh":
        return Math.acosh(this.args[0].evaluate(e));
      case "asin":
        return Math.asin(this.args[0].evaluate(e));
      case "asinh":
        return Math.asinh(this.args[0].evaluate(e));
      case "atan":
        return Math.atan(this.args[0].evaluate(e));
      case "atan2":
        return Math.atan2(this.args[0].evaluate(e), this.args[1].evaluate(e));
      case "atanh":
        return Math.atanh(this.args[0].evaluate(e));
      case "ceil":
        return Math.ceil(this.args[0].evaluate(e));
      case "clamp":
        return Math.min(Math.max(this.args[0].evaluate(e), this.args[1].evaluate(e)), this.args[2].evaluate(e));
      case "cos":
        return Math.cos(this.args[0].evaluate(e));
      case "degrees":
        return this.args[0].evaluate(e) * 180 / Math.PI;
      case "distance":
        return Math.sqrt(Math.pow(this.args[0].evaluate(e) - this.args[1].evaluate(e), 2));
      case "dot":
      case "exp":
        return Math.exp(this.args[0].evaluate(e));
      case "exp2":
        return Math.pow(2, this.args[0].evaluate(e));
      case "floor":
        return Math.floor(this.args[0].evaluate(e));
      case "fma":
        return this.args[0].evaluate(e) * this.args[1].evaluate(e) + this.args[2].evaluate(e);
      case "fract":
        return this.args[0].evaluate(e) - Math.floor(this.args[0].evaluate(e));
      case "inverseSqrt":
        return 1 / Math.sqrt(this.args[0].evaluate(e));
      case "log":
        return Math.log(this.args[0].evaluate(e));
      case "log2":
        return Math.log2(this.args[0].evaluate(e));
      case "max":
        return Math.max(this.args[0].evaluate(e), this.args[1].evaluate(e));
      case "min":
        return Math.min(this.args[0].evaluate(e), this.args[1].evaluate(e));
      case "mix":
        return this.args[0].evaluate(e) * (1 - this.args[2].evaluate(e)) + this.args[1].evaluate(e) * this.args[2].evaluate(e);
      case "modf":
        return this.args[0].evaluate(e) - Math.floor(this.args[0].evaluate(e));
      case "pow":
        return Math.pow(this.args[0].evaluate(e), this.args[1].evaluate(e));
      case "radians":
        return this.args[0].evaluate(e) * Math.PI / 180;
      case "round":
        return Math.round(this.args[0].evaluate(e));
      case "sign":
        return Math.sign(this.args[0].evaluate(e));
      case "sin":
        return Math.sin(this.args[0].evaluate(e));
      case "sinh":
        return Math.sinh(this.args[0].evaluate(e));
      case "saturate":
        return Math.min(Math.max(this.args[0].evaluate(e), 0), 1);
      case "smoothstep":
        return this.args[0].evaluate(e) * this.args[0].evaluate(e) * (3 - 2 * this.args[0].evaluate(e));
      case "sqrt":
        return Math.sqrt(this.args[0].evaluate(e));
      case "step":
        return this.args[0].evaluate(e) < this.args[1].evaluate(e) ? 0 : 1;
      case "tan":
        return Math.tan(this.args[0].evaluate(e));
      case "tanh":
        return Math.tanh(this.args[0].evaluate(e));
      case "trunc":
        return Math.trunc(this.args[0].evaluate(e));
      default:
        throw new Error("Non const function: " + this.name);
    }
  }
  search(e) {
    for (const i of this.args)
      i.search(e);
    e(this);
  }
}
class ag extends Kn {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "varExpr";
  }
  search(e) {
    e(this), this.postfix && this.postfix.search(e);
  }
  evaluate(e) {
    const i = e.constants.get(this.name);
    if (!i)
      throw new Error("Cannot evaluate node");
    return i.evaluate(e);
  }
}
class hv extends Kn {
  constructor(e, i) {
    super(), this.name = e, this.initializer = i;
  }
  get astNodeType() {
    return "constExpr";
  }
  evaluate(e) {
    var i, s;
    if (this.initializer instanceof mc) {
      const o = (i = this.postfix) === null || i === void 0 ? void 0 : i.evaluateString(e), l = (s = this.initializer.type) === null || s === void 0 ? void 0 : s.name, u = e.structs.get(l), c = u == null ? void 0 : u.getMemberIndex(o);
      return c !== void 0 && c != -1 ? this.initializer.args[c].evaluate(e) : this.initializer.evaluate(e);
    }
    return this.initializer.evaluate(e);
  }
  search(e) {
    this.initializer.search(e);
  }
}
class uv extends Kn {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "literalExpr";
  }
  evaluate() {
    return this.value;
  }
}
class WM extends Kn {
  constructor(e, i) {
    super(), this.type = e, this.value = i;
  }
  get astNodeType() {
    return "bitcastExpr";
  }
  search(e) {
    this.value.search(e);
  }
}
class dv extends Kn {
  constructor(e) {
    super(), this.contents = e;
  }
  get astNodeType() {
    return "groupExpr";
  }
  evaluate(e) {
    return this.contents[0].evaluate(e);
  }
  search(e) {
    this.searchBlock(this.contents, e);
  }
}
class qM extends Kn {
  constructor(e) {
    super(), this.index = e;
  }
  search(e) {
    this.index.search(e);
  }
}
class Nw extends Kn {
  constructor() {
    super();
  }
}
class ZM extends Nw {
  constructor(e, i) {
    super(), this.operator = e, this.right = i;
  }
  get astNodeType() {
    return "unaryOp";
  }
  evaluate(e) {
    switch (this.operator) {
      case "+":
        return this.right.evaluate(e);
      case "-":
        return -this.right.evaluate(e);
      case "!":
        return this.right.evaluate(e) ? 0 : 1;
      case "~":
        return ~this.right.evaluate(e);
      default:
        throw new Error("Unknown unary operator: " + this.operator);
    }
  }
  search(e) {
    this.right.search(e);
  }
}
class Ln extends Nw {
  constructor(e, i, s) {
    super(), this.operator = e, this.left = i, this.right = s;
  }
  get astNodeType() {
    return "binaryOp";
  }
  evaluate(e) {
    switch (this.operator) {
      case "+":
        return this.left.evaluate(e) + this.right.evaluate(e);
      case "-":
        return this.left.evaluate(e) - this.right.evaluate(e);
      case "*":
        return this.left.evaluate(e) * this.right.evaluate(e);
      case "/":
        return this.left.evaluate(e) / this.right.evaluate(e);
      case "%":
        return this.left.evaluate(e) % this.right.evaluate(e);
      case "==":
        return this.left.evaluate(e) == this.right.evaluate(e) ? 1 : 0;
      case "!=":
        return this.left.evaluate(e) != this.right.evaluate(e) ? 1 : 0;
      case "<":
        return this.left.evaluate(e) < this.right.evaluate(e) ? 1 : 0;
      case ">":
        return this.left.evaluate(e) > this.right.evaluate(e) ? 1 : 0;
      case "<=":
        return this.left.evaluate(e) <= this.right.evaluate(e) ? 1 : 0;
      case ">=":
        return this.left.evaluate(e) >= this.right.evaluate(e) ? 1 : 0;
      case "&&":
        return this.left.evaluate(e) && this.right.evaluate(e) ? 1 : 0;
      case "||":
        return this.left.evaluate(e) || this.right.evaluate(e) ? 1 : 0;
      default:
        throw new Error(`Unknown operator ${this.operator}`);
    }
  }
  search(e) {
    this.left.search(e), this.right.search(e);
  }
}
class Lw extends To {
  constructor() {
    super();
  }
}
class KM extends Lw {
  constructor(e, i) {
    super(), this.selector = e, this.body = i;
  }
  get astNodeType() {
    return "case";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class JM extends Lw {
  constructor(e) {
    super(), this.body = e;
  }
  get astNodeType() {
    return "default";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class YM extends To {
  constructor(e, i, s) {
    super(), this.name = e, this.type = i, this.attributes = s;
  }
  get astNodeType() {
    return "argument";
  }
}
class QM extends To {
  constructor(e, i) {
    super(), this.condition = e, this.body = i;
  }
  get astNodeType() {
    return "elseif";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e);
  }
}
class eP extends To {
  constructor(e, i, s) {
    super(), this.name = e, this.type = i, this.attributes = s;
  }
  get astNodeType() {
    return "member";
  }
}
let tP = class extends To {
  constructor(e, i) {
    super(), this.name = e, this.value = i;
  }
  get astNodeType() {
    return "attribute";
  }
};
var Ce, be;
(function(t) {
  t[t.token = 0] = "token", t[t.keyword = 1] = "keyword", t[t.reserved = 2] = "reserved";
})(be || (be = {}));
class ve {
  constructor(e, i, s) {
    this.name = e, this.type = i, this.rule = s;
  }
  toString() {
    return this.name;
  }
}
class J {
}
Ce = J;
J.none = new ve("", be.reserved, "");
J.eof = new ve("EOF", be.token, "");
J.reserved = {
  asm: new ve("asm", be.reserved, "asm"),
  bf16: new ve("bf16", be.reserved, "bf16"),
  do: new ve("do", be.reserved, "do"),
  enum: new ve("enum", be.reserved, "enum"),
  f16: new ve("f16", be.reserved, "f16"),
  f64: new ve("f64", be.reserved, "f64"),
  handle: new ve("handle", be.reserved, "handle"),
  i8: new ve("i8", be.reserved, "i8"),
  i16: new ve("i16", be.reserved, "i16"),
  i64: new ve("i64", be.reserved, "i64"),
  mat: new ve("mat", be.reserved, "mat"),
  premerge: new ve("premerge", be.reserved, "premerge"),
  regardless: new ve("regardless", be.reserved, "regardless"),
  typedef: new ve("typedef", be.reserved, "typedef"),
  u8: new ve("u8", be.reserved, "u8"),
  u16: new ve("u16", be.reserved, "u16"),
  u64: new ve("u64", be.reserved, "u64"),
  unless: new ve("unless", be.reserved, "unless"),
  using: new ve("using", be.reserved, "using"),
  vec: new ve("vec", be.reserved, "vec"),
  void: new ve("void", be.reserved, "void")
};
J.keywords = {
  array: new ve("array", be.keyword, "array"),
  atomic: new ve("atomic", be.keyword, "atomic"),
  bool: new ve("bool", be.keyword, "bool"),
  f32: new ve("f32", be.keyword, "f32"),
  i32: new ve("i32", be.keyword, "i32"),
  mat2x2: new ve("mat2x2", be.keyword, "mat2x2"),
  mat2x3: new ve("mat2x3", be.keyword, "mat2x3"),
  mat2x4: new ve("mat2x4", be.keyword, "mat2x4"),
  mat3x2: new ve("mat3x2", be.keyword, "mat3x2"),
  mat3x3: new ve("mat3x3", be.keyword, "mat3x3"),
  mat3x4: new ve("mat3x4", be.keyword, "mat3x4"),
  mat4x2: new ve("mat4x2", be.keyword, "mat4x2"),
  mat4x3: new ve("mat4x3", be.keyword, "mat4x3"),
  mat4x4: new ve("mat4x4", be.keyword, "mat4x4"),
  ptr: new ve("ptr", be.keyword, "ptr"),
  sampler: new ve("sampler", be.keyword, "sampler"),
  sampler_comparison: new ve("sampler_comparison", be.keyword, "sampler_comparison"),
  struct: new ve("struct", be.keyword, "struct"),
  texture_1d: new ve("texture_1d", be.keyword, "texture_1d"),
  texture_2d: new ve("texture_2d", be.keyword, "texture_2d"),
  texture_2d_array: new ve("texture_2d_array", be.keyword, "texture_2d_array"),
  texture_3d: new ve("texture_3d", be.keyword, "texture_3d"),
  texture_cube: new ve("texture_cube", be.keyword, "texture_cube"),
  texture_cube_array: new ve("texture_cube_array", be.keyword, "texture_cube_array"),
  texture_multisampled_2d: new ve("texture_multisampled_2d", be.keyword, "texture_multisampled_2d"),
  texture_storage_1d: new ve("texture_storage_1d", be.keyword, "texture_storage_1d"),
  texture_storage_2d: new ve("texture_storage_2d", be.keyword, "texture_storage_2d"),
  texture_storage_2d_array: new ve("texture_storage_2d_array", be.keyword, "texture_storage_2d_array"),
  texture_storage_3d: new ve("texture_storage_3d", be.keyword, "texture_storage_3d"),
  texture_depth_2d: new ve("texture_depth_2d", be.keyword, "texture_depth_2d"),
  texture_depth_2d_array: new ve("texture_depth_2d_array", be.keyword, "texture_depth_2d_array"),
  texture_depth_cube: new ve("texture_depth_cube", be.keyword, "texture_depth_cube"),
  texture_depth_cube_array: new ve("texture_depth_cube_array", be.keyword, "texture_depth_cube_array"),
  texture_depth_multisampled_2d: new ve("texture_depth_multisampled_2d", be.keyword, "texture_depth_multisampled_2d"),
  texture_external: new ve("texture_external", be.keyword, "texture_external"),
  u32: new ve("u32", be.keyword, "u32"),
  vec2: new ve("vec2", be.keyword, "vec2"),
  vec3: new ve("vec3", be.keyword, "vec3"),
  vec4: new ve("vec4", be.keyword, "vec4"),
  bitcast: new ve("bitcast", be.keyword, "bitcast"),
  block: new ve("block", be.keyword, "block"),
  break: new ve("break", be.keyword, "break"),
  case: new ve("case", be.keyword, "case"),
  continue: new ve("continue", be.keyword, "continue"),
  continuing: new ve("continuing", be.keyword, "continuing"),
  default: new ve("default", be.keyword, "default"),
  diagnostic: new ve("diagnostic", be.keyword, "diagnostic"),
  discard: new ve("discard", be.keyword, "discard"),
  else: new ve("else", be.keyword, "else"),
  enable: new ve("enable", be.keyword, "enable"),
  fallthrough: new ve("fallthrough", be.keyword, "fallthrough"),
  false: new ve("false", be.keyword, "false"),
  fn: new ve("fn", be.keyword, "fn"),
  for: new ve("for", be.keyword, "for"),
  function: new ve("function", be.keyword, "function"),
  if: new ve("if", be.keyword, "if"),
  let: new ve("let", be.keyword, "let"),
  const: new ve("const", be.keyword, "const"),
  loop: new ve("loop", be.keyword, "loop"),
  while: new ve("while", be.keyword, "while"),
  private: new ve("private", be.keyword, "private"),
  read: new ve("read", be.keyword, "read"),
  read_write: new ve("read_write", be.keyword, "read_write"),
  return: new ve("return", be.keyword, "return"),
  requires: new ve("requires", be.keyword, "requires"),
  storage: new ve("storage", be.keyword, "storage"),
  switch: new ve("switch", be.keyword, "switch"),
  true: new ve("true", be.keyword, "true"),
  alias: new ve("alias", be.keyword, "alias"),
  type: new ve("type", be.keyword, "type"),
  uniform: new ve("uniform", be.keyword, "uniform"),
  var: new ve("var", be.keyword, "var"),
  override: new ve("override", be.keyword, "override"),
  workgroup: new ve("workgroup", be.keyword, "workgroup"),
  write: new ve("write", be.keyword, "write"),
  r8unorm: new ve("r8unorm", be.keyword, "r8unorm"),
  r8snorm: new ve("r8snorm", be.keyword, "r8snorm"),
  r8uint: new ve("r8uint", be.keyword, "r8uint"),
  r8sint: new ve("r8sint", be.keyword, "r8sint"),
  r16uint: new ve("r16uint", be.keyword, "r16uint"),
  r16sint: new ve("r16sint", be.keyword, "r16sint"),
  r16float: new ve("r16float", be.keyword, "r16float"),
  rg8unorm: new ve("rg8unorm", be.keyword, "rg8unorm"),
  rg8snorm: new ve("rg8snorm", be.keyword, "rg8snorm"),
  rg8uint: new ve("rg8uint", be.keyword, "rg8uint"),
  rg8sint: new ve("rg8sint", be.keyword, "rg8sint"),
  r32uint: new ve("r32uint", be.keyword, "r32uint"),
  r32sint: new ve("r32sint", be.keyword, "r32sint"),
  r32float: new ve("r32float", be.keyword, "r32float"),
  rg16uint: new ve("rg16uint", be.keyword, "rg16uint"),
  rg16sint: new ve("rg16sint", be.keyword, "rg16sint"),
  rg16float: new ve("rg16float", be.keyword, "rg16float"),
  rgba8unorm: new ve("rgba8unorm", be.keyword, "rgba8unorm"),
  rgba8unorm_srgb: new ve("rgba8unorm_srgb", be.keyword, "rgba8unorm_srgb"),
  rgba8snorm: new ve("rgba8snorm", be.keyword, "rgba8snorm"),
  rgba8uint: new ve("rgba8uint", be.keyword, "rgba8uint"),
  rgba8sint: new ve("rgba8sint", be.keyword, "rgba8sint"),
  bgra8unorm: new ve("bgra8unorm", be.keyword, "bgra8unorm"),
  bgra8unorm_srgb: new ve("bgra8unorm_srgb", be.keyword, "bgra8unorm_srgb"),
  rgb10a2unorm: new ve("rgb10a2unorm", be.keyword, "rgb10a2unorm"),
  rg11b10float: new ve("rg11b10float", be.keyword, "rg11b10float"),
  rg32uint: new ve("rg32uint", be.keyword, "rg32uint"),
  rg32sint: new ve("rg32sint", be.keyword, "rg32sint"),
  rg32float: new ve("rg32float", be.keyword, "rg32float"),
  rgba16uint: new ve("rgba16uint", be.keyword, "rgba16uint"),
  rgba16sint: new ve("rgba16sint", be.keyword, "rgba16sint"),
  rgba16float: new ve("rgba16float", be.keyword, "rgba16float"),
  rgba32uint: new ve("rgba32uint", be.keyword, "rgba32uint"),
  rgba32sint: new ve("rgba32sint", be.keyword, "rgba32sint"),
  rgba32float: new ve("rgba32float", be.keyword, "rgba32float"),
  static_assert: new ve("static_assert", be.keyword, "static_assert")
  // WGSL grammar has a few keywords that have different token names than the strings they
  // represent. Aliasing them here.
  /*int32: new TokenType("i32", TokenClass.keyword, "i32"),
      uint32: new TokenType("u32", TokenClass.keyword, "u32"),
      float32: new TokenType("f32", TokenClass.keyword, "f32"),
      pointer: new TokenType("ptr", TokenClass.keyword, "ptr"),*/
};
J.tokens = {
  decimal_float_literal: new ve("decimal_float_literal", be.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),
  hex_float_literal: new ve("hex_float_literal", be.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),
  int_literal: new ve("int_literal", be.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
  uint_literal: new ve("uint_literal", be.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
  ident: new ve("ident", be.token, /[_a-zA-Z][0-9a-zA-Z_]*/),
  and: new ve("and", be.token, "&"),
  and_and: new ve("and_and", be.token, "&&"),
  arrow: new ve("arrow ", be.token, "->"),
  attr: new ve("attr", be.token, "@"),
  forward_slash: new ve("forward_slash", be.token, "/"),
  bang: new ve("bang", be.token, "!"),
  bracket_left: new ve("bracket_left", be.token, "["),
  bracket_right: new ve("bracket_right", be.token, "]"),
  brace_left: new ve("brace_left", be.token, "{"),
  brace_right: new ve("brace_right", be.token, "}"),
  colon: new ve("colon", be.token, ":"),
  comma: new ve("comma", be.token, ","),
  equal: new ve("equal", be.token, "="),
  equal_equal: new ve("equal_equal", be.token, "=="),
  not_equal: new ve("not_equal", be.token, "!="),
  greater_than: new ve("greater_than", be.token, ">"),
  greater_than_equal: new ve("greater_than_equal", be.token, ">="),
  shift_right: new ve("shift_right", be.token, ">>"),
  less_than: new ve("less_than", be.token, "<"),
  less_than_equal: new ve("less_than_equal", be.token, "<="),
  shift_left: new ve("shift_left", be.token, "<<"),
  modulo: new ve("modulo", be.token, "%"),
  minus: new ve("minus", be.token, "-"),
  minus_minus: new ve("minus_minus", be.token, "--"),
  period: new ve("period", be.token, "."),
  plus: new ve("plus", be.token, "+"),
  plus_plus: new ve("plus_plus", be.token, "++"),
  or: new ve("or", be.token, "|"),
  or_or: new ve("or_or", be.token, "||"),
  paren_left: new ve("paren_left", be.token, "("),
  paren_right: new ve("paren_right", be.token, ")"),
  semicolon: new ve("semicolon", be.token, ";"),
  star: new ve("star", be.token, "*"),
  tilde: new ve("tilde", be.token, "~"),
  underscore: new ve("underscore", be.token, "_"),
  xor: new ve("xor", be.token, "^"),
  plus_equal: new ve("plus_equal", be.token, "+="),
  minus_equal: new ve("minus_equal", be.token, "-="),
  times_equal: new ve("times_equal", be.token, "*="),
  division_equal: new ve("division_equal", be.token, "/="),
  modulo_equal: new ve("modulo_equal", be.token, "%="),
  and_equal: new ve("and_equal", be.token, "&="),
  or_equal: new ve("or_equal", be.token, "|="),
  xor_equal: new ve("xor_equal", be.token, "^="),
  shift_right_equal: new ve("shift_right_equal", be.token, ">>="),
  shift_left_equal: new ve("shift_left_equal", be.token, "<<=")
};
J.simpleTokens = {
  "@": Ce.tokens.attr,
  "{": Ce.tokens.brace_left,
  "}": Ce.tokens.brace_right,
  ":": Ce.tokens.colon,
  ",": Ce.tokens.comma,
  "(": Ce.tokens.paren_left,
  ")": Ce.tokens.paren_right,
  ";": Ce.tokens.semicolon
};
J.literalTokens = {
  "&": Ce.tokens.and,
  "&&": Ce.tokens.and_and,
  "->": Ce.tokens.arrow,
  "/": Ce.tokens.forward_slash,
  "!": Ce.tokens.bang,
  "[": Ce.tokens.bracket_left,
  "]": Ce.tokens.bracket_right,
  "=": Ce.tokens.equal,
  "==": Ce.tokens.equal_equal,
  "!=": Ce.tokens.not_equal,
  ">": Ce.tokens.greater_than,
  ">=": Ce.tokens.greater_than_equal,
  ">>": Ce.tokens.shift_right,
  "<": Ce.tokens.less_than,
  "<=": Ce.tokens.less_than_equal,
  "<<": Ce.tokens.shift_left,
  "%": Ce.tokens.modulo,
  "-": Ce.tokens.minus,
  "--": Ce.tokens.minus_minus,
  ".": Ce.tokens.period,
  "+": Ce.tokens.plus,
  "++": Ce.tokens.plus_plus,
  "|": Ce.tokens.or,
  "||": Ce.tokens.or_or,
  "*": Ce.tokens.star,
  "~": Ce.tokens.tilde,
  _: Ce.tokens.underscore,
  "^": Ce.tokens.xor,
  "+=": Ce.tokens.plus_equal,
  "-=": Ce.tokens.minus_equal,
  "*=": Ce.tokens.times_equal,
  "/=": Ce.tokens.division_equal,
  "%=": Ce.tokens.modulo_equal,
  "&=": Ce.tokens.and_equal,
  "|=": Ce.tokens.or_equal,
  "^=": Ce.tokens.xor_equal,
  ">>=": Ce.tokens.shift_right_equal,
  "<<=": Ce.tokens.shift_left_equal
};
J.regexTokens = {
  decimal_float_literal: Ce.tokens.decimal_float_literal,
  hex_float_literal: Ce.tokens.hex_float_literal,
  int_literal: Ce.tokens.int_literal,
  uint_literal: Ce.tokens.uint_literal,
  ident: Ce.tokens.ident
};
J.storage_class = [
  Ce.keywords.function,
  Ce.keywords.private,
  Ce.keywords.workgroup,
  Ce.keywords.uniform,
  Ce.keywords.storage
];
J.access_mode = [
  Ce.keywords.read,
  Ce.keywords.write,
  Ce.keywords.read_write
];
J.sampler_type = [
  Ce.keywords.sampler,
  Ce.keywords.sampler_comparison
];
J.sampled_texture_type = [
  Ce.keywords.texture_1d,
  Ce.keywords.texture_2d,
  Ce.keywords.texture_2d_array,
  Ce.keywords.texture_3d,
  Ce.keywords.texture_cube,
  Ce.keywords.texture_cube_array
];
J.multisampled_texture_type = [
  Ce.keywords.texture_multisampled_2d
];
J.storage_texture_type = [
  Ce.keywords.texture_storage_1d,
  Ce.keywords.texture_storage_2d,
  Ce.keywords.texture_storage_2d_array,
  Ce.keywords.texture_storage_3d
];
J.depth_texture_type = [
  Ce.keywords.texture_depth_2d,
  Ce.keywords.texture_depth_2d_array,
  Ce.keywords.texture_depth_cube,
  Ce.keywords.texture_depth_cube_array,
  Ce.keywords.texture_depth_multisampled_2d
];
J.texture_external_type = [Ce.keywords.texture_external];
J.any_texture_type = [
  ...Ce.sampled_texture_type,
  ...Ce.multisampled_texture_type,
  ...Ce.storage_texture_type,
  ...Ce.depth_texture_type,
  ...Ce.texture_external_type
];
J.texel_format = [
  Ce.keywords.r8unorm,
  Ce.keywords.r8snorm,
  Ce.keywords.r8uint,
  Ce.keywords.r8sint,
  Ce.keywords.r16uint,
  Ce.keywords.r16sint,
  Ce.keywords.r16float,
  Ce.keywords.rg8unorm,
  Ce.keywords.rg8snorm,
  Ce.keywords.rg8uint,
  Ce.keywords.rg8sint,
  Ce.keywords.r32uint,
  Ce.keywords.r32sint,
  Ce.keywords.r32float,
  Ce.keywords.rg16uint,
  Ce.keywords.rg16sint,
  Ce.keywords.rg16float,
  Ce.keywords.rgba8unorm,
  Ce.keywords.rgba8unorm_srgb,
  Ce.keywords.rgba8snorm,
  Ce.keywords.rgba8uint,
  Ce.keywords.rgba8sint,
  Ce.keywords.bgra8unorm,
  Ce.keywords.bgra8unorm_srgb,
  Ce.keywords.rgb10a2unorm,
  Ce.keywords.rg11b10float,
  Ce.keywords.rg32uint,
  Ce.keywords.rg32sint,
  Ce.keywords.rg32float,
  Ce.keywords.rgba16uint,
  Ce.keywords.rgba16sint,
  Ce.keywords.rgba16float,
  Ce.keywords.rgba32uint,
  Ce.keywords.rgba32sint,
  Ce.keywords.rgba32float
];
J.const_literal = [
  Ce.tokens.int_literal,
  Ce.tokens.uint_literal,
  Ce.tokens.decimal_float_literal,
  Ce.tokens.hex_float_literal,
  Ce.keywords.true,
  Ce.keywords.false
];
J.literal_or_ident = [
  Ce.tokens.ident,
  Ce.tokens.int_literal,
  Ce.tokens.uint_literal,
  Ce.tokens.decimal_float_literal,
  Ce.tokens.hex_float_literal
];
J.element_count_expression = [
  Ce.tokens.int_literal,
  Ce.tokens.uint_literal,
  Ce.tokens.ident
];
J.template_types = [
  Ce.keywords.vec2,
  Ce.keywords.vec3,
  Ce.keywords.vec4,
  Ce.keywords.mat2x2,
  Ce.keywords.mat2x3,
  Ce.keywords.mat2x4,
  Ce.keywords.mat3x2,
  Ce.keywords.mat3x3,
  Ce.keywords.mat3x4,
  Ce.keywords.mat4x2,
  Ce.keywords.mat4x3,
  Ce.keywords.mat4x4,
  Ce.keywords.atomic,
  Ce.keywords.bitcast,
  ...Ce.any_texture_type
];
J.attribute_name = [Ce.tokens.ident, Ce.keywords.block, Ce.keywords.diagnostic];
J.assignment_operators = [
  Ce.tokens.equal,
  Ce.tokens.plus_equal,
  Ce.tokens.minus_equal,
  Ce.tokens.times_equal,
  Ce.tokens.division_equal,
  Ce.tokens.modulo_equal,
  Ce.tokens.and_equal,
  Ce.tokens.or_equal,
  Ce.tokens.xor_equal,
  Ce.tokens.shift_right_equal,
  Ce.tokens.shift_left_equal
];
J.increment_operators = [
  Ce.tokens.plus_plus,
  Ce.tokens.minus_minus
];
class fv {
  constructor(e, i, s) {
    this.type = e, this.lexeme = i, this.line = s;
  }
  toString() {
    return this.lexeme;
  }
  isTemplateType() {
    return J.template_types.indexOf(this.type) != -1;
  }
  isArrayType() {
    return this.type == J.keywords.array;
  }
  isArrayOrTemplateType() {
    return this.isArrayType() || this.isTemplateType();
  }
}
class iP {
  constructor(e) {
    this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = e ?? "";
  }
  /// Scan all tokens from the source.
  scanTokens() {
    for (; !this._isAtEnd(); )
      if (this._start = this._current, !this.scanToken())
        throw `Invalid syntax at line ${this._line}`;
    return this._tokens.push(new fv(J.eof, "", this._line)), this._tokens;
  }
  /// Scan a single token from the source.
  scanToken() {
    let e = this._advance();
    if (e == `
`)
      return this._line++, !0;
    if (this._isWhitespace(e))
      return !0;
    if (e == "/") {
      if (this._peekAhead() == "/") {
        for (; e != `
`; ) {
          if (this._isAtEnd())
            return !0;
          e = this._advance();
        }
        return this._line++, !0;
      } else if (this._peekAhead() == "*") {
        this._advance();
        let u = 1;
        for (; u > 0; ) {
          if (this._isAtEnd())
            return !0;
          if (e = this._advance(), e == `
`)
            this._line++;
          else if (e == "*") {
            if (this._peekAhead() == "/" && (this._advance(), u--, u == 0))
              return !0;
          } else e == "/" && this._peekAhead() == "*" && (this._advance(), u++);
        }
        return !0;
      }
    }
    const i = J.simpleTokens[e];
    if (i)
      return this._addToken(i), !0;
    let s = J.none;
    const o = this._isAlpha(e), l = e === "_";
    if (this._isAlphaNumeric(e)) {
      let u = this._peekAhead();
      for (; this._isAlphaNumeric(u); )
        e += this._advance(), u = this._peekAhead();
    }
    if (o) {
      const u = J.keywords[e];
      if (u)
        return this._addToken(u), !0;
    }
    if (o || l)
      return this._addToken(J.tokens.ident), !0;
    for (; ; ) {
      let u = this._findType(e);
      const c = this._peekAhead();
      if (e == "-" && this._tokens.length > 0) {
        if (c == "=")
          return this._current++, e += c, this._addToken(J.tokens.minus_equal), !0;
        if (c == "-")
          return this._current++, e += c, this._addToken(J.tokens.minus_minus), !0;
        const x = this._tokens.length - 1;
        if ((J.literal_or_ident.indexOf(this._tokens[x].type) != -1 || this._tokens[x].type == J.tokens.paren_right) && c != ">")
          return this._addToken(u), !0;
      }
      if (e == ">" && (c == ">" || c == "=")) {
        let x = !1, w = this._tokens.length - 1;
        for (let C = 0; C < 5 && w >= 0 && J.assignment_operators.indexOf(this._tokens[w].type) === -1; ++C, --w)
          if (this._tokens[w].type === J.tokens.less_than) {
            w > 0 && this._tokens[w - 1].isArrayOrTemplateType() && (x = !0);
            break;
          }
        if (x)
          return this._addToken(u), !0;
      }
      if (u === J.none) {
        let x = e, w = 0;
        const C = 2;
        for (let M = 0; M < C; ++M)
          if (x += this._peekAhead(M), u = this._findType(x), u !== J.none) {
            w = M;
            break;
          }
        if (u === J.none)
          return s === J.none ? !1 : (this._current--, this._addToken(s), !0);
        e = x, this._current += w + 1;
      }
      if (s = u, this._isAtEnd())
        break;
      e += this._advance();
    }
    return s === J.none ? !1 : (this._addToken(s), !0);
  }
  _findType(e) {
    for (const s in J.regexTokens) {
      const o = J.regexTokens[s];
      if (this._match(e, o.rule))
        return o;
    }
    const i = J.literalTokens[e];
    return i || J.none;
  }
  _match(e, i) {
    const s = i.exec(e);
    return s && s.index == 0 && s[0] == e;
  }
  _isAtEnd() {
    return this._current >= this._source.length;
  }
  _isAlpha(e) {
    return e >= "a" && e <= "z" || e >= "A" && e <= "Z";
  }
  _isAlphaNumeric(e) {
    return e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e == "_" || e >= "0" && e <= "9";
  }
  _isWhitespace(e) {
    return e == " " || e == "	" || e == "\r";
  }
  _advance(e = 0) {
    let i = this._source[this._current];
    return e = e || 0, e++, this._current += e, i;
  }
  _peekAhead(e = 0) {
    return e = e || 0, this._current + e >= this._source.length ? "\0" : this._source[this._current + e];
  }
  _addToken(e) {
    const i = this._source.substring(this._start, this._current);
    this._tokens.push(new fv(e, i, this._line));
  }
}
class sP {
  constructor() {
    this._tokens = [], this._current = 0, this._currentLine = 0, this._context = new IM(), this._deferArrayCountEval = [];
  }
  parse(e) {
    this._initialize(e), this._deferArrayCountEval.length = 0;
    const i = [];
    for (; !this._isAtEnd(); ) {
      const s = this._global_decl_or_directive();
      if (!s)
        break;
      i.push(s);
    }
    if (this._deferArrayCountEval.length > 0) {
      for (const s of this._deferArrayCountEval) {
        const o = s.arrayType, l = s.countNode;
        if (l instanceof ag) {
          const c = l.name, x = this._context.constants.get(c);
          if (x)
            try {
              const w = x.evaluate(this._context);
              o.count = w;
            } catch {
            }
        }
      }
      this._deferArrayCountEval.length = 0;
    }
    return i;
  }
  _initialize(e) {
    if (e)
      if (typeof e == "string") {
        const i = new iP(e);
        this._tokens = i.scanTokens();
      } else
        this._tokens = e;
    else
      this._tokens = [];
    this._current = 0;
  }
  _error(e, i) {
    return {
      token: e,
      message: i,
      toString: function() {
        return `${i}`;
      }
    };
  }
  _isAtEnd() {
    return this._current >= this._tokens.length || this._peek().type == J.eof;
  }
  _match(e) {
    if (e instanceof ve)
      return this._check(e) ? (this._advance(), !0) : !1;
    for (let i = 0, s = e.length; i < s; ++i) {
      const o = e[i];
      if (this._check(o))
        return this._advance(), !0;
    }
    return !1;
  }
  _consume(e, i) {
    if (this._check(e))
      return this._advance();
    throw this._error(this._peek(), i);
  }
  _check(e) {
    if (this._isAtEnd())
      return !1;
    const i = this._peek();
    if (e instanceof Array) {
      const s = i.type;
      return e.indexOf(s) != -1;
    }
    return i.type == e;
  }
  _advance() {
    var e, i;
    return this._currentLine = (i = (e = this._peek()) === null || e === void 0 ? void 0 : e.line) !== null && i !== void 0 ? i : -1, this._isAtEnd() || this._current++, this._previous();
  }
  _peek() {
    return this._tokens[this._current];
  }
  _previous() {
    return this._tokens[this._current - 1];
  }
  _global_decl_or_directive() {
    for (; this._match(J.tokens.semicolon) && !this._isAtEnd(); )
      ;
    if (this._match(J.keywords.alias)) {
      const i = this._type_alias();
      return this._consume(J.tokens.semicolon, "Expected ';'"), i;
    }
    if (this._match(J.keywords.diagnostic)) {
      const i = this._diagnostic();
      return this._consume(J.tokens.semicolon, "Expected ';'"), i;
    }
    if (this._match(J.keywords.requires)) {
      const i = this._requires_directive();
      return this._consume(J.tokens.semicolon, "Expected ';'"), i;
    }
    if (this._match(J.keywords.enable)) {
      const i = this._enable_directive();
      return this._consume(J.tokens.semicolon, "Expected ';'"), i;
    }
    const e = this._attribute();
    if (this._check(J.keywords.var)) {
      const i = this._global_variable_decl();
      return i != null && (i.attributes = e), this._consume(J.tokens.semicolon, "Expected ';'."), i;
    }
    if (this._check(J.keywords.override)) {
      const i = this._override_variable_decl();
      return i != null && (i.attributes = e), this._consume(J.tokens.semicolon, "Expected ';'."), i;
    }
    if (this._check(J.keywords.let)) {
      const i = this._global_let_decl();
      return i != null && (i.attributes = e), this._consume(J.tokens.semicolon, "Expected ';'."), i;
    }
    if (this._check(J.keywords.const)) {
      const i = this._global_const_decl();
      return i != null && (i.attributes = e), this._consume(J.tokens.semicolon, "Expected ';'."), i;
    }
    if (this._check(J.keywords.struct)) {
      const i = this._struct_decl();
      return i != null && (i.attributes = e), i;
    }
    if (this._check(J.keywords.fn)) {
      const i = this._function_decl();
      return i != null && (i.attributes = e), i;
    }
    return null;
  }
  _function_decl() {
    if (!this._match(J.keywords.fn))
      return null;
    const e = this._currentLine, i = this._consume(J.tokens.ident, "Expected function name.").toString();
    this._consume(J.tokens.paren_left, "Expected '(' for function arguments.");
    const s = [];
    if (!this._check(J.tokens.paren_right))
      do {
        if (this._check(J.tokens.paren_right))
          break;
        const c = this._attribute(), x = this._consume(J.tokens.ident, "Expected argument name.").toString();
        this._consume(J.tokens.colon, "Expected ':' for argument type.");
        const w = this._attribute(), C = this._type_decl();
        C != null && (C.attributes = w, s.push(new YM(x, C, c)));
      } while (this._match(J.tokens.comma));
    this._consume(J.tokens.paren_right, "Expected ')' after function arguments.");
    let o = null;
    if (this._match(J.tokens.arrow)) {
      const c = this._attribute();
      o = this._type_decl(), o != null && (o.attributes = c);
    }
    const l = this._compound_statement(), u = this._currentLine;
    return new ng(i, s, o, l, e, u);
  }
  _compound_statement() {
    const e = [];
    for (this._consume(J.tokens.brace_left, "Expected '{' for block."); !this._check(J.tokens.brace_right); ) {
      const i = this._statement();
      i !== null && e.push(i);
    }
    return this._consume(J.tokens.brace_right, "Expected '}' for block."), e;
  }
  _statement() {
    for (; this._match(J.tokens.semicolon) && !this._isAtEnd(); )
      ;
    if (this._check(J.tokens.attr) && this._attribute(), this._check(J.keywords.if))
      return this._if_statement();
    if (this._check(J.keywords.switch))
      return this._switch_statement();
    if (this._check(J.keywords.loop))
      return this._loop_statement();
    if (this._check(J.keywords.for))
      return this._for_statement();
    if (this._check(J.keywords.while))
      return this._while_statement();
    if (this._check(J.keywords.continuing))
      return this._continuing_statement();
    if (this._check(J.keywords.static_assert))
      return this._static_assert_statement();
    if (this._check(J.tokens.brace_left))
      return this._compound_statement();
    let e = null;
    return this._check(J.keywords.return) ? e = this._return_statement() : this._check([
      J.keywords.var,
      J.keywords.let,
      J.keywords.const
    ]) ? e = this._variable_statement() : this._match(J.keywords.discard) ? e = new HM() : this._match(J.keywords.break) ? e = new jM() : this._match(J.keywords.continue) ? e = new $M() : e = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement(), e != null && this._consume(J.tokens.semicolon, "Expected ';' after statement."), e;
  }
  _static_assert_statement() {
    if (!this._match(J.keywords.static_assert))
      return null;
    const e = this._optional_paren_expression();
    return new RM(e);
  }
  _while_statement() {
    if (!this._match(J.keywords.while))
      return null;
    const e = this._optional_paren_expression();
    this._check(J.tokens.attr) && this._attribute();
    const i = this._compound_statement();
    return new MM(e, i);
  }
  _continuing_statement() {
    if (!this._match(J.keywords.continuing))
      return null;
    const e = this._compound_statement();
    return new PM(e);
  }
  _for_statement() {
    if (!this._match(J.keywords.for))
      return null;
    this._consume(J.tokens.paren_left, "Expected '('.");
    const e = this._check(J.tokens.semicolon) ? null : this._for_init();
    this._consume(J.tokens.semicolon, "Expected ';'.");
    const i = this._check(J.tokens.semicolon) ? null : this._short_circuit_or_expression();
    this._consume(J.tokens.semicolon, "Expected ';'.");
    const s = this._check(J.tokens.paren_right) ? null : this._for_increment();
    this._consume(J.tokens.paren_right, "Expected ')'."), this._check(J.tokens.attr) && this._attribute();
    const o = this._compound_statement();
    return new BM(e, i, s, o);
  }
  _for_init() {
    return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
  }
  _for_increment() {
    return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
  }
  _variable_statement() {
    if (this._check(J.keywords.var)) {
      const e = this._variable_decl();
      if (e === null)
        throw this._error(this._peek(), "Variable declaration expected.");
      let i = null;
      return this._match(J.tokens.equal) && (i = this._short_circuit_or_expression()), new Ka(e.name, e.type, e.storage, e.access, i);
    }
    if (this._match(J.keywords.let)) {
      const e = this._consume(J.tokens.ident, "Expected name for let.").toString();
      let i = null;
      if (this._match(J.tokens.colon)) {
        const o = this._attribute();
        i = this._type_decl(), i != null && (i.attributes = o);
      }
      this._consume(J.tokens.equal, "Expected '=' for let.");
      const s = this._short_circuit_or_expression();
      return new og(e, i, null, null, s);
    }
    if (this._match(J.keywords.const)) {
      const e = this._consume(J.tokens.ident, "Expected name for const.").toString();
      let i = null;
      if (this._match(J.tokens.colon)) {
        const o = this._attribute();
        i = this._type_decl(), i != null && (i.attributes = o);
      }
      this._consume(J.tokens.equal, "Expected '=' for const.");
      const s = this._short_circuit_or_expression();
      return new cv(e, i, null, null, s);
    }
    return null;
  }
  _increment_decrement_statement() {
    const e = this._current, i = this._unary_expression();
    if (i == null)
      return null;
    if (!this._check(J.increment_operators))
      return this._current = e, null;
    const s = this._consume(J.increment_operators, "Expected increment operator");
    return new DM(s.type === J.tokens.plus_plus ? Oc.increment : Oc.decrement, i);
  }
  _assignment_statement() {
    let e = null;
    if (this._check(J.tokens.brace_right))
      return null;
    let i = this._match(J.tokens.underscore);
    if (i || (e = this._unary_expression()), !i && e == null)
      return null;
    const s = this._consume(J.assignment_operators, "Expected assignment operator."), o = this._short_circuit_or_expression();
    return new OM(wu.parse(s.lexeme), e, o);
  }
  _func_call_statement() {
    if (!this._check(J.tokens.ident))
      return null;
    const e = this._current, i = this._consume(J.tokens.ident, "Expected function name."), s = this._argument_expression_list();
    return s === null ? (this._current = e, null) : new Bw(i.lexeme, s);
  }
  _loop_statement() {
    if (!this._match(J.keywords.loop))
      return null;
    this._check(J.tokens.attr) && this._attribute(), this._consume(J.tokens.brace_left, "Expected '{' for loop.");
    const e = [];
    let i = this._statement();
    for (; i !== null; ) {
      if (Array.isArray(i))
        for (let o of i)
          e.push(o);
      else
        e.push(i);
      i = this._statement();
    }
    let s = null;
    return this._match(J.keywords.continuing) && (s = this._compound_statement()), this._consume(J.tokens.brace_right, "Expected '}' for loop."), new FM(e, s);
  }
  _switch_statement() {
    if (!this._match(J.keywords.switch))
      return null;
    const e = this._optional_paren_expression();
    this._check(J.tokens.attr) && this._attribute(), this._consume(J.tokens.brace_left, "Expected '{' for switch.");
    const i = this._switch_body();
    if (i == null || i.length == 0)
      throw this._error(this._previous(), "Expected 'case' or 'default'.");
    return this._consume(J.tokens.brace_right, "Expected '}' for switch."), new kM(e, i);
  }
  _switch_body() {
    const e = [];
    if (this._match(J.keywords.case)) {
      const i = this._case_selectors();
      this._match(J.tokens.colon), this._check(J.tokens.attr) && this._attribute(), this._consume(J.tokens.brace_left, "Exected '{' for switch case.");
      const s = this._case_body();
      this._consume(J.tokens.brace_right, "Exected '}' for switch case."), e.push(new KM(i, s));
    }
    if (this._match(J.keywords.default)) {
      this._match(J.tokens.colon), this._check(J.tokens.attr) && this._attribute(), this._consume(J.tokens.brace_left, "Exected '{' for switch default.");
      const i = this._case_body();
      this._consume(J.tokens.brace_right, "Exected '}' for switch default."), e.push(new JM(i));
    }
    if (this._check([J.keywords.default, J.keywords.case])) {
      const i = this._switch_body();
      e.push(i[0]);
    }
    return e;
  }
  _case_selectors() {
    const e = [
      this._shift_expression()
      //?.evaluate(this._context).toString() ?? "",
    ];
    for (; this._match(J.tokens.comma); )
      e.push(this._shift_expression());
    return e;
  }
  _case_body() {
    if (this._match(J.keywords.fallthrough))
      return this._consume(J.tokens.semicolon, "Expected ';'"), [];
    let e = this._statement();
    if (e == null)
      return [];
    e instanceof Array || (e = [e]);
    const i = this._case_body();
    return i.length == 0 ? e : [...e, i[0]];
  }
  _if_statement() {
    if (!this._match(J.keywords.if))
      return null;
    const e = this._optional_paren_expression();
    this._check(J.tokens.attr) && this._attribute();
    const i = this._compound_statement();
    let s = [];
    this._match_elseif() && (this._check(J.tokens.attr) && this._attribute(), s = this._elseif_statement(s));
    let o = null;
    return this._match(J.keywords.else) && (this._check(J.tokens.attr) && this._attribute(), o = this._compound_statement()), new NM(e, i, s, o);
  }
  _match_elseif() {
    return this._tokens[this._current].type === J.keywords.else && this._tokens[this._current + 1].type === J.keywords.if ? (this._advance(), this._advance(), !0) : !1;
  }
  _elseif_statement(e = []) {
    const i = this._optional_paren_expression(), s = this._compound_statement();
    return e.push(new QM(i, s)), this._match_elseif() && (this._check(J.tokens.attr) && this._attribute(), this._elseif_statement(e)), e;
  }
  _return_statement() {
    if (!this._match(J.keywords.return))
      return null;
    const e = this._short_circuit_or_expression();
    return new LM(e);
  }
  _short_circuit_or_expression() {
    let e = this._short_circuit_and_expr();
    for (; this._match(J.tokens.or_or); )
      e = new Ln(this._previous().toString(), e, this._short_circuit_and_expr());
    return e;
  }
  _short_circuit_and_expr() {
    let e = this._inclusive_or_expression();
    for (; this._match(J.tokens.and_and); )
      e = new Ln(this._previous().toString(), e, this._inclusive_or_expression());
    return e;
  }
  _inclusive_or_expression() {
    let e = this._exclusive_or_expression();
    for (; this._match(J.tokens.or); )
      e = new Ln(this._previous().toString(), e, this._exclusive_or_expression());
    return e;
  }
  _exclusive_or_expression() {
    let e = this._and_expression();
    for (; this._match(J.tokens.xor); )
      e = new Ln(this._previous().toString(), e, this._and_expression());
    return e;
  }
  _and_expression() {
    let e = this._equality_expression();
    for (; this._match(J.tokens.and); )
      e = new Ln(this._previous().toString(), e, this._equality_expression());
    return e;
  }
  _equality_expression() {
    const e = this._relational_expression();
    return this._match([J.tokens.equal_equal, J.tokens.not_equal]) ? new Ln(this._previous().toString(), e, this._relational_expression()) : e;
  }
  _relational_expression() {
    let e = this._shift_expression();
    for (; this._match([
      J.tokens.less_than,
      J.tokens.greater_than,
      J.tokens.less_than_equal,
      J.tokens.greater_than_equal
    ]); )
      e = new Ln(this._previous().toString(), e, this._shift_expression());
    return e;
  }
  _shift_expression() {
    let e = this._additive_expression();
    for (; this._match([J.tokens.shift_left, J.tokens.shift_right]); )
      e = new Ln(this._previous().toString(), e, this._additive_expression());
    return e;
  }
  _additive_expression() {
    let e = this._multiplicative_expression();
    for (; this._match([J.tokens.plus, J.tokens.minus]); )
      e = new Ln(this._previous().toString(), e, this._multiplicative_expression());
    return e;
  }
  _multiplicative_expression() {
    let e = this._unary_expression();
    for (; this._match([
      J.tokens.star,
      J.tokens.forward_slash,
      J.tokens.modulo
    ]); )
      e = new Ln(this._previous().toString(), e, this._unary_expression());
    return e;
  }
  _unary_expression() {
    return this._match([
      J.tokens.minus,
      J.tokens.bang,
      J.tokens.tilde,
      J.tokens.star,
      J.tokens.and
    ]) ? new ZM(this._previous().toString(), this._unary_expression()) : this._singular_expression();
  }
  _singular_expression() {
    const e = this._primary_expression(), i = this._postfix_expression();
    return i && (e.postfix = i), e;
  }
  _postfix_expression() {
    if (this._match(J.tokens.bracket_left)) {
      const e = this._short_circuit_or_expression();
      this._consume(J.tokens.bracket_right, "Expected ']'.");
      const i = new qM(e), s = this._postfix_expression();
      return s && (i.postfix = s), i;
    }
    if (this._match(J.tokens.period)) {
      const e = this._consume(J.tokens.ident, "Expected member name."), i = this._postfix_expression(), s = new XM(e.lexeme);
      return i && (s.postfix = i), s;
    }
    return null;
  }
  _getStruct(e) {
    return this._context.aliases.has(e) ? this._context.aliases.get(e).type : this._context.structs.has(e) ? this._context.structs.get(e) : null;
  }
  _primary_expression() {
    if (this._match(J.tokens.ident)) {
      const s = this._previous().toString();
      if (this._check(J.tokens.paren_left)) {
        const o = this._argument_expression_list(), l = this._getStruct(s);
        return l != null ? new mc(l, o) : new kw(s, o);
      }
      if (this._context.constants.has(s)) {
        const o = this._context.constants.get(s);
        return new hv(s, o.value);
      }
      return new ag(s);
    }
    if (this._match(J.const_literal))
      return new uv(parseFloat(this._previous().toString()));
    if (this._check(J.tokens.paren_left))
      return this._paren_expression();
    if (this._match(J.keywords.bitcast)) {
      this._consume(J.tokens.less_than, "Expected '<'.");
      const s = this._type_decl();
      this._consume(J.tokens.greater_than, "Expected '>'.");
      const o = this._paren_expression();
      return new WM(s, o);
    }
    const e = this._type_decl(), i = this._argument_expression_list();
    return new mc(e, i);
  }
  _argument_expression_list() {
    if (!this._match(J.tokens.paren_left))
      return null;
    const e = [];
    do {
      if (this._check(J.tokens.paren_right))
        break;
      const i = this._short_circuit_or_expression();
      e.push(i);
    } while (this._match(J.tokens.comma));
    return this._consume(J.tokens.paren_right, "Expected ')' for agument list"), e;
  }
  _optional_paren_expression() {
    this._match(J.tokens.paren_left);
    const e = this._short_circuit_or_expression();
    return this._match(J.tokens.paren_right), new dv([e]);
  }
  _paren_expression() {
    this._consume(J.tokens.paren_left, "Expected '('.");
    const e = this._short_circuit_or_expression();
    return this._consume(J.tokens.paren_right, "Expected ')'."), new dv([e]);
  }
  _struct_decl() {
    if (!this._match(J.keywords.struct))
      return null;
    const e = this._currentLine, i = this._consume(J.tokens.ident, "Expected name for struct.").toString();
    this._consume(J.tokens.brace_left, "Expected '{' for struct body.");
    const s = [];
    for (; !this._check(J.tokens.brace_right); ) {
      const u = this._attribute(), c = this._consume(J.tokens.ident, "Expected variable name.").toString();
      this._consume(J.tokens.colon, "Expected ':' for struct member type.");
      const x = this._attribute(), w = this._type_decl();
      w != null && (w.attributes = x), this._check(J.tokens.brace_right) ? this._match(J.tokens.comma) : this._consume(J.tokens.comma, "Expected ',' for struct member."), s.push(new eP(c, w, u));
    }
    this._consume(J.tokens.brace_right, "Expected '}' after struct body.");
    const o = this._currentLine, l = new Za(i, s, e, o);
    return this._context.structs.set(i, l), l;
  }
  _global_variable_decl() {
    const e = this._variable_decl();
    return e && this._match(J.tokens.equal) && (e.value = this._const_expression()), e;
  }
  _override_variable_decl() {
    const e = this._override_decl();
    return e && this._match(J.tokens.equal) && (e.value = this._const_expression()), e;
  }
  _global_const_decl() {
    if (!this._match(J.keywords.const))
      return null;
    const e = this._consume(J.tokens.ident, "Expected variable name");
    let i = null;
    if (this._match(J.tokens.colon)) {
      const l = this._attribute();
      i = this._type_decl(), i != null && (i.attributes = l);
    }
    let s = null;
    if (this._match(J.tokens.equal)) {
      const l = this._short_circuit_or_expression();
      if (l instanceof mc)
        s = l;
      else if (l instanceof hv && l.initializer instanceof mc)
        s = l.initializer;
      else
        try {
          const u = l.evaluate(this._context);
          s = new uv(u);
        } catch {
          s = l;
        }
    }
    const o = new cv(e.toString(), i, "", "", s);
    return this._context.constants.set(o.name, o), o;
  }
  _global_let_decl() {
    if (!this._match(J.keywords.let))
      return null;
    const e = this._consume(J.tokens.ident, "Expected variable name");
    let i = null;
    if (this._match(J.tokens.colon)) {
      const o = this._attribute();
      i = this._type_decl(), i != null && (i.attributes = o);
    }
    let s = null;
    return this._match(J.tokens.equal) && (s = this._const_expression()), new og(e.toString(), i, "", "", s);
  }
  _const_expression() {
    return this._short_circuit_or_expression();
  }
  _variable_decl() {
    if (!this._match(J.keywords.var))
      return null;
    let e = "", i = "";
    this._match(J.tokens.less_than) && (e = this._consume(J.storage_class, "Expected storage_class.").toString(), this._match(J.tokens.comma) && (i = this._consume(J.access_mode, "Expected access_mode.").toString()), this._consume(J.tokens.greater_than, "Expected '>'."));
    const s = this._consume(J.tokens.ident, "Expected variable name");
    let o = null;
    if (this._match(J.tokens.colon)) {
      const l = this._attribute();
      o = this._type_decl(), o != null && (o.attributes = l);
    }
    return new Ka(s.toString(), o, e, i, null);
  }
  _override_decl() {
    if (!this._match(J.keywords.override))
      return null;
    const e = this._consume(J.tokens.ident, "Expected variable name");
    let i = null;
    if (this._match(J.tokens.colon)) {
      const s = this._attribute();
      i = this._type_decl(), i != null && (i.attributes = s);
    }
    return new Pw(e.toString(), i, null);
  }
  _diagnostic() {
    this._consume(J.tokens.paren_left, "Expected '('");
    const e = this._consume(J.tokens.ident, "Expected severity control name.");
    this._consume(J.tokens.comma, "Expected ','");
    const i = this._consume(J.tokens.ident, "Expected diagnostic rule name.");
    return this._consume(J.tokens.paren_right, "Expected ')'"), new VM(e.toString(), i.toString());
  }
  _enable_directive() {
    const e = this._consume(J.tokens.ident, "identity expected.");
    return new UM(e.toString());
  }
  _requires_directive() {
    const e = [this._consume(J.tokens.ident, "identity expected.").toString()];
    for (; this._match(J.tokens.comma); ) {
      const i = this._consume(J.tokens.ident, "identity expected.");
      e.push(i.toString());
    }
    return new zM(e);
  }
  _type_alias() {
    const e = this._consume(J.tokens.ident, "identity expected.");
    this._consume(J.tokens.equal, "Expected '=' for type alias.");
    let i = this._type_decl();
    if (i === null)
      throw this._error(this._peek(), "Expected Type for Alias.");
    this._context.aliases.has(i.name) && (i = this._context.aliases.get(i.name).type);
    const s = new Dw(e.toString(), i);
    return this._context.aliases.set(s.name, s), s;
  }
  _type_decl() {
    if (this._check([
      J.tokens.ident,
      ...J.texel_format,
      J.keywords.bool,
      J.keywords.f32,
      J.keywords.i32,
      J.keywords.u32
    ])) {
      const s = this._advance(), o = s.toString();
      return this._context.structs.has(o) ? this._context.structs.get(o) : this._context.aliases.has(o) ? this._context.aliases.get(o).type : new dl(s.toString());
    }
    let e = this._texture_sampler_types();
    if (e)
      return e;
    if (this._check(J.template_types)) {
      let s = this._advance().toString(), o = null, l = null;
      return this._match(J.tokens.less_than) && (o = this._type_decl(), l = null, this._match(J.tokens.comma) && (l = this._consume(J.access_mode, "Expected access_mode for pointer").toString()), this._consume(J.tokens.greater_than, "Expected '>' for type.")), new Ow(s, o, l);
    }
    if (this._match(J.keywords.ptr)) {
      let s = this._previous().toString();
      this._consume(J.tokens.less_than, "Expected '<' for pointer.");
      const o = this._consume(J.storage_class, "Expected storage_class for pointer");
      this._consume(J.tokens.comma, "Expected ',' for pointer.");
      const l = this._type_decl();
      let u = null;
      return this._match(J.tokens.comma) && (u = this._consume(J.access_mode, "Expected access_mode for pointer").toString()), this._consume(J.tokens.greater_than, "Expected '>' for pointer."), new GM(s, o.toString(), l, u);
    }
    const i = this._attribute();
    if (this._match(J.keywords.array)) {
      let s = null, o = -1;
      const l = this._previous();
      let u = null;
      if (this._match(J.tokens.less_than)) {
        s = this._type_decl(), this._context.aliases.has(s.name) && (s = this._context.aliases.get(s.name).type);
        let x = "";
        if (this._match(J.tokens.comma)) {
          u = this._shift_expression();
          try {
            x = u.evaluate(this._context).toString(), u = null;
          } catch {
            x = "1";
          }
        }
        this._consume(J.tokens.greater_than, "Expected '>' for array."), o = x ? parseInt(x) : 0;
      }
      const c = new Fw(l.toString(), i, s, o);
      return u && this._deferArrayCountEval.push({ arrayType: c, countNode: u }), c;
    }
    return null;
  }
  _texture_sampler_types() {
    if (this._match(J.sampler_type))
      return new ou(this._previous().toString(), null, null);
    if (this._match(J.depth_texture_type))
      return new ou(this._previous().toString(), null, null);
    if (this._match(J.sampled_texture_type) || this._match(J.multisampled_texture_type)) {
      const e = this._previous();
      this._consume(J.tokens.less_than, "Expected '<' for sampler type.");
      const i = this._type_decl();
      return this._consume(J.tokens.greater_than, "Expected '>' for sampler type."), new ou(e.toString(), i, null);
    }
    if (this._match(J.storage_texture_type)) {
      const e = this._previous();
      this._consume(J.tokens.less_than, "Expected '<' for sampler type.");
      const i = this._consume(J.texel_format, "Invalid texel format.").toString();
      this._consume(J.tokens.comma, "Expected ',' after texel format.");
      const s = this._consume(J.access_mode, "Expected access mode for storage texture type.").toString();
      return this._consume(J.tokens.greater_than, "Expected '>' for sampler type."), new ou(e.toString(), i, s);
    }
    return null;
  }
  _attribute() {
    let e = [];
    for (; this._match(J.tokens.attr); ) {
      const i = this._consume(J.attribute_name, "Expected attribute name"), s = new tP(i.toString(), null);
      if (this._match(J.tokens.paren_left)) {
        if (s.value = this._consume(J.literal_or_ident, "Expected attribute value").toString(), this._check(J.tokens.comma)) {
          this._advance();
          do {
            const o = this._consume(J.literal_or_ident, "Expected attribute value").toString();
            s.value instanceof Array || (s.value = [s.value]), s.value.push(o);
          } while (this._match(J.tokens.comma));
        }
        this._consume(J.tokens.paren_right, "Expected ')'");
      }
      e.push(s);
    }
    return e.length == 0 ? null : e;
  }
}
class Sc {
  constructor(e, i) {
    this.name = e, this.attributes = i, this.size = 0;
  }
  get isArray() {
    return !1;
  }
  get isStruct() {
    return !1;
  }
  get isTemplate() {
    return !1;
  }
}
class pv {
  constructor(e, i, s) {
    this.name = e, this.type = i, this.attributes = s, this.offset = 0, this.size = 0;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray ? this.type.format : this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class $d extends Sc {
  constructor(e, i) {
    super(e, i), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = !1;
  }
  get isStruct() {
    return !0;
  }
}
class J_ extends Sc {
  constructor(e, i) {
    super(e, i), this.count = 0, this.stride = 0;
  }
  get isArray() {
    return !0;
  }
}
class _v extends Sc {
  constructor(e, i, s, o) {
    super(e, s), this.format = i, this.access = o;
  }
  get isTemplate() {
    return !0;
  }
}
var la;
(function(t) {
  t[t.Uniform = 0] = "Uniform", t[t.Storage = 1] = "Storage", t[t.Texture = 2] = "Texture", t[t.Sampler = 3] = "Sampler", t[t.StorageTexture = 4] = "StorageTexture";
})(la || (la = {}));
class Gd {
  constructor(e, i, s, o, l, u, c) {
    this.name = e, this.type = i, this.group = s, this.binding = o, this.attributes = l, this.resourceType = u, this.access = c;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get size() {
    return this.type.size;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray ? this.type.format : this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class rP {
  constructor(e, i) {
    this.name = e, this.type = i;
  }
}
class Xd {
  constructor(e, i) {
    this.align = e, this.size = i;
  }
}
class nP {
  constructor(e, i, s, o) {
    this.name = e, this.type = i, this.locationType = s, this.location = o, this.interpolation = null;
  }
}
class mv {
  constructor(e, i, s, o) {
    this.name = e, this.type = i, this.locationType = s, this.location = o;
  }
}
class oP {
  constructor(e, i, s, o) {
    this.name = e, this.type = i, this.attributes = s, this.id = o;
  }
}
class aP {
  constructor(e, i) {
    this.name = e, this.type = i;
  }
}
class lP {
  constructor(e, i = null) {
    this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = !1, this.calls = /* @__PURE__ */ new Set(), this.name = e, this.stage = i;
  }
}
class cP {
  constructor() {
    this.vertex = [], this.fragment = [], this.compute = [];
  }
}
class hP {
  constructor(e) {
    this.resources = null, this.inUse = !1, this.info = null, this.node = e;
  }
}
class yo {
  constructor(e) {
    this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new cP(), this.functions = [], this._types = /* @__PURE__ */ new Map(), this._functions = /* @__PURE__ */ new Map(), e && this.update(e);
  }
  _isStorageTexture(e) {
    return e.name == "texture_storage_1d" || e.name == "texture_storage_2d" || e.name == "texture_storage_2d_array" || e.name == "texture_storage_3d";
  }
  update(e) {
    const s = new sP().parse(e);
    for (const o of s)
      o instanceof ng && this._functions.set(o.name, new hP(o));
    for (const o of s)
      if (o instanceof Za) {
        const l = this._getTypeInfo(o, null);
        l instanceof $d && this.structs.push(l);
      }
    for (const o of s) {
      if (o instanceof Dw) {
        this.aliases.push(this._getAliasInfo(o));
        continue;
      }
      if (o instanceof Pw) {
        const l = o, u = this._getAttributeNum(l.attributes, "id", 0), c = l.type != null ? this._getTypeInfo(l.type, l.attributes) : null;
        this.overrides.push(new oP(l.name, c, l.attributes, u));
        continue;
      }
      if (this._isUniformVar(o)) {
        const l = o, u = this._getAttributeNum(l.attributes, "group", 0), c = this._getAttributeNum(l.attributes, "binding", 0), x = this._getTypeInfo(l.type, l.attributes), w = new Gd(l.name, x, u, c, l.attributes, la.Uniform, l.access);
        this.uniforms.push(w);
        continue;
      }
      if (this._isStorageVar(o)) {
        const l = o, u = this._getAttributeNum(l.attributes, "group", 0), c = this._getAttributeNum(l.attributes, "binding", 0), x = this._getTypeInfo(l.type, l.attributes), w = this._isStorageTexture(x), C = new Gd(l.name, x, u, c, l.attributes, w ? la.StorageTexture : la.Storage, l.access);
        this.storage.push(C);
        continue;
      }
      if (this._isTextureVar(o)) {
        const l = o, u = this._getAttributeNum(l.attributes, "group", 0), c = this._getAttributeNum(l.attributes, "binding", 0), x = this._getTypeInfo(l.type, l.attributes), w = this._isStorageTexture(x), C = new Gd(l.name, x, u, c, l.attributes, w ? la.StorageTexture : la.Texture, l.access);
        w ? this.storage.push(C) : this.textures.push(C);
        continue;
      }
      if (this._isSamplerVar(o)) {
        const l = o, u = this._getAttributeNum(l.attributes, "group", 0), c = this._getAttributeNum(l.attributes, "binding", 0), x = this._getTypeInfo(l.type, l.attributes), w = new Gd(l.name, x, u, c, l.attributes, la.Sampler, l.access);
        this.samplers.push(w);
        continue;
      }
      if (o instanceof ng) {
        const l = this._getAttribute(o, "vertex"), u = this._getAttribute(o, "fragment"), c = this._getAttribute(o, "compute"), x = l || u || c, w = new lP(o.name, x == null ? void 0 : x.name);
        w.startLine = o.startLine, w.endLine = o.endLine, this.functions.push(w), this._functions.get(o.name).info = w, x ? (this._functions.get(o.name).inUse = !0, w.inUse = !0, w.resources = this._findResources(o, !!x), w.inputs = this._getInputs(o.args), w.outputs = this._getOutputs(o.returnType), this.entry[x.name].push(w)) : (w.arguments = o.args.map((C) => new aP(C.name, this._getTypeInfo(C.type, C.attributes))), w.returnType = o.returnType ? this._getTypeInfo(o.returnType, o.attributes) : null);
        continue;
      }
    }
    for (const o of this._functions.values())
      o.info && (o.info.inUse = o.inUse, this._addCalls(o.node, o.info.calls));
    for (const o of this._functions.values())
      o.node.search((l) => {
        var u;
        if (l.astNodeType === "varExpr") {
          const c = l;
          for (const x of this.overrides)
            c.name == x.name && ((u = o.info) === null || u === void 0 || u.overrides.push(x));
        }
      });
    for (const o of this.uniforms)
      this._markStructsInUse(o.type);
    for (const o of this.storage)
      this._markStructsInUse(o.type);
  }
  _markStructsInUse(e) {
    if (e)
      if (e.isStruct) {
        if (e.inUse = !0, e.members)
          for (const i of e.members)
            this._markStructsInUse(i.type);
      } else if (e.isArray)
        this._markStructsInUse(e.format);
      else if (e.isTemplate)
        e.format && this._markStructsInUse(e.format);
      else {
        const i = this._getAlias(e.name);
        i && this._markStructsInUse(i);
      }
  }
  _addCalls(e, i) {
    var s;
    for (const o of e.calls) {
      const l = (s = this._functions.get(o.name)) === null || s === void 0 ? void 0 : s.info;
      l && i.add(l);
    }
  }
  /// Find a resource by its group and binding.
  findResource(e, i) {
    for (const s of this.uniforms)
      if (s.group == e && s.binding == i)
        return s;
    for (const s of this.storage)
      if (s.group == e && s.binding == i)
        return s;
    for (const s of this.textures)
      if (s.group == e && s.binding == i)
        return s;
    for (const s of this.samplers)
      if (s.group == e && s.binding == i)
        return s;
    return null;
  }
  _findResource(e) {
    for (const i of this.uniforms)
      if (i.name == e)
        return i;
    for (const i of this.storage)
      if (i.name == e)
        return i;
    for (const i of this.textures)
      if (i.name == e)
        return i;
    for (const i of this.samplers)
      if (i.name == e)
        return i;
    return null;
  }
  _markStructsFromAST(e) {
    const i = this._getTypeInfo(e, null);
    this._markStructsInUse(i);
  }
  _findResources(e, i) {
    const s = [], o = this, l = [];
    return e.search((u) => {
      if (u instanceof Lf)
        l.push({});
      else if (u instanceof Uf)
        l.pop();
      else if (u instanceof Ka) {
        const c = u;
        i && c.type !== null && this._markStructsFromAST(c.type), l.length > 0 && (l[l.length - 1][c.name] = c);
      } else if (u instanceof mc) {
        const c = u;
        i && c.type !== null && this._markStructsFromAST(c.type);
      } else if (u instanceof og) {
        const c = u;
        i && c.type !== null && this._markStructsFromAST(c.type), l.length > 0 && (l[l.length - 1][c.name] = c);
      } else if (u instanceof ag) {
        const c = u;
        if (l.length > 0 && l[l.length - 1][c.name])
          return;
        const x = o._findResource(c.name);
        x && s.push(x);
      } else if (u instanceof kw) {
        const c = u, x = o._functions.get(c.name);
        x && (i && (x.inUse = !0), e.calls.add(x.node), x.resources === null && (x.resources = o._findResources(x.node, i)), s.push(...x.resources));
      } else if (u instanceof Bw) {
        const c = u, x = o._functions.get(c.name);
        x && (i && (x.inUse = !0), e.calls.add(x.node), x.resources === null && (x.resources = o._findResources(x.node, i)), s.push(...x.resources));
      }
    }), [...new Map(s.map((u) => [u.name, u])).values()];
  }
  getBindGroups() {
    const e = [];
    function i(s, o) {
      s >= e.length && (e.length = s + 1), e[s] === void 0 && (e[s] = []), o >= e[s].length && (e[s].length = o + 1);
    }
    for (const s of this.uniforms) {
      i(s.group, s.binding);
      const o = e[s.group];
      o[s.binding] = s;
    }
    for (const s of this.storage) {
      i(s.group, s.binding);
      const o = e[s.group];
      o[s.binding] = s;
    }
    for (const s of this.textures) {
      i(s.group, s.binding);
      const o = e[s.group];
      o[s.binding] = s;
    }
    for (const s of this.samplers) {
      i(s.group, s.binding);
      const o = e[s.group];
      o[s.binding] = s;
    }
    return e;
  }
  _getOutputs(e, i = void 0) {
    if (i === void 0 && (i = []), e instanceof Za)
      this._getStructOutputs(e, i);
    else {
      const s = this._getOutputInfo(e);
      s !== null && i.push(s);
    }
    return i;
  }
  _getStructOutputs(e, i) {
    for (const s of e.members)
      if (s.type instanceof Za)
        this._getStructOutputs(s.type, i);
      else {
        const o = this._getAttribute(s, "location") || this._getAttribute(s, "builtin");
        if (o !== null) {
          const l = this._getTypeInfo(s.type, s.type.attributes), u = this._parseInt(o.value), c = new mv(s.name, l, o.name, u);
          i.push(c);
        }
      }
  }
  _getOutputInfo(e) {
    const i = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
    if (i !== null) {
      const s = this._getTypeInfo(e, e.attributes), o = this._parseInt(i.value);
      return new mv("", s, i.name, o);
    }
    return null;
  }
  _getInputs(e, i = void 0) {
    i === void 0 && (i = []);
    for (const s of e)
      if (s.type instanceof Za)
        this._getStructInputs(s.type, i);
      else {
        const o = this._getInputInfo(s);
        o !== null && i.push(o);
      }
    return i;
  }
  _getStructInputs(e, i) {
    for (const s of e.members)
      if (s.type instanceof Za)
        this._getStructInputs(s.type, i);
      else {
        const o = this._getInputInfo(s);
        o !== null && i.push(o);
      }
  }
  _getInputInfo(e) {
    const i = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
    if (i !== null) {
      const s = this._getAttribute(e, "interpolation"), o = this._getTypeInfo(e.type, e.attributes), l = this._parseInt(i.value), u = new nP(e.name, o, i.name, l);
      return s !== null && (u.interpolation = this._parseString(s.value)), u;
    }
    return null;
  }
  _parseString(e) {
    return e instanceof Array && (e = e[0]), e;
  }
  _parseInt(e) {
    e instanceof Array && (e = e[0]);
    const i = parseInt(e);
    return isNaN(i) ? e : i;
  }
  _getAlias(e) {
    for (const i of this.aliases)
      if (i.name == e)
        return i.type;
    return null;
  }
  _getAliasInfo(e) {
    return new rP(e.name, this._getTypeInfo(e.type, null));
  }
  _getTypeInfo(e, i) {
    if (this._types.has(e))
      return this._types.get(e);
    if (e instanceof Fw) {
      const o = e, l = o.format ? this._getTypeInfo(o.format, o.attributes) : null, u = new J_(o.name, i);
      return u.format = l, u.count = o.count, this._types.set(e, u), this._updateTypeInfo(u), u;
    }
    if (e instanceof Za) {
      const o = e, l = new $d(o.name, i);
      l.startLine = o.startLine, l.endLine = o.endLine;
      for (const u of o.members) {
        const c = this._getTypeInfo(u.type, u.attributes);
        l.members.push(new pv(u.name, c, u.attributes));
      }
      return this._types.set(e, l), this._updateTypeInfo(l), l;
    }
    if (e instanceof ou) {
      const o = e, l = o.format instanceof dl, u = o.format ? l ? this._getTypeInfo(o.format, null) : new Sc(o.format, null) : null, c = new _v(o.name, u, i, o.access);
      return this._types.set(e, c), this._updateTypeInfo(c), c;
    }
    if (e instanceof Ow) {
      const o = e, l = o.format ? this._getTypeInfo(o.format, null) : null, u = new _v(o.name, l, i, o.access);
      return this._types.set(e, u), this._updateTypeInfo(u), u;
    }
    const s = new Sc(e.name, i);
    return this._types.set(e, s), this._updateTypeInfo(s), s;
  }
  _updateTypeInfo(e) {
    var i, s;
    const o = this._getTypeSize(e);
    if (e.size = (i = o == null ? void 0 : o.size) !== null && i !== void 0 ? i : 0, e instanceof J_ && e.format) {
      const l = this._getTypeSize(e.format);
      e.stride = (s = l == null ? void 0 : l.size) !== null && s !== void 0 ? s : 0, this._updateTypeInfo(e.format);
    }
    e instanceof $d && this._updateStructInfo(e);
  }
  _updateStructInfo(e) {
    var i;
    let s = 0, o = 0, l = 0, u = 0;
    for (let c = 0, x = e.members.length; c < x; ++c) {
      const w = e.members[c], C = this._getTypeSize(w);
      if (!C)
        continue;
      (i = this._getAlias(w.type.name)) !== null && i !== void 0 || w.type;
      const M = C.align, P = C.size;
      s = this._roundUp(M, s + o), o = P, l = s, u = Math.max(u, M), w.offset = s, w.size = P, this._updateTypeInfo(w.type);
    }
    e.size = this._roundUp(u, l + o), e.align = u;
  }
  _getTypeSize(e) {
    var i, s;
    if (e == null)
      return null;
    const o = this._getAttributeNum(e.attributes, "size", 0), l = this._getAttributeNum(e.attributes, "align", 0);
    if (e instanceof pv && (e = e.type), e instanceof Sc) {
      const u = this._getAlias(e.name);
      u !== null && (e = u);
    }
    {
      const u = yo._typeInfo[e.name];
      if (u !== void 0) {
        const c = ((i = e.format) === null || i === void 0 ? void 0 : i.name) === "f16" ? 2 : 1;
        return new Xd(Math.max(l, u.align / c), Math.max(o, u.size / c));
      }
    }
    {
      const u = yo._typeInfo[e.name.substring(0, e.name.length - 1)];
      if (u) {
        const c = e.name[e.name.length - 1] === "h" ? 2 : 1;
        return new Xd(Math.max(l, u.align / c), Math.max(o, u.size / c));
      }
    }
    if (e instanceof J_) {
      let u = e, c = 8, x = 8;
      const w = this._getTypeSize(u.format);
      w !== null && (x = w.size, c = w.align);
      const C = u.count, M = this._getAttributeNum((s = e == null ? void 0 : e.attributes) !== null && s !== void 0 ? s : null, "stride", this._roundUp(c, x));
      return x = C * M, o && (x = o), new Xd(Math.max(l, c), Math.max(o, x));
    }
    if (e instanceof $d) {
      let u = 0, c = 0, x = 0, w = 0, C = 0;
      for (const M of e.members) {
        const P = this._getTypeSize(M.type);
        P !== null && (u = Math.max(P.align, u), x = this._roundUp(P.align, x + w), w = P.size, C = x);
      }
      return c = this._roundUp(u, C + w), new Xd(Math.max(l, u), Math.max(o, c));
    }
    return null;
  }
  _isUniformVar(e) {
    return e instanceof Ka && e.storage == "uniform";
  }
  _isStorageVar(e) {
    return e instanceof Ka && e.storage == "storage";
  }
  _isTextureVar(e) {
    return e instanceof Ka && e.type !== null && yo._textureTypes.indexOf(e.type.name) != -1;
  }
  _isSamplerVar(e) {
    return e instanceof Ka && e.type !== null && yo._samplerTypes.indexOf(e.type.name) != -1;
  }
  _getAttribute(e, i) {
    const s = e;
    if (!s || !s.attributes)
      return null;
    const o = s.attributes;
    for (let l of o)
      if (l.name == i)
        return l;
    return null;
  }
  _getAttributeNum(e, i, s) {
    if (e === null)
      return s;
    for (let o of e)
      if (o.name == i) {
        let l = o !== null && o.value !== null ? o.value : s;
        return l instanceof Array && (l = l[0]), typeof l == "number" ? l : typeof l == "string" ? parseInt(l) : s;
      }
    return s;
  }
  _roundUp(e, i) {
    return Math.ceil(i / e) * e;
  }
}
yo._typeInfo = {
  f16: { align: 2, size: 2 },
  i32: { align: 4, size: 4 },
  u32: { align: 4, size: 4 },
  f32: { align: 4, size: 4 },
  atomic: { align: 4, size: 4 },
  vec2: { align: 8, size: 8 },
  vec3: { align: 16, size: 12 },
  vec4: { align: 16, size: 16 },
  mat2x2: { align: 8, size: 16 },
  mat3x2: { align: 8, size: 24 },
  mat4x2: { align: 8, size: 32 },
  mat2x3: { align: 16, size: 32 },
  mat3x3: { align: 16, size: 48 },
  mat4x3: { align: 16, size: 64 },
  mat2x4: { align: 16, size: 32 },
  mat3x4: { align: 16, size: 48 },
  mat4x4: { align: 16, size: 64 }
};
yo._textureTypes = J.any_texture_type.map((t) => t.name);
yo._samplerTypes = J.sampler_type.map((t) => t.name);
function uP(t) {
  var l;
  const e = { attributes: [], bindings: [] };
  let i;
  try {
    i = dP(t);
  } catch (u) {
    return $e.error(u.message)(), e;
  }
  for (const u of i.uniforms) {
    const c = [];
    for (const x of ((l = u.type) == null ? void 0 : l.members) || [])
      c.push({
        name: x.name,
        type: gv(x.type)
      });
    e.bindings.push({
      type: "uniform",
      name: u.name,
      location: u.binding,
      // @ts-expect-error
      group: u.group,
      members: c
    });
  }
  const s = i.entry.vertex[0], o = (s == null ? void 0 : s.inputs.length) || 0;
  for (let u = 0; u < o; u++) {
    const c = s.inputs[u];
    if (c.locationType === "location") {
      const x = gv(c.type);
      e.attributes.push({
        name: c.name,
        location: Number(c.location),
        type: x
      });
    }
  }
  return e;
}
function gv(t) {
  return t.format ? `${t.name}<${t.format.name}>` : t.name;
}
function dP(t) {
  try {
    return new yo(t);
  } catch (e) {
    if (e instanceof Error)
      throw e;
    let i = "WGSL parse error";
    throw typeof e == "object" && (e != null && e.message) && (i += `: ${e.message} `), typeof e == "object" && (e != null && e.token) && (i += e.token.line || ""), new Error(i, { cause: e });
  }
}
const fP = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;
const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;
const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;
const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;
float sin_taylor_fp32(float a) {
float r, s, t, x;
if (a == 0.0) {
return 0.0;
}
x = -a * a;
s = a;
r = a;
r = r * x;
t = r * INVERSE_FACTORIAL_3;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_5;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_7;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_9;
s = s + t;
return s;
}
void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
if (a == 0.0) {
sin_t = 0.0;
cos_t = 1.0;
}
sin_t = sin_taylor_fp32(a);
cos_t = sqrt(1.0 - sin_t * sin_t);
}
float tan_taylor_fp32(float a) {
float sin_a;
float cos_a;
if (a == 0.0) {
return 0.0;
}
float z = floor(a / TWO_PI);
float r = a - TWO_PI * z;
float t;
float q = floor(r / PI_2 + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return 1.0 / 0.0;
}
t = r - PI_2 * q;
q = floor(t / PI_16 + 0.5);
int k = int(q);
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return 1.0 / 0.0;
} else {
t = t - PI_16 * q;
}
float u = 0.0;
float v = 0.0;
float sin_t, cos_t;
float s, c;
sincos_taylor_fp32(t, sin_t, cos_t);
if (k == 0) {
s = sin_t;
c = cos_t;
} else {
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0;
v = SIN_TABLE_0;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1;
v = SIN_TABLE_1;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2;
v = SIN_TABLE_2;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3;
v = SIN_TABLE_3;
}
if (k > 0) {
s = u * sin_t + v * cos_t;
c = u * cos_t - v * sin_t;
} else {
s = u * sin_t - v * cos_t;
c = u * cos_t + v * sin_t;
}
}
if (j == 0) {
sin_a = s;
cos_a = c;
} else if (j == 1) {
sin_a = c;
cos_a = -s;
} else if (j == -1) {
sin_a = -c;
cos_a = s;
} else {
sin_a = -s;
cos_a = -c;
}
return sin_a / cos_a;
}
#endif
float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
return tan_taylor_fp32(a);
#else
return tan(a);
#endif
}
`, pP = {
  name: "fp32",
  vs: fP
}, _P = [0, 1, 1, 1], mP = `uniform pickingUniforms {
float isActive;
float isAttribute;
float isHighlightActive;
float useFloatColors;
vec3 highlightedObjectColor;
vec4 highlightColor;
} picking;
out vec4 picking_vRGBcolor_Avalid;
vec3 picking_normalizeColor(vec3 color) {
return picking.useFloatColors > 0.5 ? color : color / 255.0;
}
vec4 picking_normalizeColor(vec4 color) {
return picking.useFloatColors > 0.5 ? color : color / 255.0;
}
bool picking_isColorZero(vec3 color) {
return dot(color, vec3(1.0)) < 0.00001;
}
bool picking_isColorValid(vec3 color) {
return dot(color, vec3(1.0)) > 0.00001;
}
bool isVertexHighlighted(vec3 vertexColor) {
vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
return
bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}
void picking_setPickingColor(vec3 pickingColor) {
pickingColor = picking_normalizeColor(pickingColor);
if (bool(picking.isActive)) {
picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));
if (!bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rgb = pickingColor;
}
} else {
picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
}
}
void picking_setPickingAttribute(float value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.r = value;
}
}
void picking_setPickingAttribute(vec2 value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rg = value;
}
}
void picking_setPickingAttribute(vec3 value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rgb = value;
}
}
`, gP = `uniform pickingUniforms {
float isActive;
float isAttribute;
float isHighlightActive;
float useFloatColors;
vec3 highlightedObjectColor;
vec4 highlightColor;
} picking;
in vec4 picking_vRGBcolor_Avalid;
vec4 picking_filterHighlightColor(vec4 color) {
if (picking.isActive > 0.5) {
return color;
}
bool selected = bool(picking_vRGBcolor_Avalid.a);
if (selected) {
float highLightAlpha = picking.highlightColor.a;
float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
float highLightRatio = highLightAlpha / blendedAlpha;
vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
return vec4(blendedRGB, blendedAlpha);
} else {
return color;
}
}
vec4 picking_filterPickingColor(vec4 color) {
if (bool(picking.isActive)) {
if (picking_vRGBcolor_Avalid.a == 0.0) {
discard;
}
return picking_vRGBcolor_Avalid;
}
return color;
}
vec4 picking_filterColor(vec4 color) {
vec4 highlightColor = picking_filterHighlightColor(color);
return picking_filterPickingColor(highlightColor);
}
`, yv = {
  name: "picking",
  vs: mP,
  fs: gP,
  uniformTypes: {
    isActive: "f32",
    isAttribute: "f32",
    isHighlightActive: "f32",
    useFloatColors: "f32",
    highlightedObjectColor: "vec3<f32>",
    highlightColor: "vec4<f32>"
  },
  defaultUniforms: {
    isActive: !1,
    isAttribute: !1,
    isHighlightActive: !1,
    useFloatColors: !0,
    highlightedObjectColor: [0, 0, 0],
    highlightColor: _P
  },
  getUniforms: yP
};
function yP(t = {}, e) {
  const i = {};
  if (t.highlightedObjectColor !== void 0) if (t.highlightedObjectColor === null)
    i.isHighlightActive = !1;
  else {
    i.isHighlightActive = !0;
    const s = t.highlightedObjectColor.slice(0, 3);
    i.highlightedObjectColor = s;
  }
  if (t.highlightColor) {
    const s = Array.from(t.highlightColor, (o) => o / 255);
    Number.isFinite(s[3]) || (s[3] = 1), i.highlightColor = s;
  }
  return t.isActive !== void 0 && (i.isActive = !!t.isActive, i.isAttribute = !!t.isAttribute), t.useFloatColors !== void 0 && (i.useFloatColors = !!t.useFloatColors), i;
}
function Uw(t, e = [], i = 0) {
  const s = Math.fround(t), o = t - s;
  return e[i] = s, e[i + 1] = o, e;
}
function bP(t) {
  return t - Math.fround(t);
}
function vP(t) {
  const e = new Float32Array(32);
  for (let i = 0; i < 4; ++i)
    for (let s = 0; s < 4; ++s) {
      const o = i * 4 + s;
      Uw(t[s * 4 + i], e, o * 2);
    }
  return e;
}
const xP = `uniform float ONE;
vec2 split(float a) {
const float SPLIT = 4097.0;
float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float a_hi = t * ONE - (t - a);
float a_lo = a * ONE - a_hi;
#else
float a_hi = t - (t - a);
float a_lo = a - a_hi;
#endif
return vec2(a_hi, a_lo);
}
vec2 split2(vec2 a) {
vec2 b = split(a.x);
b.y += a.y;
return b;
}
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float sum = (a + b) * ONE;
float err = b - (sum - a) * ONE;
#else
float sum = a + b;
float err = b - (sum - a);
#endif
return vec2(sum, err);
}
vec2 twoSum(float a, float b) {
float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);
#else
float v = s - a;
float err = (a - (s - v)) + (b - v);
#endif
return vec2(s, err);
}
vec2 twoSub(float a, float b) {
float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);
#else
float v = s - a;
float err = (a - (s - v)) - (b + v);
#endif
return vec2(s, err);
}
vec2 twoSqr(float a) {
float prod = a * a;
vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *
a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;
#else
float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
return vec2(prod, err);
}
vec2 twoProd(float a, float b) {
float prod = a * b;
vec2 a_fp64 = split(a);
vec2 b_fp64 = split(b);
float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
return vec2(prod, err);
}
vec2 sum_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSum(a.x, b.x);
t = twoSum(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 sub_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSub(a.x, b.x);
t = twoSub(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 mul_fp64(vec2 a, vec2 b) {
vec2 prod = twoProd(a.x, b.x);
prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
return prod;
}
vec2 div_fp64(vec2 a, vec2 b) {
float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
vec2 yn = a * xn;
#endif
float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
vec2 prod = twoProd(xn, diff);
return sum_fp64(yn, prod);
}
vec2 sqrt_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
float x = 1.0 / sqrt(a.x);
float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
vec2 yn_sqr = twoSqr(yn) * ONE;
#else
vec2 yn_sqr = twoSqr(yn);
#endif
float diff = sub_fp64(a, yn_sqr).x;
vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
return sum_fp64(split(yn), prod);
#else
return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`, wP = {
  // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
  ONE: 1
};
function AP() {
  return wP;
}
const TP = {
  name: "fp64-arithmetic",
  vs: xP,
  getUniforms: AP,
  fp64ify: Uw,
  fp64LowPart: bP,
  fp64ifyMatrix4: vP
}, EP = 1 / Math.PI * 180, SP = 1 / 180 * Math.PI, CP = {
  EPSILON: 1e-12,
  debug: !1,
  precision: 4,
  printTypes: !1,
  printDegrees: !1,
  printRowMajor: !0,
  _cartographicRadians: !1
};
globalThis.mathgl = globalThis.mathgl || { config: { ...CP } };
const us = globalThis.mathgl.config;
function IP(t, { precision: e = us.precision } = {}) {
  return t = BP(t), `${parseFloat(t.toPrecision(e))}`;
}
function _a(t) {
  return Array.isArray(t) || ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function RP(t) {
  return PP(t);
}
function MP(t) {
  return fn(t);
}
function PP(t, e) {
  return sy(t, (i) => i * SP, e);
}
function fn(t, e) {
  return sy(t, (i) => i * EP, e);
}
function bo(t, e, i) {
  return sy(t, (s) => Math.max(e, Math.min(i, s)));
}
function zf(t, e, i) {
  return _a(t) ? t.map((s, o) => zf(s, e[o], i)) : i * e + (1 - i) * t;
}
function bn(t, e, i) {
  const s = us.EPSILON;
  i && (us.EPSILON = i);
  try {
    if (t === e)
      return !0;
    if (_a(t) && _a(e)) {
      if (t.length !== e.length)
        return !1;
      for (let o = 0; o < t.length; ++o)
        if (!bn(t[o], e[o]))
          return !1;
      return !0;
    }
    return t && t.equals ? t.equals(e) : e && e.equals ? e.equals(t) : typeof t == "number" && typeof e == "number" ? Math.abs(t - e) <= us.EPSILON * Math.max(1, Math.abs(t), Math.abs(e)) : !1;
  } finally {
    us.EPSILON = s;
  }
}
function BP(t) {
  return Math.round(t / us.EPSILON) * us.EPSILON;
}
function DP(t) {
  return t.clone ? t.clone() : new Array(t.length);
}
function sy(t, e, i) {
  if (_a(t)) {
    const s = t;
    i = i || DP(s);
    for (let o = 0; o < i.length && o < s.length; ++o) {
      const l = typeof t == "number" ? t : t[o];
      i[o] = e(l, o, i);
    }
    return i;
  }
  return e(t);
}
class ry extends Array {
  // Common methods
  /**
   * Clone the current object
   * @returns a new copy of this object
   */
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, i = 0) {
    for (let s = 0; s < this.ELEMENTS; ++s)
      this[s] = e[s + i];
    return this.check();
  }
  toArray(e = [], i = 0) {
    for (let s = 0; s < this.ELEMENTS; ++s)
      e[i + s] = this[s];
    return e;
  }
  toObject(e) {
    return e;
  }
  from(e) {
    return Array.isArray(e) ? this.copy(e) : (
      // @ts-ignore
      this.fromObject(e)
    );
  }
  to(e) {
    return e === this ? this : _a(e) ? this.toArray(e) : this.toObject(e);
  }
  toTarget(e) {
    return e ? this.to(e) : this;
  }
  /** @deprecated */
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(us);
  }
  /** Formats string according to options */
  formatString(e) {
    let i = "";
    for (let s = 0; s < this.ELEMENTS; ++s)
      i += (s > 0 ? ", " : "") + IP(this[s], e);
    return `${e.printTypes ? this.constructor.name : ""}[${i}]`;
  }
  equals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let i = 0; i < this.ELEMENTS; ++i)
      if (!bn(this[i], e[i]))
        return !1;
    return !0;
  }
  exactEquals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let i = 0; i < this.ELEMENTS; ++i)
      if (this[i] !== e[i])
        return !1;
    return !0;
  }
  // Modifiers
  /** Negates all values in this object */
  negate() {
    for (let e = 0; e < this.ELEMENTS; ++e)
      this[e] = -this[e];
    return this.check();
  }
  lerp(e, i, s) {
    if (s === void 0)
      return this.lerp(this, e, i);
    for (let o = 0; o < this.ELEMENTS; ++o) {
      const l = e[o], u = typeof i == "number" ? i : i[o];
      this[o] = l + s * (u - l);
    }
    return this.check();
  }
  /** Minimal */
  min(e) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = Math.min(e[i], this[i]);
    return this.check();
  }
  /** Maximal */
  max(e) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = Math.max(e[i], this[i]);
    return this.check();
  }
  clamp(e, i) {
    for (let s = 0; s < this.ELEMENTS; ++s)
      this[s] = Math.min(Math.max(this[s], e[s]), i[s]);
    return this.check();
  }
  add(...e) {
    for (const i of e)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] += i[s];
    return this.check();
  }
  subtract(...e) {
    for (const i of e)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] -= i[s];
    return this.check();
  }
  scale(e) {
    if (typeof e == "number")
      for (let i = 0; i < this.ELEMENTS; ++i)
        this[i] *= e;
    else
      for (let i = 0; i < this.ELEMENTS && i < e.length; ++i)
        this[i] *= e[i];
    return this.check();
  }
  /**
   * Multiplies all elements by `scale`
   * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
   */
  multiplyByScalar(e) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] *= e;
    return this.check();
  }
  // Debug checks
  /** Throws an error if array length is incorrect or contains illegal values */
  check() {
    if (us.debug && !this.validate())
      throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
    return this;
  }
  /** Returns false if the array length is incorrect or contains illegal values */
  validate() {
    let e = this.length === this.ELEMENTS;
    for (let i = 0; i < this.ELEMENTS; ++i)
      e = e && Number.isFinite(this[i]);
    return e;
  }
  // three.js compatibility
  /** @deprecated */
  sub(e) {
    return this.subtract(e);
  }
  /** @deprecated */
  setScalar(e) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = e;
    return this.check();
  }
  /** @deprecated */
  addScalar(e) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] += e;
    return this.check();
  }
  /** @deprecated */
  subScalar(e) {
    return this.addScalar(-e);
  }
  /** @deprecated */
  multiplyScalar(e) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] *= e;
    return this.check();
  }
  /** @deprecated */
  divideScalar(e) {
    return this.multiplyByScalar(1 / e);
  }
  /** @deprecated */
  clampScalar(e, i) {
    for (let s = 0; s < this.ELEMENTS; ++s)
      this[s] = Math.min(Math.max(this[s], e), i);
    return this.check();
  }
  /** @deprecated */
  get elements() {
    return this;
  }
}
function OP(t, e) {
  if (t.length !== e)
    return !1;
  for (let i = 0; i < t.length; ++i)
    if (!Number.isFinite(t[i]))
      return !1;
  return !0;
}
function si(t) {
  if (!Number.isFinite(t))
    throw new Error(`Invalid number ${JSON.stringify(t)}`);
  return t;
}
function fu(t, e, i = "") {
  if (us.debug && !OP(t, e))
    throw new Error(`math.gl: ${i} some fields set to invalid numbers'`);
  return t;
}
function pn(t, e) {
  if (!t)
    throw new Error(`math.gl assertion ${e}`);
}
class ny extends ry {
  // ACCESSORS
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = si(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = si(e);
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   *
   * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
   * Instead we provide `len` and `magnitude`
   */
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   */
  magnitude() {
    return this.len();
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  lengthSquared() {
    let e = 0;
    for (let i = 0; i < this.ELEMENTS; ++i)
      e += this[i] * this[i];
    return e;
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(e) {
    return Math.sqrt(this.distanceSquared(e));
  }
  distanceSquared(e) {
    let i = 0;
    for (let s = 0; s < this.ELEMENTS; ++s) {
      const o = this[s] - e[s];
      i += o * o;
    }
    return si(i);
  }
  dot(e) {
    let i = 0;
    for (let s = 0; s < this.ELEMENTS; ++s)
      i += this[s] * e[s];
    return si(i);
  }
  // MODIFIERS
  normalize() {
    const e = this.magnitude();
    if (e !== 0)
      for (let i = 0; i < this.ELEMENTS; ++i)
        this[i] /= e;
    return this.check();
  }
  multiply(...e) {
    for (const i of e)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] *= i[s];
    return this.check();
  }
  divide(...e) {
    for (const i of e)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] /= i[s];
    return this.check();
  }
  // THREE.js compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(e) {
    return this.distance(e);
  }
  distanceToSquared(e) {
    return this.distanceSquared(e);
  }
  getComponent(e) {
    return pn(e >= 0 && e < this.ELEMENTS, "index is out of range"), si(this[e]);
  }
  setComponent(e, i) {
    return pn(e >= 0 && e < this.ELEMENTS, "index is out of range"), this[e] = i, this.check();
  }
  addVectors(e, i) {
    return this.copy(e).add(i);
  }
  subVectors(e, i) {
    return this.copy(e).subtract(i);
  }
  multiplyVectors(e, i) {
    return this.copy(e).multiply(i);
  }
  addScaledVector(e, i) {
    return this.add(new this.constructor(e).multiplyScalar(i));
  }
}
const pu = 1e-6;
let xn = typeof Float32Array < "u" ? Float32Array : Array;
function FP() {
  const t = new xn(2);
  return xn != Float32Array && (t[0] = 0, t[1] = 0), t;
}
function bv(t, e, i) {
  return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t;
}
function kP(t, e) {
  return t[0] = -e[0], t[1] = -e[1], t;
}
function zw(t, e, i, s) {
  const o = e[0], l = e[1];
  return t[0] = o + s * (i[0] - o), t[1] = l + s * (i[1] - l), t;
}
function NP(t, e, i) {
  const s = e[0], o = e[1];
  return t[0] = i[0] * s + i[2] * o, t[1] = i[1] * s + i[3] * o, t;
}
function LP(t, e, i) {
  const s = e[0], o = e[1];
  return t[0] = i[0] * s + i[2] * o + i[4], t[1] = i[1] * s + i[3] * o + i[5], t;
}
function Vw(t, e, i) {
  const s = e[0], o = e[1];
  return t[0] = i[0] * s + i[3] * o + i[6], t[1] = i[1] * s + i[4] * o + i[7], t;
}
function Hw(t, e, i) {
  const s = e[0], o = e[1];
  return t[0] = i[0] * s + i[4] * o + i[12], t[1] = i[1] * s + i[5] * o + i[13], t;
}
(function() {
  const t = FP();
  return function(e, i, s, o, l, u) {
    let c, x;
    for (i || (i = 2), s || (s = 0), o ? x = Math.min(o * i + s, e.length) : x = e.length, c = s; c < x; c += i)
      t[0] = e[c], t[1] = e[c + 1], l(t, t, u), e[c] = t[0], e[c + 1] = t[1];
    return e;
  };
})();
function jw(t, e, i) {
  const s = e[0], o = e[1], l = i[3] * s + i[7] * o || 1;
  return t[0] = (i[0] * s + i[4] * o) / l, t[1] = (i[1] * s + i[5] * o) / l, t;
}
function $w(t, e, i) {
  const s = e[0], o = e[1], l = e[2], u = i[3] * s + i[7] * o + i[11] * l || 1;
  return t[0] = (i[0] * s + i[4] * o + i[8] * l) / u, t[1] = (i[1] * s + i[5] * o + i[9] * l) / u, t[2] = (i[2] * s + i[6] * o + i[10] * l) / u, t;
}
function UP(t, e, i) {
  const s = e[0], o = e[1];
  return t[0] = i[0] * s + i[2] * o, t[1] = i[1] * s + i[3] * o, t[2] = e[2], t;
}
function zP(t, e, i) {
  const s = e[0], o = e[1];
  return t[0] = i[0] * s + i[2] * o, t[1] = i[1] * s + i[3] * o, t[2] = e[2], t[3] = e[3], t;
}
function Gw(t, e, i) {
  const s = e[0], o = e[1], l = e[2];
  return t[0] = i[0] * s + i[3] * o + i[6] * l, t[1] = i[1] * s + i[4] * o + i[7] * l, t[2] = i[2] * s + i[5] * o + i[8] * l, t[3] = e[3], t;
}
class oy extends ny {
  // Creates a new, empty vec2
  constructor(e = 0, i = 0) {
    super(2), _a(e) && arguments.length === 1 ? this.copy(e) : (us.debug && (si(e), si(i)), this[0] = e, this[1] = i);
  }
  set(e, i) {
    return this[0] = e, this[1] = i, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this.check();
  }
  fromObject(e) {
    return us.debug && (si(e.x), si(e.y)), this[0] = e.x, this[1] = e.y, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e;
  }
  // Getters/setters
  get ELEMENTS() {
    return 2;
  }
  /**
   * Returns angle from x axis
   * @returns
   */
  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }
  /**
   * Returns angle from y axis
   * @returns
   */
  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }
  // Transforms
  /**
   * Transforms as point
   * @param matrix4
   * @returns
   */
  transform(e) {
    return this.transformAsPoint(e);
  }
  /**
   * transforms as point (4th component is implicitly 1)
   * @param matrix4
   * @returns
   */
  transformAsPoint(e) {
    return Hw(this, this, e), this.check();
  }
  /**
   * transforms as vector (4th component is implicitly 0, ignores translation. slightly faster)
   * @param matrix4
   * @returns
   */
  transformAsVector(e) {
    return jw(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return Vw(this, this, e), this.check();
  }
  transformByMatrix2x3(e) {
    return LP(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return NP(this, this, e), this.check();
  }
}
function Xw() {
  const t = new xn(3);
  return xn != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
}
function Ww(t) {
  const e = t[0], i = t[1], s = t[2];
  return Math.sqrt(e * e + i * i + s * s);
}
function vv(t, e, i) {
  const s = new xn(3);
  return s[0] = t, s[1] = e, s[2] = i, s;
}
function VP(t, e, i) {
  return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2], t;
}
function HP(t, e) {
  return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t;
}
function jP(t, e) {
  const i = e[0], s = e[1], o = e[2];
  let l = i * i + s * s + o * o;
  return l > 0 && (l = 1 / Math.sqrt(l)), t[0] = e[0] * l, t[1] = e[1] * l, t[2] = e[2] * l, t;
}
function ay(t, e) {
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
}
function vf(t, e, i) {
  const s = e[0], o = e[1], l = e[2], u = i[0], c = i[1], x = i[2];
  return t[0] = o * x - l * c, t[1] = l * u - s * x, t[2] = s * c - o * u, t;
}
function ly(t, e, i) {
  const s = e[0], o = e[1], l = e[2];
  let u = i[3] * s + i[7] * o + i[11] * l + i[15];
  return u = u || 1, t[0] = (i[0] * s + i[4] * o + i[8] * l + i[12]) / u, t[1] = (i[1] * s + i[5] * o + i[9] * l + i[13]) / u, t[2] = (i[2] * s + i[6] * o + i[10] * l + i[14]) / u, t;
}
function qw(t, e, i) {
  const s = e[0], o = e[1], l = e[2];
  return t[0] = s * i[0] + o * i[3] + l * i[6], t[1] = s * i[1] + o * i[4] + l * i[7], t[2] = s * i[2] + o * i[5] + l * i[8], t;
}
function Zw(t, e, i) {
  const s = i[0], o = i[1], l = i[2], u = i[3], c = e[0], x = e[1], w = e[2];
  let C = o * w - l * x, M = l * c - s * w, P = s * x - o * c, j = o * P - l * M, Y = l * C - s * P, Q = s * M - o * C;
  const _e = u * 2;
  return C *= _e, M *= _e, P *= _e, j *= 2, Y *= 2, Q *= 2, t[0] = c + C + j, t[1] = x + M + Y, t[2] = w + P + Q, t;
}
function $P(t, e, i, s) {
  const o = [], l = [];
  return o[0] = e[0] - i[0], o[1] = e[1] - i[1], o[2] = e[2] - i[2], l[0] = o[0], l[1] = o[1] * Math.cos(s) - o[2] * Math.sin(s), l[2] = o[1] * Math.sin(s) + o[2] * Math.cos(s), t[0] = l[0] + i[0], t[1] = l[1] + i[1], t[2] = l[2] + i[2], t;
}
function GP(t, e, i, s) {
  const o = [], l = [];
  return o[0] = e[0] - i[0], o[1] = e[1] - i[1], o[2] = e[2] - i[2], l[0] = o[2] * Math.sin(s) + o[0] * Math.cos(s), l[1] = o[1], l[2] = o[2] * Math.cos(s) - o[0] * Math.sin(s), t[0] = l[0] + i[0], t[1] = l[1] + i[1], t[2] = l[2] + i[2], t;
}
function XP(t, e, i, s) {
  const o = [], l = [];
  return o[0] = e[0] - i[0], o[1] = e[1] - i[1], o[2] = e[2] - i[2], l[0] = o[0] * Math.cos(s) - o[1] * Math.sin(s), l[1] = o[0] * Math.sin(s) + o[1] * Math.cos(s), l[2] = o[2], t[0] = l[0] + i[0], t[1] = l[1] + i[1], t[2] = l[2] + i[2], t;
}
function WP(t, e) {
  const i = t[0], s = t[1], o = t[2], l = e[0], u = e[1], c = e[2], x = Math.sqrt((i * i + s * s + o * o) * (l * l + u * u + c * c)), w = x && ay(t, e) / x;
  return Math.acos(Math.min(Math.max(w, -1), 1));
}
const qP = VP, ZP = Ww;
(function() {
  const t = Xw();
  return function(e, i, s, o, l, u) {
    let c, x;
    for (i || (i = 3), s || (s = 0), o ? x = Math.min(o * i + s, e.length) : x = e.length, c = s; c < x; c += i)
      t[0] = e[c], t[1] = e[c + 1], t[2] = e[c + 2], l(t, t, u), e[c] = t[0], e[c + 1] = t[1], e[c + 2] = t[2];
    return e;
  };
})();
const Y_ = [0, 0, 0];
let Wd;
class Se extends ny {
  static get ZERO() {
    return Wd || (Wd = new Se(0, 0, 0), Object.freeze(Wd)), Wd;
  }
  /**
   * @class
   * @param x
   * @param y
   * @param z
   */
  constructor(e = 0, i = 0, s = 0) {
    super(-0, -0, -0), arguments.length === 1 && _a(e) ? this.copy(e) : (us.debug && (si(e), si(i), si(s)), this[0] = e, this[1] = i, this[2] = s);
  }
  set(e, i, s) {
    return this[0] = e, this[1] = i, this[2] = s, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this.check();
  }
  fromObject(e) {
    return us.debug && (si(e.x), si(e.y), si(e.z)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e;
  }
  // Getters/setters
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = si(e);
  }
  // ACCESSORS
  angle(e) {
    return WP(this, e);
  }
  // MODIFIERS
  cross(e) {
    return vf(this, this, e), this.check();
  }
  rotateX({ radians: e, origin: i = Y_ }) {
    return $P(this, this, i, e), this.check();
  }
  rotateY({ radians: e, origin: i = Y_ }) {
    return GP(this, this, i, e), this.check();
  }
  rotateZ({ radians: e, origin: i = Y_ }) {
    return XP(this, this, i, e), this.check();
  }
  // Transforms
  // transforms as point (4th component is implicitly 1)
  transform(e) {
    return this.transformAsPoint(e);
  }
  // transforms as point (4th component is implicitly 1)
  transformAsPoint(e) {
    return ly(this, this, e), this.check();
  }
  // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
  transformAsVector(e) {
    return $w(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return qw(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return UP(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return Zw(this, this, e), this.check();
  }
}
let qd;
class cy extends ny {
  static get ZERO() {
    return qd || (qd = new cy(0, 0, 0, 0), Object.freeze(qd)), qd;
  }
  constructor(e = 0, i = 0, s = 0, o = 0) {
    super(-0, -0, -0, -0), _a(e) && arguments.length === 1 ? this.copy(e) : (us.debug && (si(e), si(i), si(s), si(o)), this[0] = e, this[1] = i, this[2] = s, this[3] = o);
  }
  set(e, i, s, o) {
    return this[0] = e, this[1] = i, this[2] = s, this[3] = o, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  fromObject(e) {
    return us.debug && (si(e.x), si(e.y), si(e.z), si(e.w)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this;
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e.w = this[3], e;
  }
  // Getters/setters
  /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
  get ELEMENTS() {
    return 4;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = si(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = si(e);
  }
  transform(e) {
    return ly(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return Gw(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return zP(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return Zw(this, this, e), this.check();
  }
  // three.js compatibility
  applyMatrix4(e) {
    return e.transform(this, this), this;
  }
}
class Kw extends ry {
  // fromObject(object) {
  //   const array = object.elements;
  //   return this.fromRowMajor(array);
  // }
  // toObject(object) {
  //   const array = object.elements;
  //   this.toRowMajor(array);
  //   return object;
  // }
  // TODO better override formatString?
  toString() {
    let e = "[";
    if (us.printRowMajor) {
      e += "row-major:";
      for (let i = 0; i < this.RANK; ++i)
        for (let s = 0; s < this.RANK; ++s)
          e += ` ${this[s * this.RANK + i]}`;
    } else {
      e += "column-major:";
      for (let i = 0; i < this.ELEMENTS; ++i)
        e += ` ${this[i]}`;
    }
    return e += "]", e;
  }
  getElementIndex(e, i) {
    return i * this.RANK + e;
  }
  // By default assumes row major indices
  getElement(e, i) {
    return this[i * this.RANK + e];
  }
  // By default assumes row major indices
  setElement(e, i, s) {
    return this[i * this.RANK + e] = si(s), this;
  }
  getColumn(e, i = new Array(this.RANK).fill(-0)) {
    const s = e * this.RANK;
    for (let o = 0; o < this.RANK; ++o)
      i[o] = this[s + o];
    return i;
  }
  setColumn(e, i) {
    const s = e * this.RANK;
    for (let o = 0; o < this.RANK; ++o)
      this[s + o] = i[o];
    return this;
  }
}
function KP() {
  const t = new xn(9);
  return xn != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
}
function JP(t, e) {
  if (t === e) {
    const i = e[1], s = e[2], o = e[5];
    t[1] = e[3], t[2] = e[6], t[3] = i, t[5] = e[7], t[6] = s, t[7] = o;
  } else
    t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];
  return t;
}
function YP(t, e) {
  const i = e[0], s = e[1], o = e[2], l = e[3], u = e[4], c = e[5], x = e[6], w = e[7], C = e[8], M = C * u - c * w, P = -C * l + c * x, j = w * l - u * x;
  let Y = i * M + s * P + o * j;
  return Y ? (Y = 1 / Y, t[0] = M * Y, t[1] = (-C * s + o * w) * Y, t[2] = (c * s - o * u) * Y, t[3] = P * Y, t[4] = (C * i - o * x) * Y, t[5] = (-c * i + o * l) * Y, t[6] = j * Y, t[7] = (-w * i + s * x) * Y, t[8] = (u * i - s * l) * Y, t) : null;
}
function QP(t) {
  const e = t[0], i = t[1], s = t[2], o = t[3], l = t[4], u = t[5], c = t[6], x = t[7], w = t[8];
  return e * (w * l - u * x) + i * (-w * o + u * c) + s * (x * o - l * c);
}
function xv(t, e, i) {
  const s = e[0], o = e[1], l = e[2], u = e[3], c = e[4], x = e[5], w = e[6], C = e[7], M = e[8], P = i[0], j = i[1], Y = i[2], Q = i[3], _e = i[4], me = i[5], we = i[6], Ee = i[7], Oe = i[8];
  return t[0] = P * s + j * u + Y * w, t[1] = P * o + j * c + Y * C, t[2] = P * l + j * x + Y * M, t[3] = Q * s + _e * u + me * w, t[4] = Q * o + _e * c + me * C, t[5] = Q * l + _e * x + me * M, t[6] = we * s + Ee * u + Oe * w, t[7] = we * o + Ee * c + Oe * C, t[8] = we * l + Ee * x + Oe * M, t;
}
function e3(t, e, i) {
  const s = e[0], o = e[1], l = e[2], u = e[3], c = e[4], x = e[5], w = e[6], C = e[7], M = e[8], P = i[0], j = i[1];
  return t[0] = s, t[1] = o, t[2] = l, t[3] = u, t[4] = c, t[5] = x, t[6] = P * s + j * u + w, t[7] = P * o + j * c + C, t[8] = P * l + j * x + M, t;
}
function t3(t, e, i) {
  const s = e[0], o = e[1], l = e[2], u = e[3], c = e[4], x = e[5], w = e[6], C = e[7], M = e[8], P = Math.sin(i), j = Math.cos(i);
  return t[0] = j * s + P * u, t[1] = j * o + P * c, t[2] = j * l + P * x, t[3] = j * u - P * s, t[4] = j * c - P * o, t[5] = j * x - P * l, t[6] = w, t[7] = C, t[8] = M, t;
}
function wv(t, e, i) {
  const s = i[0], o = i[1];
  return t[0] = s * e[0], t[1] = s * e[1], t[2] = s * e[2], t[3] = o * e[3], t[4] = o * e[4], t[5] = o * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
}
function i3(t, e) {
  const i = e[0], s = e[1], o = e[2], l = e[3], u = i + i, c = s + s, x = o + o, w = i * u, C = s * u, M = s * c, P = o * u, j = o * c, Y = o * x, Q = l * u, _e = l * c, me = l * x;
  return t[0] = 1 - M - Y, t[3] = C - me, t[6] = P + _e, t[1] = C + me, t[4] = 1 - w - Y, t[7] = j - Q, t[2] = P - _e, t[5] = j + Q, t[8] = 1 - w - M, t;
}
var lg;
(function(t) {
  t[t.COL0ROW0 = 0] = "COL0ROW0", t[t.COL0ROW1 = 1] = "COL0ROW1", t[t.COL0ROW2 = 2] = "COL0ROW2", t[t.COL1ROW0 = 3] = "COL1ROW0", t[t.COL1ROW1 = 4] = "COL1ROW1", t[t.COL1ROW2 = 5] = "COL1ROW2", t[t.COL2ROW0 = 6] = "COL2ROW0", t[t.COL2ROW1 = 7] = "COL2ROW1", t[t.COL2ROW2 = 8] = "COL2ROW2";
})(lg || (lg = {}));
const s3 = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
class qi extends Kw {
  static get IDENTITY() {
    return n3();
  }
  static get ZERO() {
    return r3();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return lg;
  }
  constructor(e, ...i) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : i.length > 0 ? this.copy([e, ...i]) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this.check();
  }
  // Constructors
  identity() {
    return this.copy(s3);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(e) {
    return this.check();
  }
  /** Calculates a 3x3 matrix from the given quaternion
   * q quat  Quaternion to create matrix from
   */
  fromQuaternion(e) {
    return i3(this, e), this.check();
  }
  /**
   * accepts column major order, stores in column major order
   */
  // eslint-disable-next-line max-params
  set(e, i, s, o, l, u, c, x, w) {
    return this[0] = e, this[1] = i, this[2] = s, this[3] = o, this[4] = l, this[5] = u, this[6] = c, this[7] = x, this[8] = w, this.check();
  }
  /**
   * accepts row major order, stores as column major
   */
  // eslint-disable-next-line max-params
  setRowMajor(e, i, s, o, l, u, c, x, w) {
    return this[0] = e, this[1] = o, this[2] = c, this[3] = i, this[4] = l, this[5] = x, this[6] = s, this[7] = u, this[8] = w, this.check();
  }
  // Accessors
  determinant() {
    return QP(this);
  }
  // Modifiers
  transpose() {
    return JP(this, this), this.check();
  }
  /** Invert a matrix. Note that this can fail if the matrix is not invertible */
  invert() {
    return YP(this, this), this.check();
  }
  // Operations
  multiplyLeft(e) {
    return xv(this, e, this), this.check();
  }
  multiplyRight(e) {
    return xv(this, this, e), this.check();
  }
  rotate(e) {
    return t3(this, this, e), this.check();
  }
  scale(e) {
    return Array.isArray(e) ? wv(this, this, e) : wv(this, this, [e, e]), this.check();
  }
  translate(e) {
    return e3(this, this, e), this.check();
  }
  // Transforms
  transform(e, i) {
    let s;
    switch (e.length) {
      case 2:
        s = Vw(i || [-0, -0], e, this);
        break;
      case 3:
        s = qw(i || [-0, -0, -0], e, this);
        break;
      case 4:
        s = Gw(i || [-0, -0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return fu(s, e.length), s;
  }
  /** @deprecated */
  transformVector(e, i) {
    return this.transform(e, i);
  }
  /** @deprecated */
  transformVector2(e, i) {
    return this.transform(e, i);
  }
  /** @deprecated */
  transformVector3(e, i) {
    return this.transform(e, i);
  }
}
let Zd, Kd = null;
function r3() {
  return Zd || (Zd = new qi([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Zd)), Zd;
}
function n3() {
  return Kd || (Kd = new qi(), Object.freeze(Kd)), Kd;
}
function o3(t) {
  return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
}
function a3(t, e) {
  if (t === e) {
    const i = e[1], s = e[2], o = e[3], l = e[6], u = e[7], c = e[11];
    t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = i, t[6] = e[9], t[7] = e[13], t[8] = s, t[9] = l, t[11] = e[14], t[12] = o, t[13] = u, t[14] = c;
  } else
    t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15];
  return t;
}
function cg(t, e) {
  const i = e[0], s = e[1], o = e[2], l = e[3], u = e[4], c = e[5], x = e[6], w = e[7], C = e[8], M = e[9], P = e[10], j = e[11], Y = e[12], Q = e[13], _e = e[14], me = e[15], we = i * c - s * u, Ee = i * x - o * u, Oe = i * w - l * u, Ne = s * x - o * c, ze = s * w - l * c, nt = o * w - l * x, mt = C * Q - M * Y, We = C * _e - P * Y, at = C * me - j * Y, it = M * _e - P * Q, Ut = M * me - j * Q, Rt = P * me - j * _e;
  let yt = we * Rt - Ee * Ut + Oe * it + Ne * at - ze * We + nt * mt;
  return yt ? (yt = 1 / yt, t[0] = (c * Rt - x * Ut + w * it) * yt, t[1] = (o * Ut - s * Rt - l * it) * yt, t[2] = (Q * nt - _e * ze + me * Ne) * yt, t[3] = (P * ze - M * nt - j * Ne) * yt, t[4] = (x * at - u * Rt - w * We) * yt, t[5] = (i * Rt - o * at + l * We) * yt, t[6] = (_e * Oe - Y * nt - me * Ee) * yt, t[7] = (C * nt - P * Oe + j * Ee) * yt, t[8] = (u * Ut - c * at + w * mt) * yt, t[9] = (s * at - i * Ut - l * mt) * yt, t[10] = (Y * ze - Q * Oe + me * we) * yt, t[11] = (M * Oe - C * ze - j * we) * yt, t[12] = (c * We - u * it - x * mt) * yt, t[13] = (i * it - s * We + o * mt) * yt, t[14] = (Q * Ee - Y * Ne - _e * we) * yt, t[15] = (C * Ne - M * Ee + P * we) * yt, t) : null;
}
function l3(t) {
  const e = t[0], i = t[1], s = t[2], o = t[3], l = t[4], u = t[5], c = t[6], x = t[7], w = t[8], C = t[9], M = t[10], P = t[11], j = t[12], Y = t[13], Q = t[14], _e = t[15], me = e * u - i * l, we = e * c - s * l, Ee = i * c - s * u, Oe = w * Y - C * j, Ne = w * Q - M * j, ze = C * Q - M * Y, nt = e * ze - i * Ne + s * Oe, mt = l * ze - u * Ne + c * Oe, We = w * Ee - C * we + M * me, at = j * Ee - Y * we + Q * me;
  return x * nt - o * mt + _e * We - P * at;
}
function rl(t, e, i) {
  const s = e[0], o = e[1], l = e[2], u = e[3], c = e[4], x = e[5], w = e[6], C = e[7], M = e[8], P = e[9], j = e[10], Y = e[11], Q = e[12], _e = e[13], me = e[14], we = e[15];
  let Ee = i[0], Oe = i[1], Ne = i[2], ze = i[3];
  return t[0] = Ee * s + Oe * c + Ne * M + ze * Q, t[1] = Ee * o + Oe * x + Ne * P + ze * _e, t[2] = Ee * l + Oe * w + Ne * j + ze * me, t[3] = Ee * u + Oe * C + Ne * Y + ze * we, Ee = i[4], Oe = i[5], Ne = i[6], ze = i[7], t[4] = Ee * s + Oe * c + Ne * M + ze * Q, t[5] = Ee * o + Oe * x + Ne * P + ze * _e, t[6] = Ee * l + Oe * w + Ne * j + ze * me, t[7] = Ee * u + Oe * C + Ne * Y + ze * we, Ee = i[8], Oe = i[9], Ne = i[10], ze = i[11], t[8] = Ee * s + Oe * c + Ne * M + ze * Q, t[9] = Ee * o + Oe * x + Ne * P + ze * _e, t[10] = Ee * l + Oe * w + Ne * j + ze * me, t[11] = Ee * u + Oe * C + Ne * Y + ze * we, Ee = i[12], Oe = i[13], Ne = i[14], ze = i[15], t[12] = Ee * s + Oe * c + Ne * M + ze * Q, t[13] = Ee * o + Oe * x + Ne * P + ze * _e, t[14] = Ee * l + Oe * w + Ne * j + ze * me, t[15] = Ee * u + Oe * C + Ne * Y + ze * we, t;
}
function Vf(t, e, i) {
  const s = i[0], o = i[1], l = i[2];
  let u, c, x, w, C, M, P, j, Y, Q, _e, me;
  return e === t ? (t[12] = e[0] * s + e[4] * o + e[8] * l + e[12], t[13] = e[1] * s + e[5] * o + e[9] * l + e[13], t[14] = e[2] * s + e[6] * o + e[10] * l + e[14], t[15] = e[3] * s + e[7] * o + e[11] * l + e[15]) : (u = e[0], c = e[1], x = e[2], w = e[3], C = e[4], M = e[5], P = e[6], j = e[7], Y = e[8], Q = e[9], _e = e[10], me = e[11], t[0] = u, t[1] = c, t[2] = x, t[3] = w, t[4] = C, t[5] = M, t[6] = P, t[7] = j, t[8] = Y, t[9] = Q, t[10] = _e, t[11] = me, t[12] = u * s + C * o + Y * l + e[12], t[13] = c * s + M * o + Q * l + e[13], t[14] = x * s + P * o + _e * l + e[14], t[15] = w * s + j * o + me * l + e[15]), t;
}
function hy(t, e, i) {
  const s = i[0], o = i[1], l = i[2];
  return t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t[3] = e[3] * s, t[4] = e[4] * o, t[5] = e[5] * o, t[6] = e[6] * o, t[7] = e[7] * o, t[8] = e[8] * l, t[9] = e[9] * l, t[10] = e[10] * l, t[11] = e[11] * l, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
}
function c3(t, e, i, s) {
  let o = s[0], l = s[1], u = s[2], c = Math.sqrt(o * o + l * l + u * u), x, w, C, M, P, j, Y, Q, _e, me, we, Ee, Oe, Ne, ze, nt, mt, We, at, it, Ut, Rt, yt, di;
  return c < pu ? null : (c = 1 / c, o *= c, l *= c, u *= c, w = Math.sin(i), x = Math.cos(i), C = 1 - x, M = e[0], P = e[1], j = e[2], Y = e[3], Q = e[4], _e = e[5], me = e[6], we = e[7], Ee = e[8], Oe = e[9], Ne = e[10], ze = e[11], nt = o * o * C + x, mt = l * o * C + u * w, We = u * o * C - l * w, at = o * l * C - u * w, it = l * l * C + x, Ut = u * l * C + o * w, Rt = o * u * C + l * w, yt = l * u * C - o * w, di = u * u * C + x, t[0] = M * nt + Q * mt + Ee * We, t[1] = P * nt + _e * mt + Oe * We, t[2] = j * nt + me * mt + Ne * We, t[3] = Y * nt + we * mt + ze * We, t[4] = M * at + Q * it + Ee * Ut, t[5] = P * at + _e * it + Oe * Ut, t[6] = j * at + me * it + Ne * Ut, t[7] = Y * at + we * it + ze * Ut, t[8] = M * Rt + Q * yt + Ee * di, t[9] = P * Rt + _e * yt + Oe * di, t[10] = j * Rt + me * yt + Ne * di, t[11] = Y * Rt + we * yt + ze * di, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t);
}
function Jw(t, e, i) {
  const s = Math.sin(i), o = Math.cos(i), l = e[4], u = e[5], c = e[6], x = e[7], w = e[8], C = e[9], M = e[10], P = e[11];
  return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = l * o + w * s, t[5] = u * o + C * s, t[6] = c * o + M * s, t[7] = x * o + P * s, t[8] = w * o - l * s, t[9] = C * o - u * s, t[10] = M * o - c * s, t[11] = P * o - x * s, t;
}
function h3(t, e, i) {
  const s = Math.sin(i), o = Math.cos(i), l = e[0], u = e[1], c = e[2], x = e[3], w = e[8], C = e[9], M = e[10], P = e[11];
  return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = l * o - w * s, t[1] = u * o - C * s, t[2] = c * o - M * s, t[3] = x * o - P * s, t[8] = l * s + w * o, t[9] = u * s + C * o, t[10] = c * s + M * o, t[11] = x * s + P * o, t;
}
function Yw(t, e, i) {
  const s = Math.sin(i), o = Math.cos(i), l = e[0], u = e[1], c = e[2], x = e[3], w = e[4], C = e[5], M = e[6], P = e[7];
  return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = l * o + w * s, t[1] = u * o + C * s, t[2] = c * o + M * s, t[3] = x * o + P * s, t[4] = w * o - l * s, t[5] = C * o - u * s, t[6] = M * o - c * s, t[7] = P * o - x * s, t;
}
function u3(t, e) {
  const i = e[0], s = e[1], o = e[2], l = e[4], u = e[5], c = e[6], x = e[8], w = e[9], C = e[10];
  return t[0] = Math.sqrt(i * i + s * s + o * o), t[1] = Math.sqrt(l * l + u * u + c * c), t[2] = Math.sqrt(x * x + w * w + C * C), t;
}
function d3(t, e) {
  const i = e[0], s = e[1], o = e[2], l = e[3], u = i + i, c = s + s, x = o + o, w = i * u, C = s * u, M = s * c, P = o * u, j = o * c, Y = o * x, Q = l * u, _e = l * c, me = l * x;
  return t[0] = 1 - M - Y, t[1] = C + me, t[2] = P - _e, t[3] = 0, t[4] = C - me, t[5] = 1 - w - Y, t[6] = j + Q, t[7] = 0, t[8] = P + _e, t[9] = j - Q, t[10] = 1 - w - M, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
}
function f3(t, e, i, s, o, l, u) {
  const c = 1 / (i - e), x = 1 / (o - s), w = 1 / (l - u);
  return t[0] = l * 2 * c, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = l * 2 * x, t[6] = 0, t[7] = 0, t[8] = (i + e) * c, t[9] = (o + s) * x, t[10] = (u + l) * w, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = u * l * 2 * w, t[15] = 0, t;
}
function p3(t, e, i, s, o) {
  const l = 1 / Math.tan(e / 2);
  if (t[0] = l / i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, o != null && o !== 1 / 0) {
    const u = 1 / (s - o);
    t[10] = (o + s) * u, t[14] = 2 * o * s * u;
  } else
    t[10] = -1, t[14] = -2 * s;
  return t;
}
const _3 = p3;
function m3(t, e, i, s, o, l, u) {
  const c = 1 / (e - i), x = 1 / (s - o), w = 1 / (l - u);
  return t[0] = -2 * c, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * x, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * w, t[11] = 0, t[12] = (e + i) * c, t[13] = (o + s) * x, t[14] = (u + l) * w, t[15] = 1, t;
}
const g3 = m3;
function y3(t, e, i, s) {
  let o, l, u, c, x, w, C, M, P, j;
  const Y = e[0], Q = e[1], _e = e[2], me = s[0], we = s[1], Ee = s[2], Oe = i[0], Ne = i[1], ze = i[2];
  return Math.abs(Y - Oe) < pu && Math.abs(Q - Ne) < pu && Math.abs(_e - ze) < pu ? o3(t) : (M = Y - Oe, P = Q - Ne, j = _e - ze, o = 1 / Math.sqrt(M * M + P * P + j * j), M *= o, P *= o, j *= o, l = we * j - Ee * P, u = Ee * M - me * j, c = me * P - we * M, o = Math.sqrt(l * l + u * u + c * c), o ? (o = 1 / o, l *= o, u *= o, c *= o) : (l = 0, u = 0, c = 0), x = P * c - j * u, w = j * l - M * c, C = M * u - P * l, o = Math.sqrt(x * x + w * w + C * C), o ? (o = 1 / o, x *= o, w *= o, C *= o) : (x = 0, w = 0, C = 0), t[0] = l, t[1] = x, t[2] = M, t[3] = 0, t[4] = u, t[5] = w, t[6] = P, t[7] = 0, t[8] = c, t[9] = C, t[10] = j, t[11] = 0, t[12] = -(l * Y + u * Q + c * _e), t[13] = -(x * Y + w * Q + C * _e), t[14] = -(M * Y + P * Q + j * _e), t[15] = 1, t);
}
function b3() {
  const t = new xn(4);
  return xn != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;
}
function v3(t, e, i) {
  return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2], t[3] = e[3] + i[3], t;
}
function Qw(t, e, i) {
  return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[3] = e[3] * i, t;
}
function x3(t) {
  const e = t[0], i = t[1], s = t[2], o = t[3];
  return Math.sqrt(e * e + i * i + s * s + o * o);
}
function w3(t) {
  const e = t[0], i = t[1], s = t[2], o = t[3];
  return e * e + i * i + s * s + o * o;
}
function A3(t, e) {
  const i = e[0], s = e[1], o = e[2], l = e[3];
  let u = i * i + s * s + o * o + l * l;
  return u > 0 && (u = 1 / Math.sqrt(u)), t[0] = i * u, t[1] = s * u, t[2] = o * u, t[3] = l * u, t;
}
function T3(t, e) {
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];
}
function E3(t, e, i, s) {
  const o = e[0], l = e[1], u = e[2], c = e[3];
  return t[0] = o + s * (i[0] - o), t[1] = l + s * (i[1] - l), t[2] = u + s * (i[2] - u), t[3] = c + s * (i[3] - c), t;
}
function ku(t, e, i) {
  const s = e[0], o = e[1], l = e[2], u = e[3];
  return t[0] = i[0] * s + i[4] * o + i[8] * l + i[12] * u, t[1] = i[1] * s + i[5] * o + i[9] * l + i[13] * u, t[2] = i[2] * s + i[6] * o + i[10] * l + i[14] * u, t[3] = i[3] * s + i[7] * o + i[11] * l + i[15] * u, t;
}
function S3(t, e, i) {
  const s = e[0], o = e[1], l = e[2], u = i[0], c = i[1], x = i[2], w = i[3], C = w * s + c * l - x * o, M = w * o + x * s - u * l, P = w * l + u * o - c * s, j = -u * s - c * o - x * l;
  return t[0] = C * w + j * -u + M * -x - P * -c, t[1] = M * w + j * -c + P * -u - C * -x, t[2] = P * w + j * -x + C * -c - M * -u, t[3] = e[3], t;
}
(function() {
  const t = b3();
  return function(e, i, s, o, l, u) {
    let c, x;
    for (i || (i = 4), s || (s = 0), o ? x = Math.min(o * i + s, e.length) : x = e.length, c = s; c < x; c += i)
      t[0] = e[c], t[1] = e[c + 1], t[2] = e[c + 2], t[3] = e[c + 3], l(t, t, u), e[c] = t[0], e[c + 1] = t[1], e[c + 2] = t[2], e[c + 3] = t[3];
    return e;
  };
})();
var hg;
(function(t) {
  t[t.COL0ROW0 = 0] = "COL0ROW0", t[t.COL0ROW1 = 1] = "COL0ROW1", t[t.COL0ROW2 = 2] = "COL0ROW2", t[t.COL0ROW3 = 3] = "COL0ROW3", t[t.COL1ROW0 = 4] = "COL1ROW0", t[t.COL1ROW1 = 5] = "COL1ROW1", t[t.COL1ROW2 = 6] = "COL1ROW2", t[t.COL1ROW3 = 7] = "COL1ROW3", t[t.COL2ROW0 = 8] = "COL2ROW0", t[t.COL2ROW1 = 9] = "COL2ROW1", t[t.COL2ROW2 = 10] = "COL2ROW2", t[t.COL2ROW3 = 11] = "COL2ROW3", t[t.COL3ROW0 = 12] = "COL3ROW0", t[t.COL3ROW1 = 13] = "COL3ROW1", t[t.COL3ROW2 = 14] = "COL3ROW2", t[t.COL3ROW3 = 15] = "COL3ROW3";
})(hg || (hg = {}));
const C3 = 45 * Math.PI / 180, I3 = 1, Q_ = 0.1, em = 500, R3 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class Xt extends Kw {
  static get IDENTITY() {
    return P3();
  }
  static get ZERO() {
    return M3();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return hg;
  }
  constructor(e) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this[9] = e[9], this[10] = e[10], this[11] = e[11], this[12] = e[12], this[13] = e[13], this[14] = e[14], this[15] = e[15], this.check();
  }
  // eslint-disable-next-line max-params
  set(e, i, s, o, l, u, c, x, w, C, M, P, j, Y, Q, _e) {
    return this[0] = e, this[1] = i, this[2] = s, this[3] = o, this[4] = l, this[5] = u, this[6] = c, this[7] = x, this[8] = w, this[9] = C, this[10] = M, this[11] = P, this[12] = j, this[13] = Y, this[14] = Q, this[15] = _e, this.check();
  }
  // accepts row major order, stores as column major
  // eslint-disable-next-line max-params
  setRowMajor(e, i, s, o, l, u, c, x, w, C, M, P, j, Y, Q, _e) {
    return this[0] = e, this[1] = l, this[2] = w, this[3] = j, this[4] = i, this[5] = u, this[6] = C, this[7] = Y, this[8] = s, this[9] = c, this[10] = M, this[11] = Q, this[12] = o, this[13] = x, this[14] = P, this[15] = _e, this.check();
  }
  toRowMajor(e) {
    return e[0] = this[0], e[1] = this[4], e[2] = this[8], e[3] = this[12], e[4] = this[1], e[5] = this[5], e[6] = this[9], e[7] = this[13], e[8] = this[2], e[9] = this[6], e[10] = this[10], e[11] = this[14], e[12] = this[3], e[13] = this[7], e[14] = this[11], e[15] = this[15], e;
  }
  // Constructors
  /** Set to identity matrix */
  identity() {
    return this.copy(R3);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(e) {
    return this.check();
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @param quaternion Quaternion to create matrix from
   * @returns self
   */
  fromQuaternion(e) {
    return d3(this, e), this.check();
  }
  /**
   * Generates a frustum matrix with the given bounds
   * @param view.left - Left bound of the frustum
   * @param view.right - Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top - Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far - Far bound of the frustum. Can be set to Infinity.
   * @returns self
   */
  frustum(e) {
    const { left: i, right: s, bottom: o, top: l, near: u = Q_, far: c = em } = e;
    return c === 1 / 0 ? B3(this, i, s, o, l, u) : f3(this, i, s, o, l, u, c), this.check();
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point,
   * and up axis
   * @param view.eye - (vector) Position of the viewer
   * @param view.center - (vector) Point the viewer is looking at
   * @param view.up - (vector) Up axis
   * @returns self
   */
  lookAt(e) {
    const { eye: i, center: s = [0, 0, 0], up: o = [0, 1, 0] } = e;
    return y3(this, i, s, o), this.check();
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   * from "traditional" view space parameters
   * @param view.left - Left bound of the frustum
   * @param view.right number  Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top number  Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far number  Far bound of the frustum
   * @returns self
   */
  ortho(e) {
    const { left: i, right: s, bottom: o, top: l, near: u = Q_, far: c = em } = e;
    return g3(this, i, s, o, l, u, c), this.check();
  }
  /**
   * Generates an orthogonal projection matrix with the same parameters
   * as a perspective matrix (plus focalDistance)
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. Typically viewport width / viewport height
   * @param view.focalDistance Distance in the view frustum used for extent calculations
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  orthographic(e) {
    const { fovy: i = C3, aspect: s = I3, focalDistance: o = 1, near: l = Q_, far: u = em } = e;
    Av(i);
    const c = i / 2, x = o * Math.tan(c), w = x * s;
    return this.ortho({
      left: -w,
      right: w,
      bottom: -x,
      top: x,
      near: l,
      far: u
    });
  }
  /**
   * Generates a perspective projection matrix with the given bounds
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. typically viewport width/height
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  perspective(e) {
    const { fovy: i = 45 * Math.PI / 180, aspect: s = 1, near: o = 0.1, far: l = 500 } = e;
    return Av(i), _3(this, i, s, o, l), this.check();
  }
  // Accessors
  determinant() {
    return l3(this);
  }
  /**
   * Extracts the non-uniform scale assuming the matrix is an affine transformation.
   * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
   * @param result
   * @returns self
   */
  getScale(e = [-0, -0, -0]) {
    return e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), e;
  }
  /**
   * Gets the translation portion, assuming the matrix is a affine transformation matrix.
   * @param result
   * @returns self
   */
  getTranslation(e = [-0, -0, -0]) {
    return e[0] = this[12], e[1] = this[13], e[2] = this[14], e;
  }
  /**
   * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotation(e, i) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], i = i || [-0, -0, -0];
    const s = this.getScale(i), o = 1 / s[0], l = 1 / s[1], u = 1 / s[2];
    return e[0] = this[0] * o, e[1] = this[1] * l, e[2] = this[2] * u, e[3] = 0, e[4] = this[4] * o, e[5] = this[5] * l, e[6] = this[6] * u, e[7] = 0, e[8] = this[8] * o, e[9] = this[9] * l, e[10] = this[10] * u, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   *
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotationMatrix3(e, i) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0], i = i || [-0, -0, -0];
    const s = this.getScale(i), o = 1 / s[0], l = 1 / s[1], u = 1 / s[2];
    return e[0] = this[0] * o, e[1] = this[1] * l, e[2] = this[2] * u, e[3] = this[4] * o, e[4] = this[5] * l, e[5] = this[6] * u, e[6] = this[8] * o, e[7] = this[9] * l, e[8] = this[10] * u, e;
  }
  // Modifiers
  transpose() {
    return a3(this, this), this.check();
  }
  invert() {
    return cg(this, this), this.check();
  }
  // Operations
  multiplyLeft(e) {
    return rl(this, e, this), this.check();
  }
  multiplyRight(e) {
    return rl(this, this, e), this.check();
  }
  // Rotates a matrix by the given angle around the X axis
  rotateX(e) {
    return Jw(this, this, e), this.check();
  }
  // Rotates a matrix by the given angle around the Y axis.
  rotateY(e) {
    return h3(this, this, e), this.check();
  }
  /**
   * Rotates a matrix by the given angle around the Z axis.
   * @param radians
   * @returns self
   */
  rotateZ(e) {
    return Yw(this, this, e), this.check();
  }
  /**
   *
   * @param param0
   * @returns self
   */
  rotateXYZ(e) {
    return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2]);
  }
  /**
   *
   * @param radians
   * @param axis
   * @returns self
   */
  rotateAxis(e, i) {
    return c3(this, this, e, i), this.check();
  }
  /**
   *
   * @param factor
   * @returns self
   */
  scale(e) {
    return hy(this, this, Array.isArray(e) ? e : [e, e, e]), this.check();
  }
  /**
   *
   * @param vec
   * @returns self
   */
  translate(e) {
    return Vf(this, this, e), this.check();
  }
  // Transforms
  /**
   * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
   * @param vector
   * @param result
   * @returns self
   */
  transform(e, i) {
    return e.length === 4 ? (i = ku(i || [-0, -0, -0, -0], e, this), fu(i, 4), i) : this.transformAsPoint(e, i);
  }
  /**
   * Transforms any 2 or 3 element array as point (w implicitly 1)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsPoint(e, i) {
    const { length: s } = e;
    let o;
    switch (s) {
      case 2:
        o = Hw(i || [-0, -0], e, this);
        break;
      case 3:
        o = ly(i || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return fu(o, e.length), o;
  }
  /**
   * Transforms any 2 or 3 element array as vector (w implicitly 0)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsVector(e, i) {
    let s;
    switch (e.length) {
      case 2:
        s = jw(i || [-0, -0], e, this);
        break;
      case 3:
        s = $w(i || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return fu(s, e.length), s;
  }
  /** @deprecated */
  transformPoint(e, i) {
    return this.transformAsPoint(e, i);
  }
  /** @deprecated */
  transformVector(e, i) {
    return this.transformAsPoint(e, i);
  }
  /** @deprecated */
  transformDirection(e, i) {
    return this.transformAsVector(e, i);
  }
  // three.js math API compatibility
  makeRotationX(e) {
    return this.identity().rotateX(e);
  }
  makeTranslation(e, i, s) {
    return this.identity().translate([e, i, s]);
  }
}
let Jd, Yd;
function M3() {
  return Jd || (Jd = new Xt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Jd)), Jd;
}
function P3() {
  return Yd || (Yd = new Xt(), Object.freeze(Yd)), Yd;
}
function Av(t) {
  if (t > Math.PI * 2)
    throw Error("expected radians");
}
function B3(t, e, i, s, o, l) {
  const u = 2 * l / (i - e), c = 2 * l / (o - s), x = (i + e) / (i - e), w = (o + s) / (o - s), C = -1, M = -1, P = -2 * l;
  return t[0] = u, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = c, t[6] = 0, t[7] = 0, t[8] = x, t[9] = w, t[10] = C, t[11] = M, t[12] = 0, t[13] = 0, t[14] = P, t[15] = 0, t;
}
function Tv() {
  const t = new xn(4);
  return xn != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
}
function D3(t) {
  return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
}
function eA(t, e, i) {
  i = i * 0.5;
  const s = Math.sin(i);
  return t[0] = s * e[0], t[1] = s * e[1], t[2] = s * e[2], t[3] = Math.cos(i), t;
}
function Ev(t, e, i) {
  const s = e[0], o = e[1], l = e[2], u = e[3], c = i[0], x = i[1], w = i[2], C = i[3];
  return t[0] = s * C + u * c + o * w - l * x, t[1] = o * C + u * x + l * c - s * w, t[2] = l * C + u * w + s * x - o * c, t[3] = u * C - s * c - o * x - l * w, t;
}
function O3(t, e, i) {
  i *= 0.5;
  const s = e[0], o = e[1], l = e[2], u = e[3], c = Math.sin(i), x = Math.cos(i);
  return t[0] = s * x + u * c, t[1] = o * x + l * c, t[2] = l * x - o * c, t[3] = u * x - s * c, t;
}
function F3(t, e, i) {
  i *= 0.5;
  const s = e[0], o = e[1], l = e[2], u = e[3], c = Math.sin(i), x = Math.cos(i);
  return t[0] = s * x - l * c, t[1] = o * x + u * c, t[2] = l * x + s * c, t[3] = u * x - o * c, t;
}
function k3(t, e, i) {
  i *= 0.5;
  const s = e[0], o = e[1], l = e[2], u = e[3], c = Math.sin(i), x = Math.cos(i);
  return t[0] = s * x + o * c, t[1] = o * x - s * c, t[2] = l * x + u * c, t[3] = u * x - l * c, t;
}
function N3(t, e) {
  const i = e[0], s = e[1], o = e[2];
  return t[0] = i, t[1] = s, t[2] = o, t[3] = Math.sqrt(Math.abs(1 - i * i - s * s - o * o)), t;
}
function xf(t, e, i, s) {
  const o = e[0], l = e[1], u = e[2], c = e[3];
  let x = i[0], w = i[1], C = i[2], M = i[3], P, j, Y, Q, _e;
  return P = o * x + l * w + u * C + c * M, P < 0 && (P = -P, x = -x, w = -w, C = -C, M = -M), 1 - P > pu ? (j = Math.acos(P), _e = Math.sin(j), Y = Math.sin((1 - s) * j) / _e, Q = Math.sin(s * j) / _e) : (Y = 1 - s, Q = s), t[0] = Y * o + Q * x, t[1] = Y * l + Q * w, t[2] = Y * u + Q * C, t[3] = Y * c + Q * M, t;
}
function L3(t, e) {
  const i = e[0], s = e[1], o = e[2], l = e[3], u = i * i + s * s + o * o + l * l, c = u ? 1 / u : 0;
  return t[0] = -i * c, t[1] = -s * c, t[2] = -o * c, t[3] = l * c, t;
}
function U3(t, e) {
  return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;
}
function tA(t, e) {
  const i = e[0] + e[4] + e[8];
  let s;
  if (i > 0)
    s = Math.sqrt(i + 1), t[3] = 0.5 * s, s = 0.5 / s, t[0] = (e[5] - e[7]) * s, t[1] = (e[6] - e[2]) * s, t[2] = (e[1] - e[3]) * s;
  else {
    let o = 0;
    e[4] > e[0] && (o = 1), e[8] > e[o * 3 + o] && (o = 2);
    const l = (o + 1) % 3, u = (o + 2) % 3;
    s = Math.sqrt(e[o * 3 + o] - e[l * 3 + l] - e[u * 3 + u] + 1), t[o] = 0.5 * s, s = 0.5 / s, t[3] = (e[l * 3 + u] - e[u * 3 + l]) * s, t[l] = (e[l * 3 + o] + e[o * 3 + l]) * s, t[u] = (e[u * 3 + o] + e[o * 3 + u]) * s;
  }
  return t;
}
const z3 = v3, V3 = Qw, H3 = T3, j3 = E3, $3 = x3, G3 = w3, iA = A3, X3 = function() {
  const t = Xw(), e = vv(1, 0, 0), i = vv(0, 1, 0);
  return function(s, o, l) {
    const u = ay(o, l);
    return u < -0.999999 ? (vf(t, e, o), ZP(t) < 1e-6 && vf(t, i, o), jP(t, t), eA(s, t, Math.PI), s) : u > 0.999999 ? (s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1, s) : (vf(t, o, l), s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = 1 + u, iA(s, s));
  };
}();
(function() {
  const t = Tv(), e = Tv();
  return function(i, s, o, l, u, c) {
    return xf(t, s, u, c), xf(e, o, l, c), xf(i, t, e, 2 * c * (1 - c)), i;
  };
})();
(function() {
  const t = KP();
  return function(e, i, s, o) {
    return t[0] = s[0], t[3] = s[1], t[6] = s[2], t[1] = o[0], t[4] = o[1], t[7] = o[2], t[2] = -i[0], t[5] = -i[1], t[8] = -i[2], iA(e, tA(e, t));
  };
})();
const W3 = [0, 0, 0, 1];
class Au extends ry {
  constructor(e = 0, i = 0, s = 0, o = 1) {
    super(-0, -0, -0, -0), Array.isArray(e) && arguments.length === 1 ? this.copy(e) : this.set(e, i, s, o);
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  set(e, i, s, o) {
    return this[0] = e, this[1] = i, this[2] = s, this[3] = o, this.check();
  }
  fromObject(e) {
    return this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this.check();
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   * NOTE: The resultant quaternion is not normalized, so you should
   * be sure to renormalize the quaternion yourself where necessary.
   * @param m
   * @returns
   */
  fromMatrix3(e) {
    return tA(this, e), this.check();
  }
  fromAxisRotation(e, i) {
    return eA(this, e, i), this.check();
  }
  /** Set a quat to the identity quaternion */
  identity() {
    return D3(this), this.check();
  }
  // Set the components of a quat to the given values
  // set(i, j, k, l) {
  //   quat_set(this, i, j, k, l);
  //   return this.check();
  // }
  // Sets a quat from the given angle and rotation axis, then returns it.
  setAxisAngle(e, i) {
    return this.fromAxisRotation(e, i);
  }
  // Getters/setters
  get ELEMENTS() {
    return 4;
  }
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = si(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = si(e);
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = si(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = si(e);
  }
  // Calculates the length of a quat
  len() {
    return $3(this);
  }
  // Calculates the squared length of a quat
  lengthSquared() {
    return G3(this);
  }
  // Calculates the dot product of two quat's
  // @return {Number}
  dot(e) {
    return H3(this, e);
  }
  // Gets the rotation axis and angle for a given quaternion.
  // If a quaternion is created with setAxisAngle, this method will
  // return the same values as providied in the original parameter
  // list OR functionally equivalent values.
  // Example: The quaternion formed by axis [0, 0, 1] and angle -90
  // is the same as the quaternion formed by [0, 0, 1] and 270.
  // This method favors the latter.
  // @return {{[x,y,z], Number}}
  // getAxisAngle() {
  //   const axis = [];
  // //   const angle = quat_getAxisAngle(axis, this);
  //   return {axis, angle};
  // }
  // MODIFIERS
  // Sets a quaternion to represent the shortest rotation from one vector
  // to another. Both vectors are assumed to be unit length.
  rotationTo(e, i) {
    return X3(this, e, i), this.check();
  }
  // Sets the specified quaternion with values corresponding to the given axes.
  // Each axis is a vec3 and is expected to be unit length and perpendicular
  // to all other specified axes.
  // setAxes() {
  //   Number
  // }
  // Performs a spherical linear interpolation with two control points
  // sqlerp() {
  //   Number;
  // }
  // Adds two quat's
  add(e) {
    return z3(this, this, e), this.check();
  }
  // Calculates the W component of a quat from the X, Y, and Z components.
  // Any existing W component will be ignored.
  calculateW() {
    return N3(this, this), this.check();
  }
  // Calculates the conjugate of a quat If the quaternion is normalized,
  // this function is faster than quat_invert and produces the same result.
  conjugate() {
    return U3(this, this), this.check();
  }
  // Calculates the inverse of a quat
  invert() {
    return L3(this, this), this.check();
  }
  // Performs a linear interpolation between two quat's
  lerp(e, i, s) {
    return s === void 0 ? this.lerp(this, e, i) : (j3(this, e, i, s), this.check());
  }
  // Multiplies two quat's
  multiplyRight(e) {
    return Ev(this, this, e), this.check();
  }
  multiplyLeft(e) {
    return Ev(this, e, this), this.check();
  }
  // Normalize a quat
  normalize() {
    const e = this.len(), i = e > 0 ? 1 / e : 0;
    return this[0] = this[0] * i, this[1] = this[1] * i, this[2] = this[2] * i, this[3] = this[3] * i, e === 0 && (this[3] = 1), this.check();
  }
  // Rotates a quaternion by the given angle about the X axis
  rotateX(e) {
    return O3(this, this, e), this.check();
  }
  // Rotates a quaternion by the given angle about the Y axis
  rotateY(e) {
    return F3(this, this, e), this.check();
  }
  // Rotates a quaternion by the given angle about the Z axis
  rotateZ(e) {
    return k3(this, this, e), this.check();
  }
  // Scales a quat by a scalar number
  scale(e) {
    return V3(this, this, e), this.check();
  }
  // Performs a spherical linear interpolation between two quat
  slerp(e, i, s) {
    let o, l, u;
    switch (arguments.length) {
      case 1:
        ({
          start: o = W3,
          target: l,
          ratio: u
        } = e);
        break;
      case 2:
        o = this, l = e, u = i;
        break;
      default:
        o = e, l = i, u = s;
    }
    return xf(this, o, l, u), this.check();
  }
  transformVector4(e, i = new cy()) {
    return S3(i, e, this), fu(i, 4);
  }
  // THREE.js Math API compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  setFromAxisAngle(e, i) {
    return this.setAxisAngle(e, i);
  }
  premultiply(e) {
    return this.multiplyLeft(e);
  }
  multiply(e) {
    return this.multiplyRight(e);
  }
}
const q3 = 0.1, Z3 = 1e-12, sA = 1e-15, K3 = 1e-20, Sv = `#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
vec3 color;
};
struct PointLight {
vec3 color;
vec3 position;
vec3 attenuation;
};
struct DirectionalLight {
vec3 color;
vec3 direction;
};
uniform AmbientLight lighting_uAmbientLight;
uniform PointLight lighting_uPointLight[MAX_LIGHTS];
uniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];
uniform int lighting_uPointLightCount;
uniform int lighting_uDirectionalLightCount;
uniform bool lighting_uEnabled;
float getPointLightAttenuation(PointLight pointLight, float distance) {
return pointLight.attenuation.x
+ pointLight.attenuation.y * distance
+ pointLight.attenuation.z * distance * distance;
}
#endif
`, J3 = {
  lightSources: {}
};
function tm(t = {}) {
  const { color: e = [0, 0, 0], intensity: i = 1 } = t;
  return e.map((s) => s * i / 255);
}
function Y3({ ambientLight: t, pointLights: e = [], directionalLights: i = [] }) {
  const s = {};
  return t ? s["lighting_uAmbientLight.color"] = tm(t) : s["lighting_uAmbientLight.color"] = [0, 0, 0], e.forEach((o, l) => {
    s[`lighting_uPointLight[${l}].color`] = tm(o), s[`lighting_uPointLight[${l}].position`] = o.position, s[`lighting_uPointLight[${l}].attenuation`] = o.attenuation || [
      1,
      0,
      0
    ];
  }), s.lighting_uPointLightCount = e.length, i.forEach((o, l) => {
    s[`lighting_uDirectionalLight[${l}].color`] = tm(o), s[`lighting_uDirectionalLight[${l}].direction`] = o.direction;
  }), s.lighting_uDirectionalLightCount = i.length, s;
}
function rA(t = J3) {
  var e, i;
  if ("lightSources" in t) {
    const { ambientLight: s, pointLights: o, directionalLights: l } = t.lightSources || {};
    return s || o && o.length > 0 || l && l.length > 0 ? Object.assign({}, Y3({ ambientLight: s, pointLights: o, directionalLights: l }), {
      lighting_uEnabled: !0
    }) : { lighting_uEnabled: !1 };
  }
  if ("lights" in t) {
    const s = { pointLights: [], directionalLights: [] };
    for (const o of t.lights || [])
      switch (o.type) {
        case "ambient":
          s.ambientLight = o;
          break;
        case "directional":
          (e = s.directionalLights) == null || e.push(o);
          break;
        case "point":
          (i = s.pointLights) == null || i.push(o);
          break;
      }
    return rA({ lightSources: s });
  }
  return {};
}
const uy = {
  name: "lights",
  vs: Sv,
  fs: Sv,
  getUniforms: rA,
  defines: {
    MAX_LIGHTS: 3
  }
}, nA = `uniform float lighting_uAmbient;
uniform float lighting_uDiffuse;
uniform float lighting_uShininess;
uniform vec3  lighting_uSpecularColor;
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
vec3 halfway_direction = normalize(light_direction + view_direction);
float lambertian = dot(light_direction, normal_worldspace);
float specular = 0.0;
if (lambertian > 0.0) {
float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
specular = pow(specular_angle, lighting_uShininess);
}
lambertian = max(lambertian, 0.0);
return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;
}
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = surfaceColor;
if (lighting_uEnabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uPointLightCount) {
break;
}
PointLight pointLight = lighting_uPointLight[i];
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uDirectionalLightCount) {
break;
}
DirectionalLight directionalLight = lighting_uDirectionalLight[i];
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = vec3(0, 0, 0);
vec3 surfaceColor = vec3(0, 0, 0);
if (lighting_uEnabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uPointLightCount) {
break;
}
PointLight pointLight = lighting_uPointLight[i];
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uDirectionalLightCount) {
break;
}
DirectionalLight directionalLight = lighting_uDirectionalLight[i];
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
`, Q3 = {};
function eB(t) {
  const { ambient: e = 0.35, diffuse: i = 0.6, shininess: s = 32, specularColor: o = [30, 30, 30] } = t;
  return {
    lighting_uAmbient: e,
    lighting_uDiffuse: i,
    lighting_uShininess: s,
    lighting_uSpecularColor: o.map((l) => l / 255)
  };
}
function oA(t = Q3) {
  if (!("material" in t))
    return {};
  const { material: e } = t;
  return e ? eB(e) : { lighting_uEnabled: !1 };
}
const tB = {
  name: "gouraud-lighting",
  dependencies: [uy],
  vs: nA,
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms: oA
}, iB = {
  name: "phong-lighting",
  dependencies: [uy],
  fs: nA,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  getUniforms: oA
}, sB = `uniform mat4 u_MVPMatrix;
uniform mat4 u_ModelMatrix;
uniform mat4 u_NormalMatrix;
out vec3 pbr_vPosition;
out vec2 pbr_vUV;
#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
out mat3 pbr_vTBN;
# else
out vec3 pbr_vNormal;
# endif
#endif
void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
vec4 pos = u_ModelMatrix * position;
pbr_vPosition = vec3(pos.xyz) / pos.w;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));
vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));
vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else
pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0.,0.);
#endif
}
`, rB = `precision highp float;
uniform bool pbr_uUnlit;
#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
uniform vec2 u_ScaleIBLAmbient;
#endif
#ifdef HAS_BASECOLORMAP
uniform sampler2D u_BaseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D u_NormalSampler;
uniform float u_NormalScale;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D u_EmissiveSampler;
uniform vec3 u_EmissiveFactor;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D u_MetallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D u_OcclusionSampler;
uniform float u_OcclusionStrength;
#endif
#ifdef ALPHA_CUTOFF
uniform float u_AlphaCutoff;
#endif
uniform vec2 u_MetallicRoughnessValues;
uniform vec4 u_BaseColorFactor;
uniform vec3 u_Camera;
#ifdef PBR_DEBUG
uniform vec4 u_ScaleDiffBaseMR;
uniform vec4 u_ScaleFGDSpec;
#endif
in vec3 pbr_vPosition;
in vec2 pbr_vUV;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
in mat3 pbr_vTBN;
#else
in vec3 pbr_vNormal;
#endif
#endif
struct PBRInfo
{
float NdotL;
float NdotV;
float NdotH;
float LdotH;
float VdotH;
float perceptualRoughness;
float metalness;
vec3 reflectance0;
vec3 reflectance90;
float alphaRoughness;
vec3 diffuseColor;
vec3 specularColor;
vec3 n;
vec3 v;
};
const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;
vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else
vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif
return vec4(linOut,srgbIn.w);;
#else
return srgbIn;
#endif
}
vec3 getNormal()
{
#ifndef HAS_TANGENTS
vec3 pos_dx = dFdx(pbr_vPosition);
vec3 pos_dy = dFdy(pbr_vPosition);
vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);
#ifdef HAS_NORMALS
vec3 ng = normalize(pbr_vNormal);
#else
vec3 ng = cross(pos_dx, pos_dy);
#endif
t = normalize(t - ng * dot(ng, t));
vec3 b = normalize(cross(ng, t));
mat3 tbn = mat3(t, b, ng);
#else
mat3 tbn = pbr_vTBN;
#endif
#ifdef HAS_NORMALMAP
vec3 n = texture(u_NormalSampler, pbr_vUV).rgb;
n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));
#else
vec3 n = normalize(tbn[2].xyz);
#endif
return n;
}
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
{
float mipCount = 9.0;
float lod = (pbrInputs.perceptualRoughness * mipCount);
vec3 brdf = SRGBtoLINEAR(texture(u_brdfLUT,
vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;
#ifdef USE_TEX_LOD
vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;
#else
vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;
#endif
vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);
diffuse *= u_ScaleIBLAmbient.x;
specular *= u_ScaleIBLAmbient.y;
return diffuse + specular;
}
#endif
vec3 diffuse(PBRInfo pbrInputs)
{
return pbrInputs.diffuseColor / M_PI;
}
vec3 specularReflection(PBRInfo pbrInputs)
{
return pbrInputs.reflectance0 +
(pbrInputs.reflectance90 - pbrInputs.reflectance0) *
pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
}
float geometricOcclusion(PBRInfo pbrInputs)
{
float NdotL = pbrInputs.NdotL;
float NdotV = pbrInputs.NdotV;
float r = pbrInputs.alphaRoughness;
float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
return attenuationL * attenuationV;
}
float microfacetDistribution(PBRInfo pbrInputs)
{
float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
return roughnessSq / (M_PI * f * f);
}
void PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {
pbrInputs.NdotL = 1.0;
pbrInputs.NdotH = 0.0;
pbrInputs.LdotH = 0.0;
pbrInputs.VdotH = 1.0;
}
void PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {
vec3 n = pbrInputs.n;
vec3 v = pbrInputs.v;
vec3 l = normalize(lightDirection);
vec3 h = normalize(l+v);
pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);
pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);
pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);
pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);
}
void PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {
vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
PBRInfo_setDirectionalLight(pbrInputs, light_direction);
}
vec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {
vec3 F = specularReflection(pbrInputs);
float G = geometricOcclusion(pbrInputs);
float D = microfacetDistribution(pbrInputs);
vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);
return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);
}
vec4 pbr_filterColor(vec4 colorUnused)
{
#ifdef HAS_BASECOLORMAP
vec4 baseColor = SRGBtoLINEAR(texture(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;
#else
vec4 baseColor = u_BaseColorFactor;
#endif
#ifdef ALPHA_CUTOFF
if (baseColor.a < u_AlphaCutoff) {
discard;
}
#endif
vec3 color = vec3(0, 0, 0);
if(pbr_uUnlit){
color.rgb = baseColor.rgb;
}
else{
float perceptualRoughness = u_MetallicRoughnessValues.y;
float metallic = u_MetallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
vec4 mrSample = texture(u_MetallicRoughnessSampler, pbr_vUV);
perceptualRoughness = mrSample.g * perceptualRoughness;
metallic = mrSample.b * metallic;
#endif
perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
metallic = clamp(metallic, 0.0, 1.0);
float alphaRoughness = perceptualRoughness * perceptualRoughness;
vec3 f0 = vec3(0.04);
vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
diffuseColor *= 1.0 - metallic;
vec3 specularColor = mix(f0, baseColor.rgb, metallic);
float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);
float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
vec3 specularEnvironmentR0 = specularColor.rgb;
vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;
vec3 n = getNormal();
vec3 v = normalize(u_Camera - pbr_vPosition);
float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
vec3 reflection = -normalize(reflect(v, n));
PBRInfo pbrInputs = PBRInfo(
0.0,
NdotV,
0.0,
0.0,
0.0,
perceptualRoughness,
metallic,
specularEnvironmentR0,
specularEnvironmentR90,
alphaRoughness,
diffuseColor,
specularColor,
n,
v
);
#ifdef USE_LIGHTS
PBRInfo_setAmbientLight(pbrInputs);
color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);
for(int i = 0; i < lighting_uDirectionalLightCount; i++) {
if (i < lighting_uDirectionalLightCount) {
PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);
color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);
}
}
for(int i = 0; i < lighting_uPointLightCount; i++) {
if (i < lighting_uPointLightCount) {
PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);
float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));
color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);
}
}
#endif
#ifdef USE_IBL
color += getIBLContribution(pbrInputs, n, reflection);
#endif
#ifdef HAS_OCCLUSIONMAP
float ao = texture(u_OcclusionSampler, pbr_vUV).r;
color = mix(color, color * ao, u_OcclusionStrength);
#endif
#ifdef HAS_EMISSIVEMAP
vec3 emissive = SRGBtoLINEAR(texture(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;
color += emissive;
#endif
#ifdef PBR_DEBUG
color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);
color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);
color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);
#endif
}
return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`, dy = {
  name: "pbr",
  vs: sB,
  fs: rB,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  dependencies: [uy]
}, aA = "#define SMOOTH_EDGE_RADIUS 0.5", nB = `
${aA}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`, oB = `
${aA}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`, aB = { name: "geometry", vs: nB, fs: oB }, Wt = {
  /**
   * `LNGLAT` if rendering into a geospatial viewport, `CARTESIAN` otherwise
   */
  DEFAULT: -1,
  /**
   * Positions are interpreted as [longitude, latitude, elevation]
   * longitude/latitude are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT: 1,
  /**
   * Positions are interpreted as [x, y, z] in meter offsets from the coordinate origin.
   * Dimensions are in meters.
   */
  METER_OFFSETS: 2,
  /**
   * Positions are interpreted as [deltaLng, deltaLat, elevation] from the coordinate origin.
   * deltaLng/deltaLat are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT_OFFSETS: 3,
  /**
   * Positions and dimensions are in the common units of the viewport.
   */
  CARTESIAN: 0
};
Object.defineProperty(Wt, "IDENTITY", {
  get: () => (Jt.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
});
const Wn = {
  /**
   * Render geospatial data in Web Mercator projection
   */
  WEB_MERCATOR: 1,
  /**
   * Render geospatial data as a 3D globe
   */
  GLOBE: 2,
  /**
   * (Internal use only) Web Mercator projection at high zoom
   */
  WEB_MERCATOR_AUTO_OFFSET: 4,
  /**
   * No transformation
   */
  IDENTITY: 0
}, ug = {
  common: 0,
  meters: 1,
  pixels: 2
}, dg = {
  click: { handler: "onClick" },
  panstart: { handler: "onDragStart" },
  panmove: { handler: "onDrag" },
  panend: { handler: "onDragEnd" }
}, lB = Object.keys(Wt).map((t) => `const int COORDINATE_SYSTEM_${t} = ${Wt[t]};`).join(""), cB = Object.keys(Wn).map((t) => `const int PROJECTION_MODE_${t} = ${Wn[t]};`).join(""), hB = Object.keys(ug).map((t) => `const int UNIT_${t.toUpperCase()} = ${ug[t]};`).join(""), uB = `${lB}
${cB}
${hB}
uniform int project_uCoordinateSystem;
uniform int project_uProjectionMode;
uniform float project_uScale;
uniform bool project_uWrapLongitude;
uniform vec3 project_uCommonUnitsPerMeter;
uniform vec3 project_uCommonUnitsPerWorldUnit;
uniform vec3 project_uCommonUnitsPerWorldUnit2;
uniform vec4 project_uCenter;
uniform mat4 project_uModelMatrix;
uniform mat4 project_uViewProjectionMatrix;
uniform vec2 project_uViewportSize;
uniform float project_uDevicePixelRatio;
uniform float project_uFocalDistance;
uniform vec3 project_uCameraPosition;
uniform vec3 project_uCoordinateOrigin;
uniform vec3 project_uCommonOrigin;
uniform bool project_uPseudoMeters;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project_uPseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project_uCommonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project_uCommonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project_uCommonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project_uWrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project_uModelMatrix * position;
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project_uCoordinateOrigin;
}
}
if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project_uCommonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||
(project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project_uCoordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project_uModelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;
return offset * project_uFocalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project_uScale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project_uScale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project_uScale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project_uScale;
}
`;
function dB(t, e) {
  if (t === e)
    return !0;
  if (Array.isArray(t)) {
    const i = t.length;
    if (!e || e.length !== i)
      return !1;
    for (let s = 0; s < i; s++)
      if (t[s] !== e[s])
        return !1;
    return !0;
  }
  return !1;
}
function Nu(t) {
  let e = {}, i;
  return (s) => {
    for (const o in s)
      if (!dB(s[o], e[o])) {
        i = t(s), e = s;
        break;
      }
    return i;
  };
}
const Cv = [0, 0, 0, 0], fB = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], lA = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], pB = [0, 0, 0], cA = [0, 0, 0], _B = Nu(yB);
function hA(t, e, i = cA) {
  i.length < 3 && (i = [i[0], i[1], 0]);
  let s = i, o, l = !0;
  switch (e === Wt.LNGLAT_OFFSETS || e === Wt.METER_OFFSETS ? o = i : o = t.isGeospatial ? (
    // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports
    [Math.fround(t.longitude), Math.fround(t.latitude), 0]
  ) : null, t.projectionMode) {
    case Wn.WEB_MERCATOR:
      (e === Wt.LNGLAT || e === Wt.CARTESIAN) && (o = [0, 0, 0], l = !1);
      break;
    case Wn.WEB_MERCATOR_AUTO_OFFSET:
      e === Wt.LNGLAT ? s = o : e === Wt.CARTESIAN && (s = [
        Math.fround(t.center[0]),
        Math.fround(t.center[1]),
        0
      ], o = t.unprojectPosition(s), s[0] -= i[0], s[1] -= i[1], s[2] -= i[2]);
      break;
    case Wn.IDENTITY:
      s = t.position.map(Math.fround), s[2] = s[2] || 0;
      break;
    case Wn.GLOBE:
      l = !1, o = null;
      break;
    default:
      l = !1;
  }
  return { geospatialOrigin: o, shaderCoordinateOrigin: s, offsetMode: l };
}
function mB(t, e, i) {
  const { viewMatrixUncentered: s, projectionMatrix: o } = t;
  let { viewMatrix: l, viewProjectionMatrix: u } = t, c = Cv, x = Cv, w = t.cameraPosition;
  const { geospatialOrigin: C, shaderCoordinateOrigin: M, offsetMode: P } = hA(t, e, i);
  return P && (x = t.projectPosition(C || M), w = [
    w[0] - x[0],
    w[1] - x[1],
    w[2] - x[2]
  ], x[3] = 1, c = ku([], x, u), l = s || l, u = rl([], o, l), u = rl([], u, fB)), {
    viewMatrix: l,
    viewProjectionMatrix: u,
    projectionCenter: c,
    originCommon: x,
    cameraPosCommon: w,
    shaderCoordinateOrigin: M,
    geospatialOrigin: C
  };
}
function gB({
  viewport: t,
  devicePixelRatio: e = 1,
  modelMatrix: i = null,
  // Match Layer.defaultProps
  coordinateSystem: s = Wt.DEFAULT,
  coordinateOrigin: o = cA,
  autoWrapLongitude: l = !1
}) {
  s === Wt.DEFAULT && (s = t.isGeospatial ? Wt.LNGLAT : Wt.CARTESIAN);
  const u = _B({
    viewport: t,
    devicePixelRatio: e,
    coordinateSystem: s,
    coordinateOrigin: o
  });
  return u.project_uWrapLongitude = l, u.project_uModelMatrix = i || lA, u;
}
function yB({ viewport: t, devicePixelRatio: e, coordinateSystem: i, coordinateOrigin: s }) {
  const { projectionCenter: o, viewProjectionMatrix: l, originCommon: u, cameraPosCommon: c, shaderCoordinateOrigin: x, geospatialOrigin: w } = mB(t, i, s), C = t.getDistanceScales(), M = [
    t.width * e,
    t.height * e
  ], P = ku([], [0, 0, -t.focalDistance, 1], t.projectionMatrix)[3] || 1, j = {
    // Projection mode values
    project_uCoordinateSystem: i,
    project_uProjectionMode: t.projectionMode,
    project_uCoordinateOrigin: x,
    project_uCommonOrigin: u.slice(0, 3),
    project_uCenter: o,
    // Backward compatibility
    // TODO: remove in v9
    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport
    project_uPseudoMeters: !!t._pseudoMeters,
    // Screen size
    project_uViewportSize: M,
    project_uDevicePixelRatio: e,
    project_uFocalDistance: P,
    project_uCommonUnitsPerMeter: C.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit: C.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit2: pB,
    project_uScale: t.scale,
    // This is the mercator scale (2 ** zoom)
    project_uWrapLongitude: !1,
    project_uViewProjectionMatrix: l,
    project_uModelMatrix: lA,
    // This is for lighting calculations
    project_uCameraPosition: c
  };
  if (w) {
    const Y = t.getDistanceScales(w);
    switch (i) {
      case Wt.METER_OFFSETS:
        j.project_uCommonUnitsPerWorldUnit = Y.unitsPerMeter, j.project_uCommonUnitsPerWorldUnit2 = Y.unitsPerMeter2;
        break;
      case Wt.LNGLAT:
      case Wt.LNGLAT_OFFSETS:
        t._pseudoMeters || (j.project_uCommonUnitsPerMeter = Y.unitsPerMeter), j.project_uCommonUnitsPerWorldUnit = Y.unitsPerDegree, j.project_uCommonUnitsPerWorldUnit2 = Y.unitsPerDegree2;
        break;
      case Wt.CARTESIAN:
        j.project_uCommonUnitsPerWorldUnit = [1, 1, Y.unitsPerMeter[2]], j.project_uCommonUnitsPerWorldUnit2 = [
          0,
          0,
          Y.unitsPerMeter2[2]
        ];
        break;
    }
  }
  return j;
}
const bB = {};
function vB(t = bB) {
  return "viewport" in t ? gB(t) : {};
}
const fy = {
  name: "project",
  dependencies: [pP, aB],
  vs: uB,
  getUniforms: vB
}, xB = `
vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`, py = {
  name: "project32",
  dependencies: [fy],
  vs: xB
};
function wB() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function Cc(t, e) {
  const i = ku([], e, t);
  return Qw(i, i, 1 / i[3]), i;
}
function Iv(t, e) {
  const i = t % e;
  return i < 0 ? e + i : i;
}
function fg(t, e, i) {
  return t < e ? e : t > i ? i : t;
}
function AB(t) {
  return Math.log(t) * Math.LOG2E;
}
const _y = Math.log2 || AB;
function Ao(t, e) {
  if (!t)
    throw new Error(e || "@math.gl/web-mercator: assertion failed.");
}
const mn = Math.PI, uA = mn / 4, nn = mn / 180, pg = 180 / mn, Fc = 512, Hf = 4003e4, Qd = 85.051129, TB = 1.5;
function EB(t) {
  return _y(t);
}
function Tu(t) {
  const [e, i] = t;
  Ao(Number.isFinite(e)), Ao(Number.isFinite(i) && i >= -90 && i <= 90, "invalid latitude");
  const s = e * nn, o = i * nn, l = Fc * (s + mn) / (2 * mn), u = Fc * (mn + Math.log(Math.tan(uA + o * 0.5))) / (2 * mn);
  return [l, u];
}
function kc(t) {
  const [e, i] = t, s = e / Fc * (2 * mn) - mn, o = 2 * (Math.atan(Math.exp(i / Fc * (2 * mn) - mn)) - uA);
  return [s * pg, o * pg];
}
function SB(t) {
  const { latitude: e } = t;
  Ao(Number.isFinite(e));
  const i = Math.cos(e * nn);
  return EB(Hf * i) - 9;
}
function wf(t) {
  const e = Math.cos(t * nn);
  return Fc / Hf / e;
}
function _g(t) {
  const { latitude: e, longitude: i, highPrecision: s = !1 } = t;
  Ao(Number.isFinite(e) && Number.isFinite(i));
  const o = Fc, l = Math.cos(e * nn), u = o / 360, c = u / l, x = o / Hf / l, w = {
    unitsPerMeter: [x, x, x],
    metersPerUnit: [1 / x, 1 / x, 1 / x],
    unitsPerDegree: [u, c, x],
    degreesPerUnit: [1 / u, 1 / c, 1 / x]
  };
  if (s) {
    const C = nn * Math.tan(e * nn) / l, M = u * C / 2, P = o / Hf * C, j = P / c * x;
    w.unitsPerDegree2 = [0, M, P], w.unitsPerMeter2 = [j, 0, j];
  }
  return w;
}
function dA(t, e) {
  const [i, s, o] = t, [l, u, c] = e, { unitsPerMeter: x, unitsPerMeter2: w } = _g({
    longitude: i,
    latitude: s,
    highPrecision: !0
  }), C = Tu(t);
  C[0] += l * (x[0] + w[0] * u), C[1] += u * (x[1] + w[1] * u);
  const M = kc(C), P = (o || 0) + (c || 0);
  return Number.isFinite(o) || Number.isFinite(c) ? [M[0], M[1], P] : M;
}
function CB(t) {
  const {
    // Viewport props
    height: e,
    pitch: i,
    bearing: s,
    altitude: o,
    // Pre-calculated parameters
    scale: l,
    center: u
  } = t, c = wB();
  Vf(c, c, [0, 0, -o]), Jw(c, c, -i * nn), Yw(c, c, s * nn);
  const x = l / e;
  return hy(c, c, [x, x, x]), u && Vf(c, c, HP([], u)), c;
}
function IB(t) {
  const { width: e, height: i, altitude: s, pitch: o = 0, offset: l, center: u, scale: c, nearZMultiplier: x = 1, farZMultiplier: w = 1 } = t;
  let { fovy: C = jf(TB) } = t;
  s !== void 0 && (C = jf(s));
  const M = C * nn, P = o * nn, j = fA(C);
  let Y = j;
  u && (Y += u[2] * c / Math.cos(P) / i);
  const Q = M * (0.5 + (l ? l[1] : 0) / i), _e = Math.sin(Q) * Y / Math.sin(fg(Math.PI / 2 - P - Q, 0.01, Math.PI - 0.01)), me = Math.sin(P) * _e + Y, we = Y * 10, Ee = Math.min(me * w, we);
  return {
    fov: M,
    aspect: e / i,
    focalDistance: j,
    near: x,
    far: Ee
  };
}
function jf(t) {
  return 2 * Math.atan(0.5 / t) * pg;
}
function fA(t) {
  return 0.5 / Math.tan(0.5 * t * nn);
}
function pA(t, e) {
  const [i, s, o = 0] = t;
  return Ao(Number.isFinite(i) && Number.isFinite(s) && Number.isFinite(o)), Cc(e, [i, s, o, 1]);
}
function my(t, e, i = 0) {
  const [s, o, l] = t;
  if (Ao(Number.isFinite(s) && Number.isFinite(o), "invalid pixel coordinate"), Number.isFinite(l))
    return Cc(e, [s, o, l, 1]);
  const u = Cc(e, [s, o, 0, 1]), c = Cc(e, [s, o, 1, 1]), x = u[2], w = c[2], C = x === w ? 0 : ((i || 0) - x) / (w - x);
  return zw([], u, c, C);
}
function RB(t) {
  const {
    width: e,
    height: i,
    bounds: s,
    minExtent: o = 0,
    // 0.01 would be about 1000 meters (degree is ~110KM)
    maxZoom: l = 24,
    // ~x4,000,000 => About 10 meter extents
    offset: u = [0, 0]
  } = t, [[c, x], [w, C]] = s, M = MB(t.padding), P = Tu([c, fg(C, -Qd, Qd)]), j = Tu([w, fg(x, -Qd, Qd)]), Y = [
    Math.max(Math.abs(j[0] - P[0]), o),
    Math.max(Math.abs(j[1] - P[1]), o)
  ], Q = [
    e - M.left - M.right - Math.abs(u[0]) * 2,
    i - M.top - M.bottom - Math.abs(u[1]) * 2
  ];
  Ao(Q[0] > 0 && Q[1] > 0);
  const _e = Q[0] / Y[0], me = Q[1] / Y[1], we = (M.right - M.left) / 2 / _e, Ee = (M.top - M.bottom) / 2 / me, Oe = [(j[0] + P[0]) / 2 + we, (j[1] + P[1]) / 2 + Ee], Ne = kc(Oe), ze = Math.min(l, _y(Math.abs(Math.min(_e, me))));
  return Ao(Number.isFinite(ze)), {
    longitude: Ne[0],
    latitude: Ne[1],
    zoom: ze
  };
}
function MB(t = 0) {
  return typeof t == "number" ? {
    top: t,
    bottom: t,
    left: t,
    right: t
  } : (Ao(Number.isFinite(t.top) && Number.isFinite(t.bottom) && Number.isFinite(t.left) && Number.isFinite(t.right)), t);
}
const Rv = Math.PI / 180;
function PB(t, e = 0) {
  const { width: i, height: s, unproject: o } = t, l = { targetZ: e }, u = o([0, s], l), c = o([i, s], l);
  let x, w;
  const C = t.fovy ? 0.5 * t.fovy * Rv : Math.atan(0.5 / t.altitude), M = (90 - t.pitch) * Rv;
  return C > M - 0.01 ? (x = Mv(t, 0, e), w = Mv(t, i, e)) : (x = o([0, 0], l), w = o([i, 0], l)), [u, c, w, x];
}
function Mv(t, e, i) {
  const { pixelUnprojectionMatrix: s } = t, o = Cc(s, [e, 0, 1, 1]), l = Cc(s, [e, t.height, 1, 1]), c = (i * t.distanceScales.unitsPerMeter[2] - o[2]) / (l[2] - o[2]), x = zw([], o, l, c), w = kc(x);
  return w.push(i), w;
}
const Pv = 512;
function BB(t) {
  const { width: e, height: i, pitch: s = 0 } = t;
  let { longitude: o, latitude: l, zoom: u, bearing: c = 0 } = t;
  (o < -180 || o > 180) && (o = Iv(o + 180, 360) - 180), (c < -180 || c > 180) && (c = Iv(c + 180, 360) - 180);
  const x = _y(i / Pv);
  if (u <= x)
    u = x, l = 0;
  else {
    const w = i / 2 / Math.pow(2, u), C = kc([0, w])[1];
    if (l < C)
      l = C;
    else {
      const M = kc([0, Pv - w])[1];
      l > M && (l = M);
    }
  }
  return { width: e, height: i, longitude: o, latitude: l, zoom: u, pitch: s, bearing: c };
}
const DB = `
const int max_lights = 2;
uniform mat4 shadow_uViewProjectionMatrices[max_lights];
uniform vec4 shadow_uProjectCenters[max_lights];
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform int shadow_uLightId;
uniform float shadow_uLightCount;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  if (shadow_uDrawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);
  }
  if (shadow_uUseShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow_uLightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`, OB = `
const int max_lights = 2;
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;
uniform vec4 shadow_uColor;
uniform float shadow_uLightCount;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow_uDrawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow_uUseShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow_uLightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`, FB = Nu(zB), kB = Nu(VB), NB = [0, 0, 0, 1], LB = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function UB(t, e) {
  const [i, s, o] = t, l = my([i, s, o], e);
  return Number.isFinite(o) ? l : [l[0], l[1], 0];
}
function zB({ viewport: t, center: e }) {
  return new Xt(t.viewProjectionMatrix).invert().transform(e);
}
function VB({ viewport: t, shadowMatrices: e }) {
  const i = [], s = t.pixelUnprojectionMatrix, o = t.isGeospatial ? void 0 : 1, l = [
    [0, 0, o],
    // top left ground
    [t.width, 0, o],
    // top right ground
    [0, t.height, o],
    // bottom left ground
    [t.width, t.height, o],
    // bottom right ground
    [0, 0, -1],
    // top left near
    [t.width, 0, -1],
    // top right near
    [0, t.height, -1],
    // bottom left near
    [t.width, t.height, -1]
    // bottom right near
  ].map((u) => (
    // @ts-expect-error z may be undefined
    UB(u, s)
  ));
  for (const u of e) {
    const c = u.clone().translate(new Se(t.center).negate()), x = l.map((C) => c.transform(C)), w = new Xt().ortho({
      left: Math.min(...x.map((C) => C[0])),
      right: Math.max(...x.map((C) => C[0])),
      bottom: Math.min(...x.map((C) => C[1])),
      top: Math.max(...x.map((C) => C[1])),
      near: Math.min(...x.map((C) => -C[2])),
      far: Math.max(...x.map((C) => -C[2]))
    });
    i.push(w.multiplyRight(u));
  }
  return i;
}
function HB(t, e) {
  const { shadowEnabled: i = !0 } = t;
  if (!i || !t.shadowMatrices || !t.shadowMatrices.length)
    return {
      shadow_uDrawShadowMap: !1,
      shadow_uUseShadowMap: !1,
      shadow_uShadowMap0: t.dummyShadowMap,
      shadow_uShadowMap1: t.dummyShadowMap
    };
  const s = {
    shadow_uDrawShadowMap: !!t.drawToShadowMap,
    shadow_uUseShadowMap: t.shadowMaps ? t.shadowMaps.length > 0 : !1,
    shadow_uColor: t.shadowColor || NB,
    shadow_uLightId: t.shadowLightId || 0,
    shadow_uLightCount: t.shadowMatrices.length
  }, o = FB({
    viewport: t.viewport,
    center: e.project_uCenter
  }), l = [], u = kB({
    shadowMatrices: t.shadowMatrices,
    viewport: t.viewport
  }).slice();
  for (let c = 0; c < t.shadowMatrices.length; c++) {
    const x = u[c], w = x.clone().translate(new Se(t.viewport.center).negate());
    e.project_uCoordinateSystem === Wt.LNGLAT && e.project_uProjectionMode === Wn.WEB_MERCATOR ? (u[c] = w, l[c] = o) : (u[c] = x.clone().multiplyRight(LB), l[c] = w.transform(o));
  }
  for (let c = 0; c < u.length; c++)
    s[`shadow_uViewProjectionMatrices[${c}]`] = u[c], s[`shadow_uProjectCenters[${c}]`] = l[c];
  for (let c = 0; c < 2; c++)
    s[`shadow_uShadowMap${c}`] = t.shadowMaps && t.shadowMaps[c] || t.dummyShadowMap;
  return s;
}
const Bv = {
  name: "shadow",
  dependencies: [fy],
  vs: DB,
  fs: OB,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
    "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
  },
  // @ts-expect-error stricter luma gl types
  getUniforms: (t = {}, e = {}) => "viewport" in t && (t.drawToShadowMap || t.shadowMaps && t.shadowMaps.length > 0) ? HB(t, e) : {}
}, gy = {
  ...yv,
  defaultUniforms: { ...yv.defaultUniforms, useFloatColors: !1 },
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
    "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
    }
  }
}, jB = [fy], $B = [
  "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
  "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
];
function GB() {
  const t = Pf.getDefaultShaderAssembler();
  for (const e of jB)
    t.addDefaultModule(e);
  for (const e of $B)
    t.addShaderHook(e);
  return t;
}
const XB = [255, 255, 255], WB = 1;
let qB = 0;
class ZB {
  constructor(e = {}) {
    this.type = "ambient";
    const { color: i = XB } = e, { intensity: s = WB } = e;
    this.id = e.id || `ambient-${qB++}`, this.color = i, this.intensity = s;
  }
}
const KB = [255, 255, 255], JB = 1, YB = [0, 0, -1];
let QB = 0;
class Dv {
  constructor(e = {}) {
    this.type = "directional";
    const { color: i = KB } = e, { intensity: s = JB } = e, { direction: o = YB } = e, { _shadow: l = !1 } = e;
    this.id = e.id || `directional-${QB++}`, this.color = i, this.intensity = s, this.type = "directional", this.direction = new Se(o).normalize().toArray(), this.shadow = l;
  }
  getProjectedLight(e) {
    return this;
  }
}
class eD {
  /** Create a new Pass instance */
  constructor(e, i = { id: "pass" }) {
    const { id: s } = i;
    this.id = s, this.device = e, this.props = { ...i };
  }
  setProps(e) {
    Object.assign(this.props, e);
  }
  render(e) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  cleanup() {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
}
class yy extends eD {
  constructor() {
    super(...arguments), this._lastRenderIndex = -1;
  }
  render(e) {
    const [i, s] = this.device.canvasContext.getDrawingBufferSize(), o = e.clearCanvas ?? !0, l = e.clearColor ?? (o ? [0, 0, 0, 0] : !1), u = o ? 1 : !1, c = o ? 0 : !1, x = e.colorMask ?? 15, w = { viewport: [0, 0, i, s] };
    e.colorMask && (w.colorMask = x), e.scissorRect && (w.scissorRect = e.scissorRect);
    const C = this.device.beginRenderPass({
      framebuffer: e.target,
      parameters: w,
      clearColor: l,
      clearDepth: u,
      clearStencil: c
    });
    try {
      return this._drawLayers(C, e);
    } finally {
      C.end();
    }
  }
  /** Draw a list of layers in a list of viewports */
  _drawLayers(e, i) {
    const { target: s, moduleParameters: o, viewports: l, views: u, onViewportActive: c, clearStack: x = !0 } = i;
    i.pass = i.pass || "unknown", x && (this._lastRenderIndex = -1);
    const w = [];
    for (const C of l) {
      const M = u && u[C.id];
      c == null || c(C);
      const P = this._getDrawLayerParams(C, i), j = C.subViewports || [C];
      for (const Y of j) {
        const Q = this._drawLayersInViewport(e, {
          target: s,
          moduleParameters: o,
          viewport: Y,
          view: M,
          pass: i.pass,
          layers: i.layers
        }, P);
        w.push(Q);
      }
    }
    return w;
  }
  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),
  // this is only done once for the parent viewport
  /* Resolve the parameters needed to draw each layer */
  _getDrawLayerParams(e, { layers: i, pass: s, isPicking: o = !1, layerFilter: l, cullRect: u, effects: c, moduleParameters: x }, w = !1) {
    var Y;
    const C = [], M = _A(this._lastRenderIndex + 1), P = {
      layer: i[0],
      viewport: e,
      isPicking: o,
      renderPass: s,
      cullRect: u
    }, j = {};
    for (let Q = 0; Q < i.length; Q++) {
      const _e = i[Q], me = this._shouldDrawLayer(_e, P, l, j), we = {
        shouldDrawLayer: me
      };
      me && !w && (we.layerRenderIndex = M(_e, me), we.moduleParameters = this._getModuleParameters(_e, c, s, x), we.layerParameters = {
        ...(Y = _e.context.deck) == null ? void 0 : Y.props.parameters,
        ...this.getLayerParameters(_e, Q, e)
      }), C[Q] = we;
    }
    return C;
  }
  // Draws a list of layers in one viewport
  // TODO - when picking we could completely skip rendering viewports that dont
  // intersect with the picking rect
  /* eslint-disable max-depth, max-statements */
  _drawLayersInViewport(e, { layers: i, moduleParameters: s, pass: o, target: l, viewport: u, view: c }, x) {
    const w = tD(this.device, {
      moduleParameters: s,
      target: l,
      viewport: u
    });
    if (c && c.props.clear) {
      const M = c.props.clear === !0 ? { color: !0, depth: !0 } : c.props.clear;
      this.device.withParametersWebGL({
        scissorTest: !0,
        scissor: w
      }, () => this.device.clearWebGL(M));
    }
    const C = {
      totalCount: i.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    e.setParameters({ viewport: w });
    for (let M = 0; M < i.length; M++) {
      const P = i[M], { shouldDrawLayer: j, layerRenderIndex: Y, moduleParameters: Q, layerParameters: _e } = x[M];
      if (j && P.props.pickable && C.pickableCount++, P.isComposite)
        C.compositeCount++;
      else if (j) {
        C.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, Y), Q.viewport = u, P.context.renderPass = e;
        try {
          P._drawLayer({
            renderPass: e,
            moduleParameters: Q,
            uniforms: { layerIndex: Y },
            parameters: _e
          });
        } catch (me) {
          P.raiseError(me, `drawing ${P} to ${o}`);
        }
      }
    }
    return C;
  }
  /* eslint-enable max-depth, max-statements */
  /* Methods for subclass overrides */
  shouldDrawLayer(e) {
    return !0;
  }
  getModuleParameters(e, i) {
    return null;
  }
  getLayerParameters(e, i, s) {
    return e.props.parameters;
  }
  /* Private */
  _shouldDrawLayer(e, i, s, o) {
    if (!(e.props.visible && this.shouldDrawLayer(e)))
      return !1;
    i.layer = e;
    let u = e.parent;
    for (; u; ) {
      if (!u.props.visible || !u.filterSubLayer(i))
        return !1;
      i.layer = u, u = u.parent;
    }
    if (s) {
      const c = i.layer.id;
      if (c in o || (o[c] = s(i)), !o[c])
        return !1;
    }
    return e.activateViewport(i.viewport), !0;
  }
  _getModuleParameters(e, i, s, o) {
    var c, x;
    const l = this.device.canvasContext.cssToDeviceRatio(), u = Object.assign(Object.create(((c = e.internalState) == null ? void 0 : c.propsInTransition) || e.props), {
      autoWrapLongitude: e.wrapLongitude,
      viewport: e.context.viewport,
      mousePosition: e.context.mousePosition,
      picking: {
        isActive: 0
      },
      devicePixelRatio: l
    });
    if (i)
      for (const w of i)
        Object.assign(u, (x = w.getModuleParameters) == null ? void 0 : x.call(w, e));
    return Object.assign(u, this.getModuleParameters(e, i), o);
  }
}
function _A(t = 0, e = {}) {
  const i = {}, s = (o, l) => {
    const u = o.props._offset, c = o.id, x = o.parent && o.parent.id;
    let w;
    if (x && !(x in e) && s(o.parent, !1), x in i) {
      const C = i[x] = i[x] || _A(e[x], e);
      w = C(o, l), i[c] = C;
    } else Number.isFinite(u) ? (w = u + (e[x] || 0), i[c] = null) : w = t;
    return l && w >= t && (t = w + 1), e[c] = w, w;
  };
  return s;
}
function tD(t, { moduleParameters: e, target: i, viewport: s }) {
  const o = e && e.devicePixelRatio || // @ts-expect-error TODO - assuming WebGL context
  t.canvasContext.cssToDeviceRatio(), [, l] = t.canvasContext.getDrawingBufferSize(), u = i ? i.height : l, c = s;
  return [
    c.x * o,
    u - (c.y + c.height) * o,
    c.width * o,
    c.height * o
  ];
}
class iD extends yy {
  constructor(e, i) {
    super(e, i), this.shadowMap = e.createTexture({
      width: 1,
      height: 1,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    }), this.depthBuffer = e.createTexture({
      format: "depth16unorm",
      width: 1,
      height: 1,
      mipmaps: !1,
      // TODO fix getWebGLTextureParameters() in luma to avoid passing deprecated parameters
      dataFormat: 6402,
      // gl.DEPTH_COMPONENT
      type: 5125
      // gl.UNSIGNED_INT
    }), this.fbo = e.createFramebuffer({
      id: "shadowmap",
      width: 1,
      height: 1,
      colorAttachments: [this.shadowMap],
      // Depth attachment has to be specified for depth test to work
      depthStencilAttachment: this.depthBuffer
    });
  }
  render(e) {
    const i = this.fbo, s = this.device.canvasContext.cssToDeviceRatio(), o = e.viewports[0], l = o.width * s, u = o.height * s, c = [1, 1, 1, 1];
    (l !== i.width || u !== i.height) && i.resize({ width: l, height: u }), super.render({ ...e, clearColor: c, target: i, pass: "shadow" });
  }
  getLayerParameters(e, i, s) {
    return { ...e.props.parameters, blend: !1, depthRange: [0, 1], depthTest: !0 };
  }
  shouldDrawLayer(e) {
    return e.props.shadowEnabled !== !1;
  }
  getModuleParameters() {
    return {
      drawToShadowMap: !0
    };
  }
  delete() {
    this.fbo && (this.fbo.destroy(), this.fbo = null), this.shadowMap && (this.shadowMap.destroy(), this.shadowMap = null), this.depthBuffer && (this.depthBuffer.destroy(), this.depthBuffer = null);
  }
}
const sD = { color: [255, 255, 255], intensity: 1 }, Ov = [
  {
    color: [255, 255, 255],
    intensity: 1,
    direction: [-1, 3, -1]
  },
  {
    color: [255, 255, 255],
    intensity: 0.9,
    direction: [1, -8, -2.5]
  }
], rD = [0, 0, 0, 200 / 255];
class mA {
  constructor(e = {}) {
    this.id = "lighting-effect", this.shadowColor = rD, this.shadow = !1, this.ambientLight = null, this.directionalLights = [], this.pointLights = [], this.shadowPasses = [], this.shadowMaps = [], this.dummyShadowMap = null, this.setProps(e);
  }
  setup(e) {
    this.context = e;
    const { device: i, deck: s } = e;
    this.shadow && !this.dummyShadowMap && (this._createShadowPasses(i), s._addDefaultShaderModule(Bv), this.dummyShadowMap = i.createTexture({
      width: 1,
      height: 1
    }));
  }
  setProps(e) {
    this.ambientLight = null, this.directionalLights = [], this.pointLights = [];
    for (const i in e) {
      const s = e[i];
      switch (s.type) {
        case "ambient":
          this.ambientLight = s;
          break;
        case "directional":
          this.directionalLights.push(s);
          break;
        case "point":
          this.pointLights.push(s);
          break;
      }
    }
    this._applyDefaultLights(), this.shadow = this.directionalLights.some((i) => i.shadow), this.context && this.setup(this.context), this.props = e;
  }
  preRender({ layers: e, layerFilter: i, viewports: s, onViewportActive: o, views: l }) {
    if (this.shadow) {
      this.shadowMatrices = this._calculateMatrices();
      for (let u = 0; u < this.shadowPasses.length; u++)
        this.shadowPasses[u].render({
          layers: e,
          layerFilter: i,
          viewports: s,
          onViewportActive: o,
          views: l,
          moduleParameters: {
            shadowLightId: u,
            dummyShadowMap: this.dummyShadowMap,
            shadowMatrices: this.shadowMatrices
          }
        });
    }
  }
  getModuleParameters(e) {
    const i = this.shadow ? {
      shadowMaps: this.shadowMaps,
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {};
    return i.lightSources = {
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((s) => s.getProjectedLight({ layer: e })),
      pointLights: this.pointLights.map((s) => s.getProjectedLight({ layer: e }))
    }, i;
  }
  cleanup(e) {
    for (const i of this.shadowPasses)
      i.delete();
    this.shadowPasses.length = 0, this.shadowMaps.length = 0, this.dummyShadowMap && (this.dummyShadowMap.destroy(), this.dummyShadowMap = null, e.deck._removeDefaultShaderModule(Bv));
  }
  _calculateMatrices() {
    const e = [];
    for (const i of this.directionalLights) {
      const s = new Xt().lookAt({
        eye: new Se(i.direction).negate()
      });
      e.push(s);
    }
    return e;
  }
  _createShadowPasses(e) {
    for (let i = 0; i < this.directionalLights.length; i++) {
      const s = new iD(e);
      this.shadowPasses[i] = s, this.shadowMaps[i] = s.shadowMap;
    }
  }
  _applyDefaultLights() {
    const { ambientLight: e, pointLights: i, directionalLights: s } = this;
    !e && i.length === 0 && s.length === 0 && (this.ambientLight = new ZB(sD), this.directionalLights.push(new Dv(Ov[0]), new Dv(Ov[1])));
  }
}
class nD {
  constructor(e = {}) {
    this._pool = [], this.opts = { overAlloc: 2, poolSize: 100 }, this.setOptions(e);
  }
  setOptions(e) {
    Object.assign(this.opts, e);
  }
  allocate(e, i, { size: s = 1, type: o, padding: l = 0, copy: u = !1, initialize: c = !1, maxCount: x }) {
    const w = o || e && e.constructor || Float32Array, C = i * s + l;
    if (ArrayBuffer.isView(e)) {
      if (C <= e.length)
        return e;
      if (C * e.BYTES_PER_ELEMENT <= e.buffer.byteLength)
        return new w(e.buffer, 0, C);
    }
    let M = 1 / 0;
    x && (M = x * s + l);
    const P = this._allocate(w, C, c, M);
    return e && u ? P.set(e) : c || P.fill(0, 0, 4), this._release(e), P;
  }
  release(e) {
    this._release(e);
  }
  _allocate(e, i, s, o) {
    let l = Math.max(Math.ceil(i * this.opts.overAlloc), 1);
    l > o && (l = o);
    const u = this._pool, c = e.BYTES_PER_ELEMENT * l, x = u.findIndex((w) => w.byteLength >= c);
    if (x >= 0) {
      const w = new e(u.splice(x, 1)[0], 0, l);
      return s && w.fill(0), w;
    }
    return new e(l);
  }
  _release(e) {
    if (!ArrayBuffer.isView(e))
      return;
    const i = this._pool, { buffer: s } = e, { byteLength: o } = s, l = i.findIndex((u) => u.byteLength >= o);
    l < 0 ? i.push(s) : (l > 0 || i.length < this.opts.poolSize) && i.splice(l, 0, s), i.length > this.opts.poolSize && i.shift();
  }
}
const Eu = new nD();
function au() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function oD(t) {
  return [t[12], t[13], t[14]];
}
function aD(t) {
  return {
    left: lc(t[3] + t[0], t[7] + t[4], t[11] + t[8], t[15] + t[12]),
    right: lc(t[3] - t[0], t[7] - t[4], t[11] - t[8], t[15] - t[12]),
    bottom: lc(t[3] + t[1], t[7] + t[5], t[11] + t[9], t[15] + t[13]),
    top: lc(t[3] - t[1], t[7] - t[5], t[11] - t[9], t[15] - t[13]),
    near: lc(t[3] + t[2], t[7] + t[6], t[11] + t[10], t[15] + t[14]),
    far: lc(t[3] - t[2], t[7] - t[6], t[11] - t[10], t[15] - t[14])
  };
}
const Fv = new Se();
function lc(t, e, i, s) {
  Fv.set(t, e, i);
  const o = Fv.len();
  return { distance: s / o, normal: new Se(-t / o, -e / o, -i / o) };
}
function lD(t) {
  return t - Math.fround(t);
}
let Zh;
function im(t, e) {
  const { size: i = 1, startIndex: s = 0 } = e, o = e.endIndex !== void 0 ? e.endIndex : t.length, l = (o - s) / i;
  Zh = Eu.allocate(Zh, l, {
    type: Float32Array,
    size: i * 2
  });
  let u = s, c = 0;
  for (; u < o; ) {
    for (let x = 0; x < i; x++) {
      const w = t[u++];
      Zh[c + x] = w, Zh[c + x + i] = lD(w);
    }
    c += i * 2;
  }
  return Zh.subarray(0, l * i * 2);
}
function cD(t) {
  let e = null, i = !1;
  for (const s of t)
    s && (e ? (i || (e = [
      [e[0][0], e[0][1]],
      [e[1][0], e[1][1]]
    ], i = !0), e[0][0] = Math.min(e[0][0], s[0][0]), e[0][1] = Math.min(e[0][1], s[0][1]), e[1][0] = Math.max(e[1][0], s[1][0]), e[1][1] = Math.max(e[1][1], s[1][1])) : e = s);
  return e;
}
const hD = Math.PI / 180, uD = au(), kv = [0, 0, 0], dD = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function fD({ width: t, height: e, orthographic: i, fovyRadians: s, focalDistance: o, padding: l, near: u, far: c }) {
  const x = t / e, w = i ? new Xt().orthographic({ fovy: s, aspect: x, focalDistance: o, near: u, far: c }) : new Xt().perspective({ fovy: s, aspect: x, near: u, far: c });
  if (l) {
    const { left: C = 0, right: M = 0, top: P = 0, bottom: j = 0 } = l, Y = bo((C + t - M) / 2, 0, t) - t / 2, Q = bo((P + e - j) / 2, 0, e) - e / 2;
    w[8] -= Y * 2 / t, w[9] += Q * 2 / e;
  }
  return w;
}
class Lu {
  // eslint-disable-next-line complexity
  constructor(e = {}) {
    this._frustumPlanes = {}, this.id = e.id || this.constructor.displayName || "viewport", this.x = e.x || 0, this.y = e.y || 0, this.width = e.width || 1, this.height = e.height || 1, this.zoom = e.zoom || 0, this.padding = e.padding, this.distanceScales = e.distanceScales || dD, this.focalDistance = e.focalDistance || 1, this.position = e.position || kv, this.modelMatrix = e.modelMatrix || null;
    const { longitude: i, latitude: s } = e;
    this.isGeospatial = Number.isFinite(s) && Number.isFinite(i), this._initProps(e), this._initMatrices(e), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    return this.isGeospatial ? this.zoom < 12 ? Wn.WEB_MERCATOR : Wn.WEB_MERCATOR_AUTO_OFFSET : Wn.IDENTITY;
  }
  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.
  equals(e) {
    return e instanceof Lu ? this === e ? !0 : e.width === this.width && e.height === this.height && e.scale === this.scale && bn(e.projectionMatrix, this.projectionMatrix) && bn(e.viewMatrix, this.viewMatrix) : !1;
  }
  /**
   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
   * using viewport projection parameters
   * - [longitude, latitude] to [x, y]
   * - [longitude, latitude, Z] => [x, y, z]
   * Note: By default, returns top-left coordinates for canvas/SVG type render
   *
   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether projected coords are top left
   * @return {Array} - [x, y] or [x, y, z] in top left coords
   */
  project(e, { topLeft: i = !0 } = {}) {
    const s = this.projectPosition(e), o = pA(s, this.pixelProjectionMatrix), [l, u] = o, c = i ? u : this.height - u;
    return e.length === 2 ? [l, c] : [l, c, o[2]];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(e, { topLeft: i = !0, targetZ: s } = {}) {
    const [o, l, u] = e, c = i ? l : this.height - l, x = s && s * this.distanceScales.unitsPerMeter[2], w = my([o, c, u], this.pixelUnprojectionMatrix, x), [C, M, P] = this.unprojectPosition(w);
    return Number.isFinite(u) ? [C, M, P] : Number.isFinite(s) ? [C, M, s] : [C, M];
  }
  // NON_LINEAR PROJECTION HOOKS
  // Used for web meractor projection
  projectPosition(e) {
    const [i, s] = this.projectFlat(e), o = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [i, s, o];
  }
  unprojectPosition(e) {
    const [i, s] = this.unprojectFlat(e), o = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [i, s, o];
  }
  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */
  projectFlat(e) {
    if (this.isGeospatial) {
      const i = Tu(e);
      return i[1] = bo(i[1], -318, 830), i;
    }
    return e;
  }
  /**
   * Unproject world point [x,y] on map onto {lat, lon} on sphere
   * @param {object|Vector} xy - object with {x,y} members
   *  representing point on projected map plane
   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
   *   Has toArray method if you need a GeoJSON Array.
   *   Per cartographic tradition, lat and lon are specified as degrees.
   */
  unprojectFlat(e) {
    return this.isGeospatial ? kc(e) : e;
  }
  /**
   * Get bounds of the current viewport
   * @return {Array} - [minX, minY, maxX, maxY]
   */
  getBounds(e = {}) {
    const i = { targetZ: e.z || 0 }, s = this.unproject([0, 0], i), o = this.unproject([this.width, 0], i), l = this.unproject([0, this.height], i), u = this.unproject([this.width, this.height], i);
    return [
      Math.min(s[0], o[0], l[0], u[0]),
      Math.min(s[1], o[1], l[1], u[1]),
      Math.max(s[0], o[0], l[0], u[0]),
      Math.max(s[1], o[1], l[1], u[1])
    ];
  }
  getDistanceScales(e) {
    return e ? _g({
      longitude: e[0],
      latitude: e[1],
      highPrecision: !0
    }) : this.distanceScales;
  }
  containsPixel({ x: e, y: i, width: s = 1, height: o = 1 }) {
    return e < this.x + this.width && this.x < e + s && i < this.y + this.height && this.y < i + o;
  }
  // Extract frustum planes in common space
  getFrustumPlanes() {
    return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, aD(this.viewProjectionMatrix)), this._frustumPlanes);
  }
  // EXPERIMENTAL METHODS
  /**
   * Needed by panning and linear transition
   * Pan the viewport to place a given world coordinate at screen point [x, y]
   *
   * @param {Array} coords - world coordinates
   * @param {Array} pixel - [x,y] coordinates on screen
   * @return {Object} props of the new viewport
   */
  panByPosition(e, i) {
    return null;
  }
  // INTERNAL METHODS
  /* eslint-disable complexity, max-statements */
  _initProps(e) {
    const i = e.longitude, s = e.latitude;
    this.isGeospatial && (Number.isFinite(e.zoom) || (this.zoom = SB({ latitude: s }) + Math.log2(this.focalDistance)), this.distanceScales = e.distanceScales || _g({ latitude: s, longitude: i }));
    const o = Math.pow(2, this.zoom);
    this.scale = o;
    const { position: l, modelMatrix: u } = e;
    let c = kv;
    if (l && (c = u ? new Xt(u).transformAsVector(l, []) : l), this.isGeospatial) {
      const x = this.projectPosition([i, s, 0]);
      this.center = new Se(c).scale(this.distanceScales.unitsPerMeter).add(x);
    } else
      this.center = this.projectPosition(c);
  }
  /* eslint-enable complexity, max-statements */
  _initMatrices(e) {
    const {
      // View matrix
      viewMatrix: i = uD,
      // Projection matrix
      projectionMatrix: s = null,
      // Projection matrix parameters, used if projectionMatrix not supplied
      orthographic: o = !1,
      fovyRadians: l,
      fovy: u = 75,
      near: c = 0.1,
      // Distance of near clipping plane
      far: x = 1e3,
      // Distance of far clipping plane
      padding: w = null,
      // Center offset in pixels
      focalDistance: C = 1
    } = e;
    this.viewMatrixUncentered = i, this.viewMatrix = new Xt().multiplyRight(i).translate(new Se(this.center).negate()), this.projectionMatrix = s || fD({
      width: this.width,
      height: this.height,
      orthographic: o,
      fovyRadians: l || u * hD,
      focalDistance: C,
      padding: w,
      near: c,
      far: x
    });
    const M = au();
    rl(M, M, this.projectionMatrix), rl(M, M, this.viewMatrix), this.viewProjectionMatrix = M, this.viewMatrixInverse = cg([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = oD(this.viewMatrixInverse);
    const P = au(), j = au();
    hy(P, P, [this.width / 2, -this.height / 2, 1]), Vf(P, P, [1, -1, 0]), rl(j, P, this.viewProjectionMatrix), this.pixelProjectionMatrix = j, this.pixelUnprojectionMatrix = cg(au(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || Jt.warn("Pixel project matrix not invertible")();
  }
}
Lu.displayName = "Viewport";
class ol extends Lu {
  /* eslint-disable complexity, max-statements */
  constructor(e = {}) {
    const {
      latitude: i = 0,
      longitude: s = 0,
      zoom: o = 0,
      pitch: l = 0,
      bearing: u = 0,
      nearZMultiplier: c = 0.1,
      farZMultiplier: x = 1.01,
      nearZ: w,
      farZ: C,
      orthographic: M = !1,
      projectionMatrix: P,
      repeat: j = !1,
      worldOffset: Y = 0,
      position: Q,
      padding: _e,
      // backward compatibility
      // TODO: remove in v9
      legacyMeterSizes: me = !1
    } = e;
    let { width: we, height: Ee, altitude: Oe = 1.5 } = e;
    const Ne = Math.pow(2, o);
    we = we || 1, Ee = Ee || 1;
    let ze, nt = null;
    if (P)
      Oe = P[5] / 2, ze = jf(Oe);
    else {
      e.fovy ? (ze = e.fovy, Oe = fA(ze)) : ze = jf(Oe);
      let We;
      if (_e) {
        const { top: at = 0, bottom: it = 0 } = _e;
        We = [0, bo((at + Ee - it) / 2, 0, Ee) - Ee / 2];
      }
      nt = IB({
        width: we,
        height: Ee,
        scale: Ne,
        center: Q && [0, 0, Q[2] * wf(i)],
        offset: We,
        pitch: l,
        fovy: ze,
        nearZMultiplier: c,
        farZMultiplier: x
      }), Number.isFinite(w) && (nt.near = w), Number.isFinite(C) && (nt.far = C);
    }
    let mt = CB({
      height: Ee,
      pitch: l,
      bearing: u,
      scale: Ne,
      altitude: Oe
    });
    Y && (mt = new Xt().translate([512 * Y, 0, 0]).multiplyLeft(mt)), super({
      ...e,
      // x, y,
      width: we,
      height: Ee,
      // view matrix
      viewMatrix: mt,
      longitude: s,
      latitude: i,
      zoom: o,
      // projection matrix parameters
      ...nt,
      fovy: ze,
      focalDistance: Oe
    }), this.latitude = i, this.longitude = s, this.zoom = o, this.pitch = l, this.bearing = u, this.altitude = Oe, this.fovy = ze, this.orthographic = M, this._subViewports = j ? [] : null, this._pseudoMeters = me, Object.freeze(this);
  }
  /* eslint-enable complexity, max-statements */
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const e = this.getBounds(), i = Math.floor((e[0] + 180) / 360), s = Math.ceil((e[2] - 180) / 360);
      for (let o = i; o <= s; o++) {
        const l = o ? new ol({
          ...this,
          worldOffset: o
        }) : this;
        this._subViewports.push(l);
      }
    }
    return this._subViewports;
  }
  projectPosition(e) {
    if (this._pseudoMeters)
      return super.projectPosition(e);
    const [i, s] = this.projectFlat(e), o = (e[2] || 0) * wf(e[1]);
    return [i, s, o];
  }
  unprojectPosition(e) {
    if (this._pseudoMeters)
      return super.unprojectPosition(e);
    const [i, s] = this.unprojectFlat(e), o = (e[2] || 0) / wf(s);
    return [i, s, o];
  }
  /**
   * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
   *
   * Note: Uses simple linear approximation around the viewport center
   * Error increases with size of offset (roughly 1% per 100km)
   *
   * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
   * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
   */
  addMetersToLngLat(e, i) {
    return dA(e, i);
  }
  panByPosition(e, i) {
    const s = my(i, this.pixelUnprojectionMatrix), o = this.projectFlat(e), l = bv([], o, kP([], s)), u = bv([], this.center, l), [c, x] = this.unprojectFlat(u);
    return { longitude: c, latitude: x };
  }
  getBounds(e = {}) {
    const i = PB(this, e.z || 0);
    return [
      Math.min(i[0][0], i[1][0], i[2][0], i[3][0]),
      Math.min(i[0][1], i[1][1], i[2][1], i[3][1]),
      Math.max(i[0][0], i[1][0], i[2][0], i[3][0]),
      Math.max(i[0][1], i[1][1], i[2][1], i[3][1])
    ];
  }
  /**
   * Returns a new viewport that fit around the given rectangle.
   * Only supports non-perspective mode.
   */
  fitBounds(e, i = {}) {
    const { width: s, height: o } = this, { longitude: l, latitude: u, zoom: c } = RB({ width: s, height: o, bounds: e, ...i });
    return new ol({ width: s, height: o, longitude: l, latitude: u, zoom: c });
  }
}
ol.displayName = "WebMercatorViewport";
const Nv = [0, 0, 0];
function sm(t, e, i = !1) {
  const s = e.projectPosition(t);
  if (i && e instanceof ol) {
    const [o, l, u = 0] = t, c = e.getDistanceScales([o, l]);
    s[2] = u * c.unitsPerMeter[2];
  }
  return s;
}
function pD(t) {
  const { viewport: e, modelMatrix: i, coordinateOrigin: s } = t;
  let { coordinateSystem: o, fromCoordinateSystem: l, fromCoordinateOrigin: u } = t;
  return o === Wt.DEFAULT && (o = e.isGeospatial ? Wt.LNGLAT : Wt.CARTESIAN), l === void 0 && (l = o), u === void 0 && (u = s), {
    viewport: e,
    coordinateSystem: o,
    coordinateOrigin: s,
    modelMatrix: i,
    fromCoordinateSystem: l,
    fromCoordinateOrigin: u
  };
}
function gA(t, { viewport: e, modelMatrix: i, coordinateSystem: s, coordinateOrigin: o, offsetMode: l }) {
  let [u, c, x = 0] = t;
  switch (i && ([u, c, x] = ku([], [u, c, x, 1], i)), s) {
    case Wt.LNGLAT:
      return sm([u, c, x], e, l);
    case Wt.LNGLAT_OFFSETS:
      return sm([u + o[0], c + o[1], x + (o[2] || 0)], e, l);
    case Wt.METER_OFFSETS:
      return sm(dA(o, [u, c, x]), e, l);
    case Wt.CARTESIAN:
    default:
      return e.isGeospatial ? [u + o[0], c + o[1], x + o[2]] : e.projectPosition([u, c, x]);
  }
}
function _D(t, e) {
  const { viewport: i, coordinateSystem: s, coordinateOrigin: o, modelMatrix: l, fromCoordinateSystem: u, fromCoordinateOrigin: c } = pD(e), { autoOffset: x = !0 } = e, { geospatialOrigin: w = Nv, shaderCoordinateOrigin: C = Nv, offsetMode: M = !1 } = x ? hA(i, s, o) : {}, P = gA(t, {
    viewport: i,
    modelMatrix: l,
    coordinateSystem: u,
    coordinateOrigin: c,
    offsetMode: M
  });
  if (M) {
    const j = i.projectPosition(w || C);
    qP(P, P, j);
  }
  return P;
}
let mD = 1, gD = 1;
class yA {
  constructor() {
    O(this, "time", 0);
    O(this, "channels", /* @__PURE__ */ new Map());
    O(this, "animations", /* @__PURE__ */ new Map());
    O(this, "playing", !1);
    O(this, "lastEngineTime", -1);
  }
  addChannel(e) {
    const { delay: i = 0, duration: s = Number.POSITIVE_INFINITY, rate: o = 1, repeat: l = 1 } = e, u = mD++, c = {
      time: 0,
      delay: i,
      duration: s,
      rate: o,
      repeat: l
    };
    return this._setChannelTime(c, this.time), this.channels.set(u, c), u;
  }
  removeChannel(e) {
    this.channels.delete(e);
    for (const [i, s] of this.animations)
      s.channel === e && this.detachAnimation(i);
  }
  isFinished(e) {
    const i = this.channels.get(e);
    return i === void 0 ? !1 : this.time >= i.delay + i.duration * i.repeat;
  }
  getTime(e) {
    if (e === void 0)
      return this.time;
    const i = this.channels.get(e);
    return i === void 0 ? -1 : i.time;
  }
  setTime(e) {
    this.time = Math.max(0, e);
    const i = this.channels.values();
    for (const o of i)
      this._setChannelTime(o, this.time);
    const s = this.animations.values();
    for (const o of s) {
      const { animation: l, channel: u } = o;
      l.setTime(this.getTime(u));
    }
  }
  play() {
    this.playing = !0;
  }
  pause() {
    this.playing = !1, this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(e, i) {
    const s = gD++;
    return this.animations.set(s, {
      animation: e,
      channel: i
    }), e.setTime(this.getTime(i)), s;
  }
  detachAnimation(e) {
    this.animations.delete(e);
  }
  update(e) {
    this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = e), this.setTime(this.time + (e - this.lastEngineTime)), this.lastEngineTime = e);
  }
  _setChannelTime(e, i) {
    const s = i - e.delay, o = e.duration * e.repeat;
    s >= o ? e.time = e.duration * e.rate : (e.time = Math.max(0, s) % e.duration, e.time *= e.rate);
  }
}
let yD = 0;
const bD = {
  device: null,
  onAddHTML: () => "",
  onInitialize: async () => null,
  onRender: () => {
  },
  onFinalize: () => {
  },
  onError: (t) => console.error(t),
  // eslint-disable-line no-console
  stats: Ec.stats.get(`animation-loop-${yD++}`),
  // view parameters
  useDevicePixels: !0,
  autoResizeViewport: !1,
  autoResizeDrawingBuffer: !1
};
class vD {
  // _gpuTimeQuery: Query | null = null;
  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  constructor(e) {
    O(this, "device", null);
    O(this, "canvas", null);
    O(this, "props");
    O(this, "animationProps", null);
    O(this, "timeline", null);
    O(this, "stats");
    O(this, "cpuTime");
    O(this, "gpuTime");
    O(this, "frameRate");
    O(this, "display");
    O(this, "needsRedraw", "initialized");
    O(this, "_initialized", !1);
    O(this, "_running", !1);
    O(this, "_animationFrameId", null);
    O(this, "_nextFramePromise", null);
    O(this, "_resolveNextFrame", null);
    O(this, "_cpuStartTime", 0);
    if (this.props = { ...bD, ...e }, e = this.props, !e.device)
      throw new Error("No device provided");
    const { useDevicePixels: i = !0 } = this.props;
    this.stats = e.stats || new jc({ id: "animation-loop-stats" }), this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this.setProps({
      autoResizeViewport: e.autoResizeViewport,
      autoResizeDrawingBuffer: e.autoResizeDrawingBuffer,
      useDevicePixels: i
    }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this);
  }
  destroy() {
    this.stop(), this._setDisplay(null);
  }
  /** @deprecated Use .destroy() */
  delete() {
    this.destroy();
  }
  /** Flags this animation loop as needing redraw */
  setNeedsRedraw(e) {
    return this.needsRedraw = this.needsRedraw || e, this;
  }
  /** TODO - move these props to CanvasContext? */
  setProps(e) {
    return "autoResizeViewport" in e && (this.props.autoResizeViewport = e.autoResizeViewport || !1), "autoResizeDrawingBuffer" in e && (this.props.autoResizeDrawingBuffer = e.autoResizeDrawingBuffer || !1), "useDevicePixels" in e && (this.props.useDevicePixels = e.useDevicePixels || !1), this;
  }
  /** Starts a render loop if not already running */
  async start() {
    if (this._running)
      return this;
    this._running = !0;
    try {
      let e;
      return this._initialized || (this._initialized = !0, await this._initDevice(), this._initialize(), await this.props.onInitialize(this._getAnimationProps())), this._running ? (e !== !1 && (this._cancelAnimationFrame(), this._requestAnimationFrame()), this) : null;
    } catch (e) {
      const i = e instanceof Error ? e : new Error("Unknown error");
      throw this.props.onError(i), i;
    }
  }
  /** Stops a render loop if already running, finalizing */
  stop() {
    return this._running && (this.animationProps && this.props.onFinalize(this.animationProps), this._cancelAnimationFrame(), this._nextFramePromise = null, this._resolveNextFrame = null, this._running = !1), this;
  }
  /** Explicitly draw a frame */
  redraw() {
    var e;
    return (e = this.device) != null && e.isLost ? this : (this._beginFrameTimers(), this._setupFrame(), this._updateAnimationProps(), this._renderFrame(this._getAnimationProps()), this._clearNeedsRedraw(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endFrameTimers(), this);
  }
  /** Add a timeline, it will be automatically updated by the animation loop. */
  attachTimeline(e) {
    return this.timeline = e, this.timeline;
  }
  /** Remove a timeline */
  detachTimeline() {
    this.timeline = null;
  }
  /** Wait until a render completes */
  waitForRender() {
    return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise((e) => {
      this._resolveNextFrame = e;
    })), this._nextFramePromise;
  }
  /** TODO - should use device.deviceContext */
  async toDataURL() {
    if (this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.canvas instanceof HTMLCanvasElement)
      return this.canvas.toDataURL();
    throw new Error("OffscreenCanvas");
  }
  // PRIVATE METHODS
  _initialize() {
    this._startEventHandling(), this._initializeAnimationProps(), this._updateAnimationProps(), this._resizeCanvasDrawingBuffer(), this._resizeViewport();
  }
  _setDisplay(e) {
    this.display && (this.display.destroy(), this.display.animationLoop = null), e && (e.animationLoop = this), this.display = e;
  }
  _requestAnimationFrame() {
    this._running && (this._animationFrameId = SM(this._animationFrame.bind(this)));
  }
  _cancelAnimationFrame() {
    this._animationFrameId !== null && (CM(this._animationFrameId), this._animationFrameId = null);
  }
  _animationFrame() {
    this._running && (this.redraw(), this._requestAnimationFrame());
  }
  // Called on each frame, can be overridden to call onRender multiple times
  // to support e.g. stereoscopic rendering
  _renderFrame(e) {
    if (this.display) {
      this.display._renderFrame(e);
      return;
    }
    this.props.onRender(this._getAnimationProps()), this.device.submit();
  }
  _clearNeedsRedraw() {
    this.needsRedraw = !1;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer(), this._resizeViewport();
  }
  // Initialize the  object that will be passed to app callbacks
  _initializeAnimationProps() {
    var e, i;
    if (!this.device)
      throw new Error("loop");
    this.animationProps = {
      animationLoop: this,
      device: this.device,
      canvas: (i = (e = this.device) == null ? void 0 : e.canvasContext) == null ? void 0 : i.canvas,
      timeline: this.timeline,
      // Initial values
      useDevicePixels: this.props.useDevicePixels,
      needsRedraw: !1,
      // Placeholders
      width: 1,
      height: 1,
      aspect: 1,
      // Animation props
      time: 0,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      // Experimental
      _mousePosition: null
      // Event props
    };
  }
  _getAnimationProps() {
    if (!this.animationProps)
      throw new Error("animationProps");
    return this.animationProps;
  }
  // Update the context object that will be passed to app callbacks
  _updateAnimationProps() {
    if (!this.animationProps)
      return;
    const { width: e, height: i, aspect: s } = this._getSizeAndAspect();
    (e !== this.animationProps.width || i !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), s !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = e, this.animationProps.height = i, this.animationProps.aspect = s, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
  }
  /** Wait for supplied device */
  async _initDevice() {
    var e;
    if (this.device = await this.props.device, !this.device)
      throw new Error("No device provided");
    this.canvas = ((e = this.device.canvasContext) == null ? void 0 : e.canvas) || null;
  }
  _createInfoDiv() {
    if (this.canvas && this.props.onAddHTML) {
      const e = document.createElement("div");
      document.body.appendChild(e), e.style.position = "relative";
      const i = document.createElement("div");
      i.style.position = "absolute", i.style.left = "10px", i.style.bottom = "10px", i.style.width = "300px", i.style.background = "white", this.canvas instanceof HTMLCanvasElement && e.appendChild(this.canvas), e.appendChild(i);
      const s = this.props.onAddHTML(i);
      s && (i.innerHTML = s);
    }
  }
  _getSizeAndAspect() {
    var l, u, c, x;
    if (!this.device)
      return { width: 1, height: 1, aspect: 1 };
    const [e, i] = ((u = (l = this.device) == null ? void 0 : l.canvasContext) == null ? void 0 : u.getPixelSize()) || [1, 1];
    let s = 1;
    const o = (x = (c = this.device) == null ? void 0 : c.canvasContext) == null ? void 0 : x.canvas;
    return o && o.clientHeight ? s = o.clientWidth / o.clientHeight : e > 0 && i > 0 && (s = e / i), { width: e, height: i, aspect: s };
  }
  /** Default viewport setup */
  _resizeViewport() {
    this.props.autoResizeViewport && this.device.gl && this.device.gl.viewport(
      0,
      0,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferWidth,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferHeight
    );
  }
  /**
   * Resize the render buffer of the canvas to match canvas client size
   * Optionally multiplying with devicePixel ratio
   */
  _resizeCanvasDrawingBuffer() {
    var e, i;
    this.props.autoResizeDrawingBuffer && ((i = (e = this.device) == null ? void 0 : e.canvasContext) == null || i.resize({ useDevicePixels: this.props.useDevicePixels }));
  }
  _beginFrameTimers() {
    this.frameRate.timeEnd(), this.frameRate.timeStart(), this.cpuTime.timeStart();
  }
  _endFrameTimers() {
    this.cpuTime.timeEnd();
  }
  // Event handling
  _startEventHandling() {
    this.canvas && (this.canvas.addEventListener("mousemove", this._onMousemove.bind(this)), this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this)));
  }
  _onMousemove(e) {
    e instanceof MouseEvent && (this._getAnimationProps()._mousePosition = [e.offsetX, e.offsetY]);
  }
  _onMouseleave(e) {
    this._getAnimationProps()._mousePosition = null;
  }
}
class Lv {
  constructor(e) {
    O(this, "id");
    O(this, "userData", {});
    /** Determines how vertices are read from the 'vertex' attributes */
    O(this, "topology");
    O(this, "bufferLayout", []);
    O(this, "vertexCount");
    O(this, "indices");
    O(this, "attributes");
    this.id = e.id || ba("geometry"), this.topology = e.topology, this.indices = e.indices || null, this.attributes = e.attributes, this.vertexCount = e.vertexCount, this.bufferLayout = e.bufferLayout || [], this.indices && ri(this.indices.usage === Vi.INDEX);
  }
  destroy() {
    var e;
    (e = this.indices) == null || e.destroy();
    for (const i of Object.values(this.attributes))
      i.destroy();
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getIndexes() {
    return this.indices;
  }
  _calculateVertexCount(e) {
    return e.byteLength / 12;
  }
}
function xD(t, e) {
  if (e instanceof Lv)
    return e;
  const i = wD(t, e), { attributes: s, bufferLayout: o } = AD(t, e);
  return new Lv({
    topology: e.topology || "triangle-list",
    bufferLayout: o,
    vertexCount: e.vertexCount,
    indices: i,
    attributes: s
  });
}
function wD(t, e) {
  if (!e.indices)
    return;
  const i = e.indices.value;
  return t.createBuffer({ usage: Vi.INDEX, data: i });
}
function AD(t, e) {
  const i = [], s = {};
  for (const [l, u] of Object.entries(e.attributes)) {
    let c = l;
    switch (l) {
      case "POSITION":
        c = "positions";
        break;
      case "NORMAL":
        c = "normals";
        break;
      case "TEXCOORD_0":
        c = "texCoords";
        break;
      case "COLOR_0":
        c = "colors";
        break;
    }
    s[c] = t.createBuffer({ data: u.value, id: `${l}-buffer` });
    const { value: x, size: w, normalized: C } = u;
    i.push({ name: c, format: xM(x, w, C) });
  }
  const o = e._calculateVertexCount(e.attributes, e.indices);
  return { attributes: s, bufferLayout: i, vertexCount: o };
}
class TD {
  /**
   * Create a new UniformStore instance
   * @param modules
   */
  constructor(e) {
    /**
     * The map of modules
     * @todo should should this include the resolved dependencies?
     */
    O(this, "modules");
    /** Stores the uniform values for each module */
    O(this, "moduleUniforms");
    /** Stores the uniform bindings for each module  */
    O(this, "moduleBindings");
    /** Tracks if uniforms have changed */
    O(this, "moduleUniformsChanged");
    const i = _p(Object.values(e).filter((s) => s.dependencies));
    for (const s of i)
      e[s.name] = s;
    $e.log(1, "Creating ShaderInputs with modules", Object.keys(e))(), this.modules = e, this.moduleUniforms = {}, this.moduleBindings = {};
    for (const [s, o] of Object.entries(e)) {
      const l = s;
      this.moduleUniforms[l] = o.defaultUniforms || {}, this.moduleBindings[l] = {};
    }
  }
  /** Destroy */
  destroy() {
  }
  /**
   * Set module props
   */
  setProps(e) {
    var i;
    for (const s of Object.keys(e)) {
      const o = s, l = e[o], u = this.modules[o];
      if (!u) {
        $e.warn(`Module ${s} not found`)();
        continue;
      }
      const c = this.moduleUniforms[o], x = this.moduleBindings[o], w = ((i = u.getUniforms) == null ? void 0 : i.call(u, l, c)) || l, { uniforms: C, bindings: M } = iy(w);
      this.moduleUniforms[o] = { ...c, ...C }, this.moduleBindings[o] = { ...x, ...M };
    }
  }
  /** Merges all bindings for the shader (from the various modules) */
  // getUniformBlocks(): Record<string, Texture | Sampler> {
  //   return this.moduleUniforms;
  // }
  /**
   * Return the map of modules
   * @todo should should this include the resolved dependencies?
   */
  getModules() {
    return Object.values(this.modules);
  }
  /** Get all uniform values for all modules */
  getUniformValues() {
    return this.moduleUniforms;
  }
  /** Merges all bindings for the shader (from the various modules) */
  getBindings() {
    const e = {};
    for (const i of Object.values(this.moduleBindings))
      Object.assign(e, i);
    return e;
  }
  getDebugTable() {
    var i;
    const e = {};
    for (const [s, o] of Object.entries(this.moduleUniforms))
      for (const [l, u] of Object.entries(o))
        e[`${s}.${l}`] = {
          type: (i = this.modules[s].uniformTypes) == null ? void 0 : i[l],
          value: String(u)
        };
    return e;
  }
}
const hp = class hp {
  constructor(e) {
    O(this, "device");
    O(this, "_hashCounter", 0);
    O(this, "_hashes", {});
    O(this, "_renderPipelineCache", {});
    O(this, "_computePipelineCache", {});
    this.device = e;
  }
  /** Get the singleton default pipeline factory for the specified device */
  static getDefaultPipelineFactory(e) {
    return e._lumaData.defaultPipelineFactory = e._lumaData.defaultPipelineFactory || new hp(e), e._lumaData.defaultPipelineFactory;
  }
  /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */
  createRenderPipeline(e) {
    const i = { ...Dc.defaultProps, ...e }, s = this._hashRenderPipeline(i);
    if (!this._renderPipelineCache[s]) {
      const o = this.device.createRenderPipeline({
        ...i,
        id: i.id ? `${i.id}-cached` : void 0
      });
      o.hash = s, this._renderPipelineCache[s] = { pipeline: o, useCount: 0 };
    }
    return this._renderPipelineCache[s].useCount++, this._renderPipelineCache[s].pipeline;
  }
  createComputePipeline(e) {
    const i = { ...Nf.defaultProps, ...e }, s = this._hashComputePipeline(i);
    if (!this._computePipelineCache[s]) {
      const o = this.device.createComputePipeline({
        ...i,
        id: i.id ? `${i.id}-cached` : void 0
      });
      o.hash = s, this._computePipelineCache[s] = { pipeline: o, useCount: 0 };
    }
    return this._computePipelineCache[s].useCount++, this._computePipelineCache[s].pipeline;
  }
  release(e) {
    const i = e.hash, s = e instanceof Nf ? this._computePipelineCache : this._renderPipelineCache;
    s[i].useCount--, s[i].useCount === 0 && (s[i].pipeline.destroy(), delete s[i]);
  }
  // PRIVATE
  _hashComputePipeline(e) {
    return `${this._getHash(e.shader.source)}`;
  }
  /** Calculate a hash based on all the inputs for a render pipeline */
  _hashRenderPipeline(e) {
    const i = this._getHash(e.vs.source), s = e.fs ? this._getHash(e.fs.source) : 0, o = "-", l = this._getHash(JSON.stringify(e.bufferLayout));
    switch (this.device.type) {
      case "webgl":
        return `${i}/${s}V${o}BL${l}`;
      default:
        const u = this._getHash(JSON.stringify(e.parameters));
        return `${i}/${s}V${o}T${e.topology}P${u}BL${l}`;
    }
  }
  _getHash(e) {
    return this._hashes[e] === void 0 && (this._hashes[e] = this._hashCounter++), this._hashes[e];
  }
};
O(hp, "defaultProps", { ...Dc.defaultProps });
let mg = hp;
const up = class up {
  /** @internal */
  constructor(e) {
    O(this, "device");
    O(this, "_cache", {});
    this.device = e;
  }
  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */
  static getDefaultShaderFactory(e) {
    var i;
    return (i = e._lumaData).defaultShaderFactory || (i.defaultShaderFactory = new up(e)), e._lumaData.defaultShaderFactory;
  }
  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */
  createShader(e) {
    const i = this._hashShader(e);
    let s = this._cache[i];
    if (!s) {
      const o = this.device.createShader({
        ...e,
        id: e.id ? `${e.id}-cached` : void 0
      });
      this._cache[i] = s = { shader: o, useCount: 0 };
    }
    return s.useCount++, s.shader;
  }
  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */
  release(e) {
    const i = this._hashShader(e), s = this._cache[i];
    s && (s.useCount--, s.useCount === 0 && (delete this._cache[i], s.shader.destroy()));
  }
  // PRIVATE
  _hashShader(e) {
    return `${e.stage}:${e.source}`;
  }
};
O(up, "defaultProps", { ...Of.defaultProps });
let gg = up;
function ED(t, e) {
  var o;
  const i = {}, s = "Values";
  if (t.attributes.length === 0 && !((o = t.varyings) != null && o.length))
    return { "No attributes or varyings": { [s]: "N/A" } };
  for (const l of t.attributes)
    if (l) {
      const u = `${l.location} ${l.name}: ${l.type}`;
      i[`in ${u}`] = { [s]: l.stepMode || "vertex" };
    }
  for (const l of t.varyings || []) {
    const u = `${l.location} ${l.name}`;
    i[`out ${u}`] = { [s]: JSON.stringify(l.accessor) };
  }
  return i;
}
let Ts = null, rm = null;
function SD(t, { id: e, minimap: i, opaque: s, top: o = "0", left: l = "0", rgbaScale: u = 1 }) {
  Ts || (Ts = document.createElement("canvas"), Ts.id = e, Ts.title = e, Ts.style.zIndex = "100", Ts.style.position = "absolute", Ts.style.top = o, Ts.style.left = l, Ts.style.border = "blue 1px solid", Ts.style.transform = "scaleY(-1)", document.body.appendChild(Ts), rm = Ts.getContext("2d")), (Ts.width !== t.width || Ts.height !== t.height) && (Ts.width = t.width / 2, Ts.height = t.height / 2, Ts.style.width = "400px", Ts.style.height = "400px");
  const c = t.device.readPixelsToArrayWebGL(t), x = rm.createImageData(t.width, t.height), w = 0;
  for (let C = 0; C < c.length; C += 4)
    x.data[w + C + 0] = c[C + 0] * u, x.data[w + C + 1] = c[C + 1] * u, x.data[w + C + 2] = c[C + 2] * u, x.data[w + C + 3] = s ? 255 : c[C + 3] * u;
  rm.putImageData(x, 0, 0);
}
const cc = 2, CD = 1e4, dp = class dp {
  constructor(e, i) {
    O(this, "device");
    O(this, "id");
    O(this, "source");
    O(this, "vs");
    O(this, "fs");
    O(this, "pipelineFactory");
    O(this, "shaderFactory");
    O(this, "userData", {});
    // Fixed properties (change can trigger pipeline rebuild)
    /** The render pipeline GPU parameters, depth testing etc */
    O(this, "parameters");
    /** The primitive topology */
    O(this, "topology");
    /** Buffer layout */
    O(this, "bufferLayout");
    // Dynamic properties
    /** Use instanced rendering */
    O(this, "isInstanced");
    /** instance count. `undefined` means not instanced */
    O(this, "instanceCount", 0);
    /** Vertex count */
    O(this, "vertexCount");
    /** Index buffer */
    O(this, "indexBuffer", null);
    /** Buffer-valued attributes */
    O(this, "bufferAttributes", {});
    /** Constant-valued attributes */
    O(this, "constantAttributes", {});
    /** Bindings (textures, samplers, uniform buffers) */
    O(this, "bindings", {});
    /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/
    O(this, "uniforms", {});
    /**
     * VertexArray
     * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
     * @todo - allow application to define multiple vertex arrays?
     * */
    O(this, "vertexArray");
    /** TransformFeedback, WebGL 2 only. */
    O(this, "transformFeedback", null);
    /** The underlying GPU "program". @note May be recreated if parameters change */
    O(this, "pipeline");
    /** ShaderInputs instance */
    O(this, "shaderInputs");
    O(this, "_uniformStore");
    O(this, "_attributeInfos", {});
    O(this, "_gpuGeometry", null);
    O(this, "_getModuleUniforms");
    O(this, "props");
    O(this, "_pipelineNeedsUpdate", "newly created");
    O(this, "_needsRedraw", "initializing");
    O(this, "_destroyed", !1);
    /** "Time" of last draw. Monotonically increasing timestamp */
    O(this, "_lastDrawTimestamp", -1);
    /** Throttle draw call logging */
    O(this, "_lastLogTime", 0);
    O(this, "_logOpen", !1);
    O(this, "_drawCount", 0);
    var c, x, w, C;
    this.props = { ...dp.defaultProps, ...i }, i = this.props, this.id = i.id || ba("model"), this.device = e, Object.assign(this.userData, i.userData);
    const s = Object.fromEntries(((c = this.props.modules) == null ? void 0 : c.map((M) => [M.name, M])) || []);
    this.setShaderInputs(i.shaderInputs || new TD(s));
    const o = ID(e), l = (((x = this.props.modules) == null ? void 0 : x.length) > 0 ? this.props.modules : (w = this.shaderInputs) == null ? void 0 : w.getModules()) || [];
    if (this.device.type === "webgpu" && this.props.source) {
      (C = this.props).shaderLayout || (C.shaderLayout = uP(this.props.source));
      const { source: M, getUniforms: P } = this.props.shaderAssembler.assembleShader({
        platformInfo: o,
        ...this.props,
        modules: l
      });
      this.source = M, this._getModuleUniforms = P;
    } else {
      const { vs: M, fs: P, getUniforms: j } = this.props.shaderAssembler.assembleShaderPair({
        platformInfo: o,
        ...this.props,
        modules: l
      });
      this.vs = M, this.fs = P, this._getModuleUniforms = j;
    }
    this.vertexCount = this.props.vertexCount, this.instanceCount = this.props.instanceCount, this.topology = this.props.topology, this.bufferLayout = this.props.bufferLayout, this.parameters = this.props.parameters, i.geometry && this.setGeometry(i.geometry), this.pipelineFactory = i.pipelineFactory || mg.getDefaultPipelineFactory(this.device), this.shaderFactory = i.shaderFactory || gg.getDefaultShaderFactory(this.device), this.pipeline = this._updatePipeline(), this.vertexArray = e.createVertexArray({
      renderPipeline: this.pipeline
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry), "isInstanced" in i && (this.isInstanced = i.isInstanced), i.instanceCount && this.setInstanceCount(i.instanceCount), i.vertexCount && this.setVertexCount(i.vertexCount), i.indexBuffer && this.setIndexBuffer(i.indexBuffer), i.attributes && this.setAttributes(i.attributes), i.constantAttributes && this.setConstantAttributes(i.constantAttributes), i.bindings && this.setBindings(i.bindings), i.uniforms && this.setUniforms(i.uniforms), i.moduleSettings && this.updateModuleSettings(i.moduleSettings), i.transformFeedback && (this.transformFeedback = i.transformFeedback), Object.seal(this);
  }
  destroy() {
    var e;
    this._destroyed || (this.pipelineFactory.release(this.pipeline), this.shaderFactory.release(this.pipeline.vs), this.pipeline.fs && this.shaderFactory.release(this.pipeline.fs), this._uniformStore.destroy(), (e = this._gpuGeometry) == null || e.destroy(), this._destroyed = !0);
  }
  // Draw call
  /** Query redraw status. Clears the status. */
  needsRedraw() {
    this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp && this.setNeedsRedraw("contents of bound textures or buffers updated");
    const e = this._needsRedraw;
    return this._needsRedraw = !1, e;
  }
  /** Mark the model as needing a redraw */
  setNeedsRedraw(e) {
    this._needsRedraw || (this._needsRedraw = e);
  }
  predraw() {
    this.updateShaderInputs(), this.pipeline = this._updatePipeline();
  }
  draw(e) {
    this.predraw();
    let i;
    try {
      this._logDrawCallStart(), this.pipeline = this._updatePipeline(), this.pipeline.setBindings(this.bindings, { disableWarnings: this.props.disableWarnings }), Bf(this.uniforms) || this.pipeline.setUniformsWebGL(this.uniforms);
      const { indexBuffer: s } = this.vertexArray, o = s ? s.byteLength / (s.indexType === "uint32" ? 4 : 2) : void 0;
      i = this.pipeline.draw({
        renderPass: e,
        vertexArray: this.vertexArray,
        isInstanced: this.isInstanced,
        vertexCount: this.vertexCount,
        instanceCount: this.instanceCount,
        indexCount: o,
        transformFeedback: this.transformFeedback || void 0,
        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
        // so we must provide our unique parameters to each draw
        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
        parameters: this.parameters,
        topology: this.topology
      });
    } finally {
      this._logDrawCallEnd();
    }
    return this._logFramebuffer(e), i ? (this._lastDrawTimestamp = this.device.timestamp, this._needsRedraw = !1) : this._needsRedraw = "waiting for resource initialization", i;
  }
  // Update fixed fields (can trigger pipeline rebuild)
  /**
   * Updates the optional geometry
   * Geometry, set topology and bufferLayout
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setGeometry(e) {
    var s;
    (s = this._gpuGeometry) == null || s.destroy();
    const i = e && xD(this.device, e);
    i && (this.setTopology(i.topology || "triangle-list"), this.bufferLayout = Uv(i.bufferLayout, this.bufferLayout), this.vertexArray && this._setGeometryAttributes(i)), this._gpuGeometry = i;
  }
  /**
   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setTopology(e) {
    e !== this.topology && (this.topology = e, this._setPipelineNeedsUpdate("topology"));
  }
  /**
   * Updates the buffer layout.
   * @note Triggers a pipeline rebuild / pipeline cache fetch
   */
  setBufferLayout(e) {
    this.bufferLayout = this._gpuGeometry ? Uv(e, this._gpuGeometry.bufferLayout) : e, this._setPipelineNeedsUpdate("bufferLayout"), this.pipeline = this._updatePipeline(), this.vertexArray = this.device.createVertexArray({
      renderPipeline: this.pipeline
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry);
  }
  /**
   * Set GPU parameters.
   * @note Can trigger a pipeline rebuild / pipeline cache fetch.
   * @param parameters
   */
  setParameters(e) {
    rg(e, this.parameters, 2) || (this.parameters = e, this._setPipelineNeedsUpdate("parameters"));
  }
  // Update dynamic fields
  /**
   * Updates the instance count (used in draw calls)
   * @note Any attributes with stepMode=instance need to be at least this big
   */
  setInstanceCount(e) {
    this.instanceCount = e, this.isInstanced === void 0 && e > 0 && (this.isInstanced = !0), this.setNeedsRedraw("instanceCount");
  }
  /**
   * Updates the vertex count (used in draw calls)
   * @note Any attributes with stepMode=vertex need to be at least this big
   */
  setVertexCount(e) {
    this.vertexCount = e, this.setNeedsRedraw("vertexCount");
  }
  /** Set the shader inputs */
  setShaderInputs(e) {
    this.shaderInputs = e, this._uniformStore = new vM(this.shaderInputs.modules);
    for (const i of Object.keys(this.shaderInputs.modules)) {
      const s = this._uniformStore.getManagedUniformBuffer(this.device, i);
      this.bindings[`${i}Uniforms`] = s;
    }
    this.setNeedsRedraw("shaderInputs");
  }
  /** Update uniform buffers from the model's shader inputs */
  updateShaderInputs() {
    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()), this.setBindings(this.shaderInputs.getBindings()), this.setNeedsRedraw("shaderInputs");
  }
  /**
   * Sets bindings (textures, samplers, uniform buffers)
   */
  setBindings(e) {
    Object.assign(this.bindings, e), this.setNeedsRedraw("bindings");
  }
  /**
   * Updates optional transform feedback. WebGL only.
   */
  setTransformFeedback(e) {
    this.transformFeedback = e, this.setNeedsRedraw("transformFeedback");
  }
  /**
   * Sets the index buffer
   * @todo - how to unset it if we change geometry?
   */
  setIndexBuffer(e) {
    this.vertexArray.setIndexBuffer(e), this.setNeedsRedraw("indexBuffer");
  }
  /**
   * Sets attributes (buffers)
   * @note Overrides any attributes previously set with the same name
   */
  setAttributes(e, i) {
    e.indices && $e.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
    for (const [s, o] of Object.entries(e)) {
      const l = this.bufferLayout.find((x) => zv(x).includes(s));
      if (!l) {
        $e.warn(`Model(${this.id}): Missing layout for buffer "${s}".`)();
        continue;
      }
      const u = zv(l);
      let c = !1;
      for (const x of u) {
        const w = this._attributeInfos[x];
        w && (this.vertexArray.setBuffer(w.location, o), c = !0);
      }
      !c && !((i == null ? void 0 : i.disableWarnings) ?? this.props.disableWarnings) && $e.warn(`Model(${this.id}): Ignoring buffer "${o.id}" for unknown attribute "${s}"`)();
    }
    this.setNeedsRedraw("attributes");
  }
  /**
   * Sets constant attributes
   * @note Overrides any attributes previously set with the same name
   * Constant attributes are only supported in WebGL, not in WebGPU
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @param constantAttributes
   */
  setConstantAttributes(e, i) {
    for (const [s, o] of Object.entries(e)) {
      const l = this._attributeInfos[s];
      l ? this.vertexArray.setConstantWebGL(l.location, o) : ((i == null ? void 0 : i.disableWarnings) ?? this.props.disableWarnings) || $e.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${s}"`)();
    }
    this.setNeedsRedraw("constants");
  }
  // DEPRECATED METHODS
  /**
   * Sets individual uniforms
   * @deprecated WebGL only, use uniform buffers for portability
   * @param uniforms
   */
  setUniforms(e) {
    Bf(e) || (this.pipeline.setUniformsWebGL(e), Object.assign(this.uniforms, e)), this.setNeedsRedraw("uniforms");
  }
  /**
   * @deprecated Updates shader module settings (which results in uniforms being set)
   */
  updateModuleSettings(e) {
    const { bindings: i, uniforms: s } = iy(this._getModuleUniforms(e));
    Object.assign(this.bindings, i), Object.assign(this.uniforms, s), this.setNeedsRedraw("moduleSettings");
  }
  // Internal methods
  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */
  _getBindingsUpdateTimestamp() {
    let e = 0;
    for (const i of Object.values(this.bindings))
      i instanceof Df ? e = Math.max(e, i.texture.updateTimestamp) : i instanceof Vi || i instanceof Ur ? e = Math.max(e, i.updateTimestamp) : i instanceof Ff || (e = Math.max(e, i.buffer.updateTimestamp));
    return e;
  }
  /**
   * Updates the optional geometry attributes
   * Geometry, sets several attributes, indexBuffer, and also vertex count
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  _setGeometryAttributes(e) {
    const i = { ...e.attributes };
    for (const [s] of Object.entries(i))
      !this.pipeline.shaderLayout.attributes.find((o) => o.name === s) && s !== "positions" && delete i[s];
    this.vertexCount = e.vertexCount, this.setIndexBuffer(e.indices || null), this.setAttributes(e.attributes, { disableWarnings: !0 }), this.setAttributes(i, { disableWarnings: this.props.disableWarnings }), this.setNeedsRedraw("geometry attributes");
  }
  /** Mark pipeline as needing update */
  _setPipelineNeedsUpdate(e) {
    this._pipelineNeedsUpdate || (this._pipelineNeedsUpdate = e), this.setNeedsRedraw(e);
  }
  /** Update pipeline if needed */
  _updatePipeline() {
    if (this._pipelineNeedsUpdate) {
      let e = null, i = null;
      this.pipeline && ($e.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(), e = this.pipeline.vs, i = this.pipeline.fs), this._pipelineNeedsUpdate = !1;
      const s = this.shaderFactory.createShader({
        id: `${this.id}-vertex`,
        stage: "vertex",
        source: this.source || this.vs,
        debug: this.props.debugShaders
      });
      let o = null;
      this.source ? o = s : this.fs && (o = this.shaderFactory.createShader({
        id: `${this.id}-fragment`,
        stage: "fragment",
        source: this.source || this.fs,
        debug: this.props.debugShaders
      })), this.pipeline = this.pipelineFactory.createRenderPipeline({
        ...this.props,
        bufferLayout: this.bufferLayout,
        topology: this.topology,
        parameters: this.parameters,
        vs: s,
        fs: o
      }), this._attributeInfos = Sw(this.pipeline.shaderLayout, this.bufferLayout), e && this.shaderFactory.release(e), i && this.shaderFactory.release(i);
    }
    return this.pipeline;
  }
  _logDrawCallStart() {
    const e = $e.level > 3 ? 0 : CD;
    $e.level < 2 || Date.now() - this._lastLogTime < e || (this._lastLogTime = Date.now(), this._logOpen = !0, $e.group(cc, `>>> DRAWING MODEL ${this.id}`, { collapsed: $e.level <= 2 })());
  }
  _logDrawCallEnd() {
    if (this._logOpen) {
      const e = ED(this.pipeline.shaderLayout, this.id);
      $e.table(cc, e)();
      const i = this.shaderInputs.getDebugTable();
      for (const [o, l] of Object.entries(this.uniforms))
        i[o] = { value: l };
      $e.table(cc, i)();
      const s = this._getAttributeDebugTable();
      $e.table(cc, this._attributeInfos)(), $e.table(cc, s)(), $e.groupEnd(cc)(), this._logOpen = !1;
    }
  }
  _logFramebuffer(e) {
    const i = $e.get("framebuffer");
    if (this._drawCount++, !i || this._drawCount++ > 3 && this._drawCount % 60)
      return;
    const s = e.props.framebuffer;
    s && SD(s, { id: s.id, minimap: !0 });
  }
  _getAttributeDebugTable() {
    const e = {};
    for (const [i, s] of Object.entries(this._attributeInfos))
      e[s.location] = {
        name: i,
        type: s.shaderType,
        values: this._getBufferOrConstantValues(this.vertexArray.attributes[s.location], s.bufferDataType)
      };
    if (this.vertexArray.indexBuffer) {
      const { indexBuffer: i } = this.vertexArray, s = i.indexType === "uint32" ? new Uint32Array(i.debugData) : new Uint16Array(i.debugData);
      e.indices = {
        name: "indices",
        type: i.indexType,
        values: s.toString()
      };
    }
    return e;
  }
  // TODO - fix typing of luma data types
  _getBufferOrConstantValues(e, i) {
    const s = Rw(i);
    return (e instanceof Vi ? new s(e.debugData) : e).toString();
  }
};
O(dp, "defaultProps", {
  ...Dc.defaultProps,
  source: null,
  vs: null,
  fs: null,
  id: "unnamed",
  handle: void 0,
  userData: {},
  defines: {},
  modules: [],
  moduleSettings: void 0,
  geometry: null,
  indexBuffer: null,
  attributes: {},
  constantAttributes: {},
  varyings: [],
  isInstanced: void 0,
  instanceCount: 0,
  vertexCount: 0,
  shaderInputs: void 0,
  pipelineFactory: void 0,
  shaderFactory: void 0,
  transformFeedback: void 0,
  shaderAssembler: Pf.getDefaultShaderAssembler(),
  debugShaders: void 0,
  disableWarnings: void 0
});
let ma = dp;
function Uv(t, e) {
  const i = [...t];
  for (const s of e) {
    const o = i.findIndex((l) => l.name === s.name);
    o < 0 ? i.push(s) : i[o] = s;
  }
  return i;
}
function ID(t) {
  return {
    type: t.type,
    shaderLanguage: t.info.shadingLanguage,
    shaderLanguageVersion: t.info.shadingLanguageVersion,
    gpu: t.info.gpu,
    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
    features: t.features
  };
}
function zv(t) {
  var e;
  return t.attributes ? (e = t.attributes) == null ? void 0 : e.map((i) => i.attribute) : [t.name];
}
class Su {
  constructor(e, i = ma.defaultProps) {
    O(this, "device");
    O(this, "model");
    O(this, "transformFeedback");
    ri(Su.isSupported(e), "BufferTransform not yet implemented on WebGPU"), this.device = e, this.model = new ma(this.device, {
      id: i.id || "buffer-transform-model",
      fs: i.fs || wR(),
      topology: i.topology || "point-list",
      ...i
    }), this.transformFeedback = this.device.createTransformFeedback({
      layout: this.model.pipeline.shaderLayout,
      buffers: i.feedbackBuffers
    }), this.model.setTransformFeedback(this.transformFeedback), Object.seal(this);
  }
  /** @deprecated Use device feature test. */
  static isSupported(e) {
    var i;
    return ((i = e == null ? void 0 : e.info) == null ? void 0 : i.type) === "webgl";
  }
  /** Destroy owned resources. */
  destroy() {
    this.model && this.model.destroy();
  }
  /** @deprecated Use {@link destroy}. */
  delete() {
    this.destroy();
  }
  /** Run one transform loop. */
  run(e) {
    const i = this.device.beginRenderPass(e);
    this.model.draw(i), i.end();
  }
  /** @deprecated */
  update(...e) {
    console.warn("TextureTransform#update() not implemented");
  }
  /** Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
  getBuffer(e) {
    return this.transformFeedback.getBuffer(e);
  }
  readAsync(e) {
    const i = this.getBuffer(e);
    if (i instanceof Vi)
      return i.readAsync();
    const { buffer: s, byteOffset: o = 0, byteLength: l = s.byteLength } = i;
    return s.readAsync(o, l);
  }
}
class Ic {
  constructor(e) {
    O(this, "id");
    /** Determines how vertices are read from the 'vertex' attributes */
    O(this, "topology");
    O(this, "vertexCount");
    O(this, "indices");
    O(this, "attributes");
    O(this, "userData", {});
    const { attributes: i = {}, indices: s = null, vertexCount: o = null } = e;
    this.id = e.id || ba("geometry"), this.topology = e.topology, s && (this.indices = ArrayBuffer.isView(s) ? { value: s, size: 1 } : s), this.attributes = {};
    for (const [l, u] of Object.entries(i)) {
      const c = ArrayBuffer.isView(u) ? { value: u } : u;
      ri(ArrayBuffer.isView(c.value), `${this._print(l)}: must be typed array or object with value as typed array`), (l === "POSITION" || l === "positions") && !c.size && (c.size = 3), l === "indices" ? (ri(!this.indices), this.indices = c) : this.attributes[l] = c;
    }
    this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this.vertexCount = o || this._calculateVertexCount(this.attributes, this.indices);
  }
  getVertexCount() {
    return this.vertexCount;
  }
  /**
   * Return an object with all attributes plus indices added as a field.
   * TODO Geometry types are a mess
   */
  getAttributes() {
    return this.indices ? { indices: this.indices, ...this.attributes } : this.attributes;
  }
  // PRIVATE
  _print(e) {
    return `Geometry ${this.id} attribute ${e}`;
  }
  /**
   * GeometryAttribute
   * value: typed array
   * type: indices, vertices, uvs
   * size: elements per vertex
   * target: WebGL buffer type (string or constant)
   *
   * @param attributes
   * @param indices
   * @returns
   */
  _setAttributes(e, i) {
    return this;
  }
  _calculateVertexCount(e, i) {
    if (i)
      return i.value.length;
    let s = 1 / 0;
    for (const o of Object.values(e)) {
      const { value: l, size: u, constant: c } = o;
      !c && l && u >= 1 && (s = Math.min(s, l.length / u));
    }
    return ri(Number.isFinite(s)), s;
  }
}
class $f {
  constructor(e = {}) {
    O(this, "id");
    O(this, "matrix", new Xt());
    O(this, "display", !0);
    O(this, "position", new Se());
    O(this, "rotation", new Se());
    O(this, "scale", new Se(1, 1, 1));
    O(this, "userData", {});
    O(this, "props", {});
    const { id: i } = e;
    this.id = i || ba(this.constructor.name), this._setScenegraphNodeProps(e);
  }
  getBounds() {
    return null;
  }
  destroy() {
  }
  /** @deprecated use .destroy() */
  delete() {
    this.destroy();
  }
  setProps(e) {
    return this._setScenegraphNodeProps(e), this;
  }
  toString() {
    return `{type: ScenegraphNode, id: ${this.id})}`;
  }
  setPosition(e) {
    return ri(e.length === 3, "setPosition requires vector argument"), this.position = e, this;
  }
  setRotation(e) {
    return ri(e.length === 3, "setRotation requires vector argument"), this.rotation = e, this;
  }
  setScale(e) {
    return ri(e.length === 3, "setScale requires vector argument"), this.scale = e, this;
  }
  setMatrix(e, i = !0) {
    i ? this.matrix.copy(e) : this.matrix = e;
  }
  setMatrixComponents(e) {
    const { position: i, rotation: s, scale: o, update: l = !0 } = e;
    return i && this.setPosition(i), s && this.setRotation(s), o && this.setScale(o), l && this.updateMatrix(), this;
  }
  updateMatrix() {
    const e = this.position, i = this.rotation, s = this.scale;
    return this.matrix.identity(), this.matrix.translate(e), this.matrix.rotateXYZ(i), this.matrix.scale(s), this;
  }
  update(e = {}) {
    const { position: i, rotation: s, scale: o } = e;
    return i && this.setPosition(i), s && this.setRotation(s), o && this.setScale(o), this.updateMatrix(), this;
  }
  getCoordinateUniforms(e, i) {
    ri(e), i = i || this.matrix;
    const s = new Xt(e).multiplyRight(i), o = s.invert(), l = o.transpose();
    return {
      viewMatrix: e,
      modelMatrix: i,
      objectMatrix: i,
      worldMatrix: s,
      worldInverseMatrix: o,
      worldInverseTransposeMatrix: l
    };
  }
  // TODO - copied code, not yet vetted
  /*
    transform() {
      if (!this.parent) {
        this.endPosition.set(this.position);
        this.endRotation.set(this.rotation);
        this.endScale.set(this.scale);
      } else {
        const parent = this.parent;
        this.endPosition.set(this.position.add(parent.endPosition));
        this.endRotation.set(this.rotation.add(parent.endRotation));
        this.endScale.set(this.scale.add(parent.endScale));
      }
  
      const ch = this.children;
      for (let i = 0; i < ch.length; ++i) {
        ch[i].transform();
      }
  
      return this;
    }
    */
  _setScenegraphNodeProps(e) {
    "display" in e && (this.display = e.display), "position" in e && this.setPosition(e.position), "rotation" in e && this.setRotation(e.rotation), "scale" in e && this.setScale(e.scale), "matrix" in e && this.setMatrix(e.matrix), Object.assign(this.props, e);
  }
}
class Rc extends $f {
  constructor(i = {}) {
    i = Array.isArray(i) ? { children: i } : i;
    const { children: s = [] } = i;
    $e.assert(s.every((o) => o instanceof $f), "every child must an instance of ScenegraphNode");
    super(i);
    O(this, "children");
    this.children = s;
  }
  getBounds() {
    const i = [
      [1 / 0, 1 / 0, 1 / 0],
      [-1 / 0, -1 / 0, -1 / 0]
    ];
    return this.traverse((s, { worldMatrix: o }) => {
      const l = s.getBounds();
      if (!l)
        return;
      const [u, c] = l, x = new Se(u).add(c).divide([2, 2, 2]);
      o.transformAsPoint(x, x);
      const w = new Se(c).subtract(u).divide([2, 2, 2]);
      o.transformAsVector(w, w);
      for (let C = 0; C < 8; C++) {
        const M = new Se(C & 1 ? -1 : 1, C & 2 ? -1 : 1, C & 4 ? -1 : 1).multiply(w).add(x);
        for (let P = 0; P < 3; P++)
          i[0][P] = Math.min(i[0][P], M[P]), i[1][P] = Math.max(i[1][P], M[P]);
      }
    }), Number.isFinite(i[0][0]) ? i : null;
  }
  destroy() {
    this.children.forEach((i) => i.destroy()), this.removeAll(), super.destroy();
  }
  // Unpacks arrays and nested arrays of children
  add(...i) {
    for (const s of i)
      Array.isArray(s) ? this.add(...s) : this.children.push(s);
    return this;
  }
  remove(i) {
    const s = this.children, o = s.indexOf(i);
    return o > -1 && s.splice(o, 1), this;
  }
  removeAll() {
    return this.children = [], this;
  }
  traverse(i, { worldMatrix: s = new Xt() } = {}) {
    const o = new Xt(s).multiplyRight(this.matrix);
    for (const l of this.children)
      l instanceof Rc ? l.traverse(i, { worldMatrix: o }) : i(l, { worldMatrix: o });
  }
}
class yg extends $f {
  // TODO - is this used? override callbacks to make sure we call them with this
  // onBeforeRender = null;
  // onAfterRender = null;
  // AfterRender = null;
  constructor(i) {
    super(i);
    O(this, "model");
    O(this, "bounds", null);
    O(this, "managedResources");
    this.model = i.model, this.managedResources = i.managedResources || [], this.bounds = i.bounds || null, this.setProps(i);
  }
  getBounds() {
    return this.bounds;
  }
  destroy() {
    this.model && (this.model.destroy(), this.model = null), this.managedResources.forEach((i) => i.destroy()), this.managedResources = [];
  }
  // Expose model methods
  draw(i) {
    return this.model.draw(i);
  }
}
const RD = {
  blendColorOperation: "add",
  blendColorSrcFactor: "one",
  blendColorDstFactor: "zero",
  blendAlphaOperation: "add",
  blendAlphaSrcFactor: "constant-alpha",
  blendAlphaDstFactor: "zero"
};
class bA extends yy {
  constructor() {
    super(...arguments), this._colorEncoderState = null;
  }
  render(e) {
    return "pickingFBO" in e ? this._drawPickingBuffer(e) : super.render(e);
  }
  // Private
  // Draws list of layers and viewports into the picking buffer
  // Note: does not sample the buffer, that has to be done by the caller
  _drawPickingBuffer({ layers: e, layerFilter: i, views: s, viewports: o, onViewportActive: l, pickingFBO: u, deviceRect: { x: c, y: x, width: w, height: C }, cullRect: M, effects: P, pass: j = "picking", pickZ: Y, moduleParameters: Q }) {
    this.pickZ = Y;
    const _e = this._resetColorEncoder(Y), me = [c, x, w, C], we = super.render({
      target: u,
      layers: e,
      layerFilter: i,
      views: s,
      viewports: o,
      onViewportActive: l,
      cullRect: M,
      effects: P == null ? void 0 : P.filter((Oe) => Oe.useInPicking),
      pass: j,
      isPicking: !0,
      moduleParameters: Q,
      clearColor: [0, 0, 0, 0],
      colorMask: 15,
      scissorRect: me
    });
    return this._colorEncoderState = null, { decodePickingColor: _e && PD.bind(null, _e), stats: we };
  }
  shouldDrawLayer(e) {
    const { pickable: i, operation: s } = e.props;
    return i && s.includes("draw") || s.includes("terrain") || s.includes("mask");
  }
  getModuleParameters() {
    return {
      picking: {
        isActive: 1,
        isAttribute: this.pickZ
      },
      // turn off lighting by adding empty light source object
      // lights shader module relies on the `lightSources` to turn on/off lighting
      lightSources: {}
    };
  }
  getLayerParameters(e, i, s) {
    const o = {
      // TODO - When used as a custom layer in older Mapbox versions, context
      // state was dirty. Mapbox fixed that; we should test and remove the workaround.
      // https://github.com/mapbox/mapbox-gl-js/issues/7801
      depthMask: !0,
      depthTest: !0,
      depthRange: [0, 1],
      ...e.props.parameters
    }, { pickable: l, operation: u } = e.props;
    return !this._colorEncoderState || u.includes("terrain") ? o.blend = !1 : l && u.includes("draw") && (Object.assign(o, RD), o.blend = !0, o.blendColor = MD(this._colorEncoderState, e, s)), o;
  }
  _resetColorEncoder(e) {
    return this._colorEncoderState = e ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    }, this._colorEncoderState;
  }
}
function MD(t, e, i) {
  const { byLayer: s, byAlpha: o } = t;
  let l, u = s.get(e);
  return u ? (u.viewports.push(i), l = u.a) : (l = s.size + 1, l <= 255 ? (u = { a: l, layer: e, viewports: [i] }, s.set(e, u), o[l] = u) : (Jt.warn("Too many pickable layers, only picking the first 255")(), l = 0)), [0, 0, 0, l / 255];
}
function PD(t, e) {
  const i = t.byAlpha[e[3]];
  return i && {
    pickedLayer: i.layer,
    pickedViewports: i.viewports,
    pickedObjectIndex: i.layer.decodePickingColor(e)
  };
}
const pc = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
}, Gf = Symbol.for("component"), da = Symbol.for("propTypes"), nm = Symbol.for("deprecatedProps"), Mc = Symbol.for("asyncPropDefaults"), al = Symbol.for("asyncPropOriginal"), ha = Symbol.for("asyncPropResolved");
function Nc(t, e = () => !0) {
  return Array.isArray(t) ? vA(t, e, []) : e(t) ? [t] : [];
}
function vA(t, e, i) {
  let s = -1;
  for (; ++s < t.length; ) {
    const o = t[s];
    Array.isArray(o) ? vA(o, e, i) : e(o) && i.push(o);
  }
  return i;
}
function BD({ target: t, source: e, start: i = 0, count: s = 1 }) {
  const o = e.length, l = s * o;
  let u = 0;
  for (let c = i; u < o; u++)
    t[c++] = e[u];
  for (; u < l; )
    u < l - u ? (t.copyWithin(i + u, i, i + u), u *= 2) : (t.copyWithin(i + u, i, i + l - u), u = l);
  return t;
}
class DD {
  constructor(e, i, s) {
    this._loadCount = 0, this._subscribers = /* @__PURE__ */ new Set(), this.id = e, this.context = s, this.setData(i);
  }
  // consumer: {onChange: Function}
  subscribe(e) {
    this._subscribers.add(e);
  }
  unsubscribe(e) {
    this._subscribers.delete(e);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(e, i) {
    if (e === this._data && !i)
      return;
    this._data = e;
    const s = ++this._loadCount;
    let o = e;
    typeof e == "string" && (o = pa(e)), o instanceof Promise ? (this.isLoaded = !1, this._loader = o.then((l) => {
      this._loadCount === s && (this.isLoaded = !0, this._error = void 0, this._content = l);
    }).catch((l) => {
      this._loadCount === s && (this.isLoaded = !0, this._error = l || !0);
    })) : (this.isLoaded = !0, this._error = void 0, this._content = e);
    for (const l of this._subscribers)
      l.onChange(this.getData());
  }
}
class OD {
  constructor(e) {
    var i;
    this.protocol = e.protocol || "resource://", this._context = {
      device: e.device,
      // @ts-expect-error
      gl: (i = e.device) == null ? void 0 : i.gl,
      resourceManager: this
    }, this._resources = {}, this._consumers = {}, this._pruneRequest = null;
  }
  contains(e) {
    return e.startsWith(this.protocol) ? !0 : e in this._resources;
  }
  add({ resourceId: e, data: i, forceUpdate: s = !1, persistent: o = !0 }) {
    let l = this._resources[e];
    l ? l.setData(i, s) : (l = new DD(e, i, this._context), this._resources[e] = l), l.persistent = o;
  }
  remove(e) {
    const i = this._resources[e];
    i && (i.delete(), delete this._resources[e]);
  }
  unsubscribe({ consumerId: e }) {
    const i = this._consumers[e];
    if (i) {
      for (const s in i) {
        const o = i[s], l = this._resources[o.resourceId];
        l && l.unsubscribe(o);
      }
      delete this._consumers[e], this.prune();
    }
  }
  subscribe({ resourceId: e, onChange: i, consumerId: s, requestId: o = "default" }) {
    const { _resources: l, protocol: u } = this;
    e.startsWith(u) && (e = e.replace(u, ""), l[e] || this.add({ resourceId: e, data: null, persistent: !1 }));
    const c = l[e];
    if (this._track(s, o, c, i), c)
      return c.getData();
  }
  prune() {
    this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0));
  }
  finalize() {
    for (const e in this._resources)
      this._resources[e].delete();
  }
  _track(e, i, s, o) {
    const l = this._consumers, u = l[e] = l[e] || {};
    let c = u[i];
    const x = c && c.resourceId && this._resources[c.resourceId];
    x && (x.unsubscribe(c), this.prune()), s && (c ? (c.onChange = o, c.resourceId = s.id) : c = {
      onChange: o,
      resourceId: s.id
    }, u[i] = c, s.subscribe(c));
  }
  _prune() {
    this._pruneRequest = null;
    for (const e of Object.keys(this._resources)) {
      const i = this._resources[e];
      !i.persistent && !i.inUse() && (i.delete(), delete this._resources[e]);
    }
  }
}
const FD = "layerManager.setLayers", kD = "layerManager.activateViewport";
class ND {
  /**
   * @param device
   * @param param1
   */
  // eslint-disable-next-line
  constructor(e, i) {
    this._lastRenderedLayers = [], this._needsRedraw = !1, this._needsUpdate = !1, this._nextLayers = null, this._debug = !1, this._defaultShaderModulesChanged = !1, this.activateViewport = (c) => {
      qs(kD, this, c), c && (this.context.viewport = c);
    };
    const { deck: s, stats: o, viewport: l, timeline: u } = i || {};
    this.layers = [], this.resourceManager = new OD({ device: e, protocol: "deck://" }), this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      device: e,
      // @ts-expect-error
      gl: e == null ? void 0 : e.gl,
      deck: s,
      shaderAssembler: GB(),
      defaultShaderModules: [],
      renderPass: void 0,
      stats: o || new jc({ id: "deck.gl" }),
      // Make sure context.viewport is not empty on the first layer initialization
      viewport: l || new Lu({ id: "DEFAULT-INITIAL-VIEWPORT" }),
      // Current viewport, exposed to layers for project* function
      timeline: u || new yA(),
      resourceManager: this.resourceManager,
      onError: void 0
    }, Object.seal(this);
  }
  /** Method to call when the layer manager is not needed anymore. */
  finalize() {
    this.resourceManager.finalize();
    for (const e of this.layers)
      this._finalizeLayer(e);
  }
  /** Check if a redraw is needed */
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    let i = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    for (const s of this.layers) {
      const o = s.getNeedsRedraw(e);
      i = i || o;
    }
    return i;
  }
  /** Check if a deep update of all layers is needed */
  needsUpdate() {
    return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._defaultShaderModulesChanged ? "shader modules changed" : this._needsUpdate;
  }
  /** Layers will be redrawn (in next animation frame) */
  setNeedsRedraw(e) {
    this._needsRedraw = this._needsRedraw || e;
  }
  /** Layers will be updated deeply (in next animation frame)
    Potentially regenerating attributes and sub layers */
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e;
  }
  /** Gets a list of currently rendered layers. Optionally filter by id. */
  getLayers({ layerIds: e } = {}) {
    return e ? this.layers.filter((i) => e.find((s) => i.id.indexOf(s) === 0)) : this.layers;
  }
  /** Set props needed for layer rendering and picking. */
  setProps(e) {
    "debug" in e && (this._debug = e.debug), "userData" in e && (this.context.userData = e.userData), "layers" in e && (this._nextLayers = e.layers), "onError" in e && (this.context.onError = e.onError);
  }
  /** Supply a new layer list, initiating sublayer generation and layer matching */
  setLayers(e, i) {
    qs(FD, this, i, e), this._lastRenderedLayers = e;
    const s = Nc(e, Boolean);
    for (const o of s)
      o.context = this.context;
    this._updateLayers(this.layers, s);
  }
  /** Update layers from last cycle if `setNeedsUpdate()` has been called */
  updateLayers() {
    const e = this.needsUpdate();
    e && (this.setNeedsRedraw(`updating layers: ${e}`), this.setLayers(this._nextLayers || this._lastRenderedLayers, e)), this._nextLayers = null;
  }
  /** Register a default shader module */
  addDefaultShaderModule(e) {
    const { defaultShaderModules: i } = this.context;
    i.find((s) => s.name === e.name) || (i.push(e), this._defaultShaderModulesChanged = !0);
  }
  /** Deregister a default shader module */
  removeDefaultShaderModule(e) {
    const { defaultShaderModules: i } = this.context, s = i.findIndex((o) => o.name === e.name);
    s >= 0 && (i.splice(s, 1), this._defaultShaderModulesChanged = !0);
  }
  _handleError(e, i, s) {
    s.raiseError(i, `${e} of ${s}`);
  }
  // TODO - mark layers with exceptions as bad and remove from rendering cycle?
  /** Match all layers, checking for caught errors
    to avoid having an exception in one layer disrupt other layers */
  _updateLayers(e, i) {
    const s = {};
    for (const u of e)
      s[u.id] ? Jt.warn(`Multiple old layers with same id ${u.id}`)() : s[u.id] = u;
    if (this._defaultShaderModulesChanged) {
      for (const u of e)
        u.setNeedsUpdate(), u.setChangeFlags({ extensionsChanged: !0 });
      this._defaultShaderModulesChanged = !1;
    }
    const o = [];
    this._updateSublayersRecursively(i, s, o), this._finalizeOldLayers(s);
    let l = !1;
    for (const u of o)
      if (u.hasUniformTransition()) {
        l = `Uniform transition in ${u}`;
        break;
      }
    this._needsUpdate = l, this.layers = o;
  }
  /* eslint-disable complexity,max-statements */
  // Note: adds generated layers to `generatedLayers` array parameter
  _updateSublayersRecursively(e, i, s) {
    for (const o of e) {
      o.context = this.context;
      const l = i[o.id];
      l === null && Jt.warn(`Multiple new layers with same id ${o.id}`)(), i[o.id] = null;
      let u = null;
      try {
        this._debug && l !== o && o.validateProps(), l ? (this._transferLayerState(l, o), this._updateLayer(o)) : this._initializeLayer(o), s.push(o), u = o.isComposite ? o.getSubLayers() : null;
      } catch (c) {
        this._handleError("matching", c, o);
      }
      u && this._updateSublayersRecursively(u, i, s);
    }
  }
  /* eslint-enable complexity,max-statements */
  // Finalize any old layers that were not matched
  _finalizeOldLayers(e) {
    for (const i in e) {
      const s = e[i];
      s && this._finalizeLayer(s);
    }
  }
  // / EXCEPTION SAFE LAYER ACCESS
  /** Safely initializes a single layer, calling layer methods */
  _initializeLayer(e) {
    try {
      e._initialize(), e.lifecycle = pc.INITIALIZED;
    } catch (i) {
      this._handleError("initialization", i, e);
    }
  }
  /** Transfer state from one layer to a newer version */
  _transferLayerState(e, i) {
    i._transferState(e), i.lifecycle = pc.MATCHED, i !== e && (e.lifecycle = pc.AWAITING_GC);
  }
  /** Safely updates a single layer, cleaning all flags */
  _updateLayer(e) {
    try {
      e._update();
    } catch (i) {
      this._handleError("update", i, e);
    }
  }
  /** Safely finalizes a single layer, removing all resources */
  _finalizeLayer(e) {
    this._needsRedraw = this._needsRedraw || `finalized ${e}`, e.lifecycle = pc.AWAITING_FINALIZATION;
    try {
      e._finalize(), e.lifecycle = pc.FINALIZED;
    } catch (i) {
      this._handleError("finalization", i, e);
    }
  }
}
function gn(t, e, i) {
  if (t === e)
    return !0;
  if (!i || !t || !e)
    return !1;
  if (Array.isArray(t)) {
    if (!Array.isArray(e) || t.length !== e.length)
      return !1;
    for (let s = 0; s < t.length; s++)
      if (!gn(t[s], e[s], i - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof t == "object" && typeof e == "object") {
    const s = Object.keys(t), o = Object.keys(e);
    if (s.length !== o.length)
      return !1;
    for (const l of s)
      if (!e.hasOwnProperty(l) || !gn(t[l], e[l], i - 1))
        return !1;
    return !0;
  }
  return !1;
}
class LD {
  constructor(e) {
    this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = e.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = e.eventManager, this._eventCallbacks = {
      onViewStateChange: e.onViewStateChange,
      onInteractionStateChange: e.onInteractionStateChange
    }, Object.seal(this), this.setProps(e);
  }
  /** Remove all resources and event listeners */
  finalize() {
    for (const e in this.controllers) {
      const i = this.controllers[e];
      i && i.finalize();
    }
    this.controllers = {};
  }
  /** Check if a redraw is needed */
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    const i = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), i;
  }
  /** Mark the manager as dirty. Will rebuild all viewports and update controllers. */
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e, this._needsRedraw = this._needsRedraw || e;
  }
  /** Checks each viewport for transition updates */
  updateViewStates() {
    for (const e in this.controllers) {
      const i = this.controllers[e];
      i && i.updateTransition();
    }
  }
  /** Get a set of viewports for a given width and height
   * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
   * @param rect (object, optional) - filter the viewports
   *   + not provided - return all viewports
   *   + {x, y} - only return viewports that contain this pixel
   *   + {x, y, width, height} - only return viewports that overlap with this rectangle
   */
  getViewports(e) {
    return e ? this._viewports.filter((i) => i.containsPixel(e)) : this._viewports;
  }
  /** Get a map of all views */
  getViews() {
    const e = {};
    return this.views.forEach((i) => {
      e[i.id] = i;
    }), e;
  }
  /** Resolves a viewId string to a View */
  getView(e) {
    return this.views.find((i) => i.id === e);
  }
  /** Returns the viewState for a specific viewId. Matches the viewState by
    1. view.viewStateId
    2. view.id
    3. root viewState
    then applies the view's filter if any */
  getViewState(e) {
    const i = typeof e == "string" ? this.getView(e) : e, s = i && this.viewState[i.getViewStateId()] || this.viewState;
    return i ? i.filterViewState(s) : s;
  }
  getViewport(e) {
    return this._viewportMap[e];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(e, i) {
    const s = this.getViewports(), o = { x: e[0], y: e[1] };
    for (let l = s.length - 1; l >= 0; --l) {
      const u = s[l];
      if (u.containsPixel(o)) {
        const c = e.slice();
        return c[0] -= u.x, c[1] -= u.y, u.unproject(c, i);
      }
    }
    return null;
  }
  /** Update the manager with new Deck props */
  setProps(e) {
    e.views && this._setViews(e.views), e.viewState && this._setViewState(e.viewState), ("width" in e || "height" in e) && this._setSize(e.width, e.height), this._isUpdating || this._update();
  }
  //
  // PRIVATE METHODS
  //
  _update() {
    this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1;
  }
  _setSize(e, i) {
    (e !== this.width || i !== this.height) && (this.width = e, this.height = i, this.setNeedsUpdate("Size changed"));
  }
  // Update the view descriptor list and set change flag if needed
  // Does not actually rebuild the `Viewport`s until `getViewports` is called
  _setViews(e) {
    e = Nc(e, Boolean), this._diffViews(e, this.views) && this.setNeedsUpdate("views changed"), this.views = e;
  }
  _setViewState(e) {
    e ? (!gn(e, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = e) : Jt.warn("missing `viewState` or `initialViewState`")();
  }
  _createController(e, i) {
    const s = i.type;
    return new s({
      timeline: this.timeline,
      eventManager: this._eventManager,
      // Set an internal callback that calls the prop callback if provided
      onViewStateChange: this._eventCallbacks.onViewStateChange,
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (l) => {
        var u;
        return (u = this.getView(e.id)) == null ? void 0 : u.makeViewport({
          viewState: l,
          width: this.width,
          height: this.height
        });
      }
    });
  }
  _updateController(e, i, s, o) {
    const l = e.controller;
    if (l && s) {
      const u = {
        ...i,
        ...l,
        id: e.id,
        x: s.x,
        y: s.y,
        width: s.width,
        height: s.height
      };
      return (!o || o.constructor !== l.type) && (o = this._createController(e, u)), o && o.setProps(u), o;
    }
    return null;
  }
  // Rebuilds viewports from descriptors towards a certain window size
  _rebuildViewports() {
    const { views: e } = this, i = this.controllers;
    this._viewports = [], this.controllers = {};
    let s = !1;
    for (let o = e.length; o--; ) {
      const l = e[o], u = this.getViewState(l), c = l.makeViewport({ viewState: u, width: this.width, height: this.height });
      let x = i[l.id];
      const w = !!l.controller;
      w && !x && (s = !0), (s || !w) && x && (x.finalize(), x = null), this.controllers[l.id] = this._updateController(l, u, c, x), c && this._viewports.unshift(c);
    }
    for (const o in i) {
      const l = i[o];
      l && !this.controllers[o] && l.finalize();
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {}, this._viewports.forEach((e) => {
      e.id && (this._viewportMap[e.id] = this._viewportMap[e.id] || e);
    });
  }
  // Check if viewport array has changed, returns true if any change
  // Note that descriptors can be the same
  _diffViews(e, i) {
    return e.length !== i.length ? !0 : e.some((s, o) => !e[o].equals(i[o]));
  }
}
const UD = /([0-9]+\.?[0-9]*)(%|px)/;
function ia(t) {
  switch (typeof t) {
    case "number":
      return {
        position: t,
        relative: !1
      };
    case "string":
      const e = UD.exec(t);
      if (e && e.length >= 3) {
        const i = e[2] === "%", s = parseFloat(e[1]);
        return {
          position: i ? s / 100 : s,
          relative: i
        };
      }
    default:
      throw new Error(`Could not parse position string ${t}`);
  }
}
function sa(t, e) {
  return t.relative ? Math.round(t.position * e) : t.position;
}
class zD {
  constructor(e) {
    const { id: i, x: s = 0, y: o = 0, width: l = "100%", height: u = "100%", padding: c = null } = e;
    this.id = i || this.constructor.displayName || "view", this.props = { ...e, id: this.id }, this._x = ia(s), this._y = ia(o), this._width = ia(l), this._height = ia(u), this._padding = c && {
      left: ia(c.left || 0),
      right: ia(c.right || 0),
      top: ia(c.top || 0),
      bottom: ia(c.bottom || 0)
    }, this.equals = this.equals.bind(this), Object.seal(this);
  }
  equals(e) {
    return this === e ? !0 : this.ViewportType === e.ViewportType && gn(this.props, e.props, 2);
  }
  /** Make viewport from canvas dimensions and view state */
  makeViewport({ width: e, height: i, viewState: s }) {
    s = this.filterViewState(s);
    const o = this.getDimensions({ width: e, height: i });
    return !o.height || !o.width ? null : new this.ViewportType({ ...s, ...this.props, ...o });
  }
  getViewStateId() {
    const { viewState: e } = this.props;
    return typeof e == "string" ? e : (e == null ? void 0 : e.id) || this.id;
  }
  // Allows view to override (or completely define) viewState
  filterViewState(e) {
    if (this.props.viewState && typeof this.props.viewState == "object") {
      if (!this.props.viewState.id)
        return this.props.viewState;
      const i = { ...e };
      for (const s in this.props.viewState)
        s !== "id" && (i[s] = this.props.viewState[s]);
      return i;
    }
    return e;
  }
  /** Resolve the dimensions of the view from overall canvas dimensions */
  getDimensions({ width: e, height: i }) {
    const s = {
      x: sa(this._x, e),
      y: sa(this._y, i),
      width: sa(this._width, e),
      height: sa(this._height, i)
    };
    return this._padding && (s.padding = {
      left: sa(this._padding.left, e),
      top: sa(this._padding.top, i),
      right: sa(this._padding.right, e),
      bottom: sa(this._padding.bottom, i)
    }), s;
  }
  // Used by sub classes to resolve controller props
  get controller() {
    const e = this.props.controller;
    return e ? e === !0 ? { type: this.ControllerType } : typeof e == "function" ? { type: e } : { type: this.ControllerType, ...e } : null;
  }
}
class gp {
  /**
   * @params timeline {Timeline}
   */
  constructor(e) {
    this._inProgress = !1, this._handle = null, this.time = 0, this.settings = {
      duration: 0
    }, this._timeline = e;
  }
  /* Public API */
  get inProgress() {
    return this._inProgress;
  }
  /**
   * (re)start this transition.
   * @params props {object} - optional overriding props. see constructor
   */
  start(e) {
    var i, s;
    this.cancel(), this.settings = e, this._inProgress = !0, (s = (i = this.settings).onStart) == null || s.call(i, this);
  }
  /**
   * end this transition if it is in progress.
   */
  end() {
    var e, i;
    this._inProgress && (this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1, (i = (e = this.settings).onEnd) == null || i.call(e, this));
  }
  /**
   * cancel this transition if it is in progress.
   */
  cancel() {
    var e, i;
    this._inProgress && ((i = (e = this.settings).onInterrupt) == null || i.call(e, this), this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1);
  }
  /**
   * update this transition. Returns `true` if updated.
   */
  update() {
    var e, i;
    if (!this._inProgress)
      return !1;
    if (this._handle === null) {
      const { _timeline: s, settings: o } = this;
      this._handle = s.addChannel({
        delay: s.getTime(),
        duration: o.duration
      });
    }
    return this.time = this._timeline.getTime(this._handle), this._onUpdate(), (i = (e = this.settings).onUpdate) == null || i.call(e, this), this._timeline.isFinished(this._handle) && this.end(), !0;
  }
  /* Private API */
  _onUpdate() {
  }
}
const Vv = () => {
}, bg = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
}, VD = (t) => t, HD = bg.BREAK;
class jD {
  constructor(e) {
    this._onTransitionUpdate = (i) => {
      const { time: s, settings: { interpolator: o, startProps: l, endProps: u, duration: c, easing: x } } = i, w = x(s / c), C = o.interpolateProps(l, u, w);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...C
      }).getViewportProps(), this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    }, this.getControllerState = e.getControllerState, this.propsInTransition = null, this.transition = new gp(e.timeline), this.onViewStateChange = e.onViewStateChange || Vv, this.onStateChange = e.onStateChange || Vv;
  }
  finalize() {
    this.transition.cancel();
  }
  // Returns current transitioned viewport.
  getViewportInTransition() {
    return this.propsInTransition;
  }
  // Process the vewiport change, either ignore or trigger a new transition.
  // Return true if a new transition is triggered, false otherwise.
  processViewStateChange(e) {
    let i = !1;
    const s = this.props;
    if (this.props = e, !s || this._shouldIgnoreViewportChange(s, e))
      return !1;
    if (this._isTransitionEnabled(e)) {
      let o = s;
      if (this.transition.inProgress) {
        const { interruption: l, endProps: u } = this.transition.settings;
        o = {
          ...s,
          ...l === bg.SNAP_TO_END ? u : this.propsInTransition || s
        };
      }
      this._triggerTransition(o, e), i = !0;
    } else
      this.transition.cancel();
    return i;
  }
  updateTransition() {
    this.transition.update();
  }
  // Helper methods
  _isTransitionEnabled(e) {
    const { transitionDuration: i, transitionInterpolator: s } = e;
    return (i > 0 || i === "auto") && !!s;
  }
  _isUpdateDueToCurrentTransition(e) {
    return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(e, this.propsInTransition) : !1;
  }
  _shouldIgnoreViewportChange(e, i) {
    return this.transition.inProgress ? this.transition.settings.interruption === bg.IGNORE || // Ignore update if it is due to current active transition.
    this._isUpdateDueToCurrentTransition(i) : this._isTransitionEnabled(i) ? i.transitionInterpolator.arePropsEqual(e, i) : !0;
  }
  _triggerTransition(e, i) {
    const s = this.getControllerState(e), o = this.getControllerState(i).shortestPathFrom(s), l = i.transitionInterpolator, u = l.getDuration ? l.getDuration(e, i) : i.transitionDuration;
    if (u === 0)
      return;
    const c = l.initializeProps(e, o);
    this.propsInTransition = {};
    const x = {
      duration: u,
      easing: i.transitionEasing || VD,
      interpolator: l,
      interruption: i.transitionInterruption || HD,
      startProps: c.start,
      endProps: c.end,
      onStart: i.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(i.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(i.onTransitionEnd)
    };
    this.transition.start(x), this.onStateChange({ inTransition: !0 }), this.updateTransition();
  }
  _onTransitionEnd(e) {
    return (i) => {
      this.propsInTransition = null, this.onStateChange({
        inTransition: !1,
        isZooming: !1,
        isPanning: !1,
        isRotating: !1
      }), e == null || e(i);
    };
  }
}
function hs(t, e) {
  if (!t)
    throw new Error(e || "deck.gl: assertion failed.");
}
class $D {
  /**
   * @param opts {array|object}
   * @param opts.compare {array} - prop names used in equality check
   * @param opts.extract {array} - prop names needed for interpolation
   * @param opts.required {array} - prop names that must be supplied
   * alternatively, supply one list of prop names as `opts` if all of the above are the same.
   */
  constructor(e) {
    const { compare: i, extract: s, required: o } = e;
    this._propsToCompare = i, this._propsToExtract = s || i, this._requiredProps = o;
  }
  /**
   * Checks if two sets of props need transition in between
   * @param currentProps {object} - a list of viewport props
   * @param nextProps {object} - a list of viewport props
   * @returns {bool} - true if two props are equivalent
   */
  arePropsEqual(e, i) {
    for (const s of this._propsToCompare)
      if (!(s in e) || !(s in i) || !bn(e[s], i[s]))
        return !1;
    return !0;
  }
  /**
   * Called before transition starts to validate/pre-process start and end props
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Object} {start, end} - start and end props to be passed
   *   to `interpolateProps`
   */
  initializeProps(e, i) {
    const s = {}, o = {};
    for (const l of this._propsToExtract)
      (l in e || l in i) && (s[l] = e[l], o[l] = i[l]);
    return this._checkRequiredProps(s), this._checkRequiredProps(o), { start: s, end: o };
  }
  /**
   * Returns transition duration
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Number} - transition duration in milliseconds
   */
  getDuration(e, i) {
    return i.transitionDuration;
  }
  _checkRequiredProps(e) {
    this._requiredProps && this._requiredProps.forEach((i) => {
      const s = e[i];
      hs(Number.isFinite(s) || Array.isArray(s), `${i} is required for transition`);
    });
  }
}
const GD = ["longitude", "latitude", "zoom", "bearing", "pitch"], XD = ["longitude", "latitude", "zoom"];
class xA extends $D {
  /**
   * @param {Object} opts
   * @param {Array} opts.transitionProps - list of props to apply linear transition to.
   * @param {Array} opts.around - a screen point to zoom/rotate around.
   * @param {Function} opts.makeViewport - construct a viewport instance with given props.
   */
  constructor(e = {}) {
    const i = Array.isArray(e) ? e : e.transitionProps, s = Array.isArray(e) ? {} : e;
    s.transitionProps = Array.isArray(i) ? {
      compare: i,
      required: i
    } : i || {
      compare: GD,
      required: XD
    }, super(s.transitionProps), this.opts = s;
  }
  initializeProps(e, i) {
    const s = super.initializeProps(e, i), { makeViewport: o, around: l } = this.opts;
    if (o && l) {
      const u = o(e), c = o(i), x = u.unproject(l);
      s.start.around = l, Object.assign(s.end, {
        around: c.project(x),
        aroundPosition: x,
        width: i.width,
        height: i.height
      });
    }
    return s;
  }
  interpolateProps(e, i, s) {
    const o = {};
    for (const l of this._propsToExtract)
      o[l] = zf(e[l] || 0, i[l] || 0, s);
    if (i.aroundPosition && this.opts.makeViewport) {
      const l = this.opts.makeViewport({ ...i, ...o });
      Object.assign(o, l.panByPosition(
        i.aroundPosition,
        // anchor point in current screen coordinates
        zf(e.around, i.around, s)
      ));
    }
    return o;
  }
}
const ra = {
  transitionDuration: 0
}, WD = 300, ef = (t) => 1 - (1 - t) * (1 - t), hc = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
  DOUBLE_TAP: ["doubletap"],
  KEYBOARD: ["keydown"]
}, Xa = {};
class qD {
  constructor(e) {
    this.state = {}, this._events = {}, this._interactionState = {
      isDragging: !1
    }, this._customEvents = [], this._eventStartBlocked = null, this._panMove = !1, this.invertPan = !1, this.dragMode = "rotate", this.inertia = 0, this.scrollZoom = !0, this.dragPan = !0, this.dragRotate = !0, this.doubleClickZoom = !0, this.touchZoom = !0, this.touchRotate = !1, this.keyboard = !0, this.transitionManager = new jD({
      ...e,
      getControllerState: (i) => new this.ControllerState(i),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = e.eventManager, this.onViewStateChange = e.onViewStateChange || (() => {
    }), this.onStateChange = e.onStateChange || (() => {
    }), this.makeViewport = e.makeViewport;
  }
  set events(e) {
    this.toggleEvents(this._customEvents, !1), this.toggleEvents(e, !0), this._customEvents = e, this.props && this.setProps(this.props);
  }
  finalize() {
    var e;
    for (const i in this._events)
      this._events[i] && ((e = this.eventManager) == null || e.off(i, this.handleEvent));
    this.transitionManager.finalize();
  }
  /**
   * Callback for events
   */
  handleEvent(e) {
    this._controllerState = void 0;
    const i = this._eventStartBlocked;
    switch (e.type) {
      case "panstart":
        return i ? !1 : this._onPanStart(e);
      case "panmove":
        return this._onPan(e);
      case "panend":
        return this._onPanEnd(e);
      case "pinchstart":
        return i ? !1 : this._onPinchStart(e);
      case "pinchmove":
        return this._onPinch(e);
      case "pinchend":
        return this._onPinchEnd(e);
      case "tripanstart":
        return i ? !1 : this._onTriplePanStart(e);
      case "tripanmove":
        return this._onTriplePan(e);
      case "tripanend":
        return this._onTriplePanEnd(e);
      case "doubletap":
        return this._onDoubleTap(e);
      case "wheel":
        return this._onWheel(e);
      case "keydown":
        return this._onKeyDown(e);
      default:
        return !1;
    }
  }
  /* Event utils */
  // Event object: http://hammerjs.github.io/api/#event-object
  get controllerState() {
    return this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    }), this._controllerState;
  }
  getCenter(e) {
    const { x: i, y: s } = this.props, { offsetCenter: o } = e;
    return [o.x - i, o.y - s];
  }
  isPointInBounds(e, i) {
    const { width: s, height: o } = this.props;
    if (i && i.handled)
      return !1;
    const l = e[0] >= 0 && e[0] <= s && e[1] >= 0 && e[1] <= o;
    return l && i && i.stopPropagation(), l;
  }
  isFunctionKeyPressed(e) {
    const { srcEvent: i } = e;
    return !!(i.metaKey || i.altKey || i.ctrlKey || i.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || !1;
  }
  // When a multi-touch event ends, e.g. pinch, not all pointers are lifted at the same time.
  // This triggers a brief `pan` event.
  // Calling this method will temporarily disable *start events to avoid conflicting transitions.
  blockEvents(e) {
    const i = setTimeout(() => {
      this._eventStartBlocked === i && (this._eventStartBlocked = null);
    }, e);
    this._eventStartBlocked = i;
  }
  /**
   * Extract interactivity options
   */
  setProps(e) {
    e.dragMode && (this.dragMode = e.dragMode), this.props = e, "transitionInterpolator" in e || (e.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(e);
    const { inertia: i } = e;
    this.inertia = Number.isFinite(i) ? i : i === !0 ? WD : 0;
    const { scrollZoom: s = !0, dragPan: o = !0, dragRotate: l = !0, doubleClickZoom: u = !0, touchZoom: c = !0, touchRotate: x = !1, keyboard: w = !0 } = e, C = !!this.onViewStateChange;
    this.toggleEvents(hc.WHEEL, C && s), this.toggleEvents(hc.PAN, C), this.toggleEvents(hc.PINCH, C && (c || x)), this.toggleEvents(hc.TRIPLE_PAN, C && x), this.toggleEvents(hc.DOUBLE_TAP, C && u), this.toggleEvents(hc.KEYBOARD, C && w), this.scrollZoom = s, this.dragPan = o, this.dragRotate = l, this.doubleClickZoom = u, this.touchZoom = c, this.touchRotate = x, this.keyboard = w;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(e, i) {
    this.eventManager && e.forEach((s) => {
      this._events[s] !== i && (this._events[s] = i, i ? this.eventManager.on(s, this.handleEvent) : this.eventManager.off(s, this.handleEvent));
    });
  }
  // Private Methods
  /* Callback util */
  // formats map state and invokes callback function
  updateViewport(e, i = null, s = {}) {
    const o = { ...e.getViewportProps(), ...i }, l = this.controllerState !== e;
    if (this.state = e.getState(), this._setInteractionState(s), l) {
      const u = this.controllerState && this.controllerState.getViewportProps();
      this.onViewStateChange && this.onViewStateChange({ viewState: o, interactionState: this._interactionState, oldViewState: u, viewId: this.props.id });
    }
  }
  _onTransition(e) {
    this.onViewStateChange({ ...e, interactionState: this._interactionState, viewId: this.props.id });
  }
  _setInteractionState(e) {
    Object.assign(this._interactionState, e), this.onStateChange(this._interactionState);
  }
  /* Event handlers */
  // Default handler for the `panstart` event.
  _onPanStart(e) {
    const i = this.getCenter(e);
    if (!this.isPointInBounds(i, e))
      return !1;
    let s = this.isFunctionKeyPressed(e) || e.rightButton || !1;
    (this.invertPan || this.dragMode === "pan") && (s = !s);
    const o = this.controllerState[s ? "panStart" : "rotateStart"]({
      pos: i
    });
    return this._panMove = s, this.updateViewport(o, ra, { isDragging: !0 }), !0;
  }
  // Default handler for the `panmove` and `panend` event.
  _onPan(e) {
    return this.isDragging() ? this._panMove ? this._onPanMove(e) : this._onPanRotate(e) : !1;
  }
  _onPanEnd(e) {
    return this.isDragging() ? this._panMove ? this._onPanMoveEnd(e) : this._onPanRotateEnd(e) : !1;
  }
  // Default handler for panning to move.
  // Called by `_onPan` when panning without function key pressed.
  _onPanMove(e) {
    if (!this.dragPan)
      return !1;
    const i = this.getCenter(e), s = this.controllerState.pan({ pos: i });
    return this.updateViewport(s, ra, {
      isDragging: !0,
      isPanning: !0
    }), !0;
  }
  _onPanMoveEnd(e) {
    const { inertia: i } = this;
    if (this.dragPan && i && e.velocity) {
      const s = this.getCenter(e), o = [
        s[0] + e.velocityX * i / 2,
        s[1] + e.velocityY * i / 2
      ], l = this.controllerState.pan({ pos: o }).panEnd();
      this.updateViewport(l, {
        ...this._getTransitionProps(),
        transitionDuration: i,
        transitionEasing: ef
      }, {
        isDragging: !1,
        isPanning: !0
      });
    } else {
      const s = this.controllerState.panEnd();
      this.updateViewport(s, null, {
        isDragging: !1,
        isPanning: !1
      });
    }
    return !0;
  }
  // Default handler for panning to rotate.
  // Called by `_onPan` when panning with function key pressed.
  _onPanRotate(e) {
    if (!this.dragRotate)
      return !1;
    const i = this.getCenter(e), s = this.controllerState.rotate({ pos: i });
    return this.updateViewport(s, ra, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onPanRotateEnd(e) {
    const { inertia: i } = this;
    if (this.dragRotate && i && e.velocity) {
      const s = this.getCenter(e), o = [
        s[0] + e.velocityX * i / 2,
        s[1] + e.velocityY * i / 2
      ], l = this.controllerState.rotate({ pos: o }).rotateEnd();
      this.updateViewport(l, {
        ...this._getTransitionProps(),
        transitionDuration: i,
        transitionEasing: ef
      }, {
        isDragging: !1,
        isRotating: !0
      });
    } else {
      const s = this.controllerState.rotateEnd();
      this.updateViewport(s, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `wheel` event.
  _onWheel(e) {
    if (!this.scrollZoom)
      return !1;
    const i = this.getCenter(e);
    if (!this.isPointInBounds(i, e))
      return !1;
    e.srcEvent.preventDefault();
    const { speed: s = 0.01, smooth: o = !1 } = this.scrollZoom === !0 ? {} : this.scrollZoom, { delta: l } = e;
    let u = 2 / (1 + Math.exp(-Math.abs(l * s)));
    l < 0 && u !== 0 && (u = 1 / u);
    const c = this.controllerState.zoom({ pos: i, scale: u });
    return this.updateViewport(c, { ...this._getTransitionProps({ around: i }), transitionDuration: o ? 250 : 1 }, {
      isZooming: !0,
      isPanning: !0
    }), !0;
  }
  _onTriplePanStart(e) {
    const i = this.getCenter(e);
    if (!this.isPointInBounds(i, e))
      return !1;
    const s = this.controllerState.rotateStart({ pos: i });
    return this.updateViewport(s, ra, { isDragging: !0 }), !0;
  }
  _onTriplePan(e) {
    if (!this.touchRotate || !this.isDragging())
      return !1;
    const i = this.getCenter(e);
    i[0] -= e.deltaX;
    const s = this.controllerState.rotate({ pos: i });
    return this.updateViewport(s, ra, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onTriplePanEnd(e) {
    if (!this.isDragging())
      return !1;
    const { inertia: i } = this;
    if (this.touchRotate && i && e.velocityY) {
      const s = this.getCenter(e), o = [s[0], s[1] += e.velocityY * i / 2], l = this.controllerState.rotate({ pos: o });
      this.updateViewport(l, {
        ...this._getTransitionProps(),
        transitionDuration: i,
        transitionEasing: ef
      }, {
        isDragging: !1,
        isRotating: !0
      }), this.blockEvents(i);
    } else {
      const s = this.controllerState.rotateEnd();
      this.updateViewport(s, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `pinchstart` event.
  _onPinchStart(e) {
    const i = this.getCenter(e);
    if (!this.isPointInBounds(i, e))
      return !1;
    const s = this.controllerState.zoomStart({ pos: i }).rotateStart({ pos: i });
    return Xa._startPinchRotation = e.rotation, Xa._lastPinchEvent = e, this.updateViewport(s, ra, { isDragging: !0 }), !0;
  }
  // Default handler for the `pinchmove` and `pinchend` events.
  _onPinch(e) {
    if (!this.touchZoom && !this.touchRotate || !this.isDragging())
      return !1;
    let i = this.controllerState;
    if (this.touchZoom) {
      const { scale: s } = e, o = this.getCenter(e);
      i = i.zoom({ pos: o, scale: s });
    }
    if (this.touchRotate) {
      const { rotation: s } = e;
      i = i.rotate({
        deltaAngleX: Xa._startPinchRotation - s
      });
    }
    return this.updateViewport(i, ra, {
      isDragging: !0,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    }), Xa._lastPinchEvent = e, !0;
  }
  _onPinchEnd(e) {
    if (!this.isDragging())
      return !1;
    const { inertia: i } = this, { _lastPinchEvent: s } = Xa;
    if (this.touchZoom && i && s && e.scale !== s.scale) {
      const o = this.getCenter(e);
      let l = this.controllerState.rotateEnd();
      const u = Math.log2(e.scale), c = (u - Math.log2(s.scale)) / (e.deltaTime - s.deltaTime), x = Math.pow(2, u + c * i / 2);
      l = l.zoom({ pos: o, scale: x }).zoomEnd(), this.updateViewport(l, {
        ...this._getTransitionProps({ around: o }),
        transitionDuration: i,
        transitionEasing: ef
      }, {
        isDragging: !1,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: !1
      }), this.blockEvents(i);
    } else {
      const o = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(o, null, {
        isDragging: !1,
        isPanning: !1,
        isZooming: !1,
        isRotating: !1
      });
    }
    return Xa._startPinchRotation = null, Xa._lastPinchEvent = null, !0;
  }
  // Default handler for the `doubletap` event.
  _onDoubleTap(e) {
    if (!this.doubleClickZoom)
      return !1;
    const i = this.getCenter(e);
    if (!this.isPointInBounds(i, e))
      return !1;
    const s = this.isFunctionKeyPressed(e), o = this.controllerState.zoom({ pos: i, scale: s ? 0.5 : 2 });
    return this.updateViewport(o, this._getTransitionProps({ around: i }), {
      isZooming: !0,
      isPanning: !0
    }), this.blockEvents(100), !0;
  }
  // Default handler for the `keydown` event
  _onKeyDown(e) {
    if (!this.keyboard)
      return !1;
    const i = this.isFunctionKeyPressed(e), { zoomSpeed: s, moveSpeed: o, rotateSpeedX: l, rotateSpeedY: u } = this.keyboard === !0 ? {} : this.keyboard, { controllerState: c } = this;
    let x;
    const w = {};
    switch (e.srcEvent.code) {
      case "Minus":
        x = i ? c.zoomOut(s).zoomOut(s) : c.zoomOut(s), w.isZooming = !0;
        break;
      case "Equal":
        x = i ? c.zoomIn(s).zoomIn(s) : c.zoomIn(s), w.isZooming = !0;
        break;
      case "ArrowLeft":
        i ? (x = c.rotateLeft(l), w.isRotating = !0) : (x = c.moveLeft(o), w.isPanning = !0);
        break;
      case "ArrowRight":
        i ? (x = c.rotateRight(l), w.isRotating = !0) : (x = c.moveRight(o), w.isPanning = !0);
        break;
      case "ArrowUp":
        i ? (x = c.rotateUp(u), w.isRotating = !0) : (x = c.moveUp(o), w.isPanning = !0);
        break;
      case "ArrowDown":
        i ? (x = c.rotateDown(u), w.isRotating = !0) : (x = c.moveDown(o), w.isPanning = !0);
        break;
      default:
        return !1;
    }
    return this.updateViewport(x, this._getTransitionProps(), w), !0;
  }
  _getTransitionProps(e) {
    const { transition: i } = this;
    return !i || !i.transitionInterpolator ? ra : e ? {
      ...i,
      transitionInterpolator: new xA({
        ...e,
        ...i.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : i;
  }
}
class ZD {
  constructor(e, i) {
    this._viewportProps = this.applyConstraints(e), this._state = i;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
}
const Hv = 5, KD = 1.2;
class JD extends ZD {
  constructor(e) {
    const {
      /** Mapbox viewport properties */
      /** The width of the viewport */
      width: i,
      /** The height of the viewport */
      height: s,
      /** The latitude at the center of the viewport */
      latitude: o,
      /** The longitude at the center of the viewport */
      longitude: l,
      /** The tile zoom level of the map. */
      zoom: u,
      /** The bearing of the viewport in degrees */
      bearing: c = 0,
      /** The pitch of the viewport in degrees */
      pitch: x = 0,
      /**
       * Specify the altitude of the viewport camera
       * Unit: map heights, default 1.5
       * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
       */
      altitude: w = 1.5,
      /** Viewport position */
      position: C = [0, 0, 0],
      /** Viewport constraints */
      maxZoom: M = 20,
      minZoom: P = 0,
      maxPitch: j = 60,
      minPitch: Y = 0,
      /** Interaction states, required to calculate change during transform */
      /* The point on map being grabbed when the operation first started */
      startPanLngLat: Q,
      /* Center of the zoom when the operation first started */
      startZoomLngLat: _e,
      /* Pointer position when rotation started */
      startRotatePos: me,
      /** Bearing when current perspective rotate operation started */
      startBearing: we,
      /** Pitch when current perspective rotate operation started */
      startPitch: Ee,
      /** Zoom when current zoom operation started */
      startZoom: Oe,
      /** Normalize viewport props to fit map height into viewport */
      normalize: Ne = !0
    } = e;
    hs(Number.isFinite(l)), hs(Number.isFinite(o)), hs(Number.isFinite(u)), super({
      width: i,
      height: s,
      latitude: o,
      longitude: l,
      zoom: u,
      bearing: c,
      pitch: x,
      altitude: w,
      maxZoom: M,
      minZoom: P,
      maxPitch: j,
      minPitch: Y,
      normalize: Ne,
      position: C
    }, {
      startPanLngLat: Q,
      startZoomLngLat: _e,
      startRotatePos: me,
      startBearing: we,
      startPitch: Ee,
      startZoom: Oe
    }), this.makeViewport = e.makeViewport;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart({ pos: e }) {
    return this._getUpdatedState({
      startPanLngLat: this._unproject(e)
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   * @param {[Number, Number], optional} startPos - where the pointer grabbed at
   *   the start of the operation. Must be supplied of `panStart()` was not called
   */
  pan({ pos: e, startPos: i }) {
    const s = this.getState().startPanLngLat || this._unproject(i);
    if (!s)
      return this;
    const l = this.makeViewport(this.getViewportProps()).panByPosition(s, e);
    return this._getUpdatedState(l);
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotateStart({ pos: e }) {
    return this._getUpdatedState({
      startRotatePos: e,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotate({ pos: e, deltaAngleX: i = 0, deltaAngleY: s = 0 }) {
    const { startRotatePos: o, startBearing: l, startPitch: u } = this.getState();
    if (!o || l === void 0 || u === void 0)
      return this;
    let c;
    return e ? c = this._getNewRotation(e, o, u, l) : c = {
      bearing: l + i,
      pitch: u + s
    }, this._getUpdatedState(c);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  zoomStart({ pos: e }) {
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(e),
      startZoom: this.getViewportProps().zoom
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current center is
   * @param {[Number, Number]} startPos - the center position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom({ pos: e, startPos: i, scale: s }) {
    let { startZoom: o, startZoomLngLat: l } = this.getState();
    if (l || (o = this.getViewportProps().zoom, l = this._unproject(i) || this._unproject(e)), !l)
      return this;
    const { maxZoom: u, minZoom: c } = this.getViewportProps();
    let x = o + Math.log2(s);
    x = bo(x, c, u);
    const w = this.makeViewport({ ...this.getViewportProps(), zoom: x });
    return this._getUpdatedState({
      zoom: x,
      ...w.panByPosition(l, e)
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn(e = 2) {
    return this._zoomFromCenter(e);
  }
  zoomOut(e = 2) {
    return this._zoomFromCenter(1 / e);
  }
  moveLeft(e = 100) {
    return this._panFromCenter([e, 0]);
  }
  moveRight(e = 100) {
    return this._panFromCenter([-e, 0]);
  }
  moveUp(e = 100) {
    return this._panFromCenter([0, e]);
  }
  moveDown(e = 100) {
    return this._panFromCenter([0, -e]);
  }
  rotateLeft(e = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - e
    });
  }
  rotateRight(e = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + e
    });
  }
  rotateUp(e = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + e
    });
  }
  rotateDown(e = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - e
    });
  }
  shortestPathFrom(e) {
    const i = e.getViewportProps(), s = { ...this.getViewportProps() }, { bearing: o, longitude: l } = s;
    return Math.abs(o - i.bearing) > 180 && (s.bearing = o < 0 ? o + 360 : o - 360), Math.abs(l - i.longitude) > 180 && (s.longitude = l < 0 ? l + 360 : l - 360), s;
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(e) {
    const { maxZoom: i, minZoom: s, zoom: o } = e;
    e.zoom = bo(o, s, i);
    const { maxPitch: l, minPitch: u, pitch: c } = e;
    e.pitch = bo(c, u, l);
    const { normalize: x = !0 } = e;
    return x && Object.assign(e, BB(e)), e;
  }
  /* Private methods */
  _zoomFromCenter(e) {
    const { width: i, height: s } = this.getViewportProps();
    return this.zoom({
      pos: [i / 2, s / 2],
      scale: e
    });
  }
  _panFromCenter(e) {
    const { width: i, height: s } = this.getViewportProps();
    return this.pan({
      startPos: [i / 2, s / 2],
      pos: [i / 2 + e[0], s / 2 + e[1]]
    });
  }
  _getUpdatedState(e) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...e
    });
  }
  _unproject(e) {
    const i = this.makeViewport(this.getViewportProps());
    return e && i.unproject(e);
  }
  _getNewRotation(e, i, s, o) {
    const l = e[0] - i[0], u = e[1] - i[1], c = e[1], x = i[1], { width: w, height: C } = this.getViewportProps(), M = l / w;
    let P = 0;
    u > 0 ? Math.abs(C - x) > Hv && (P = u / (x - C) * KD) : u < 0 && x > Hv && (P = 1 - c / x), P = bo(P, -1, 1);
    const { minPitch: j, maxPitch: Y } = this.getViewportProps(), Q = o + 180 * M;
    let _e = s;
    return P > 0 ? _e = s + P * (Y - s) : P < 0 && (_e = s - P * (j - s)), {
      pitch: _e,
      bearing: Q
    };
  }
}
class YD extends qD {
  constructor() {
    super(...arguments), this.ControllerState = JD, this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new xA({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    }, this.dragMode = "pan";
  }
  setProps(e) {
    e.position = e.position || [0, 0, 0];
    const i = this.props;
    super.setProps(e), (!i || i.height !== e.height) && this.updateViewport(new this.ControllerState({
      makeViewport: this.makeViewport,
      ...e,
      ...this.state
    }));
  }
}
class by extends zD {
  constructor(e = {}) {
    super(e);
  }
  get ViewportType() {
    return ol;
  }
  get ControllerType() {
    return YD;
  }
}
by.displayName = "MapView";
const QD = new mA();
function eO(t, e) {
  const i = t.order ?? 1 / 0, s = e.order ?? 1 / 0;
  return i - s;
}
class tO {
  constructor(e) {
    this._resolvedEffects = [], this._defaultEffects = [], this.effects = [], this._context = e, this._needsRedraw = "Initial render", this._setEffects([]);
  }
  /**
   * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects
   */
  addDefaultEffect(e) {
    const i = this._defaultEffects;
    if (!i.find((s) => s.id === e.id)) {
      const s = i.findIndex((o) => eO(o, e) > 0);
      s < 0 ? i.push(e) : i.splice(s, 0, e), e.setup(this._context), this._setEffects(this.effects);
    }
  }
  setProps(e) {
    "effects" in e && (gn(e.effects, this.effects, 1) || this._setEffects(e.effects));
  }
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    const i = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), i;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(e) {
    const i = {};
    for (const o of this.effects)
      i[o.id] = o;
    const s = [];
    for (const o of e) {
      const l = i[o.id];
      let u = o;
      l && l !== o ? l.setProps ? (l.setProps(o.props), u = l) : l.cleanup(this._context) : l || o.setup(this._context), s.push(u), delete i[o.id];
    }
    for (const o in i)
      i[o].cleanup(this._context);
    this.effects = s, this._resolvedEffects = s.concat(this._defaultEffects), e.some((o) => o instanceof mA) || this._resolvedEffects.push(QD), this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const e of this._resolvedEffects)
      e.cleanup(this._context);
    this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0;
  }
}
class iO extends yy {
  shouldDrawLayer(e) {
    const { operation: i } = e.props;
    return i.includes("draw") || i.includes("terrain");
  }
}
const sO = "deckRenderer.renderLayers";
class rO {
  constructor(e) {
    this.device = e, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new iO(e), this.pickLayersPass = new bA(e), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null;
  }
  setProps(e) {
    this.layerFilter !== e.layerFilter && (this.layerFilter = e.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== e.drawPickingColors && (this.drawPickingColors = e.drawPickingColors, this._needsRedraw = "drawPickingColors changed");
  }
  renderLayers(e) {
    if (!e.viewports.length)
      return;
    const i = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass, s = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...e
    };
    s.effects && this._preRender(s.effects, s);
    const o = this.lastPostProcessEffect ? this.renderBuffers[0] : s.target;
    this.lastPostProcessEffect && (s.clearColor = [0, 0, 0, 0], s.clearCanvas = !0);
    const l = i.render({ ...s, target: o });
    s.effects && this._postRender(s.effects, s), this.renderCount++, qs(sO, this, l, e);
  }
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    const i = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), i;
  }
  finalize() {
    const { renderBuffers: e } = this;
    for (const i of e)
      i.delete();
    e.length = 0;
  }
  _preRender(e, i) {
    this.lastPostProcessEffect = null, i.preRenderStats = i.preRenderStats || {};
    for (const s of e)
      i.preRenderStats[s.id] = s.preRender(i), s.postRender && (this.lastPostProcessEffect = s.id);
    this.lastPostProcessEffect && this._resizeRenderBuffers();
  }
  _resizeRenderBuffers() {
    const { renderBuffers: e } = this, i = this.device.canvasContext.getDrawingBufferSize();
    e.length === 0 && [0, 1].map((s) => {
      const o = this.device.createTexture({
        sampler: { minFilter: "linear", magFilter: "linear" }
      });
      e.push(this.device.createFramebuffer({
        id: `deck-renderbuffer-${s}`,
        colorAttachments: [o]
      }));
    });
    for (const s of e)
      s.resize(i);
  }
  _postRender(e, i) {
    const { renderBuffers: s } = this, o = {
      ...i,
      inputBuffer: s[0],
      swapBuffer: s[1]
    };
    for (const l of e)
      if (l.postRender) {
        o.target = l.id === this.lastPostProcessEffect ? i.target : void 0;
        const u = l.postRender(o);
        o.inputBuffer = u, o.swapBuffer = u === s[0] ? s[1] : s[0];
      }
  }
}
const nO = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function oO({ pickedColors: t, decodePickingColor: e, deviceX: i, deviceY: s, deviceRadius: o, deviceRect: l }) {
  const { x: u, y: c, width: x, height: w } = l;
  let C = o * o, M = -1, P = 0;
  for (let j = 0; j < w; j++) {
    const Y = j + c - s, Q = Y * Y;
    if (Q > C)
      P += 4 * x;
    else
      for (let _e = 0; _e < x; _e++) {
        if (t[P + 3] - 1 >= 0) {
          const we = _e + u - i, Ee = we * we + Q;
          Ee <= C && (C = Ee, M = P);
        }
        P += 4;
      }
  }
  if (M >= 0) {
    const j = t.slice(M, M + 4), Y = e(j);
    if (Y) {
      const Q = Math.floor(M / 4 / x), _e = M / 4 - Q * x;
      return {
        ...Y,
        pickedColor: j,
        pickedX: u + _e,
        pickedY: c + Q
      };
    }
    Jt.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return nO;
}
function aO({ pickedColors: t, decodePickingColor: e }) {
  const i = /* @__PURE__ */ new Map();
  if (t) {
    for (let s = 0; s < t.length; s += 4)
      if (t[s + 3] - 1 >= 0) {
        const l = t.slice(s, s + 4), u = l.join(",");
        if (!i.has(u)) {
          const c = e(l);
          c ? i.set(u, {
            ...c,
            color: l
          }) : Jt.error("Picked non-existent layer. Is picking buffer corrupt?")();
        }
      }
  }
  return Array.from(i.values());
}
function wA({ pickInfo: t, viewports: e, pixelRatio: i, x: s, y: o, z: l }) {
  let u = e[0];
  e.length > 1 && (u = cO((t == null ? void 0 : t.pickedViewports) || e, { x: s, y: o }));
  let c;
  if (u) {
    const x = [s - u.x, o - u.y];
    l !== void 0 && (x[2] = l), c = u.unproject(x);
  }
  return {
    color: null,
    layer: null,
    viewport: u,
    index: -1,
    picked: !1,
    x: s,
    y: o,
    pixel: [s, o],
    coordinate: c,
    devicePixel: t && "pickedX" in t ? [t.pickedX, t.pickedY] : void 0,
    pixelRatio: i
  };
}
function lO(t) {
  const { pickInfo: e, lastPickedInfo: i, mode: s, layers: o } = t, { pickedColor: l, pickedLayer: u, pickedObjectIndex: c } = e, x = u ? [u] : [];
  if (s === "hover") {
    const M = i.index, P = i.layerId, j = u ? u.props.id : null;
    if (j !== P || c !== M) {
      if (j !== P) {
        const Y = o.find((Q) => Q.props.id === P);
        Y && x.unshift(Y);
      }
      i.layerId = j, i.index = c, i.info = null;
    }
  }
  const w = wA(t), C = /* @__PURE__ */ new Map();
  return C.set(null, w), x.forEach((M) => {
    let P = { ...w };
    M === u && (P.color = l, P.index = c, P.picked = !0), P = AA({ layer: M, info: P, mode: s });
    const j = P.layer;
    M === u && s === "hover" && (i.info = P), C.set(j.id, P), s === "hover" && j.updateAutoHighlight(P);
  }), C;
}
function AA({ layer: t, info: e, mode: i }) {
  for (; t && e; ) {
    const s = e.layer || null;
    e.sourceLayer = s, e.layer = t, e = t.getPickingInfo({ info: e, mode: i, sourceLayer: s }), t = t.parent;
  }
  return e;
}
function cO(t, e) {
  for (let i = t.length - 1; i >= 0; i--) {
    const s = t[i];
    if (s.containsPixel(e))
      return s;
  }
  return t[0];
}
class hO {
  constructor(e) {
    this._pickable = !0, this.device = e, this.pickLayersPass = new bA(e), this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(e) {
    "layerFilter" in e && (this.layerFilter = e.layerFilter), "_pickable" in e && (this._pickable = e._pickable);
  }
  finalize() {
    this.pickingFBO && this.pickingFBO.destroy(), this.depthFBO && this.depthFBO.destroy();
  }
  /** Pick the closest info at given coordinate */
  pickObject(e) {
    return this._pickClosestObject(e);
  }
  /** Get all unique infos within a bounding box */
  pickObjects(e) {
    return this._pickVisibleObjects(e);
  }
  // Returns a new picking info object by assuming the last picked object is still picked
  getLastPickedObject({ x: e, y: i, layers: s, viewports: o }, l = this.lastPickedInfo.info) {
    const u = l && l.layer && l.layer.id, c = l && l.viewport && l.viewport.id, x = u ? s.find((P) => P.id === u) : null, w = c && o.find((P) => P.id === c) || o[0], C = w && w.unproject([e - w.x, i - w.y]);
    return { ...l, ...{
      x: e,
      y: i,
      viewport: w,
      coordinate: C,
      layer: x
    } };
  }
  // Private
  /** Ensures that picking framebuffer exists and matches the canvas size */
  _resizeBuffer() {
    var i, s;
    if (!this.pickingFBO && (this.pickingFBO = this.device.createFramebuffer({
      colorAttachments: ["rgba8unorm"],
      depthStencilAttachment: "depth16unorm"
    }), this.device.isTextureFormatRenderable("rgba32float"))) {
      const o = this.device.createFramebuffer({
        colorAttachments: ["rgba32float"],
        depthStencilAttachment: "depth16unorm"
      });
      this.depthFBO = o;
    }
    const { canvas: e } = this.device.getCanvasContext();
    (i = this.pickingFBO) == null || i.resize({ width: e.width, height: e.height }), (s = this.depthFBO) == null || s.resize({ width: e.width, height: e.height });
  }
  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */
  _getPickable(e) {
    if (this._pickable === !1)
      return null;
    const i = e.filter((s) => this.pickLayersPass.shouldDrawLayer(s) && !s.isComposite);
    return i.length ? i : null;
  }
  /** Pick the closest object at the given coordinate */
  // eslint-disable-next-line max-statements,complexity
  _pickClosestObject({ layers: e, views: i, viewports: s, x: o, y: l, radius: u = 0, depth: c = 1, mode: x = "query", unproject3D: w, onViewportActive: C, effects: M }) {
    const P = this.device.canvasContext.cssToDeviceRatio(), j = this._getPickable(e);
    if (!j || s.length === 0)
      return {
        result: [],
        emptyInfo: wA({ viewports: s, x: o, y: l, pixelRatio: P })
      };
    this._resizeBuffer();
    const Y = this.device.canvasContext.cssToDevicePixels([o, l], !0), Q = [
      Y.x + Math.floor(Y.width / 2),
      Y.y + Math.floor(Y.height / 2)
    ], _e = Math.round(u * P), { width: me, height: we } = this.pickingFBO, Ee = this._getPickingRect({
      deviceX: Q[0],
      deviceY: Q[1],
      deviceRadius: _e,
      deviceWidth: me,
      deviceHeight: we
    }), Oe = {
      x: o - u,
      y: l - u,
      width: u * 2 + 1,
      height: u * 2 + 1
    };
    let Ne;
    const ze = [], nt = /* @__PURE__ */ new Set();
    for (let mt = 0; mt < c; mt++) {
      let We;
      if (Ee) {
        const it = this._drawAndSample({
          layers: j,
          views: i,
          viewports: s,
          onViewportActive: C,
          deviceRect: Ee,
          cullRect: Oe,
          effects: M,
          pass: `picking:${x}`
        });
        We = oO({
          ...it,
          deviceX: Q[0],
          deviceY: Q[1],
          deviceRadius: _e,
          deviceRect: Ee
        });
      } else
        We = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      let at;
      if (We.pickedLayer && w && this.depthFBO) {
        const { pickedColors: it } = this._drawAndSample({
          layers: [We.pickedLayer],
          views: i,
          viewports: s,
          onViewportActive: C,
          deviceRect: {
            x: We.pickedX,
            y: We.pickedY,
            width: 1,
            height: 1
          },
          cullRect: Oe,
          effects: M,
          pass: `picking:${x}:z`
        }, !0);
        it[3] && (at = it[0]);
      }
      We.pickedLayer && mt + 1 < c && (nt.add(We.pickedLayer), We.pickedLayer.disablePickingIndex(We.pickedObjectIndex)), Ne = lO({
        pickInfo: We,
        lastPickedInfo: this.lastPickedInfo,
        mode: x,
        layers: j,
        viewports: s,
        x: o,
        y: l,
        z: at,
        pixelRatio: P
      });
      for (const it of Ne.values())
        it.layer && ze.push(it);
      if (!We.pickedColor)
        break;
    }
    for (const mt of nt)
      mt.restorePickingColors();
    return { result: ze, emptyInfo: Ne.get(null) };
  }
  /** Pick all objects within the given bounding box */
  _pickVisibleObjects({ layers: e, views: i, viewports: s, x: o, y: l, width: u = 1, height: c = 1, mode: x = "query", maxObjects: w = null, onViewportActive: C, effects: M }) {
    const P = this._getPickable(e);
    if (!P || s.length === 0)
      return [];
    this._resizeBuffer();
    const j = this.device.canvasContext.cssToDeviceRatio(), Y = this.device.canvasContext.cssToDevicePixels([o, l], !0), Q = Y.x, _e = Y.y + Y.height, me = this.device.canvasContext.cssToDevicePixels([o + u, l + c], !0), we = me.x + me.width, Ee = me.y, Oe = {
      x: Q,
      y: Ee,
      // deviceTop and deviceRight represent the first pixel outside the desired rect
      width: we - Q,
      height: _e - Ee
    }, Ne = this._drawAndSample({
      layers: P,
      views: i,
      viewports: s,
      onViewportActive: C,
      deviceRect: Oe,
      cullRect: { x: o, y: l, width: u, height: c },
      effects: M,
      pass: `picking:${x}`
    }), ze = aO(Ne), nt = /* @__PURE__ */ new Map(), mt = [], We = Number.isFinite(w);
    for (let at = 0; at < ze.length && !(We && mt.length >= w); at++) {
      const it = ze[at];
      let Ut = {
        color: it.pickedColor,
        layer: null,
        index: it.pickedObjectIndex,
        picked: !0,
        x: o,
        y: l,
        pixelRatio: j
      };
      Ut = AA({ layer: it.pickedLayer, info: Ut, mode: x });
      const Rt = Ut.layer.id;
      nt.has(Rt) || nt.set(Rt, /* @__PURE__ */ new Set());
      const yt = nt.get(Rt), di = Ut.object ?? Ut.index;
      yt.has(di) || (yt.add(di), mt.push(Ut));
    }
    return mt;
  }
  _drawAndSample({ layers: e, views: i, viewports: s, onViewportActive: o, deviceRect: l, cullRect: u, effects: c, pass: x }, w = !1) {
    const C = w ? this.depthFBO : this.pickingFBO, M = {
      layers: e,
      layerFilter: this.layerFilter,
      views: i,
      viewports: s,
      onViewportActive: o,
      pickingFBO: C,
      deviceRect: l,
      cullRect: u,
      effects: c,
      pass: x,
      pickZ: w,
      preRenderStats: {}
    };
    for (const we of c)
      we.useInPicking && (M.preRenderStats[we.id] = we.preRender(M));
    const { decodePickingColor: P } = this.pickLayersPass.render(M), { x: j, y: Y, width: Q, height: _e } = l, me = new (w ? Float32Array : Uint8Array)(Q * _e * 4);
    return this.device.readPixelsToArrayWebGL(C, {
      sourceX: j,
      sourceY: Y,
      sourceWidth: Q,
      sourceHeight: _e,
      target: me
    }), { pickedColors: me, decodePickingColor: P };
  }
  // Calculate a picking rect centered on deviceX and deviceY and clipped to device
  // Returns null if pixel is outside of device
  _getPickingRect({ deviceX: e, deviceY: i, deviceRadius: s, deviceWidth: o, deviceHeight: l }) {
    const u = Math.max(0, e - s), c = Math.max(0, i - s), x = Math.min(o, e + s + 1) - u, w = Math.min(l, i + s + 1) - c;
    return x <= 0 || w <= 0 ? null : { x: u, y: c, width: x, height: w };
  }
}
const uO = {
  "top-left": { top: 0, left: 0 },
  "top-right": { top: 0, right: 0 },
  "bottom-left": { bottom: 0, left: 0 },
  "bottom-right": { bottom: 0, right: 0 },
  fill: { top: 0, left: 0, bottom: 0, right: 0 }
}, dO = "top-left", jv = "__root";
class fO {
  constructor({ deck: e, parentElement: i }) {
    this.defaultWidgets = [], this.widgets = [], this.resolvedWidgets = [], this.containers = {}, this.lastViewports = {}, this.deck = e, this.parentElement = i;
  }
  getWidgets() {
    return this.resolvedWidgets;
  }
  /** Declarative API to configure widgets */
  setProps(e) {
    e.widgets && !gn(e.widgets, this.widgets, 1) && this._setWidgets(e.widgets);
  }
  finalize() {
    for (const e of this.getWidgets())
      this._remove(e);
    this.defaultWidgets.length = 0, this.resolvedWidgets.length = 0;
    for (const e in this.containers)
      this.containers[e].remove();
  }
  /** Imperative API. Widgets added this way are not affected by the declarative prop. */
  addDefault(e) {
    this.defaultWidgets.find((i) => i.id === e.id) || (this._add(e), this.defaultWidgets.push(e), this._setWidgets(this.widgets));
  }
  /** Resolve widgets from the declarative prop */
  _setWidgets(e) {
    const i = {};
    for (const s of this.resolvedWidgets)
      i[s.id] = s;
    this.resolvedWidgets.length = 0;
    for (const s of this.defaultWidgets)
      i[s.id] = null, this.resolvedWidgets.push(s);
    for (let s of e) {
      const o = i[s.id];
      o ? /* Widget placement changed */ o.viewId !== s.viewId || o.placement !== s.placement ? (this._remove(o), this._add(s)) : s !== o && (o.setProps(s.props), s = o) : this._add(s), i[s.id] = null, this.resolvedWidgets.push(s);
    }
    for (const s in i) {
      const o = i[s];
      o && this._remove(o);
    }
    this.widgets = e;
  }
  _add(e) {
    const { viewId: i = null, placement: s = dO } = e, o = e.onAdd({ deck: this.deck, viewId: i });
    o && this._getContainer(i, s).append(o), e._element = o;
  }
  _remove(e) {
    e.onRemove(), e._element && e._element.remove(), e._element = void 0;
  }
  /* global document */
  _getContainer(e, i) {
    var u;
    const s = e || jv;
    let o = this.containers[s];
    o || (o = document.createElement("div"), o.style.pointerEvents = "none", o.style.position = "absolute", o.style.overflow = "hidden", (u = this.parentElement) == null || u.append(o), this.containers[s] = o);
    let l = o.querySelector(`.${i}`);
    return l || (l = document.createElement("div"), l.className = i, l.style.position = "absolute", l.style.zIndex = "2", Object.assign(l.style, uO[i]), o.append(l)), l;
  }
  _updateContainers() {
    const e = this.deck.width, i = this.deck.height;
    for (const s in this.containers) {
      const o = this.lastViewports[s] || null, l = s === jv || o, u = this.containers[s];
      l ? (u.style.display = "block", u.style.left = `${o ? o.x : 0}px`, u.style.top = `${o ? o.y : 0}px`, u.style.width = `${o ? o.width : e}px`, u.style.height = `${o ? o.height : i}px`) : u.style.display = "none";
    }
  }
  onRedraw({ viewports: e, layers: i }) {
    var l, u;
    const s = e.reduce((c, x) => (c[x.id] = x, c), {}), { lastViewports: o } = this;
    for (const c of this.getWidgets()) {
      const { viewId: x } = c;
      if (x) {
        const w = s[x];
        w && (c.onViewportChange && !w.equals(o[x]) && c.onViewportChange(w), (l = c.onRedraw) == null || l.call(c, { viewports: [w], layers: i }));
      } else {
        if (c.onViewportChange)
          for (const w of e)
            w.equals(o[w.id]) || c.onViewportChange(w);
        (u = c.onRedraw) == null || u.call(c, { viewports: e, layers: i });
      }
    }
    this.lastViewports = s, this._updateContainers();
  }
  onHover(e, i) {
    var s, o;
    for (const l of this.getWidgets()) {
      const { viewId: u } = l;
      (!u || u === ((s = e.viewport) == null ? void 0 : s.id)) && ((o = l.onHover) == null || o.call(l, e, i));
    }
  }
  onEvent(e, i) {
    var o, l;
    const s = dg[i.type];
    if (s)
      for (const u of this.getWidgets()) {
        const { viewId: c } = u;
        (!c || c === ((o = e.viewport) == null ? void 0 : o.id)) && ((l = u[s.handler]) == null || l.call(u, e, i));
      }
  }
}
const pO = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
class _O {
  constructor() {
    this.id = "default-tooltip", this.placement = "fill", this.props = {}, this.isVisible = !1;
  }
  onAdd({ deck: e }) {
    const i = document.createElement("div");
    return i.className = "deck-tooltip", Object.assign(i.style, pO), this.deck = e, this.element = i, i;
  }
  onRemove() {
    this.deck = void 0, this.element = void 0;
  }
  setProps() {
  }
  onViewportChange(e) {
    var i;
    this.isVisible && e.id === ((i = this.lastViewport) == null ? void 0 : i.id) && e !== this.lastViewport && this.setTooltip(null);
  }
  onHover(e) {
    const { deck: i } = this, s = i && i.props.getTooltip;
    if (!s)
      return;
    const o = s(e);
    this.lastViewport = e.viewport, this.setTooltip(o, e.x, e.y);
  }
  setTooltip(e, i, s) {
    const o = this.element;
    if (o) {
      if (typeof e == "string")
        o.innerText = e;
      else if (e)
        e.text && (o.innerText = e.text), e.html && (o.innerHTML = e.html), e.className && (o.className = e.className);
      else {
        this.isVisible = !1, o.style.display = "none";
        return;
      }
      this.isVisible = !0, o.style.display = "block", o.style.transform = `translate(${i}px, ${s}px)`, e && typeof e == "object" && "style" in e && Object.assign(o.style, e.style);
    }
  }
}
var gc;
(function(t) {
  t[t.DEPTH_BUFFER_BIT = 256] = "DEPTH_BUFFER_BIT", t[t.STENCIL_BUFFER_BIT = 1024] = "STENCIL_BUFFER_BIT", t[t.COLOR_BUFFER_BIT = 16384] = "COLOR_BUFFER_BIT", t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", t[t.ZERO = 0] = "ZERO", t[t.ONE = 1] = "ONE", t[t.SRC_COLOR = 768] = "SRC_COLOR", t[t.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", t[t.SRC_ALPHA = 770] = "SRC_ALPHA", t[t.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", t[t.DST_ALPHA = 772] = "DST_ALPHA", t[t.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", t[t.DST_COLOR = 774] = "DST_COLOR", t[t.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", t[t.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", t[t.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", t[t.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", t[t.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", t[t.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", t[t.FUNC_ADD = 32774] = "FUNC_ADD", t[t.FUNC_SUBTRACT = 32778] = "FUNC_SUBTRACT", t[t.FUNC_REVERSE_SUBTRACT = 32779] = "FUNC_REVERSE_SUBTRACT", t[t.BLEND_EQUATION = 32777] = "BLEND_EQUATION", t[t.BLEND_EQUATION_RGB = 32777] = "BLEND_EQUATION_RGB", t[t.BLEND_EQUATION_ALPHA = 34877] = "BLEND_EQUATION_ALPHA", t[t.BLEND_DST_RGB = 32968] = "BLEND_DST_RGB", t[t.BLEND_SRC_RGB = 32969] = "BLEND_SRC_RGB", t[t.BLEND_DST_ALPHA = 32970] = "BLEND_DST_ALPHA", t[t.BLEND_SRC_ALPHA = 32971] = "BLEND_SRC_ALPHA", t[t.BLEND_COLOR = 32773] = "BLEND_COLOR", t[t.ARRAY_BUFFER_BINDING = 34964] = "ARRAY_BUFFER_BINDING", t[t.ELEMENT_ARRAY_BUFFER_BINDING = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING", t[t.LINE_WIDTH = 2849] = "LINE_WIDTH", t[t.ALIASED_POINT_SIZE_RANGE = 33901] = "ALIASED_POINT_SIZE_RANGE", t[t.ALIASED_LINE_WIDTH_RANGE = 33902] = "ALIASED_LINE_WIDTH_RANGE", t[t.CULL_FACE_MODE = 2885] = "CULL_FACE_MODE", t[t.FRONT_FACE = 2886] = "FRONT_FACE", t[t.DEPTH_RANGE = 2928] = "DEPTH_RANGE", t[t.DEPTH_WRITEMASK = 2930] = "DEPTH_WRITEMASK", t[t.DEPTH_CLEAR_VALUE = 2931] = "DEPTH_CLEAR_VALUE", t[t.DEPTH_FUNC = 2932] = "DEPTH_FUNC", t[t.STENCIL_CLEAR_VALUE = 2961] = "STENCIL_CLEAR_VALUE", t[t.STENCIL_FUNC = 2962] = "STENCIL_FUNC", t[t.STENCIL_FAIL = 2964] = "STENCIL_FAIL", t[t.STENCIL_PASS_DEPTH_FAIL = 2965] = "STENCIL_PASS_DEPTH_FAIL", t[t.STENCIL_PASS_DEPTH_PASS = 2966] = "STENCIL_PASS_DEPTH_PASS", t[t.STENCIL_REF = 2967] = "STENCIL_REF", t[t.STENCIL_VALUE_MASK = 2963] = "STENCIL_VALUE_MASK", t[t.STENCIL_WRITEMASK = 2968] = "STENCIL_WRITEMASK", t[t.STENCIL_BACK_FUNC = 34816] = "STENCIL_BACK_FUNC", t[t.STENCIL_BACK_FAIL = 34817] = "STENCIL_BACK_FAIL", t[t.STENCIL_BACK_PASS_DEPTH_FAIL = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL", t[t.STENCIL_BACK_PASS_DEPTH_PASS = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS", t[t.STENCIL_BACK_REF = 36003] = "STENCIL_BACK_REF", t[t.STENCIL_BACK_VALUE_MASK = 36004] = "STENCIL_BACK_VALUE_MASK", t[t.STENCIL_BACK_WRITEMASK = 36005] = "STENCIL_BACK_WRITEMASK", t[t.VIEWPORT = 2978] = "VIEWPORT", t[t.SCISSOR_BOX = 3088] = "SCISSOR_BOX", t[t.COLOR_CLEAR_VALUE = 3106] = "COLOR_CLEAR_VALUE", t[t.COLOR_WRITEMASK = 3107] = "COLOR_WRITEMASK", t[t.UNPACK_ALIGNMENT = 3317] = "UNPACK_ALIGNMENT", t[t.PACK_ALIGNMENT = 3333] = "PACK_ALIGNMENT", t[t.MAX_TEXTURE_SIZE = 3379] = "MAX_TEXTURE_SIZE", t[t.MAX_VIEWPORT_DIMS = 3386] = "MAX_VIEWPORT_DIMS", t[t.SUBPIXEL_BITS = 3408] = "SUBPIXEL_BITS", t[t.RED_BITS = 3410] = "RED_BITS", t[t.GREEN_BITS = 3411] = "GREEN_BITS", t[t.BLUE_BITS = 3412] = "BLUE_BITS", t[t.ALPHA_BITS = 3413] = "ALPHA_BITS", t[t.DEPTH_BITS = 3414] = "DEPTH_BITS", t[t.STENCIL_BITS = 3415] = "STENCIL_BITS", t[t.POLYGON_OFFSET_UNITS = 10752] = "POLYGON_OFFSET_UNITS", t[t.POLYGON_OFFSET_FACTOR = 32824] = "POLYGON_OFFSET_FACTOR", t[t.TEXTURE_BINDING_2D = 32873] = "TEXTURE_BINDING_2D", t[t.SAMPLE_BUFFERS = 32936] = "SAMPLE_BUFFERS", t[t.SAMPLES = 32937] = "SAMPLES", t[t.SAMPLE_COVERAGE_VALUE = 32938] = "SAMPLE_COVERAGE_VALUE", t[t.SAMPLE_COVERAGE_INVERT = 32939] = "SAMPLE_COVERAGE_INVERT", t[t.COMPRESSED_TEXTURE_FORMATS = 34467] = "COMPRESSED_TEXTURE_FORMATS", t[t.VENDOR = 7936] = "VENDOR", t[t.RENDERER = 7937] = "RENDERER", t[t.VERSION = 7938] = "VERSION", t[t.IMPLEMENTATION_COLOR_READ_TYPE = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE", t[t.IMPLEMENTATION_COLOR_READ_FORMAT = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT", t[t.BROWSER_DEFAULT_WEBGL = 37444] = "BROWSER_DEFAULT_WEBGL", t[t.STATIC_DRAW = 35044] = "STATIC_DRAW", t[t.STREAM_DRAW = 35040] = "STREAM_DRAW", t[t.DYNAMIC_DRAW = 35048] = "DYNAMIC_DRAW", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.BUFFER_SIZE = 34660] = "BUFFER_SIZE", t[t.BUFFER_USAGE = 34661] = "BUFFER_USAGE", t[t.CURRENT_VERTEX_ATTRIB = 34342] = "CURRENT_VERTEX_ATTRIB", t[t.VERTEX_ATTRIB_ARRAY_ENABLED = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED", t[t.VERTEX_ATTRIB_ARRAY_SIZE = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE", t[t.VERTEX_ATTRIB_ARRAY_STRIDE = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE", t[t.VERTEX_ATTRIB_ARRAY_TYPE = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE", t[t.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED", t[t.VERTEX_ATTRIB_ARRAY_POINTER = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER", t[t.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", t[t.CULL_FACE = 2884] = "CULL_FACE", t[t.FRONT = 1028] = "FRONT", t[t.BACK = 1029] = "BACK", t[t.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", t[t.BLEND = 3042] = "BLEND", t[t.DEPTH_TEST = 2929] = "DEPTH_TEST", t[t.DITHER = 3024] = "DITHER", t[t.POLYGON_OFFSET_FILL = 32823] = "POLYGON_OFFSET_FILL", t[t.SAMPLE_ALPHA_TO_COVERAGE = 32926] = "SAMPLE_ALPHA_TO_COVERAGE", t[t.SAMPLE_COVERAGE = 32928] = "SAMPLE_COVERAGE", t[t.SCISSOR_TEST = 3089] = "SCISSOR_TEST", t[t.STENCIL_TEST = 2960] = "STENCIL_TEST", t[t.NO_ERROR = 0] = "NO_ERROR", t[t.INVALID_ENUM = 1280] = "INVALID_ENUM", t[t.INVALID_VALUE = 1281] = "INVALID_VALUE", t[t.INVALID_OPERATION = 1282] = "INVALID_OPERATION", t[t.OUT_OF_MEMORY = 1285] = "OUT_OF_MEMORY", t[t.CONTEXT_LOST_WEBGL = 37442] = "CONTEXT_LOST_WEBGL", t[t.CW = 2304] = "CW", t[t.CCW = 2305] = "CCW", t[t.DONT_CARE = 4352] = "DONT_CARE", t[t.FASTEST = 4353] = "FASTEST", t[t.NICEST = 4354] = "NICEST", t[t.GENERATE_MIPMAP_HINT = 33170] = "GENERATE_MIPMAP_HINT", t[t.BYTE = 5120] = "BYTE", t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.SHORT = 5122] = "SHORT", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.INT = 5124] = "INT", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.FLOAT = 5126] = "FLOAT", t[t.DOUBLE = 5130] = "DOUBLE", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.ALPHA = 6406] = "ALPHA", t[t.RGB = 6407] = "RGB", t[t.RGBA = 6408] = "RGBA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.FRAGMENT_SHADER = 35632] = "FRAGMENT_SHADER", t[t.VERTEX_SHADER = 35633] = "VERTEX_SHADER", t[t.COMPILE_STATUS = 35713] = "COMPILE_STATUS", t[t.DELETE_STATUS = 35712] = "DELETE_STATUS", t[t.LINK_STATUS = 35714] = "LINK_STATUS", t[t.VALIDATE_STATUS = 35715] = "VALIDATE_STATUS", t[t.ATTACHED_SHADERS = 35717] = "ATTACHED_SHADERS", t[t.ACTIVE_ATTRIBUTES = 35721] = "ACTIVE_ATTRIBUTES", t[t.ACTIVE_UNIFORMS = 35718] = "ACTIVE_UNIFORMS", t[t.MAX_VERTEX_ATTRIBS = 34921] = "MAX_VERTEX_ATTRIBS", t[t.MAX_VERTEX_UNIFORM_VECTORS = 36347] = "MAX_VERTEX_UNIFORM_VECTORS", t[t.MAX_VARYING_VECTORS = 36348] = "MAX_VARYING_VECTORS", t[t.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS", t[t.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS", t[t.MAX_TEXTURE_IMAGE_UNITS = 34930] = "MAX_TEXTURE_IMAGE_UNITS", t[t.MAX_FRAGMENT_UNIFORM_VECTORS = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS", t[t.SHADER_TYPE = 35663] = "SHADER_TYPE", t[t.SHADING_LANGUAGE_VERSION = 35724] = "SHADING_LANGUAGE_VERSION", t[t.CURRENT_PROGRAM = 35725] = "CURRENT_PROGRAM", t[t.NEVER = 512] = "NEVER", t[t.LESS = 513] = "LESS", t[t.EQUAL = 514] = "EQUAL", t[t.LEQUAL = 515] = "LEQUAL", t[t.GREATER = 516] = "GREATER", t[t.NOTEQUAL = 517] = "NOTEQUAL", t[t.GEQUAL = 518] = "GEQUAL", t[t.ALWAYS = 519] = "ALWAYS", t[t.KEEP = 7680] = "KEEP", t[t.REPLACE = 7681] = "REPLACE", t[t.INCR = 7682] = "INCR", t[t.DECR = 7683] = "DECR", t[t.INVERT = 5386] = "INVERT", t[t.INCR_WRAP = 34055] = "INCR_WRAP", t[t.DECR_WRAP = 34056] = "DECR_WRAP", t[t.NEAREST = 9728] = "NEAREST", t[t.LINEAR = 9729] = "LINEAR", t[t.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", t[t.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", t[t.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", t[t.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", t[t.TEXTURE_MAG_FILTER = 10240] = "TEXTURE_MAG_FILTER", t[t.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", t[t.TEXTURE_WRAP_S = 10242] = "TEXTURE_WRAP_S", t[t.TEXTURE_WRAP_T = 10243] = "TEXTURE_WRAP_T", t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE = 5890] = "TEXTURE", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_BINDING_CUBE_MAP = 34068] = "TEXTURE_BINDING_CUBE_MAP", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", t[t.MAX_CUBE_MAP_TEXTURE_SIZE = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE", t[t.TEXTURE0 = 33984] = "TEXTURE0", t[t.ACTIVE_TEXTURE = 34016] = "ACTIVE_TEXTURE", t[t.REPEAT = 10497] = "REPEAT", t[t.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", t[t.TEXTURE_WIDTH = 4096] = "TEXTURE_WIDTH", t[t.TEXTURE_HEIGHT = 4097] = "TEXTURE_HEIGHT", t[t.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", t[t.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", t[t.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", t[t.INT_VEC2 = 35667] = "INT_VEC2", t[t.INT_VEC3 = 35668] = "INT_VEC3", t[t.INT_VEC4 = 35669] = "INT_VEC4", t[t.BOOL = 35670] = "BOOL", t[t.BOOL_VEC2 = 35671] = "BOOL_VEC2", t[t.BOOL_VEC3 = 35672] = "BOOL_VEC3", t[t.BOOL_VEC4 = 35673] = "BOOL_VEC4", t[t.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", t[t.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", t[t.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", t[t.SAMPLER_2D = 35678] = "SAMPLER_2D", t[t.SAMPLER_CUBE = 35680] = "SAMPLER_CUBE", t[t.LOW_FLOAT = 36336] = "LOW_FLOAT", t[t.MEDIUM_FLOAT = 36337] = "MEDIUM_FLOAT", t[t.HIGH_FLOAT = 36338] = "HIGH_FLOAT", t[t.LOW_INT = 36339] = "LOW_INT", t[t.MEDIUM_INT = 36340] = "MEDIUM_INT", t[t.HIGH_INT = 36341] = "HIGH_INT", t[t.FRAMEBUFFER = 36160] = "FRAMEBUFFER", t[t.RENDERBUFFER = 36161] = "RENDERBUFFER", t[t.RGBA4 = 32854] = "RGBA4", t[t.RGB5_A1 = 32855] = "RGB5_A1", t[t.RGB565 = 36194] = "RGB565", t[t.DEPTH_COMPONENT16 = 33189] = "DEPTH_COMPONENT16", t[t.STENCIL_INDEX = 6401] = "STENCIL_INDEX", t[t.STENCIL_INDEX8 = 36168] = "STENCIL_INDEX8", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", t[t.RENDERBUFFER_WIDTH = 36162] = "RENDERBUFFER_WIDTH", t[t.RENDERBUFFER_HEIGHT = 36163] = "RENDERBUFFER_HEIGHT", t[t.RENDERBUFFER_INTERNAL_FORMAT = 36164] = "RENDERBUFFER_INTERNAL_FORMAT", t[t.RENDERBUFFER_RED_SIZE = 36176] = "RENDERBUFFER_RED_SIZE", t[t.RENDERBUFFER_GREEN_SIZE = 36177] = "RENDERBUFFER_GREEN_SIZE", t[t.RENDERBUFFER_BLUE_SIZE = 36178] = "RENDERBUFFER_BLUE_SIZE", t[t.RENDERBUFFER_ALPHA_SIZE = 36179] = "RENDERBUFFER_ALPHA_SIZE", t[t.RENDERBUFFER_DEPTH_SIZE = 36180] = "RENDERBUFFER_DEPTH_SIZE", t[t.RENDERBUFFER_STENCIL_SIZE = 36181] = "RENDERBUFFER_STENCIL_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", t[t.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", t[t.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", t[t.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", t[t.COLOR_ATTACHMENT0 = 36064] = "COLOR_ATTACHMENT0", t[t.DEPTH_ATTACHMENT = 36096] = "DEPTH_ATTACHMENT", t[t.STENCIL_ATTACHMENT = 36128] = "STENCIL_ATTACHMENT", t[t.DEPTH_STENCIL_ATTACHMENT = 33306] = "DEPTH_STENCIL_ATTACHMENT", t[t.NONE = 0] = "NONE", t[t.FRAMEBUFFER_COMPLETE = 36053] = "FRAMEBUFFER_COMPLETE", t[t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", t[t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", t[t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", t[t.FRAMEBUFFER_UNSUPPORTED = 36061] = "FRAMEBUFFER_UNSUPPORTED", t[t.FRAMEBUFFER_BINDING = 36006] = "FRAMEBUFFER_BINDING", t[t.RENDERBUFFER_BINDING = 36007] = "RENDERBUFFER_BINDING", t[t.READ_FRAMEBUFFER = 36008] = "READ_FRAMEBUFFER", t[t.DRAW_FRAMEBUFFER = 36009] = "DRAW_FRAMEBUFFER", t[t.MAX_RENDERBUFFER_SIZE = 34024] = "MAX_RENDERBUFFER_SIZE", t[t.INVALID_FRAMEBUFFER_OPERATION = 1286] = "INVALID_FRAMEBUFFER_OPERATION", t[t.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL", t[t.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL", t[t.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL", t[t.READ_BUFFER = 3074] = "READ_BUFFER", t[t.UNPACK_ROW_LENGTH = 3314] = "UNPACK_ROW_LENGTH", t[t.UNPACK_SKIP_ROWS = 3315] = "UNPACK_SKIP_ROWS", t[t.UNPACK_SKIP_PIXELS = 3316] = "UNPACK_SKIP_PIXELS", t[t.PACK_ROW_LENGTH = 3330] = "PACK_ROW_LENGTH", t[t.PACK_SKIP_ROWS = 3331] = "PACK_SKIP_ROWS", t[t.PACK_SKIP_PIXELS = 3332] = "PACK_SKIP_PIXELS", t[t.TEXTURE_BINDING_3D = 32874] = "TEXTURE_BINDING_3D", t[t.UNPACK_SKIP_IMAGES = 32877] = "UNPACK_SKIP_IMAGES", t[t.UNPACK_IMAGE_HEIGHT = 32878] = "UNPACK_IMAGE_HEIGHT", t[t.MAX_3D_TEXTURE_SIZE = 32883] = "MAX_3D_TEXTURE_SIZE", t[t.MAX_ELEMENTS_VERTICES = 33e3] = "MAX_ELEMENTS_VERTICES", t[t.MAX_ELEMENTS_INDICES = 33001] = "MAX_ELEMENTS_INDICES", t[t.MAX_TEXTURE_LOD_BIAS = 34045] = "MAX_TEXTURE_LOD_BIAS", t[t.MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS", t[t.MAX_VERTEX_UNIFORM_COMPONENTS = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS", t[t.MAX_ARRAY_TEXTURE_LAYERS = 35071] = "MAX_ARRAY_TEXTURE_LAYERS", t[t.MIN_PROGRAM_TEXEL_OFFSET = 35076] = "MIN_PROGRAM_TEXEL_OFFSET", t[t.MAX_PROGRAM_TEXEL_OFFSET = 35077] = "MAX_PROGRAM_TEXEL_OFFSET", t[t.MAX_VARYING_COMPONENTS = 35659] = "MAX_VARYING_COMPONENTS", t[t.FRAGMENT_SHADER_DERIVATIVE_HINT = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT", t[t.RASTERIZER_DISCARD = 35977] = "RASTERIZER_DISCARD", t[t.VERTEX_ARRAY_BINDING = 34229] = "VERTEX_ARRAY_BINDING", t[t.MAX_VERTEX_OUTPUT_COMPONENTS = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS", t[t.MAX_FRAGMENT_INPUT_COMPONENTS = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS", t[t.MAX_SERVER_WAIT_TIMEOUT = 37137] = "MAX_SERVER_WAIT_TIMEOUT", t[t.MAX_ELEMENT_INDEX = 36203] = "MAX_ELEMENT_INDEX", t[t.RED = 6403] = "RED", t[t.RGB8 = 32849] = "RGB8", t[t.RGBA8 = 32856] = "RGBA8", t[t.RGB10_A2 = 32857] = "RGB10_A2", t[t.TEXTURE_3D = 32879] = "TEXTURE_3D", t[t.TEXTURE_WRAP_R = 32882] = "TEXTURE_WRAP_R", t[t.TEXTURE_MIN_LOD = 33082] = "TEXTURE_MIN_LOD", t[t.TEXTURE_MAX_LOD = 33083] = "TEXTURE_MAX_LOD", t[t.TEXTURE_BASE_LEVEL = 33084] = "TEXTURE_BASE_LEVEL", t[t.TEXTURE_MAX_LEVEL = 33085] = "TEXTURE_MAX_LEVEL", t[t.TEXTURE_COMPARE_MODE = 34892] = "TEXTURE_COMPARE_MODE", t[t.TEXTURE_COMPARE_FUNC = 34893] = "TEXTURE_COMPARE_FUNC", t[t.SRGB = 35904] = "SRGB", t[t.SRGB8 = 35905] = "SRGB8", t[t.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8", t[t.COMPARE_REF_TO_TEXTURE = 34894] = "COMPARE_REF_TO_TEXTURE", t[t.RGBA32F = 34836] = "RGBA32F", t[t.RGB32F = 34837] = "RGB32F", t[t.RGBA16F = 34842] = "RGBA16F", t[t.RGB16F = 34843] = "RGB16F", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_BINDING_2D_ARRAY = 35869] = "TEXTURE_BINDING_2D_ARRAY", t[t.R11F_G11F_B10F = 35898] = "R11F_G11F_B10F", t[t.RGB9_E5 = 35901] = "RGB9_E5", t[t.RGBA32UI = 36208] = "RGBA32UI", t[t.RGB32UI = 36209] = "RGB32UI", t[t.RGBA16UI = 36214] = "RGBA16UI", t[t.RGB16UI = 36215] = "RGB16UI", t[t.RGBA8UI = 36220] = "RGBA8UI", t[t.RGB8UI = 36221] = "RGB8UI", t[t.RGBA32I = 36226] = "RGBA32I", t[t.RGB32I = 36227] = "RGB32I", t[t.RGBA16I = 36232] = "RGBA16I", t[t.RGB16I = 36233] = "RGB16I", t[t.RGBA8I = 36238] = "RGBA8I", t[t.RGB8I = 36239] = "RGB8I", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.R8 = 33321] = "R8", t[t.RG8 = 33323] = "RG8", t[t.R16F = 33325] = "R16F", t[t.R32F = 33326] = "R32F", t[t.RG16F = 33327] = "RG16F", t[t.RG32F = 33328] = "RG32F", t[t.R8I = 33329] = "R8I", t[t.R8UI = 33330] = "R8UI", t[t.R16I = 33331] = "R16I", t[t.R16UI = 33332] = "R16UI", t[t.R32I = 33333] = "R32I", t[t.R32UI = 33334] = "R32UI", t[t.RG8I = 33335] = "RG8I", t[t.RG8UI = 33336] = "RG8UI", t[t.RG16I = 33337] = "RG16I", t[t.RG16UI = 33338] = "RG16UI", t[t.RG32I = 33339] = "RG32I", t[t.RG32UI = 33340] = "RG32UI", t[t.R8_SNORM = 36756] = "R8_SNORM", t[t.RG8_SNORM = 36757] = "RG8_SNORM", t[t.RGB8_SNORM = 36758] = "RGB8_SNORM", t[t.RGBA8_SNORM = 36759] = "RGBA8_SNORM", t[t.RGB10_A2UI = 36975] = "RGB10_A2UI", t[t.TEXTURE_IMMUTABLE_FORMAT = 37167] = "TEXTURE_IMMUTABLE_FORMAT", t[t.TEXTURE_IMMUTABLE_LEVELS = 33503] = "TEXTURE_IMMUTABLE_LEVELS", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.HALF_FLOAT = 5131] = "HALF_FLOAT", t[t.RG = 33319] = "RG", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.INT_2_10_10_10_REV = 36255] = "INT_2_10_10_10_REV", t[t.CURRENT_QUERY = 34917] = "CURRENT_QUERY", t[t.QUERY_RESULT = 34918] = "QUERY_RESULT", t[t.QUERY_RESULT_AVAILABLE = 34919] = "QUERY_RESULT_AVAILABLE", t[t.ANY_SAMPLES_PASSED = 35887] = "ANY_SAMPLES_PASSED", t[t.ANY_SAMPLES_PASSED_CONSERVATIVE = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE", t[t.MAX_DRAW_BUFFERS = 34852] = "MAX_DRAW_BUFFERS", t[t.DRAW_BUFFER0 = 34853] = "DRAW_BUFFER0", t[t.DRAW_BUFFER1 = 34854] = "DRAW_BUFFER1", t[t.DRAW_BUFFER2 = 34855] = "DRAW_BUFFER2", t[t.DRAW_BUFFER3 = 34856] = "DRAW_BUFFER3", t[t.DRAW_BUFFER4 = 34857] = "DRAW_BUFFER4", t[t.DRAW_BUFFER5 = 34858] = "DRAW_BUFFER5", t[t.DRAW_BUFFER6 = 34859] = "DRAW_BUFFER6", t[t.DRAW_BUFFER7 = 34860] = "DRAW_BUFFER7", t[t.DRAW_BUFFER8 = 34861] = "DRAW_BUFFER8", t[t.DRAW_BUFFER9 = 34862] = "DRAW_BUFFER9", t[t.DRAW_BUFFER10 = 34863] = "DRAW_BUFFER10", t[t.DRAW_BUFFER11 = 34864] = "DRAW_BUFFER11", t[t.DRAW_BUFFER12 = 34865] = "DRAW_BUFFER12", t[t.DRAW_BUFFER13 = 34866] = "DRAW_BUFFER13", t[t.DRAW_BUFFER14 = 34867] = "DRAW_BUFFER14", t[t.DRAW_BUFFER15 = 34868] = "DRAW_BUFFER15", t[t.MAX_COLOR_ATTACHMENTS = 36063] = "MAX_COLOR_ATTACHMENTS", t[t.COLOR_ATTACHMENT1 = 36065] = "COLOR_ATTACHMENT1", t[t.COLOR_ATTACHMENT2 = 36066] = "COLOR_ATTACHMENT2", t[t.COLOR_ATTACHMENT3 = 36067] = "COLOR_ATTACHMENT3", t[t.COLOR_ATTACHMENT4 = 36068] = "COLOR_ATTACHMENT4", t[t.COLOR_ATTACHMENT5 = 36069] = "COLOR_ATTACHMENT5", t[t.COLOR_ATTACHMENT6 = 36070] = "COLOR_ATTACHMENT6", t[t.COLOR_ATTACHMENT7 = 36071] = "COLOR_ATTACHMENT7", t[t.COLOR_ATTACHMENT8 = 36072] = "COLOR_ATTACHMENT8", t[t.COLOR_ATTACHMENT9 = 36073] = "COLOR_ATTACHMENT9", t[t.COLOR_ATTACHMENT10 = 36074] = "COLOR_ATTACHMENT10", t[t.COLOR_ATTACHMENT11 = 36075] = "COLOR_ATTACHMENT11", t[t.COLOR_ATTACHMENT12 = 36076] = "COLOR_ATTACHMENT12", t[t.COLOR_ATTACHMENT13 = 36077] = "COLOR_ATTACHMENT13", t[t.COLOR_ATTACHMENT14 = 36078] = "COLOR_ATTACHMENT14", t[t.COLOR_ATTACHMENT15 = 36079] = "COLOR_ATTACHMENT15", t[t.SAMPLER_3D = 35679] = "SAMPLER_3D", t[t.SAMPLER_2D_SHADOW = 35682] = "SAMPLER_2D_SHADOW", t[t.SAMPLER_2D_ARRAY = 36289] = "SAMPLER_2D_ARRAY", t[t.SAMPLER_2D_ARRAY_SHADOW = 36292] = "SAMPLER_2D_ARRAY_SHADOW", t[t.SAMPLER_CUBE_SHADOW = 36293] = "SAMPLER_CUBE_SHADOW", t[t.INT_SAMPLER_2D = 36298] = "INT_SAMPLER_2D", t[t.INT_SAMPLER_3D = 36299] = "INT_SAMPLER_3D", t[t.INT_SAMPLER_CUBE = 36300] = "INT_SAMPLER_CUBE", t[t.INT_SAMPLER_2D_ARRAY = 36303] = "INT_SAMPLER_2D_ARRAY", t[t.UNSIGNED_INT_SAMPLER_2D = 36306] = "UNSIGNED_INT_SAMPLER_2D", t[t.UNSIGNED_INT_SAMPLER_3D = 36307] = "UNSIGNED_INT_SAMPLER_3D", t[t.UNSIGNED_INT_SAMPLER_CUBE = 36308] = "UNSIGNED_INT_SAMPLER_CUBE", t[t.UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY", t[t.MAX_SAMPLES = 36183] = "MAX_SAMPLES", t[t.SAMPLER_BINDING = 35097] = "SAMPLER_BINDING", t[t.PIXEL_PACK_BUFFER = 35051] = "PIXEL_PACK_BUFFER", t[t.PIXEL_UNPACK_BUFFER = 35052] = "PIXEL_UNPACK_BUFFER", t[t.PIXEL_PACK_BUFFER_BINDING = 35053] = "PIXEL_PACK_BUFFER_BINDING", t[t.PIXEL_UNPACK_BUFFER_BINDING = 35055] = "PIXEL_UNPACK_BUFFER_BINDING", t[t.COPY_READ_BUFFER = 36662] = "COPY_READ_BUFFER", t[t.COPY_WRITE_BUFFER = 36663] = "COPY_WRITE_BUFFER", t[t.COPY_READ_BUFFER_BINDING = 36662] = "COPY_READ_BUFFER_BINDING", t[t.COPY_WRITE_BUFFER_BINDING = 36663] = "COPY_WRITE_BUFFER_BINDING", t[t.FLOAT_MAT2x3 = 35685] = "FLOAT_MAT2x3", t[t.FLOAT_MAT2x4 = 35686] = "FLOAT_MAT2x4", t[t.FLOAT_MAT3x2 = 35687] = "FLOAT_MAT3x2", t[t.FLOAT_MAT3x4 = 35688] = "FLOAT_MAT3x4", t[t.FLOAT_MAT4x2 = 35689] = "FLOAT_MAT4x2", t[t.FLOAT_MAT4x3 = 35690] = "FLOAT_MAT4x3", t[t.UNSIGNED_INT_VEC2 = 36294] = "UNSIGNED_INT_VEC2", t[t.UNSIGNED_INT_VEC3 = 36295] = "UNSIGNED_INT_VEC3", t[t.UNSIGNED_INT_VEC4 = 36296] = "UNSIGNED_INT_VEC4", t[t.UNSIGNED_NORMALIZED = 35863] = "UNSIGNED_NORMALIZED", t[t.SIGNED_NORMALIZED = 36764] = "SIGNED_NORMALIZED", t[t.VERTEX_ATTRIB_ARRAY_INTEGER = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER", t[t.VERTEX_ATTRIB_ARRAY_DIVISOR = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR", t[t.TRANSFORM_FEEDBACK_BUFFER_MODE = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE", t[t.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", t[t.TRANSFORM_FEEDBACK_VARYINGS = 35971] = "TRANSFORM_FEEDBACK_VARYINGS", t[t.TRANSFORM_FEEDBACK_BUFFER_START = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START", t[t.TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE", t[t.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", t[t.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", t[t.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", t[t.INTERLEAVED_ATTRIBS = 35980] = "INTERLEAVED_ATTRIBS", t[t.SEPARATE_ATTRIBS = 35981] = "SEPARATE_ATTRIBS", t[t.TRANSFORM_FEEDBACK_BUFFER = 35982] = "TRANSFORM_FEEDBACK_BUFFER", t[t.TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING", t[t.TRANSFORM_FEEDBACK = 36386] = "TRANSFORM_FEEDBACK", t[t.TRANSFORM_FEEDBACK_PAUSED = 36387] = "TRANSFORM_FEEDBACK_PAUSED", t[t.TRANSFORM_FEEDBACK_ACTIVE = 36388] = "TRANSFORM_FEEDBACK_ACTIVE", t[t.TRANSFORM_FEEDBACK_BINDING = 36389] = "TRANSFORM_FEEDBACK_BINDING", t[t.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", t[t.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", t[t.FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", t[t.FRAMEBUFFER_DEFAULT = 33304] = "FRAMEBUFFER_DEFAULT", t[t.DEPTH24_STENCIL8 = 35056] = "DEPTH24_STENCIL8", t[t.DRAW_FRAMEBUFFER_BINDING = 36006] = "DRAW_FRAMEBUFFER_BINDING", t[t.READ_FRAMEBUFFER_BINDING = 36010] = "READ_FRAMEBUFFER_BINDING", t[t.RENDERBUFFER_SAMPLES = 36011] = "RENDERBUFFER_SAMPLES", t[t.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", t[t.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", t[t.UNIFORM_BUFFER_BINDING = 35368] = "UNIFORM_BUFFER_BINDING", t[t.UNIFORM_BUFFER_START = 35369] = "UNIFORM_BUFFER_START", t[t.UNIFORM_BUFFER_SIZE = 35370] = "UNIFORM_BUFFER_SIZE", t[t.MAX_VERTEX_UNIFORM_BLOCKS = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS", t[t.MAX_FRAGMENT_UNIFORM_BLOCKS = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS", t[t.MAX_COMBINED_UNIFORM_BLOCKS = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS", t[t.MAX_UNIFORM_BUFFER_BINDINGS = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS", t[t.MAX_UNIFORM_BLOCK_SIZE = 35376] = "MAX_UNIFORM_BLOCK_SIZE", t[t.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", t[t.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", t[t.UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT", t[t.ACTIVE_UNIFORM_BLOCKS = 35382] = "ACTIVE_UNIFORM_BLOCKS", t[t.UNIFORM_TYPE = 35383] = "UNIFORM_TYPE", t[t.UNIFORM_SIZE = 35384] = "UNIFORM_SIZE", t[t.UNIFORM_BLOCK_INDEX = 35386] = "UNIFORM_BLOCK_INDEX", t[t.UNIFORM_OFFSET = 35387] = "UNIFORM_OFFSET", t[t.UNIFORM_ARRAY_STRIDE = 35388] = "UNIFORM_ARRAY_STRIDE", t[t.UNIFORM_MATRIX_STRIDE = 35389] = "UNIFORM_MATRIX_STRIDE", t[t.UNIFORM_IS_ROW_MAJOR = 35390] = "UNIFORM_IS_ROW_MAJOR", t[t.UNIFORM_BLOCK_BINDING = 35391] = "UNIFORM_BLOCK_BINDING", t[t.UNIFORM_BLOCK_DATA_SIZE = 35392] = "UNIFORM_BLOCK_DATA_SIZE", t[t.UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS", t[t.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", t[t.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", t[t.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", t[t.OBJECT_TYPE = 37138] = "OBJECT_TYPE", t[t.SYNC_CONDITION = 37139] = "SYNC_CONDITION", t[t.SYNC_STATUS = 37140] = "SYNC_STATUS", t[t.SYNC_FLAGS = 37141] = "SYNC_FLAGS", t[t.SYNC_FENCE = 37142] = "SYNC_FENCE", t[t.SYNC_GPU_COMMANDS_COMPLETE = 37143] = "SYNC_GPU_COMMANDS_COMPLETE", t[t.UNSIGNALED = 37144] = "UNSIGNALED", t[t.SIGNALED = 37145] = "SIGNALED", t[t.ALREADY_SIGNALED = 37146] = "ALREADY_SIGNALED", t[t.TIMEOUT_EXPIRED = 37147] = "TIMEOUT_EXPIRED", t[t.CONDITION_SATISFIED = 37148] = "CONDITION_SATISFIED", t[t.WAIT_FAILED = 37149] = "WAIT_FAILED", t[t.SYNC_FLUSH_COMMANDS_BIT = 1] = "SYNC_FLUSH_COMMANDS_BIT", t[t.COLOR = 6144] = "COLOR", t[t.DEPTH = 6145] = "DEPTH", t[t.STENCIL = 6146] = "STENCIL", t[t.MIN = 32775] = "MIN", t[t.MAX = 32776] = "MAX", t[t.DEPTH_COMPONENT24 = 33190] = "DEPTH_COMPONENT24", t[t.STREAM_READ = 35041] = "STREAM_READ", t[t.STREAM_COPY = 35042] = "STREAM_COPY", t[t.STATIC_READ = 35045] = "STATIC_READ", t[t.STATIC_COPY = 35046] = "STATIC_COPY", t[t.DYNAMIC_READ = 35049] = "DYNAMIC_READ", t[t.DYNAMIC_COPY = 35050] = "DYNAMIC_COPY", t[t.DEPTH_COMPONENT32F = 36012] = "DEPTH_COMPONENT32F", t[t.DEPTH32F_STENCIL8 = 36013] = "DEPTH32F_STENCIL8", t[t.INVALID_INDEX = 4294967295] = "INVALID_INDEX", t[t.TIMEOUT_IGNORED = -1] = "TIMEOUT_IGNORED", t[t.MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", t[t.UNMASKED_VENDOR_WEBGL = 37445] = "UNMASKED_VENDOR_WEBGL", t[t.UNMASKED_RENDERER_WEBGL = 37446] = "UNMASKED_RENDERER_WEBGL", t[t.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT", t[t.TEXTURE_MAX_ANISOTROPY_EXT = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT", t[t.R16_EXT = 33322] = "R16_EXT", t[t.RG16_EXT = 33324] = "RG16_EXT", t[t.RGB16_EXT = 32852] = "RGB16_EXT", t[t.RGBA16_EXT = 32859] = "RGBA16_EXT", t[t.R16_SNORM_EXT = 36760] = "R16_SNORM_EXT", t[t.RG16_SNORM_EXT = 36761] = "RG16_SNORM_EXT", t[t.RGB16_SNORM_EXT = 36762] = "RGB16_SNORM_EXT", t[t.RGBA16_SNORM_EXT = 36763] = "RGBA16_SNORM_EXT", t[t.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", t[t.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", t[t.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT", t[t.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT", t[t.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT", t[t.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", t[t.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", t[t.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", t[t.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", t[t.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", t[t.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", t[t.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", t[t.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", t[t.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", t[t.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", t[t.COMPRESSED_RGBA8_ETC2_EAC = 37493] = "COMPRESSED_RGBA8_ETC2_EAC", t[t.COMPRESSED_SRGB8_ETC2 = 37494] = "COMPRESSED_SRGB8_ETC2", t[t.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", t[t.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", t[t.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", t[t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", t[t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", t[t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", t[t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", t[t.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", t[t.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", t[t.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", t[t.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", t[t.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", t[t.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", t[t.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", t[t.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", t[t.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", t[t.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", t[t.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", t[t.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", t[t.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", t[t.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", t[t.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", t[t.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", t[t.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", t[t.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", t[t.QUERY_COUNTER_BITS_EXT = 34916] = "QUERY_COUNTER_BITS_EXT", t[t.CURRENT_QUERY_EXT = 34917] = "CURRENT_QUERY_EXT", t[t.QUERY_RESULT_EXT = 34918] = "QUERY_RESULT_EXT", t[t.QUERY_RESULT_AVAILABLE_EXT = 34919] = "QUERY_RESULT_AVAILABLE_EXT", t[t.TIME_ELAPSED_EXT = 35007] = "TIME_ELAPSED_EXT", t[t.TIMESTAMP_EXT = 36392] = "TIMESTAMP_EXT", t[t.GPU_DISJOINT_EXT = 36795] = "GPU_DISJOINT_EXT", t[t.COMPLETION_STATUS_KHR = 37297] = "COMPLETION_STATUS_KHR", t[t.DEPTH_CLAMP_EXT = 34383] = "DEPTH_CLAMP_EXT", t[t.FIRST_VERTEX_CONVENTION_WEBGL = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL", t[t.LAST_VERTEX_CONVENTION_WEBGL = 36430] = "LAST_VERTEX_CONVENTION_WEBGL", t[t.PROVOKING_VERTEX_WEBL = 36431] = "PROVOKING_VERTEX_WEBL", t[t.POLYGON_MODE_WEBGL = 2880] = "POLYGON_MODE_WEBGL", t[t.POLYGON_OFFSET_LINE_WEBGL = 10754] = "POLYGON_OFFSET_LINE_WEBGL", t[t.LINE_WEBGL = 6913] = "LINE_WEBGL", t[t.FILL_WEBGL = 6914] = "FILL_WEBGL", t[t.MAX_CLIP_DISTANCES_WEBGL = 3378] = "MAX_CLIP_DISTANCES_WEBGL", t[t.MAX_CULL_DISTANCES_WEBGL = 33529] = "MAX_CULL_DISTANCES_WEBGL", t[t.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL", t[t.CLIP_DISTANCE0_WEBGL = 12288] = "CLIP_DISTANCE0_WEBGL", t[t.CLIP_DISTANCE1_WEBGL = 12289] = "CLIP_DISTANCE1_WEBGL", t[t.CLIP_DISTANCE2_WEBGL = 12290] = "CLIP_DISTANCE2_WEBGL", t[t.CLIP_DISTANCE3_WEBGL = 12291] = "CLIP_DISTANCE3_WEBGL", t[t.CLIP_DISTANCE4_WEBGL = 12292] = "CLIP_DISTANCE4_WEBGL", t[t.CLIP_DISTANCE5_WEBGL = 12293] = "CLIP_DISTANCE5_WEBGL", t[t.CLIP_DISTANCE6_WEBGL = 12294] = "CLIP_DISTANCE6_WEBGL", t[t.CLIP_DISTANCE7_WEBGL = 12295] = "CLIP_DISTANCE7_WEBGL", t[t.POLYGON_OFFSET_CLAMP_EXT = 36379] = "POLYGON_OFFSET_CLAMP_EXT", t[t.LOWER_LEFT_EXT = 36001] = "LOWER_LEFT_EXT", t[t.UPPER_LEFT_EXT = 36002] = "UPPER_LEFT_EXT", t[t.NEGATIVE_ONE_TO_ONE_EXT = 37726] = "NEGATIVE_ONE_TO_ONE_EXT", t[t.ZERO_TO_ONE_EXT = 37727] = "ZERO_TO_ONE_EXT", t[t.CLIP_ORIGIN_EXT = 37724] = "CLIP_ORIGIN_EXT", t[t.CLIP_DEPTH_MODE_EXT = 37725] = "CLIP_DEPTH_MODE_EXT", t[t.SRC1_COLOR_WEBGL = 35065] = "SRC1_COLOR_WEBGL", t[t.SRC1_ALPHA_WEBGL = 34185] = "SRC1_ALPHA_WEBGL", t[t.ONE_MINUS_SRC1_COLOR_WEBGL = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL", t[t.ONE_MINUS_SRC1_ALPHA_WEBGL = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL", t[t.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL", t[t.MIRROR_CLAMP_TO_EDGE_EXT = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
})(gc || (gc = {}));
const vy = {
  3042: !1,
  32773: new Float32Array([0, 0, 0, 0]),
  32777: 32774,
  34877: 32774,
  32969: 1,
  32968: 0,
  32971: 1,
  32970: 0,
  3106: new Float32Array([0, 0, 0, 0]),
  // TBD
  3107: [!0, !0, !0, !0],
  2884: !1,
  2885: 1029,
  2929: !1,
  2931: 1,
  2932: 513,
  2928: new Float32Array([0, 1]),
  // TBD
  2930: !0,
  3024: !0,
  35725: null,
  // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: null,
  36007: null,
  34229: null,
  34964: null,
  2886: 2305,
  33170: 4352,
  2849: 1,
  32823: !1,
  32824: 0,
  10752: 0,
  32926: !1,
  32928: !1,
  32938: 1,
  32939: !1,
  3089: !1,
  // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
  3088: new Int32Array([0, 0, 1024, 1024]),
  2960: !1,
  2961: 0,
  2968: 4294967295,
  36005: 4294967295,
  2962: 519,
  2967: 0,
  2963: 4294967295,
  34816: 519,
  36003: 0,
  36004: 4294967295,
  2964: 7680,
  2965: 7680,
  2966: 7680,
  34817: 7680,
  34818: 7680,
  34819: 7680,
  // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
  2978: [0, 0, 1024, 1024],
  36389: null,
  36662: null,
  36663: null,
  35053: null,
  35055: null,
  35723: 4352,
  36010: null,
  35977: !1,
  3333: 4,
  3317: 4,
  37440: !1,
  37441: !1,
  37443: 37444,
  3330: 0,
  3332: 0,
  3331: 0,
  3314: 0,
  32878: 0,
  3316: 0,
  3315: 0,
  32877: 0
}, ss = (t, e, i) => e ? t.enable(i) : t.disable(i), $v = (t, e, i) => t.hint(i, e), Fr = (t, e, i) => t.pixelStorei(i, e), Gv = (t, e, i) => {
  const s = i === 36006 ? 36009 : 36008;
  return t.bindFramebuffer(s, e);
}, Kh = (t, e, i) => {
  const o = {
    34964: 34962,
    36662: 36662,
    36663: 36663,
    35053: 35051,
    35055: 35052
  }[i];
  t.bindBuffer(o, e);
};
function om(t) {
  return Array.isArray(t) || ArrayBuffer.isView(t) && !(t instanceof DataView);
}
const mO = {
  3042: ss,
  32773: (t, e) => t.blendColor(...e),
  32777: "blendEquation",
  34877: "blendEquation",
  32969: "blendFunc",
  32968: "blendFunc",
  32971: "blendFunc",
  32970: "blendFunc",
  3106: (t, e) => t.clearColor(...e),
  3107: (t, e) => t.colorMask(...e),
  2884: ss,
  2885: (t, e) => t.cullFace(e),
  2929: ss,
  2931: (t, e) => t.clearDepth(e),
  2932: (t, e) => t.depthFunc(e),
  2928: (t, e) => t.depthRange(...e),
  2930: (t, e) => t.depthMask(e),
  3024: ss,
  35723: $v,
  35725: (t, e) => t.useProgram(e),
  36007: (t, e) => t.bindRenderbuffer(36161, e),
  36389: (t, e) => {
    var i;
    return (i = t.bindTransformFeedback) == null ? void 0 : i.call(t, 36386, e);
  },
  34229: (t, e) => t.bindVertexArray(e),
  // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: Gv,
  36010: Gv,
  // Buffers
  34964: Kh,
  36662: Kh,
  36663: Kh,
  35053: Kh,
  35055: Kh,
  2886: (t, e) => t.frontFace(e),
  33170: $v,
  2849: (t, e) => t.lineWidth(e),
  32823: ss,
  32824: "polygonOffset",
  10752: "polygonOffset",
  35977: ss,
  32926: ss,
  32928: ss,
  32938: "sampleCoverage",
  32939: "sampleCoverage",
  3089: ss,
  3088: (t, e) => t.scissor(...e),
  2960: ss,
  2961: (t, e) => t.clearStencil(e),
  2968: (t, e) => t.stencilMaskSeparate(1028, e),
  36005: (t, e) => t.stencilMaskSeparate(1029, e),
  2962: "stencilFuncFront",
  2967: "stencilFuncFront",
  2963: "stencilFuncFront",
  34816: "stencilFuncBack",
  36003: "stencilFuncBack",
  36004: "stencilFuncBack",
  2964: "stencilOpFront",
  2965: "stencilOpFront",
  2966: "stencilOpFront",
  34817: "stencilOpBack",
  34818: "stencilOpBack",
  34819: "stencilOpBack",
  2978: (t, e) => t.viewport(...e),
  // WEBGL2 EXTENSIONS
  // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
  34383: ss,
  // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
  // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
  // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
  // POLYGON_MODE_WEBGL  TODO - extension function needed
  10754: ss,
  // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
  12288: ss,
  12289: ss,
  12290: ss,
  12291: ss,
  12292: ss,
  12293: ss,
  12294: ss,
  12295: ss,
  // PIXEL PACK/UNPACK MODES
  3333: Fr,
  3317: Fr,
  37440: Fr,
  37441: Fr,
  37443: Fr,
  3330: Fr,
  3332: Fr,
  3331: Fr,
  3314: Fr,
  32878: Fr,
  3316: Fr,
  3315: Fr,
  32877: Fr,
  // Function-style setters
  framebuffer: (t, e) => {
    const i = e && "handle" in e ? e.handle : e;
    return t.bindFramebuffer(36160, i);
  },
  blend: (t, e) => e ? t.enable(3042) : t.disable(3042),
  blendColor: (t, e) => t.blendColor(...e),
  blendEquation: (t, e) => {
    const i = typeof e == "number" ? [e, e] : e;
    t.blendEquationSeparate(...i);
  },
  blendFunc: (t, e) => {
    const i = (e == null ? void 0 : e.length) === 2 ? [...e, ...e] : e;
    t.blendFuncSeparate(...i);
  },
  clearColor: (t, e) => t.clearColor(...e),
  clearDepth: (t, e) => t.clearDepth(e),
  clearStencil: (t, e) => t.clearStencil(e),
  colorMask: (t, e) => t.colorMask(...e),
  cull: (t, e) => e ? t.enable(2884) : t.disable(2884),
  cullFace: (t, e) => t.cullFace(e),
  depthTest: (t, e) => e ? t.enable(2929) : t.disable(2929),
  depthFunc: (t, e) => t.depthFunc(e),
  depthMask: (t, e) => t.depthMask(e),
  depthRange: (t, e) => t.depthRange(...e),
  dither: (t, e) => e ? t.enable(3024) : t.disable(3024),
  derivativeHint: (t, e) => {
    t.hint(35723, e);
  },
  frontFace: (t, e) => t.frontFace(e),
  mipmapHint: (t, e) => t.hint(33170, e),
  lineWidth: (t, e) => t.lineWidth(e),
  polygonOffsetFill: (t, e) => e ? t.enable(32823) : t.disable(32823),
  polygonOffset: (t, e) => t.polygonOffset(...e),
  sampleCoverage: (t, e) => t.sampleCoverage(...e),
  scissorTest: (t, e) => e ? t.enable(3089) : t.disable(3089),
  scissor: (t, e) => t.scissor(...e),
  stencilTest: (t, e) => e ? t.enable(2960) : t.disable(2960),
  stencilMask: (t, e) => {
    e = om(e) ? e : [e, e];
    const [i, s] = e;
    t.stencilMaskSeparate(1028, i), t.stencilMaskSeparate(1029, s);
  },
  stencilFunc: (t, e) => {
    e = om(e) && e.length === 3 ? [...e, ...e] : e;
    const [i, s, o, l, u, c] = e;
    t.stencilFuncSeparate(1028, i, s, o), t.stencilFuncSeparate(1029, l, u, c);
  },
  stencilOp: (t, e) => {
    e = om(e) && e.length === 3 ? [...e, ...e] : e;
    const [i, s, o, l, u, c] = e;
    t.stencilOpSeparate(1028, i, s, o), t.stencilOpSeparate(1029, l, u, c);
  },
  viewport: (t, e) => t.viewport(...e)
};
function Wi(t, e, i) {
  return e[t] !== void 0 ? e[t] : i[t];
}
const gO = {
  blendEquation: (t, e, i) => t.blendEquationSeparate(Wi(32777, e, i), Wi(34877, e, i)),
  blendFunc: (t, e, i) => t.blendFuncSeparate(Wi(32969, e, i), Wi(32968, e, i), Wi(32971, e, i), Wi(32970, e, i)),
  polygonOffset: (t, e, i) => t.polygonOffset(Wi(32824, e, i), Wi(10752, e, i)),
  sampleCoverage: (t, e, i) => t.sampleCoverage(Wi(32938, e, i), Wi(32939, e, i)),
  stencilFuncFront: (t, e, i) => t.stencilFuncSeparate(1028, Wi(2962, e, i), Wi(2967, e, i), Wi(2963, e, i)),
  stencilFuncBack: (t, e, i) => t.stencilFuncSeparate(1029, Wi(34816, e, i), Wi(36003, e, i), Wi(36004, e, i)),
  stencilOpFront: (t, e, i) => t.stencilOpSeparate(1028, Wi(2964, e, i), Wi(2965, e, i), Wi(2966, e, i)),
  stencilOpBack: (t, e, i) => t.stencilOpSeparate(1029, Wi(34817, e, i), Wi(34818, e, i), Wi(34819, e, i))
}, Xv = {
  // GENERIC SETTERS
  enable: (t, e) => t({
    [e]: !0
  }),
  disable: (t, e) => t({
    [e]: !1
  }),
  pixelStorei: (t, e, i) => t({
    [e]: i
  }),
  hint: (t, e, i) => t({
    [e]: i
  }),
  // SPECIFIC SETTERS
  useProgram: (t, e) => t({
    35725: e
  }),
  bindRenderbuffer: (t, e, i) => t({
    36007: i
  }),
  bindTransformFeedback: (t, e, i) => t({
    36389: i
  }),
  bindVertexArray: (t, e) => t({
    34229: e
  }),
  bindFramebuffer: (t, e, i) => {
    switch (e) {
      case 36160:
        return t({
          36006: i,
          36010: i
        });
      case 36009:
        return t({ 36006: i });
      case 36008:
        return t({ 36010: i });
      default:
        return null;
    }
  },
  bindBuffer: (t, e, i) => {
    const s = {
      34962: [34964],
      36662: [36662],
      36663: [36663],
      35051: [35053],
      35052: [35055]
    }[e];
    return s ? t({ [s]: i }) : { valueChanged: !0 };
  },
  blendColor: (t, e, i, s, o) => t({
    32773: new Float32Array([e, i, s, o])
  }),
  blendEquation: (t, e) => t({
    32777: e,
    34877: e
  }),
  blendEquationSeparate: (t, e, i) => t({
    32777: e,
    34877: i
  }),
  blendFunc: (t, e, i) => t({
    32969: e,
    32968: i,
    32971: e,
    32970: i
  }),
  blendFuncSeparate: (t, e, i, s, o) => t({
    32969: e,
    32968: i,
    32971: s,
    32970: o
  }),
  clearColor: (t, e, i, s, o) => t({
    3106: new Float32Array([e, i, s, o])
  }),
  clearDepth: (t, e) => t({
    2931: e
  }),
  clearStencil: (t, e) => t({
    2961: e
  }),
  colorMask: (t, e, i, s, o) => t({
    3107: [e, i, s, o]
  }),
  cullFace: (t, e) => t({
    2885: e
  }),
  depthFunc: (t, e) => t({
    2932: e
  }),
  depthRange: (t, e, i) => t({
    2928: new Float32Array([e, i])
  }),
  depthMask: (t, e) => t({
    2930: e
  }),
  frontFace: (t, e) => t({
    2886: e
  }),
  lineWidth: (t, e) => t({
    2849: e
  }),
  polygonOffset: (t, e, i) => t({
    32824: e,
    10752: i
  }),
  sampleCoverage: (t, e, i) => t({
    32938: e,
    32939: i
  }),
  scissor: (t, e, i, s, o) => t({
    3088: new Int32Array([e, i, s, o])
  }),
  stencilMask: (t, e) => t({
    2968: e,
    36005: e
  }),
  stencilMaskSeparate: (t, e, i) => t({
    [e === 1028 ? 2968 : 36005]: i
  }),
  stencilFunc: (t, e, i, s) => t({
    2962: e,
    2967: i,
    2963: s,
    34816: e,
    36003: i,
    36004: s
  }),
  stencilFuncSeparate: (t, e, i, s, o) => t({
    [e === 1028 ? 2962 : 34816]: i,
    [e === 1028 ? 2967 : 36003]: s,
    [e === 1028 ? 2963 : 36004]: o
  }),
  stencilOp: (t, e, i, s) => t({
    2964: e,
    2965: i,
    2966: s,
    34817: e,
    34818: i,
    34819: s
  }),
  stencilOpSeparate: (t, e, i, s, o) => t({
    [e === 1028 ? 2964 : 34817]: i,
    [e === 1028 ? 2965 : 34818]: s,
    [e === 1028 ? 2966 : 34819]: o
  }),
  viewport: (t, e, i, s, o) => t({
    2978: [e, i, s, o]
  })
}, Un = (t, e) => t.isEnabled(e), Wv = {
  3042: Un,
  2884: Un,
  2929: Un,
  3024: Un,
  32823: Un,
  32926: Un,
  32928: Un,
  3089: Un,
  2960: Un,
  35977: Un
}, yO = /* @__PURE__ */ new Set([
  34016,
  36388,
  36387,
  35983,
  35368,
  34965,
  35739,
  35738,
  3074,
  34853,
  34854,
  34855,
  34856,
  34857,
  34858,
  34859,
  34860,
  34861,
  34862,
  34863,
  34864,
  34865,
  34866,
  34867,
  34868,
  35097,
  32873,
  35869,
  32874,
  34068
]);
function $c(t, e) {
  if (vO(e))
    return;
  const i = {};
  for (const o in e) {
    const l = Number(o), u = mO[o];
    u && (typeof u == "string" ? i[u] = !0 : u(t, e[o], l));
  }
  const s = t.state && t.state.cache;
  if (s)
    for (const o in i) {
      const l = gO[o];
      l(t, e, s);
    }
}
function TA(t, e = vy) {
  if (typeof e == "number") {
    const o = e, l = Wv[o];
    return l ? l(t, o) : t.getParameter(o);
  }
  const i = Array.isArray(e) ? e : Object.keys(e), s = {};
  for (const o of i) {
    const l = Wv[o];
    s[o] = l ? l(t, Number(o)) : t.getParameter(Number(o));
  }
  return s;
}
function bO(t) {
  $c(t, vy);
}
function vO(t) {
  for (const e in t)
    return !1;
  return !0;
}
function xO(t, e) {
  if (t === e)
    return !0;
  const i = Array.isArray(t) || ArrayBuffer.isView(t), s = Array.isArray(e) || ArrayBuffer.isView(e);
  if (i && s && t.length === e.length) {
    for (let o = 0; o < t.length; ++o)
      if (t[o] !== e[o])
        return !1;
    return !0;
  }
  return !1;
}
class wO {
  constructor(e, {
    copyState: i = !1,
    // Copy cache from params (slow) or initialize from WebGL defaults (fast)
    log: s = () => {
    }
    // Logging function, called when gl parameter change calls are actually issued
  } = {}) {
    O(this, "gl");
    O(this, "program", null);
    O(this, "stateStack", []);
    O(this, "enable", !0);
    O(this, "cache");
    O(this, "log");
    this.gl = e, this.cache = i ? TA(e) : Object.assign({}, vy), this.log = s, this._updateCache = this._updateCache.bind(this), Object.seal(this);
  }
  push(e = {}) {
    this.stateStack.push({});
  }
  pop() {
    ri(this.stateStack.length > 0);
    const e = this.stateStack[this.stateStack.length - 1];
    $c(this.gl, e), this.stateStack.pop();
  }
  /**
  // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter
   * @param values
   * @returns
   */
  _updateCache(e) {
    let i = !1, s;
    const o = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
    for (const l in e) {
      ri(l !== void 0);
      const u = e[l], c = this.cache[l];
      xO(u, c) || (i = !0, s = c, o && !(l in o) && (o[l] = c), this.cache[l] = u);
    }
    return { valueChanged: i, oldValue: s };
  }
}
function ll(t) {
  return t.state;
}
function EA(t, e) {
  const { enable: i = !0, copyState: s } = e;
  if (ri(s !== void 0), !t.state) {
    t.state = new wO(t, { copyState: s }), TO(t);
    for (const l in Xv) {
      const u = Xv[l];
      AO(t, l, u);
    }
    qv(t, "getParameter"), qv(t, "isEnabled");
  }
  const o = ll(t);
  return o.enable = i, t;
}
function yp(t) {
  let e = ll(t);
  e || (EA(t, { copyState: !1 }), e = ll(t)), e.push();
}
function Cu(t) {
  const e = ll(t);
  ri(e), e.pop();
}
function qv(t, e) {
  const i = t[e].bind(t);
  t[e] = function(o) {
    if (o === void 0 || yO.has(o))
      return i(o);
    const l = ll(t);
    return o in l.cache || (l.cache[o] = i(o)), l.enable ? (
      // Call the getter the params so that it can e.g. serve from a cache
      l.cache[o]
    ) : (
      // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
      i(o)
    );
  }, Object.defineProperty(t[e], "name", {
    value: `${e}-from-cache`,
    configurable: !1
  });
}
function AO(t, e, i) {
  if (!t[e])
    return;
  const s = t[e].bind(t);
  t[e] = function(...l) {
    const u = ll(t), { valueChanged: c, oldValue: x } = i(u._updateCache, ...l);
    return c && s(...l), x;
  }, Object.defineProperty(t[e], "name", {
    value: `${e}-to-cache`,
    configurable: !1
  });
}
function TO(t) {
  const e = t.useProgram.bind(t);
  t.useProgram = function(s) {
    const o = ll(t);
    o.program !== s && (e(s), o.program = s);
  };
}
const EO = {
  powerPreference: "high-performance",
  // After all, most apps are using WebGL for performance reasons
  // eslint-disable-next-line no-console
  onContextLost: () => console.error("WebGL context lost"),
  // eslint-disable-next-line no-console
  onContextRestored: () => console.info("WebGL context restored")
};
function SO(t, e) {
  e = { ...EO, ...e };
  let i = null;
  const s = (l) => i = l.statusMessage || i;
  t.addEventListener("webglcontextcreationerror", s, !1);
  let o = null;
  if (o || (o = t.getContext("webgl2", e)), t.removeEventListener("webglcontextcreationerror", s, !1), !o)
    throw new Error(`Failed to create WebGL context: ${i || "Unknown error"}`);
  if (e.onContextLost) {
    const { onContextLost: l } = e;
    t.addEventListener("webglcontextlost", (u) => l(u), !1);
  }
  if (e.onContextRestored) {
    const { onContextRestored: l } = e;
    t.addEventListener("webglcontextrestored", (u) => l(u), !1);
  }
  return o;
}
function ga(t, e, i) {
  return i[e] === void 0 && (i[e] = t.getExtension(e) || null), i[e];
}
function CO(t, e) {
  const i = t.getParameter(7936), s = t.getParameter(7937);
  ga(t, "WEBGL_debug_renderer_info", e);
  const o = e.WEBGL_debug_renderer_info, l = t.getParameter(o ? o.UNMASKED_VENDOR_WEBGL : 7936), u = t.getParameter(o ? o.UNMASKED_RENDERER_WEBGL : 7937), c = l || i, x = u || s, w = t.getParameter(7938), C = SA(c, x), M = IO(c, x), P = RO(c, x);
  return {
    type: "webgl",
    gpu: C,
    gpuType: P,
    gpuBackend: M,
    vendor: c,
    renderer: x,
    version: w,
    shadingLanguage: "glsl",
    shadingLanguageVersion: 300
  };
}
function SA(t, e) {
  return /NVIDIA/i.exec(t) || /NVIDIA/i.exec(e) ? "nvidia" : /INTEL/i.exec(t) || /INTEL/i.exec(e) ? "intel" : /Apple/i.exec(t) || /Apple/i.exec(e) ? "apple" : /AMD/i.exec(t) || /AMD/i.exec(e) || /ATI/i.exec(t) || /ATI/i.exec(e) ? "amd" : /SwiftShader/i.exec(t) || /SwiftShader/i.exec(e) ? "software" : "unknown";
}
function IO(t, e) {
  return /Metal/i.exec(t) || /Metal/i.exec(e) ? "metal" : /ANGLE/i.exec(t) || /ANGLE/i.exec(e) ? "opengl" : "unknown";
}
function RO(t, e) {
  if (/SwiftShader/i.exec(t) || /SwiftShader/i.exec(e))
    return "cpu";
  switch (SA(t, e)) {
    case "intel":
      return "integrated";
    case "software":
      return "cpu";
    case "unknown":
      return "unknown";
    default:
      return "discrete";
  }
}
function CA(t) {
  switch (t) {
    case "uint8":
      return 5121;
    case "sint8":
      return 5120;
    case "unorm8":
      return 5121;
    case "snorm8":
      return 5120;
    case "uint16":
      return 5123;
    case "sint16":
      return 5122;
    case "unorm16":
      return 5123;
    case "snorm16":
      return 5122;
    case "uint32":
      return 5125;
    case "sint32":
      return 5124;
    case "float16":
      return 5131;
    case "float32":
      return 5126;
  }
  throw new Error(String(t));
}
const Ws = "texture-compression-bc", yi = "texture-compression-astc", zn = "texture-compression-etc2", MO = "texture-compression-etc1-webgl", tf = "texture-compression-pvrtc-webgl", am = "texture-compression-atc-webgl", Jh = "float32-renderable-webgl", lm = "float16-renderable-webgl", PO = "rgb9e5ufloat_renderable-webgl", cm = "snorm8-renderable-webgl", Yh = "norm16-renderable-webgl", hm = "snorm16-renderable-webgl", sf = "float32-filterable", Zv = "float16-filterable-webgl", lu = "WEBGL_compressed_texture_s3tc", cu = "WEBGL_compressed_texture_s3tc_srgb", yc = "EXT_texture_compression_rgtc", bc = "EXT_texture_compression_bptc", BO = "WEBGL_compressed_texture_etc", DO = "WEBGL_compressed_texture_astc", OO = "WEBGL_compressed_texture_etc1", FO = "WEBGL_compressed_texture_pvrtc", kO = "WEBGL_compressed_texture_atc", Kv = "EXT_texture_norm16", Jv = "EXT_render_snorm", NO = "EXT_color_buffer_float", xy = {
  "float32-renderable-webgl": ["EXT_color_buffer_float"],
  "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
  "rgb9e5ufloat_renderable-webgl": ["WEBGL_render_shared_exponent"],
  "snorm8-renderable-webgl": [Jv],
  "norm16-renderable-webgl": [Kv],
  "snorm16-renderable-webgl": [Kv, Jv],
  "float32-filterable": ["OES_texture_float_linear"],
  "float16-filterable-webgl": ["OES_texture_half_float_linear"],
  "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
  "texture-blend-float-webgl": ["EXT_float_blend"],
  "texture-compression-bc": [lu, cu, yc, bc],
  // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
  // 'texture-compression-bc3-webgl': [X_S3TC],
  "texture-compression-bc5-webgl": [yc],
  "texture-compression-bc7-webgl": [bc],
  "texture-compression-etc2": [BO],
  "texture-compression-astc": [DO],
  "texture-compression-etc1-webgl": [OO],
  "texture-compression-pvrtc-webgl": [FO],
  "texture-compression-atc-webgl": [kO]
};
function LO(t) {
  return t in xy;
}
function UO(t, e, i) {
  return (xy[e] || []).every((o) => ga(t, o, i));
}
const bp = {
  // Unsized formats that leave the precision up to the driver. TODO - Fix bpp constants
  "rgb8unorm-unsized": {
    gl: 6407,
    b: 4,
    c: 2,
    bpp: 4,
    dataFormat: 6407,
    types: [5121, 33635]
  },
  "rgba8unorm-unsized": {
    gl: 6408,
    b: 4,
    c: 2,
    bpp: 4,
    dataFormat: 6408,
    types: [5121, 32819, 32820]
  },
  // 'r8unorm-unsized': {gl: GL.LUMINANCE, b: 4, c: 2, bpp: 4},
  // 'rgb8unorm-srgb-unsized': {gl: GL.SRGB_EXT, b: 4, c: 2, bpp: 4, gl1Ext: SRGB},
  // 'rgba8unorm-srgb-unsized': {gl: GL.SRGB_ALPHA_EXT, b: 4, c: 2, bpp: 4, gl1Ext: SRGB},
  // 8-bit formats
  r8unorm: { gl: 33321, b: 1, c: 1, rb: !0 },
  r8snorm: { gl: 36756, b: 1, c: 1, render: cm },
  r8uint: { gl: 33330, b: 1, c: 1, rb: !0 },
  r8sint: { gl: 33329, b: 1, c: 1, rb: !0 },
  // 16-bit formats
  rg8unorm: { gl: 33323, b: 2, c: 2, rb: !0 },
  rg8snorm: { gl: 36757, b: 2, c: 2, render: cm },
  rg8uint: { gl: 33336, b: 2, c: 2, rb: !0 },
  rg8sint: { gl: 33335, b: 2, c: 2, rb: !0 },
  r16uint: { gl: 33332, b: 2, c: 1, rb: !0 },
  r16sint: { gl: 33331, b: 2, c: 1, rb: !0 },
  r16float: { gl: 33325, b: 2, c: 1, render: lm, filter: "float16-filterable-webgl", rb: !0 },
  "r16unorm-webgl": { gl: 33322, b: 2, c: 1, f: Yh, rb: !0 },
  "r16snorm-webgl": { gl: 36760, b: 2, c: 1, f: hm },
  // Packed 16-bit formats
  "rgba4unorm-webgl": { gl: 32854, b: 2, c: 4, wgpu: !1, rb: !0 },
  "rgb565unorm-webgl": { gl: 36194, b: 2, c: 4, wgpu: !1, rb: !0 },
  "rgb5a1unorm-webgl": { gl: 32855, b: 2, c: 4, wgpu: !1, rb: !0 },
  // 24-bit formats
  "rgb8unorm-webgl": { gl: 32849, b: 3, c: 3, wgpu: !1 },
  "rgb8snorm-webgl": { gl: 36758, b: 3, c: 3, wgpu: !1 },
  // 32-bit formats  
  rgba8unorm: { gl: 32856, b: 4, c: 2, bpp: 4 },
  "rgba8unorm-srgb": { gl: 35907, b: 4, c: 4, bpp: 4 },
  rgba8snorm: { gl: 36759, b: 4, c: 4, render: cm },
  rgba8uint: { gl: 36220, b: 4, c: 4, bpp: 4 },
  rgba8sint: { gl: 36238, b: 4, c: 4, bpp: 4 },
  // reverse colors, webgpu only
  bgra8unorm: { b: 4, c: 4 },
  "bgra8unorm-srgb": { b: 4, c: 4 },
  rg16uint: { gl: 33338, b: 4, c: 1, bpp: 4 },
  rg16sint: { gl: 33337, b: 4, c: 2, bpp: 4 },
  // When using a WebGL 2 context and the EXT_color_buffer_float WebGL2 extension
  rg16float: { gl: 33327, bpp: 4, b: 4, c: 2, render: lm, filter: Zv, rb: !0 },
  "rg16unorm-webgl": { gl: 33324, b: 2, c: 2, render: Yh },
  "rg16snorm-webgl": { gl: 36761, b: 2, c: 2, render: hm },
  r32uint: { gl: 33334, b: 4, c: 1, bpp: 4, rb: !0 },
  r32sint: { gl: 33333, b: 4, c: 1, bpp: 4, rb: !0 },
  r32float: { gl: 33326, bpp: 4, b: 4, c: 1, render: Jh, filter: sf },
  // Packed 32-bit formats
  rgb9e5ufloat: { gl: 35901, b: 4, c: 3, p: 1, render: PO },
  // , filter: true},
  rg11b10ufloat: { gl: 35898, b: 4, c: 3, p: 1, render: Jh, rb: !0 },
  rgb10a2unorm: { gl: 32857, b: 4, c: 4, p: 1, rb: !0 },
  "rgb10a2uint-webgl": { b: 4, c: 4, gl: 36975, p: 1, wgpu: !1, bpp: 4, rb: !0 },
  // 48-bit formats
  "rgb16unorm-webgl": { gl: 32852, b: 2, c: 3, f: Yh },
  // rgb not renderable
  "rgb16snorm-webgl": { gl: 36762, b: 2, c: 3, f: Yh },
  // rgb not renderable
  // 64-bit formats
  rg32uint: { gl: 33340, b: 8, c: 2, rb: !0 },
  rg32sint: { gl: 33339, b: 8, c: 2, rb: !0 },
  rg32float: { gl: 33328, b: 8, c: 2, render: Jh, filter: sf, rb: !0 },
  rgba16uint: { gl: 36214, b: 8, c: 4, rb: !0 },
  rgba16sint: { gl: 36232, b: 8, c: 4, rb: !0 },
  rgba16float: { gl: 34842, b: 8, c: 4, render: lm, filter: Zv },
  "rgba16unorm-webgl": { gl: 32859, b: 2, c: 4, render: Yh, rb: !0 },
  "rgba16snorm-webgl": { gl: 36763, b: 2, c: 4, render: hm },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": {
    gl: 34837,
    render: Jh,
    filter: sf,
    gl2ext: NO,
    dataFormat: 6407,
    types: [5126]
  },
  // 128-bit formats
  rgba32uint: { gl: 36208, b: 16, c: 4, rb: !0 },
  rgba32sint: { gl: 36226, b: 16, c: 4, rb: !0 },
  rgba32float: { gl: 34836, b: 16, c: 4, render: Jh, filter: sf, rb: !0 },
  // Depth and stencil formats
  stencil8: { gl: 36168, b: 1, c: 1, attachment: 36128, rb: !0 },
  // 8 stencil bits
  depth16unorm: {
    gl: 33189,
    b: 2,
    c: 1,
    attachment: 36096,
    dataFormat: 6402,
    types: [5123],
    rb: !0
  },
  // 16 depth bits
  depth24plus: {
    gl: 33190,
    b: 3,
    c: 1,
    attachment: 36096,
    dataFormat: 6402,
    types: [5125]
  },
  depth32float: {
    gl: 36012,
    b: 4,
    c: 1,
    attachment: 36096,
    dataFormat: 6402,
    types: [5126],
    rb: !0
  },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": {
    gl: 35056,
    b: 4,
    c: 2,
    p: 1,
    attachment: 33306,
    rb: !0,
    depthTexture: !0,
    dataFormat: 34041,
    types: [34042]
  },
  // "depth24unorm-stencil8" feature
  "depth24unorm-stencil8": {
    gl: 35056,
    b: 4,
    c: 2,
    p: 1,
    attachment: 33306,
    dataFormat: 34041,
    types: [34042],
    rb: !0
  },
  // "depth32float-stencil8" feature - TODO below is render buffer only?
  "depth32float-stencil8": {
    gl: 36013,
    b: 5,
    c: 2,
    p: 1,
    attachment: 33306,
    dataFormat: 34041,
    types: [36269],
    rb: !0
  },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": { gl: 33776, x: lu, f: Ws },
  "bc1-rgb-unorm-srgb-webgl": { gl: 35916, x: cu, f: Ws },
  "bc1-rgba-unorm": { gl: 33777, x: lu, f: Ws },
  "bc1-rgba-unorm-srgb": { gl: 35916, x: cu, f: Ws },
  "bc2-rgba-unorm": { gl: 33778, x: lu, f: Ws },
  "bc2-rgba-unorm-srgb": { gl: 35918, x: cu, f: Ws },
  "bc3-rgba-unorm": { gl: 33779, x: lu, f: Ws },
  "bc3-rgba-unorm-srgb": { gl: 35919, x: cu, f: Ws },
  "bc4-r-unorm": { gl: 36283, x: yc, f: Ws },
  "bc4-r-snorm": { gl: 36284, x: yc, f: Ws },
  "bc5-rg-unorm": { gl: 36285, x: yc, f: Ws },
  "bc5-rg-snorm": { gl: 36286, x: yc, f: Ws },
  "bc6h-rgb-ufloat": { gl: 36495, x: bc, f: Ws },
  "bc6h-rgb-float": { gl: 36494, x: bc, f: Ws },
  "bc7-rgba-unorm": { gl: 36492, x: bc, f: Ws },
  "bc7-rgba-unorm-srgb": { gl: 36493, x: bc, f: Ws },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": { gl: 37492, f: zn },
  "etc2-rgb8unorm-srgb": { gl: 37494, f: zn },
  "etc2-rgb8a1unorm": { gl: 37496, f: zn },
  "etc2-rgb8a1unorm-srgb": { gl: 37497, f: zn },
  "etc2-rgba8unorm": { gl: 37493, f: zn },
  "etc2-rgba8unorm-srgb": { gl: 37495, f: zn },
  "eac-r11unorm": { gl: 37488, f: zn },
  "eac-r11snorm": { gl: 37489, f: zn },
  "eac-rg11unorm": { gl: 37490, f: zn },
  "eac-rg11snorm": { gl: 37491, f: zn },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": { gl: 37808, f: yi },
  "astc-4x4-unorm-srgb": { gl: 37840, f: yi },
  "astc-5x4-unorm": { gl: 37809, f: yi },
  "astc-5x4-unorm-srgb": { gl: 37841, f: yi },
  "astc-5x5-unorm": { gl: 37810, f: yi },
  "astc-5x5-unorm-srgb": { gl: 37842, f: yi },
  "astc-6x5-unorm": { gl: 37811, f: yi },
  "astc-6x5-unorm-srgb": { gl: 37843, f: yi },
  "astc-6x6-unorm": { gl: 37812, f: yi },
  "astc-6x6-unorm-srgb": { gl: 37844, f: yi },
  "astc-8x5-unorm": { gl: 37813, f: yi },
  "astc-8x5-unorm-srgb": { gl: 37845, f: yi },
  "astc-8x6-unorm": { gl: 37814, f: yi },
  "astc-8x6-unorm-srgb": { gl: 37846, f: yi },
  "astc-8x8-unorm": { gl: 37815, f: yi },
  "astc-8x8-unorm-srgb": { gl: 37847, f: yi },
  "astc-10x5-unorm": { gl: 37819, f: yi },
  "astc-10x5-unorm-srgb": { gl: 37851, f: yi },
  "astc-10x6-unorm": { gl: 37817, f: yi },
  "astc-10x6-unorm-srgb": { gl: 37849, f: yi },
  "astc-10x8-unorm": { gl: 37818, f: yi },
  "astc-10x8-unorm-srgb": { gl: 37850, f: yi },
  "astc-10x10-unorm": { gl: 37819, f: yi },
  "astc-10x10-unorm-srgb": { gl: 37851, f: yi },
  "astc-12x10-unorm": { gl: 37820, f: yi },
  "astc-12x10-unorm-srgb": { gl: 37852, f: yi },
  "astc-12x12-unorm": { gl: 37821, f: yi },
  "astc-12x12-unorm-srgb": { gl: 37853, f: yi },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": { gl: 35840, f: tf },
  "pvrtc-rgba4unorm-webgl": { gl: 35842, f: tf },
  "pvrtc-rbg2unorm-webgl": { gl: 35841, f: tf },
  "pvrtc-rgba2unorm-webgl": { gl: 35843, f: tf },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": { gl: 36196, f: MO },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": { gl: 35986, f: am },
  "atc-rgba-unorm-webgl": { gl: 35986, f: am },
  "atc-rgbai-unorm-webgl": { gl: 34798, f: am }
}, zO = {
  6403: 1,
  36244: 1,
  33319: 2,
  33320: 2,
  6407: 3,
  36248: 3,
  6408: 4,
  36249: 4,
  6402: 1,
  34041: 1,
  6406: 1,
  6409: 1,
  6410: 2
}, VO = {
  5126: 4,
  5125: 4,
  5124: 4,
  5123: 2,
  5122: 2,
  5131: 2,
  5120: 1,
  5121: 1
};
function wy(t, e, i) {
  const s = bp[e];
  if (!s || s.gl === void 0)
    return !1;
  const o = s.x || s.gl2ext;
  return o ? !!ga(t, o, i) : !0;
}
function IA(t) {
  const e = bp[t], i = e == null ? void 0 : e.gl;
  if (i === void 0)
    throw new Error(`Unsupported texture format ${t}`);
  return i;
}
function HO(t, e, i) {
  if (!wy(t, e, i) || e.startsWith("depth") || e.startsWith("stencil"))
    return !1;
  try {
    if (ww(e).signed)
      return !1;
  } catch {
    return !1;
  }
  return e.endsWith("32float") ? !!ga(t, "OES_texture_float_linear, extensions", i) : e.endsWith("16float") ? !!ga(t, "OES_texture_half_float_linear, extensions", i) : !0;
}
function jO(t, e, i) {
  return !(!wy(t, e, i) || typeof e == "number");
}
function Xf(t) {
  var o;
  const e = bp[t], i = IA(t), s = ww(t);
  return {
    format: i,
    dataFormat: (e == null ? void 0 : e.dataFormat) || GO(s.format, s.integer, s.normalized, i),
    // depth formats don't have a type
    type: s.dataType ? CA(s.dataType) : ((o = e == null ? void 0 : e.types) == null ? void 0 : o[0]) || 5121,
    // @ts-expect-error
    compressed: s.compressed
  };
}
function $O(t) {
  const e = bp[t];
  if (!(e != null && e.attachment))
    throw new Error(`${t} is not a depth stencil format`);
  return e.attachment;
}
function Yv(t) {
  const e = Xf(t), i = zO[e.dataFormat] || 4, s = VO[e.type] || 1;
  return i * s;
}
function GO(t, e, i, s) {
  if (s === 6408 || s === 6407)
    return s;
  switch (t) {
    case "r":
      return e && !i ? 36244 : 6403;
    case "rg":
      return e && !i ? 33320 : 33319;
    case "rgb":
      return e && !i ? 36248 : 6407;
    case "rgba":
      return e && !i ? 36249 : 6408;
    default:
      return 6408;
  }
}
const Qv = {
  // optional WebGPU features
  "depth-clip-control": "EXT_depth_clamp",
  // TODO these seem subtly different
  // 'timestamp-query' // GPUQueryType "timestamp-query"
  // "indirect-first-instance"
  // Textures are handled by getTextureFeatures()
  // 'depth24unorm-stencil8' // GPUTextureFormat 'depth24unorm-stencil8'
  // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
  // optional WebGL features
  "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
  "compilation-status-async-webgl": "KHR_parallel_shader_compile",
  "polygon-mode-webgl": "WEBGL_polygon_mode",
  "provoking-vertex-webgl": "WEBGL_provoking_vertex",
  "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
  "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
  "shader-conservative-depth-webgl": "EXT_conservative_depth"
  // Textures are handled by getTextureFeatures()
};
class XO extends LR {
  constructor(i, s, o) {
    super([], o);
    O(this, "gl");
    O(this, "extensions");
    O(this, "testedFeatures", /* @__PURE__ */ new Set());
    this.gl = i, this.extensions = s, ga(i, "EXT_color_buffer_float", s);
  }
  *[Symbol.iterator]() {
    const i = this.getFeatures();
    for (const s of i)
      this.has(s) && (yield s);
    return [];
  }
  has(i) {
    return this.disabledFeatures[i] ? !1 : (this.testedFeatures.has(i) || (this.testedFeatures.add(i), LO(i) && UO(this.gl, i, this.extensions) && this.features.add(i), this.getWebGLFeature(i) && this.features.add(i)), this.features.has(i));
  }
  // FOR DEVICE
  initializeFeatures() {
    const i = this.getFeatures().filter((s) => s !== "polygon-mode-webgl");
    for (const s of i)
      this.has(s);
  }
  // IMPLEMENTATION
  getFeatures() {
    return [...Object.keys(Qv), ...Object.keys(xy)];
  }
  /** Extract all WebGL features */
  getWebGLFeature(i) {
    const s = Qv[i];
    return typeof s == "string" ? !!ga(this.gl, s, this.extensions) : !!s;
  }
}
class WO extends NR {
  constructor(i) {
    super();
    // WebGL does not support compute shaders
    // PRIVATE
    O(this, "gl");
    O(this, "limits", {});
    this.gl = i;
  }
  get maxTextureDimension1D() {
    return 0;
  }
  // WebGL does not support 1D textures
  get maxTextureDimension2D() {
    return this.getParameter(3379);
  }
  get maxTextureDimension3D() {
    return this.getParameter(32883);
  }
  get maxTextureArrayLayers() {
    return this.getParameter(35071);
  }
  get maxBindGroups() {
    return 0;
  }
  get maxDynamicUniformBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxDynamicStorageBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxSampledTexturesPerShaderStage() {
    return this.getParameter(35660);
  }
  // ) TBD
  get maxSamplersPerShaderStage() {
    return this.getParameter(35661);
  }
  get maxStorageBuffersPerShaderStage() {
    return 0;
  }
  // TBD
  get maxStorageTexturesPerShaderStage() {
    return 0;
  }
  // TBD
  get maxUniformBuffersPerShaderStage() {
    return this.getParameter(35375);
  }
  get maxUniformBufferBindingSize() {
    return this.getParameter(35376);
  }
  get maxStorageBufferBindingSize() {
    return 0;
  }
  get minUniformBufferOffsetAlignment() {
    return this.getParameter(35380);
  }
  get minStorageBufferOffsetAlignment() {
    return 0;
  }
  get maxVertexBuffers() {
    return 16;
  }
  // WebGL 2 supports 16 buffers, see https://github.com/gpuweb/gpuweb/issues/4284
  get maxVertexAttributes() {
    return this.getParameter(34921);
  }
  get maxVertexBufferArrayStride() {
    return 2048;
  }
  // TBD, this is just the default value from WebGPU
  get maxInterStageShaderComponents() {
    return this.getParameter(35659);
  }
  get maxComputeWorkgroupStorageSize() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeInvocationsPerWorkgroup() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeX() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeY() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeZ() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupsPerDimension() {
    return 0;
  }
  getParameter(i) {
    return this.limits[i] === void 0 && (this.limits[i] = this.gl.getParameter(i)), this.limits[i];
  }
}
function ua(t, e, i) {
  if (qO(e))
    return i(t);
  const { nocatch: s = !0 } = e;
  yp(t), $c(t, e);
  let o;
  if (s)
    o = i(t), Cu(t);
  else
    try {
      o = i(t);
    } finally {
      Cu(t);
    }
  return o;
}
function qO(t) {
  for (const e in t)
    return !1;
  return !0;
}
function ZO(t, e, i, s) {
  if (Bf(e))
    return s(t);
  const o = t;
  yp(o.gl);
  try {
    return KO(t, e), $c(o.gl, i), s(t);
  } finally {
    Cu(o.gl);
  }
}
function KO(t, e) {
  const i = t, { gl: s } = i;
  if (e.cullMode)
    switch (e.cullMode) {
      case "none":
        s.disable(2884);
        break;
      case "front":
        s.enable(2884), s.cullFace(1028);
        break;
      case "back":
        s.enable(2884), s.cullFace(1029);
        break;
    }
  if (e.frontFace && s.frontFace(nl("frontFace", e.frontFace, {
    ccw: 2305,
    cw: 2304
  })), e.unclippedDepth && t.features.has("depth-clip-control") && s.enable(34383), e.depthBias !== void 0 && (s.enable(32823), s.polygonOffset(e.depthBias, e.depthBiasSlopeScale || 0)), e.provokingVertex && t.features.has("provoking-vertex-webgl")) {
    const l = i.getExtension("WEBGL_provoking_vertex").WEBGL_provoking_vertex, u = nl("provokingVertex", e.provokingVertex, {
      first: 36429,
      last: 36430
    });
    l == null || l.provokingVertexWEBGL(u);
  }
  if ((e.polygonMode || e.polygonOffsetLine) && t.features.has("polygon-mode-webgl")) {
    if (e.polygonMode) {
      const l = i.getExtension("WEBGL_polygon_mode").WEBGL_polygon_mode, u = nl("polygonMode", e.polygonMode, {
        fill: 6914,
        line: 6913
      });
      l == null || l.polygonModeWEBGL(1028, u), l == null || l.polygonModeWEBGL(1029, u);
    }
    e.polygonOffsetLine && s.enable(10754);
  }
  if (t.features.has("shader-clip-cull-distance-webgl") && (e.clipDistance0 && s.enable(12288), e.clipDistance1 && s.enable(12289), e.clipDistance2 && s.enable(12290), e.clipDistance3 && s.enable(12291), e.clipDistance4 && s.enable(12292), e.clipDistance5 && s.enable(12293), e.clipDistance6 && s.enable(12294), e.clipDistance7 && s.enable(12295)), e.depthWriteEnabled !== void 0 && s.depthMask(YO("depthWriteEnabled", e.depthWriteEnabled)), e.depthCompare && (e.depthCompare !== "always" ? s.enable(2929) : s.disable(2929), s.depthFunc(vg("depthCompare", e.depthCompare))), e.stencilWriteMask) {
    const o = e.stencilWriteMask;
    s.stencilMaskSeparate(1028, o), s.stencilMaskSeparate(1029, o);
  }
  if (e.stencilReadMask && $e.warn("stencilReadMask not supported under WebGL"), e.stencilCompare) {
    const o = e.stencilReadMask || 4294967295, l = vg("depthCompare", e.stencilCompare);
    e.stencilCompare !== "always" ? s.enable(2960) : s.disable(2960), s.stencilFuncSeparate(1028, l, 0, o), s.stencilFuncSeparate(1029, l, 0, o);
  }
  if (e.stencilPassOperation && e.stencilFailOperation && e.stencilDepthFailOperation) {
    const o = um("stencilPassOperation", e.stencilPassOperation), l = um("stencilFailOperation", e.stencilFailOperation), u = um("stencilDepthFailOperation", e.stencilDepthFailOperation);
    s.stencilOpSeparate(1028, l, u, o), s.stencilOpSeparate(1029, l, u, o);
  }
  if (e.blendColorOperation || e.blendAlphaOperation) {
    s.enable(3042);
    const o = ex("blendColorOperation", e.blendColorOperation || "add"), l = ex("blendAlphaOperation", e.blendAlphaOperation || "add");
    s.blendEquationSeparate(o, l);
    const u = rf("blendColorSrcFactor", e.blendColorSrcFactor || "one"), c = rf("blendColorDstFactor", e.blendColorDstFactor || "zero"), x = rf("blendAlphaSrcFactor", e.blendAlphaSrcFactor || "one"), w = rf("blendAlphaDstFactor", e.blendAlphaDstFactor || "zero");
    s.blendFuncSeparate(u, c, x, w);
  }
}
function vg(t, e) {
  return nl(t, e, {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  });
}
function um(t, e) {
  return nl(t, e, {
    keep: 7680,
    zero: 0,
    replace: 7681,
    invert: 5386,
    "increment-clamp": 7682,
    "decrement-clamp": 7683,
    "increment-wrap": 34055,
    "decrement-wrap": 34056
  });
}
function ex(t, e) {
  return nl(t, e, {
    add: 32774,
    subtract: 32778,
    "reverse-subtract": 32779,
    min: 32775,
    max: 32776
  });
}
function rf(t, e) {
  return nl(t, e, {
    one: 1,
    zero: 0,
    "src-color": 768,
    "one-minus-src-color": 769,
    "dst-color": 774,
    "one-minus-dst-color": 775,
    "src-alpha": 770,
    "one-minus-src-alpha": 771,
    "dst-alpha": 772,
    "one-minus-dst-alpha": 773,
    "src-alpha-saturated": 776,
    "constant-color": 32769,
    "one-minus-constant-color": 32770,
    "constant-alpha": 32771,
    "one-minus-constant-alpha": 32772
  });
}
function JO(t, e) {
  return `Illegal parameter ${e} for ${t}`;
}
function nl(t, e, i) {
  if (!(e in i))
    throw new Error(JO(t, e));
  return i[e];
}
function YO(t, e) {
  return e;
}
function RA(t) {
  const e = {};
  return t.addressModeU && (e[10242] = dm(t.addressModeU)), t.addressModeV && (e[10243] = dm(t.addressModeV)), t.addressModeW && (e[32882] = dm(t.addressModeW)), t.magFilter && (e[10240] = MA(t.magFilter)), (t.minFilter || t.mipmapFilter) && (e[10241] = QO(t.minFilter || "linear", t.mipmapFilter)), t.lodMinClamp !== void 0 && (e[33082] = t.lodMinClamp), t.lodMaxClamp !== void 0 && (e[33083] = t.lodMaxClamp), t.type === "comparison-sampler" && (e[34892] = 34894), t.compare && (e[34893] = vg("compare", t.compare)), t.maxAnisotropy && (e[34046] = t.maxAnisotropy), e;
}
function dm(t) {
  switch (t) {
    case "clamp-to-edge":
      return 33071;
    case "repeat":
      return 10497;
    case "mirror-repeat":
      return 33648;
  }
}
function MA(t) {
  switch (t) {
    case "nearest":
      return 9728;
    case "linear":
      return 9729;
  }
}
function QO(t, e) {
  if (!e)
    return MA(t);
  switch (t) {
    case "nearest":
      return e === "nearest" ? 9984 : 9986;
    case "linear":
      return e === "nearest" ? 9985 : 9987;
  }
}
class fa extends Vi {
  constructor(i, s = {}) {
    super(i, s);
    O(this, "device");
    O(this, "gl");
    O(this, "handle");
    /** Target in OpenGL defines the type of buffer */
    O(this, "glTarget");
    /** Usage is a hint on how frequently the buffer will be updates */
    O(this, "glUsage");
    /** Index type is needed when issuing draw calls, so we pre-compute it */
    O(this, "glIndexType", 5123);
    /** Number of bytes allocated on the GPU for this buffer */
    O(this, "byteLength");
    /** Number of bytes used */
    O(this, "bytesUsed");
    this.device = i, this.gl = this.device.gl;
    const o = typeof s == "object" ? s.handle : void 0;
    this.handle = o || this.gl.createBuffer(), i.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data }), this.glTarget = eF(this.props.usage), this.glUsage = tF(this.props.usage), this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123, s.data ? this._initWithData(s.data, s.byteOffset, s.byteLength) : this._initWithByteLength(s.byteLength || 0);
  }
  // PRIVATE METHODS
  /** Allocate a new buffer and initialize to contents of typed array */
  _initWithData(i, s = 0, o = i.byteLength + s) {
    const l = this.glTarget;
    this.gl.bindBuffer(l, this.handle), this.gl.bufferData(l, o, this.glUsage), this.gl.bufferSubData(l, s, i), this.gl.bindBuffer(l, null), this.bytesUsed = o, this.byteLength = o, this._setDebugData(i, s, o), this.trackAllocatedMemory(o);
  }
  // Allocate a GPU buffer of specified size.
  _initWithByteLength(i) {
    ri(i >= 0);
    let s = i;
    i === 0 && (s = new Float32Array(0));
    const o = this.glTarget;
    return this.gl.bindBuffer(o, this.handle), this.gl.bufferData(o, s, this.glUsage), this.gl.bindBuffer(o, null), this.bytesUsed = i, this.byteLength = i, this._setDebugData(null, 0, i), this.trackAllocatedMemory(i), this;
  }
  destroy() {
    !this.destroyed && this.handle && (this.removeStats(), this.trackDeallocatedMemory(), this.gl.deleteBuffer(this.handle), this.destroyed = !0, this.handle = null);
  }
  write(i, s = 0) {
    this.gl.bindBuffer(36663, this.handle), this.gl.bufferSubData(36663, s, i), this.gl.bindBuffer(36663, null), this._setDebugData(i, s, i.byteLength);
  }
  /** Asynchronously read data from the buffer */
  async readAsync(i = 0, s) {
    return this.readSyncWebGL(i, s);
  }
  /** Synchronously read data from the buffer. WebGL only. */
  readSyncWebGL(i = 0, s) {
    s = s ?? this.byteLength - i;
    const o = new Uint8Array(s), l = 0;
    return this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, i, o, l, s), this.gl.bindBuffer(36662, null), this._setDebugData(o, i, s), o;
  }
}
function eF(t) {
  return t & Vi.INDEX ? 34963 : t & Vi.VERTEX ? 34962 : t & Vi.UNIFORM ? 35345 : 34962;
}
function tF(t) {
  return t & Vi.INDEX || t & Vi.VERTEX ? 35044 : t & Vi.UNIFORM ? 35048 : 35044;
}
class xg extends Ff {
  constructor(i, s) {
    super(i, s);
    O(this, "device");
    O(this, "handle");
    O(this, "parameters");
    this.device = i, this.parameters = RA(s), this.handle = this.handle || this.device.gl.createSampler(), this._setSamplerParameters(this.parameters);
  }
  destroy() {
    this.handle && (this.device.gl.deleteSampler(this.handle), this.handle = void 0);
  }
  toString() {
    return `Sampler(${this.id},${JSON.stringify(this.props)})`;
  }
  /** Set sampler parameters on the sampler */
  _setSamplerParameters(i) {
    for (const [s, o] of Object.entries(i)) {
      const l = Number(s);
      switch (l) {
        case 33082:
        case 33083:
          this.device.gl.samplerParameterf(this.handle, l, o);
          break;
        default:
          this.device.gl.samplerParameteri(this.handle, l, o);
          break;
      }
    }
  }
}
class vc extends Df {
  constructor(i, s) {
    super(i, { ...Ur.defaultProps, ...s });
    O(this, "device");
    O(this, "gl");
    O(this, "handle");
    O(this, "texture");
    this.device = i, this.gl = this.device.gl, this.handle = null, this.texture = s.texture;
  }
}
const iF = {
  // deprecated
  parameters: {},
  pixelStore: {},
  pixels: null,
  border: 0,
  dataFormat: void 0,
  textureUnit: void 0,
  target: void 0
}, vu = class vu extends Ur {
  constructor(i, s) {
    var o;
    super(i, { ...iF, format: "rgba8unorm", ...s });
    O(this, "MAX_ATTRIBUTES");
    O(this, "device");
    O(this, "gl");
    O(this, "handle");
    // (TODO - currently unused in WebGL, but WebGL 2 does support sampler objects) */
    O(this, "sampler");
    O(this, "view");
    // data;
    O(this, "glFormat");
    O(this, "type");
    O(this, "dataFormat");
    O(this, "mipmaps");
    /**
     * @note `target` cannot be modified by bind:
     * textures are special because when you first bind them to a target,
     * they get special information. When you first bind a texture as a
     * GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
     * And it will always be a 2D texture; this state cannot be changed ever.
     * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
     * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
     * */
    O(this, "target");
    O(this, "textureUnit");
    /**
     * Program.draw() checks the loaded flag of all textures to avoid
     * Textures that are still loading from promises
     * Set to true as soon as texture has been initialized with valid data
     */
    O(this, "loaded", !1);
    O(this, "_video");
    this.device = i, this.gl = this.device.gl, this.handle = this.props.handle || this.gl.createTexture(), this.device.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data }), this.glFormat = 6408, this.target = sF(this.props), this.loaded = !1, typeof ((o = this.props) == null ? void 0 : o.data) == "string" && Object.assign(this.props, { data: EM(this.props.data) }), this.initialize(this.props), Object.seal(this);
  }
  destroy() {
    this.handle && (this.gl.deleteTexture(this.handle), this.removeStats(), this.trackDeallocatedMemory("Texture"), this.destroyed = !0);
  }
  toString() {
    return `Texture(${this.id},${this.width}x${this.height})`;
  }
  createView(i) {
    return new vc(this.device, { ...i, texture: this });
  }
  // eslint-disable-next-line max-statements
  initialize(i = {}) {
    if (this.props.dimension === "cube")
      return this.initializeCube(i);
    let s = i.data;
    if (s instanceof Promise)
      return s.then((me) => this.initialize(Object.assign({}, i, {
        pixels: me,
        data: me
      }))), this;
    const o = typeof HTMLVideoElement < "u" && s instanceof HTMLVideoElement;
    if (o && s.readyState < HTMLVideoElement.HAVE_METADATA)
      return this._video = null, s.addEventListener("loadeddata", () => this.initialize(i)), this;
    const { parameters: l = {} } = i, { pixels: u = null, pixelStore: c = {}, textureUnit: x = void 0, mipmaps: w = !0 } = i;
    s || (s = u);
    let { width: C, height: M, dataFormat: P, type: j, compressed: Y = !1 } = i;
    const { depth: Q = 0 } = i, _e = IA(i.format);
    return { width: C, height: M, compressed: Y, dataFormat: P, type: j } = this._deduceParameters({
      format: i.format,
      type: j,
      dataFormat: P,
      compressed: Y,
      data: s,
      width: C,
      height: M
    }), this.width = C, this.height = M, this.glFormat = _e, this.type = j, this.dataFormat = P, this.textureUnit = x, Number.isFinite(this.textureUnit) && (this.gl.activeTexture(33984 + this.textureUnit), this.gl.bindTexture(this.target, this.handle)), this.mipmaps = w, this.setImageData({
      data: s,
      width: C,
      height: M,
      depth: Q,
      format: i.format,
      type: j,
      dataFormat: P,
      // @ts-expect-error
      parameters: c,
      compressed: Y
    }), this.setSampler(i.sampler), this._setSamplerParameters(l), this.view = this.createView({ ...this.props, mipLevelCount: 1, arrayLayerCount: 1 }), w && this.device.isTextureFormatFilterable(i.format) && this.generateMipmap(), o && (this._video = {
      video: s,
      parameters: l,
      // @ts-expect-error
      lastTime: s.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? s.currentTime : -1
    }), this;
  }
  initializeCube(i) {
    const { mipmaps: s = !0, parameters: o = {} } = i;
    return this.setCubeMapImageData(i).then(() => {
      this.loaded = !0, s && this.generateMipmap(i), this.setSampler(i.sampler), this._setSamplerParameters(o);
    }), this;
  }
  setSampler(i = {}) {
    let s;
    i instanceof xg ? (this.sampler = i, s = i.props) : (this.sampler = new xg(this.device, i), s = i);
    const o = RA(s);
    return this._setSamplerParameters(o), this;
  }
  /**
   * If size has changed, reinitializes with current format
   * @note note clears image and mipmaps
   */
  resize(i) {
    const { height: s, width: o, mipmaps: l = !1 } = i;
    return o !== this.width || s !== this.height ? this.initialize({
      width: o,
      height: s,
      format: this.format,
      type: this.type,
      dataFormat: this.dataFormat,
      mipmaps: l
    }) : this;
  }
  /** Update external texture (video frame) */
  update() {
    if (this._video) {
      const { video: i, parameters: s, lastTime: o } = this._video;
      if (o === i.currentTime || i.readyState < HTMLVideoElement.HAVE_CURRENT_DATA)
        return;
      this.setSubImageData({
        data: i,
        parameters: s
      }), this.mipmaps && this.generateMipmap(), this._video.lastTime = i.currentTime;
    }
  }
  // Call to regenerate mipmaps after modifying texture(s)
  generateMipmap(i = {}) {
    return this.mipmaps = !0, this.gl.bindTexture(this.target, this.handle), ua(this.gl, i, () => {
      this.gl.generateMipmap(this.target);
    }), this.gl.bindTexture(this.target, null), this;
  }
  /*
   * Allocates storage
   * @param {*} pixels -
   *  null - create empty texture of specified format
   *  Typed array - init from image data in typed array
   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer
   *  HTMLImageElement|Image - Inits with content of image. Auto width/height
   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height
   *  HTMLVideoElement - Creates video texture. Auto width/height
   *
   * @param  width -
   * @param  height -
   * @param  mipMapLevel -
   * @param {GLenum} format - format of image data.
   * @param {GLenum} type
   *  - format of array (autodetect from type) or
   *  - (WEBGL2) format of buffer
   * @param {Number} offset - (WEBGL2) offset from start of buffer
   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.
   */
  // eslint-disable-next-line max-statements, complexity
  setImageData(i) {
    if (this.props.dimension === "3d" || this.props.dimension === "2d-array")
      return this.setImageData3D(i);
    this.trackDeallocatedMemory("Texture");
    const { target: s = this.target, pixels: o = null, level: l = 0, glFormat: u = this.glFormat, offset: c = 0, parameters: x = {} } = i;
    let { data: w = null, type: C = this.type, width: M = this.width, height: P = this.height, dataFormat: j = this.dataFormat, compressed: Y = !1 } = i;
    w || (w = o), { type: C, dataFormat: j, compressed: Y, width: M, height: P } = this._deduceParameters({
      format: this.props.format,
      type: C,
      dataFormat: j,
      compressed: Y,
      data: w,
      width: M,
      height: P
    });
    const { gl: Q } = this;
    Q.bindTexture(this.target, this.handle);
    let _e = null;
    if ({ data: w, dataType: _e } = this._getDataType({ data: w, compressed: Y }), ua(this.gl, x, () => {
      switch (_e) {
        case "null":
          Q.texImage2D(s, l, u, M, P, 0, j, C, w);
          break;
        case "typed-array":
          Q.texImage2D(
            s,
            l,
            u,
            M,
            P,
            0,
            // border (must be 0)
            j,
            C,
            w,
            c
          );
          break;
        case "buffer":
          this.device.gl.bindBuffer(35052, w.handle || w), this.device.gl.texImage2D(s, l, u, M, P, 0, j, C, c), this.device.gl.bindBuffer(35052, null);
          break;
        case "browser-object":
          Q.texImage2D(s, l, u, M, P, 0, j, C, w);
          break;
        case "compressed":
          for (const [me, we] of w.entries())
            Q.compressedTexImage2D(s, me, we.format, we.width, we.height, 0, we.data);
          break;
        default:
          ri(!1, "Unknown image data type");
      }
    }), w && w.byteLength)
      this.trackAllocatedMemory(w.byteLength, "Texture");
    else {
      const me = Yv(this.props.format);
      this.trackAllocatedMemory(this.width * this.height * me, "Texture");
    }
    return this.loaded = !0, this;
  }
  /**
   * Redefines an area of an existing texture
   * Note: does not allocate storage
   * Redefines an area of an existing texture
   */
  setSubImageData({ target: i = this.target, pixels: s = null, data: o = null, x: l = 0, y: u = 0, width: c = this.width, height: x = this.height, level: w = 0, glFormat: C = this.glFormat, type: M = this.type, dataFormat: P = this.dataFormat, compressed: j = !1, offset: Y = 0, parameters: Q = {} }) {
    if ({ type: M, dataFormat: P, compressed: j, width: c, height: x } = this._deduceParameters({
      format: this.props.format,
      type: M,
      dataFormat: P,
      compressed: j,
      data: o,
      width: c,
      height: x
    }), ri(this.depth === 1, "texSubImage not supported for 3D textures"), o || (o = s), o && o.data) {
      const _e = o;
      o = _e.data, c = _e.shape[0], x = _e.shape[1];
    }
    o instanceof fa && (o = o.handle), this.gl.bindTexture(this.target, this.handle), ua(this.gl, Q, () => {
      j ? this.gl.compressedTexSubImage2D(i, w, l, u, c, x, C, o) : o === null ? this.gl.texSubImage2D(i, w, l, u, c, x, P, M, null) : ArrayBuffer.isView(o) ? this.gl.texSubImage2D(i, w, l, u, c, x, P, M, o, Y) : typeof WebGLBuffer < "u" && o instanceof WebGLBuffer ? (this.device.gl.bindBuffer(35052, o), this.device.gl.texSubImage2D(i, w, l, u, c, x, P, M, Y), this.device.gl.bindBuffer(35052, null)) : this.device.gl.texSubImage2D(i, w, l, u, c, x, P, M, o);
    }), this.gl.bindTexture(this.target, null);
  }
  /**
   * Defines a two-dimensional texture image or cube-map texture image with
   * pixels from the current framebuffer (rather than from client memory).
   * (gl.copyTexImage2D wrapper)
   *
   * Note that binding a texture into a Framebuffer's color buffer and
   * rendering can be faster.
   */
  copyFramebuffer(i = {}) {
    return $e.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null;
  }
  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  bind(i = this.textureUnit) {
    const { gl: s } = this;
    return i !== void 0 && (this.textureUnit = i, s.activeTexture(33984 + i)), s.bindTexture(this.target, this.handle), i;
  }
  unbind(i = this.textureUnit) {
    const { gl: s } = this;
    return i !== void 0 && (this.textureUnit = i, s.activeTexture(33984 + i)), s.bindTexture(this.target, null), i;
  }
  // PRIVATE METHODS
  _getDataType({ data: i, compressed: s = !1 }) {
    return s ? { data: i, dataType: "compressed" } : i === null ? { data: i, dataType: "null" } : ArrayBuffer.isView(i) ? { data: i, dataType: "typed-array" } : i instanceof fa ? { data: i.handle, dataType: "buffer" } : typeof WebGLBuffer < "u" && i instanceof WebGLBuffer ? { data: i, dataType: "buffer" } : { data: i, dataType: "browser-object" };
  }
  // HELPER METHODS
  _deduceParameters(i) {
    const { format: s, data: o } = i;
    let { width: l, height: u, dataFormat: c, type: x, compressed: w } = i;
    const C = Xf(s);
    return c = c || C.dataFormat, x = x || C.type, w = w || C.compressed, { width: l, height: u } = this._deduceImageSize(o, l, u), { dataFormat: c, type: x, compressed: w, width: l, height: u, format: s, data: o };
  }
  // eslint-disable-next-line complexity
  _deduceImageSize(i, s, o) {
    let l;
    return typeof ImageData < "u" && i instanceof ImageData ? l = { width: i.width, height: i.height } : typeof HTMLImageElement < "u" && i instanceof HTMLImageElement ? l = { width: i.naturalWidth, height: i.naturalHeight } : typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement ? l = { width: i.width, height: i.height } : typeof ImageBitmap < "u" && i instanceof ImageBitmap ? l = { width: i.width, height: i.height } : typeof HTMLVideoElement < "u" && i instanceof HTMLVideoElement ? l = { width: i.videoWidth, height: i.videoHeight } : i ? l = { width: s, height: o } : l = { width: s >= 0 ? s : 1, height: o >= 0 ? o : 1 }, ri(l, "Could not deduced texture size"), ri(s === void 0 || l.width === s, "Deduced texture width does not match supplied width"), ri(o === void 0 || l.height === o, "Deduced texture height does not match supplied height"), l;
  }
  // CUBE MAP METHODS
  /* eslint-disable max-statements, max-len */
  async setCubeMapImageData(i) {
    const { gl: s } = this, { width: o, height: l, pixels: u, data: c, format: x = 6408, type: w = 5121 } = i, C = u || c, M = await Promise.all(vu.FACES.map((P) => {
      const j = C[P];
      return Promise.all(Array.isArray(j) ? j : [j]);
    }));
    this.bind(), vu.FACES.forEach((P, j) => {
      M[j].length > 1 && this.props.mipmaps !== !1 && $e.warn(`${this.id} has mipmap and multiple LODs.`)(), M[j].forEach((Y, Q) => {
        o && l ? s.texImage2D(P, Q, x, o, l, 0, x, w, Y) : s.texImage2D(P, Q, x, x, w, Y);
      });
    }), this.unbind();
  }
  /** @todo update this method to accept LODs */
  setImageDataForFace(i) {
    const {
      face: s,
      width: o,
      height: l,
      pixels: u,
      data: c,
      format: x = 6408,
      type: w = 5121
      // generateMipmap = false // TODO
    } = i, { gl: C } = this, M = u || c;
    return this.bind(), M instanceof Promise ? M.then((P) => this.setImageDataForFace(Object.assign({}, i, {
      face: s,
      data: P,
      pixels: P
    }))) : this.width || this.height ? C.texImage2D(s, 0, x, o, l, 0, x, w, M) : C.texImage2D(s, 0, x, x, w, M), this;
  }
  /** Image 3D copies from Typed Array or WebGLBuffer */
  setImageData3D(i) {
    const {
      level: s = 0,
      dataFormat: o,
      format: l,
      type: u,
      // = GL.UNSIGNED_BYTE,
      width: c,
      height: x,
      depth: w = 1,
      offset: C = 0,
      data: M,
      parameters: P = {}
    } = i;
    this.trackDeallocatedMemory("Texture"), this.gl.bindTexture(this.target, this.handle);
    const j = Xf(l);
    if (ua(this.gl, P, () => {
      ArrayBuffer.isView(M) && this.gl.texImage3D(
        this.target,
        s,
        j.format,
        c,
        x,
        w,
        0,
        j.dataFormat,
        j.type,
        // dataType: getWebGL,
        M
      ), M instanceof fa && (this.gl.bindBuffer(35052, M.handle), this.gl.texImage3D(this.target, s, o, c, x, w, 0, l, u, C));
    }), M && M.byteLength)
      this.trackAllocatedMemory(M.byteLength, "Texture");
    else {
      const Y = Yv(this.props.format);
      this.trackAllocatedMemory(this.width * this.height * this.depth * Y, "Texture");
    }
    return this.loaded = !0, this;
  }
  // RESOURCE METHODS
  /**
   * Sets sampler parameters on texture
   */
  _setSamplerParameters(i) {
    if (!Bf(i)) {
      rF(i), this.gl.bindTexture(this.target, this.handle);
      for (const [s, o] of Object.entries(i)) {
        const l = Number(s), u = o;
        switch (l) {
          case 33082:
          case 33083:
            this.gl.texParameterf(this.target, l, u);
            break;
          default:
            this.gl.texParameteri(this.target, l, u);
            break;
        }
      }
      this.gl.bindTexture(this.target, null);
    }
  }
};
// TODO - remove?
O(vu, "FACES", [
  34069,
  34070,
  34071,
  34072,
  34073,
  34074
]);
let qn = vu;
function sF(t) {
  switch (t.dimension) {
    case "2d":
      return 3553;
    case "cube":
      return 34067;
    case "2d-array":
      return 35866;
    case "3d":
      return 32879;
    case "1d":
    case "cube-array":
    default:
      throw new Error(t.dimension);
  }
}
function rF(t) {
  $e.log(1, "texture sampler parameters", t)();
}
class _u extends kf {
  constructor(i, s) {
    super(i, s);
    O(this, "device");
    O(this, "gl");
    O(this, "handle");
    const o = s.handle === null;
    if (this.device = i, this.gl = i.gl, this.handle = this.props.handle || o ? this.props.handle : this.gl.createFramebuffer(), !o) {
      i.setSpectorMetadata(this.handle, { id: this.props.id, props: this.props }), this.autoCreateAttachmentTextures();
      const l = this.gl.bindFramebuffer(36160, this.handle);
      for (let u = 0; u < this.colorAttachments.length; ++u) {
        const c = this.colorAttachments[u], x = 36064 + u;
        c && this._attachOne(x, c);
      }
      if (this.depthStencilAttachment && this._attachOne($O(this.depthStencilAttachment.props.format), this.depthStencilAttachment), s.check !== !1) {
        const u = this.gl.checkFramebufferStatus(36160);
        if (u !== 36053)
          throw new Error(`Framebuffer ${oF(u)}`);
      }
      this.gl.bindFramebuffer(36160, l);
    }
  }
  get texture() {
    return this.colorAttachments[0];
  }
  /** destroys any auto created resources etc. */
  destroy() {
    super.destroy(), !this.destroyed && this.handle !== null && this.gl.deleteFramebuffer(this.handle);
  }
  // PRIVATE
  /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
  createDepthStencilTexture(i) {
    return new qn(this.device, {
      id: `${this.id}-depth-stencil`,
      format: i,
      width: this.width,
      height: this.height,
      mipmaps: !1
    });
  }
  /**
   * Attachment resize is expected to be a noop if size is same
   */
  resizeAttachments(i, s) {
    if (this.handle === null)
      return this.width = this.gl.drawingBufferWidth, this.height = this.gl.drawingBufferHeight, this;
    i === void 0 && (i = this.gl.drawingBufferWidth), s === void 0 && (s = this.gl.drawingBufferHeight);
    for (const o of this.colorAttachments)
      o.texture.resize({ width: i, height: s });
    return this.depthStencilAttachment && this.depthStencilAttachment.texture.resize({ width: i, height: s }), this;
  }
  /** Attach one attachment */
  _attachOne(i, s) {
    if (Array.isArray(s)) {
      const [o, l = 0, u = 0] = s;
      return this._attachTexture(i, o, l, u), o;
    }
    if (s instanceof qn)
      return this._attachTexture(i, s, 0, 0), s;
    if (s instanceof vc) {
      const o = s;
      return this._attachTexture(i, o.texture, o.props.baseMipLevel, o.props.baseArrayLayer), s.texture;
    }
    throw new Error("attach");
  }
  // TODO - we do not seem to need render buffers in WebGL 2
  // protected _attachWEBGLRenderbuffer(attachment: GL, renderbuffer: WEBGLRenderbuffer): void {
  //   this.gl.framebufferRenderbuffer(
  //     GL.FRAMEBUFFER,
  //     attachment,
  //     GL.RENDERBUFFER,
  //     renderbuffer.handle
  //   );
  // }
  /**
   * @param attachment
   * @param texture
   * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
   * @param level = 0 - mipmapLevel
   */
  _attachTexture(i, s, o, l) {
    const { gl: u } = this.device;
    switch (u.bindTexture(s.target, s.handle), s.target) {
      case 35866:
      case 32879:
        u.framebufferTextureLayer(36160, i, s.target, l, o);
        break;
      case 34067:
        const c = nF(o);
        u.framebufferTexture2D(36160, i, c, s.handle, l);
        break;
      case 3553:
        u.framebufferTexture2D(36160, i, 3553, s.handle, l);
        break;
      default:
        ri(!1, "Illegal texture type");
    }
    u.bindTexture(s.target, null);
  }
}
function nF(t) {
  return t < 34069 ? t + 34069 : t;
}
function oF(t) {
  switch (t) {
    case 36053:
      return "success";
    case 36054:
      return "Mismatched attachments";
    case 36055:
      return "No attachments";
    case 36057:
      return "Height/width mismatch";
    case 36061:
      return "Unsupported or split attachments";
    case 36182:
      return "Samples mismatch";
    default:
      return `${t}`;
  }
}
class aF extends ty {
  constructor(i, s) {
    super(s);
    O(this, "device");
    O(this, "presentationSize");
    O(this, "_framebuffer", null);
    this.device = i, this.presentationSize = [-1, -1], this._setAutoCreatedCanvasId(`${this.device.id}-canvas`), this.update();
  }
  getCurrentFramebuffer() {
    return this.update(), this._framebuffer = this._framebuffer || new _u(this.device, { handle: null }), this._framebuffer;
  }
  /** Resizes and updates render targets if necessary */
  update() {
    const i = this.getPixelSize();
    (i[0] !== this.presentationSize[0] || i[1] !== this.presentationSize[1]) && (this.presentationSize = i, this.resize());
  }
  /**
   * Resize the canvas' drawing buffer.
   *
   * Can match the canvas CSS size, and optionally also consider devicePixelRatio
   * Can be called every frame
   *
   * Regardless of size, the drawing buffer will always be scaled to the viewport, but
   * for best visual results, usually set to either:
   *  canvas CSS width x canvas CSS height
   *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
   * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
   */
  resize(i) {
    if (this.device.gl && this.canvas) {
      const s = this.getDevicePixelRatio(i == null ? void 0 : i.useDevicePixels);
      this.setDevicePixelRatio(s, i);
      return;
    }
  }
  commit() {
  }
}
const lF = {
  spector: $e.get("spector") || $e.get("spectorjs")
}, cF = "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js", hF = 1;
let bi = null, tx = !1;
async function uF(t) {
  if (!globalThis.SPECTOR)
    try {
      await Mw(cF);
    } catch (e) {
      $e.warn(String(e));
    }
}
function dF(t) {
  if (t = { ...lF, ...t }, !(t != null && t.spector) || (!bi && globalThis.SPECTOR && ($e.probe(hF, "SPECTOR found and initialized")(), bi = new globalThis.SPECTOR.Spector(), globalThis.luma && (globalThis.luma.spector = bi)), !bi))
    return null;
  if (tx || (tx = !0, bi.spyCanvases(), bi == null || bi.onCaptureStarted.add((e) => $e.info("Spector capture started:", e)()), bi == null || bi.onCapture.add((e) => {
    $e.info("Spector capture complete:", e)(), bi == null || bi.getResultUI(), bi == null || bi.resultView.display(), bi == null || bi.resultView.addCapture(e);
  })), t != null && t.canvas) {
    if (typeof t.spector == "string" && t.spector !== t.canvas.id)
      return bi;
    bi == null || bi.startCapture(t == null ? void 0 : t.canvas, 500), new Promise((e) => setTimeout(e, 2e3)).then((e) => {
      $e.info("Spector capture stopped after 2 seconds")(), bi == null || bi.stopCapture();
    });
  }
  return bi;
}
const fF = "https://unpkg.com/webgl-debug@2.0.1/index.js";
function PA(t) {
  return t.luma = t.luma || {}, t.luma;
}
async function pF() {
  ya() && !globalThis.WebGLDebugUtils && (globalThis.global = globalThis.global || globalThis, globalThis.global.module = {}, await Mw(fF));
}
function _F(t, e = {}) {
  return t ? e.debug ? gF(t, e) : mF(t) : null;
}
function mF(t) {
  const e = PA(t);
  return e.realContext ? e.realContext : t;
}
function gF(t, e) {
  if (!globalThis.WebGLDebugUtils)
    return $e.warn("webgl-debug not loaded")(), t;
  const i = PA(t);
  if (i.debugContext)
    return i.debugContext;
  globalThis.WebGLDebugUtils.init({ ...gc, ...t });
  const s = globalThis.WebGLDebugUtils.makeDebugContext(t, yF.bind(null, e), bF.bind(null, e));
  for (const u in gc)
    !(u in s) && typeof gc[u] == "number" && (s[u] = gc[u]);
  class o {
  }
  Object.setPrototypeOf(s, Object.getPrototypeOf(t)), Object.setPrototypeOf(o, s);
  const l = Object.create(o);
  return i.realContext = t, i.debugContext = l, l.debug = !0, l;
}
function fm(t, e) {
  e = Array.from(e).map((s) => s === void 0 ? "undefined" : s);
  let i = globalThis.WebGLDebugUtils.glFunctionArgsToString(t, e);
  return i = `${i.slice(0, 100)}${i.length > 100 ? "..." : ""}`, `gl.${t}(${i})`;
}
function yF(t, e, i, s) {
  s = Array.from(s).map((c) => c === void 0 ? "undefined" : c);
  const o = globalThis.WebGLDebugUtils.glEnumToString(e), l = globalThis.WebGLDebugUtils.glFunctionArgsToString(i, s), u = `${o} in gl.${i}(${l})`;
  $e.error(u)();
  debugger;
  if (t.throwOnError)
    throw new Error(u);
}
function bF(t, e, i) {
  let s = "";
  if ($e.level >= 1 && (s = fm(e, i), $e.log(1, s)()), t.break && t.break.length > 0 && (s = s || fm(e, i), t.break.every((l) => s.indexOf(l) !== -1)))
    debugger;
  for (const o of i)
    if (o === void 0) {
      if (s = s || fm(e, i), t.throwOnError)
        throw new Error(`Undefined argument: ${s}`);
      $e.error(`Undefined argument: ${s}`)();
      debugger;
    }
}
function vF(t) {
  const e = t.split(/\r?\n/), i = [];
  for (const s of e) {
    if (s.length <= 1)
      continue;
    const o = s.split(":");
    if (o.length === 2) {
      const [M, P] = o;
      i.push({
        message: P.trim(),
        type: ix(M),
        lineNum: 0,
        linePos: 0
      });
      continue;
    }
    const [l, u, c, ...x] = o;
    let w = parseInt(c, 10);
    isNaN(w) && (w = 0);
    let C = parseInt(u, 10);
    isNaN(C) && (C = 0), i.push({
      message: x.join(":").trim(),
      type: ix(l),
      lineNum: w,
      linePos: C
      // TODO
    });
  }
  return i;
}
function ix(t) {
  const e = ["warning", "error", "info"], i = t.toLowerCase();
  return e.includes(i) ? i : "info";
}
class xF extends Of {
  constructor(i, s) {
    super(i, s);
    O(this, "device");
    O(this, "handle");
    switch (this.device = i, this.props.stage) {
      case "vertex":
        this.handle = this.props.handle || this.device.gl.createShader(35633);
        break;
      case "fragment":
        this.handle = this.props.handle || this.device.gl.createShader(35632);
        break;
      default:
        throw new Error(this.props.stage);
    }
    this._compile(this.source);
  }
  destroy() {
    this.handle && (this.removeStats(), this.device.gl.deleteShader(this.handle), this.destroyed = !0);
  }
  async getCompilationInfo() {
    return await this._waitForCompilationComplete(), this.getCompilationInfoSync();
  }
  getCompilationInfoSync() {
    const i = this.device.gl.getShaderInfoLog(this.handle);
    return vF(i);
  }
  getTranslatedSource() {
    const s = this.device.getExtension("WEBGL_debug_shaders").WEBGL_debug_shaders;
    return s == null ? void 0 : s.getTranslatedShaderSource(this.handle);
  }
  // PRIVATE METHODS
  /** Compile a shader and get compilation status */
  async _compile(i) {
    i = ((l) => l.startsWith("#version ") ? l : `#version 100
${l}`)(i);
    const { gl: o } = this.device;
    if (o.shaderSource(this.handle, i), o.compileShader(this.handle), $e.level === 0) {
      this.compilationStatus = "pending";
      return;
    }
    if (!this.device.features.has("compilation-status-async-webgl")) {
      if (this._getCompilationStatus(), this.debugShader(), this.compilationStatus === "error")
        throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
      return;
    }
    $e.once(1, "Shader compilation is asynchronous")(), await this._waitForCompilationComplete(), $e.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)(), this._getCompilationStatus(), this.debugShader();
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForCompilationComplete() {
    const i = async (l) => await new Promise((u) => setTimeout(u, l));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await i(10);
      return;
    }
    const { gl: o } = this.device;
    for (; ; ) {
      if (o.getShaderParameter(this.handle, 37297))
        return;
      await i(10);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getCompilationStatus() {
    this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
  }
}
const wF = 256, AF = 1024, TF = 16384, pm = 6144, EF = [1, 2, 4, 8];
class SF extends Ym {
  constructor(i, s) {
    super(i, s);
    O(this, "device");
    /** Parameters that should be applied before each draw call */
    O(this, "glParameters");
    this.device = i, yp(this.device.gl), this.setParameters(this.props.parameters), this.clear();
  }
  end() {
    Cu(this.device.gl);
  }
  pushDebugGroup(i) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(i) {
  }
  // beginOcclusionQuery(queryIndex: number): void;
  // endOcclusionQuery(): void;
  // executeBundles(bundles: Iterable<GPURenderBundle>): void;
  /**
   * Maps RenderPass parameters to GL parameters
   */
  setParameters(i = {}) {
    const s = { ...this.glParameters };
    this.props.framebuffer && (s.framebuffer = this.props.framebuffer), this.props.depthReadOnly && (s.depthMask = !this.props.depthReadOnly), s.stencilMask = this.props.stencilReadOnly ? 0 : 1, s[35977] = this.props.discard, i.viewport && (i.viewport.length >= 6 ? (s.viewport = i.viewport.slice(0, 4), s.depthRange = [i.viewport[4], i.viewport[5]]) : s.viewport = i.viewport), i.scissorRect && (s.scissorTest = !0, s.scissor = i.scissorRect), i.blendConstant && (s.blendColor = i.blendConstant), i.stencilReference && (console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"), i[2967] = i.stencilReference), i.colorMask && (s.colorMask = EF.map((o) => !!(o & i.colorMask))), this.glParameters = s, $c(this.device.gl, s);
  }
  beginOcclusionQuery(i) {
    const s = this.props.occlusionQuerySet;
    s == null || s.beginOcclusionQuery();
  }
  endOcclusionQuery() {
    const i = this.props.occlusionQuerySet;
    i == null || i.endOcclusionQuery();
  }
  // PRIVATE
  /**
   * Optionally clears depth, color and stencil buffers based on parameters
   */
  clear() {
    const i = { ...this.glParameters };
    let s = 0;
    this.props.clearColor !== !1 && (s |= TF, i.clearColor = this.props.clearColor), this.props.clearDepth !== !1 && (s |= wF, i.clearDepth = this.props.clearDepth), this.props.clearStencil !== !1 && (s |= AF, i.clearStencil = this.props.clearStencil), s !== 0 && ua(this.device.gl, i, () => {
      this.device.gl.clear(s);
    });
  }
  /**
   * WebGL2 - clear a specific color buffer
   */
  clearColorBuffer(i = 0, s = [0, 0, 0, 0]) {
    ua(this.device.gl, { framebuffer: this.props.framebuffer }, () => {
      switch (s.constructor) {
        case Int32Array:
          this.device.gl.clearBufferiv(pm, i, s);
          break;
        case Uint32Array:
          this.device.gl.clearBufferuiv(pm, i, s);
          break;
        case Float32Array:
        default:
          this.device.gl.clearBufferfv(pm, i, s);
          break;
      }
    });
  }
}
const CF = "Failed to deduce GL constant from typed array";
function IF(t) {
  switch (ArrayBuffer.isView(t) ? t.constructor : t) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(CF);
  }
}
function wg(t, e) {
  const { clamped: i = !0 } = e || {};
  switch (t) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return i ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}
const RF = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: !1,
  integer: !1
}, MF = {
  deprecatedProps: {
    instanced: "divisor",
    isInstanced: "divisor"
  }
};
class mu {
  constructor(...e) {
    O(this, "offset");
    O(this, "stride");
    O(this, "type");
    O(this, "size");
    O(this, "divisor");
    O(this, "normalized");
    O(this, "integer");
    O(this, "buffer");
    O(this, "index");
    e.forEach((i) => this._assign(i)), Object.freeze(this);
  }
  static getBytesPerElement(e) {
    return wg(e.type || 5126).BYTES_PER_ELEMENT;
  }
  static getBytesPerVertex(e) {
    return ri(e.size), wg(e.type || 5126).BYTES_PER_ELEMENT * e.size;
  }
  // Combines (merges) a list of accessors. On top of default values
  // Usually [programAccessor, bufferAccessor, appAccessor]
  // All props will be set in the returned object.
  // TODO check for conflicts between values in the supplied accessors
  static resolve(...e) {
    return new mu(RF, ...e);
  }
  toString() {
    return JSON.stringify(this);
  }
  // ACCESSORS
  // TODO - remove>
  get BYTES_PER_ELEMENT() {
    return mu.getBytesPerElement(this);
  }
  get BYTES_PER_VERTEX() {
    return mu.getBytesPerVertex(this);
  }
  // PRIVATE
  // eslint-disable-next-line complexity, max-statements
  _assign(e = {}) {
    return e = AM("Accessor", e, MF), e.type !== void 0 && (this.type = e.type, (e.type === 5124 || e.type === 5125) && (this.integer = !0)), e.size !== void 0 && (this.size = e.size), e.offset !== void 0 && (this.offset = e.offset), e.stride !== void 0 && (this.stride = e.stride), e.normalize !== void 0 && (this.normalized = e.normalize), e.normalized !== void 0 && (this.normalized = e.normalized), e.integer !== void 0 && (this.integer = e.integer), e.divisor !== void 0 && (this.divisor = e.divisor), e.buffer !== void 0 && (this.buffer = e.buffer), e.index !== void 0 && (typeof e.index == "boolean" ? this.index = e.index ? 1 : 0 : this.index = e.index), e.instanced !== void 0 && (this.divisor = e.instanced ? 1 : 0), e.isInstanced !== void 0 && (this.divisor = e.isInstanced ? 1 : 0), this.offset === void 0 && delete this.offset, this.stride === void 0 && delete this.stride, this.type === void 0 && delete this.type, this.size === void 0 && delete this.size, this.divisor === void 0 && delete this.divisor, this.normalized === void 0 && delete this.normalized, this.integer === void 0 && delete this.integer, this.buffer === void 0 && delete this.buffer, this.index === void 0 && delete this.index, this;
  }
}
function PF(t) {
  return BF.includes(t);
}
const BF = [
  35678,
  35680,
  35679,
  35682,
  36289,
  36292,
  36293,
  36298,
  36299,
  36300,
  36303,
  36306,
  36307,
  36308,
  36311
], BA = {
  5126: [5126, 1, "float", "f32", "float32"],
  35664: [5126, 2, "vec2", "vec2<f32>", "float32x2"],
  35665: [5126, 3, "vec3", "vec3<f32>", "float32x3"],
  35666: [5126, 4, "vec4", "vec4<f32>", "float32x4"],
  5124: [5124, 1, "int", "i32", "sint32"],
  35667: [5124, 2, "ivec2", "vec2<i32>", "sint32x2"],
  35668: [5124, 3, "ivec3", "vec3<i32>", "sint32x3"],
  35669: [5124, 4, "ivec4", "vec4<i32>", "sint32x4"],
  5125: [5125, 1, "uint", "u32", "uint32"],
  36294: [5125, 2, "uvec2", "vec2<u32>", "uint32x2"],
  36295: [5125, 3, "uvec3", "vec3<u32>", "uint32x3"],
  36296: [5125, 4, "uvec4", "vec4<u32>", "uint32x4"],
  35670: [5126, 1, "bool", "f32", "float32"],
  35671: [5126, 2, "bvec2", "vec2<f32>", "float32x2"],
  35672: [5126, 3, "bvec3", "vec3<f32>", "float32x3"],
  35673: [5126, 4, "bvec4", "vec4<f32>", "float32x4"],
  // TODO - are sizes/components below correct?
  35674: [5126, 8, "mat2", "mat2x2<f32>"],
  // 4
  35685: [5126, 8, "mat2x3", "mat2x3<f32>"],
  // 6
  35686: [5126, 8, "mat2x4", "mat2x4<f32>"],
  // 8
  35687: [5126, 12, "mat3x2", "mat3x2<f32>"],
  // 6
  35675: [5126, 12, "mat3", "mat3x3<f32>"],
  // 9
  35688: [5126, 12, "mat3x4", "mat3x4<f32>"],
  // 12
  35689: [5126, 16, "mat4x2", "mat4x2<f32>"],
  // 8
  35690: [5126, 16, "mat4x3", "mat4x3<f32>"],
  // 12
  35676: [5126, 16, "mat4", "mat4x4<f32>"]
  // 16
};
function DA(t) {
  const e = BA[t];
  if (!e)
    throw new Error("uniform");
  const [i, s, , o] = e;
  return { format: o, components: s, glType: i };
}
function DF(t) {
  const e = BA[t];
  if (!e)
    throw new Error("attribute");
  const [, i, , s, o] = e;
  return { attributeType: s, vertexFormat: o, components: i };
}
function OF(t, e) {
  const i = {
    attributes: [],
    bindings: []
  };
  i.attributes = FF(t, e);
  const s = LF(t, e);
  for (const c of s) {
    const x = c.uniforms.map((w) => ({
      name: w.name,
      format: w.format,
      byteOffset: w.byteOffset,
      byteStride: w.byteStride,
      arrayLength: w.arrayLength
    }));
    i.bindings.push({
      type: "uniform",
      name: c.name,
      location: c.location,
      visibility: (c.vertex ? 1 : 0) & (c.fragment ? 2 : 0),
      minBindingSize: c.byteLength,
      uniforms: x
    });
  }
  const o = NF(t, e);
  let l = 0;
  for (const c of o)
    if (PF(c.type)) {
      const { viewDimension: x, sampleType: w } = zF(c.type);
      i.bindings.push({
        type: "texture",
        name: c.name,
        location: l,
        viewDimension: x,
        sampleType: w
      }), c.textureUnit = l, l += 1;
    }
  o.length && (i.uniforms = o);
  const u = kF(t, e);
  return u != null && u.length && (i.varyings = u), i;
}
function FF(t, e) {
  const i = [], s = t.getProgramParameter(e, 35721);
  for (let o = 0; o < s; o++) {
    const l = t.getActiveAttrib(e, o);
    if (!l)
      throw new Error("activeInfo");
    const {
      name: u,
      type: c
      /* , size*/
    } = l, x = t.getAttribLocation(e, u);
    if (x >= 0) {
      const { attributeType: w } = DF(c), C = /instance/i.test(u) ? "instance" : "vertex";
      i.push({
        name: u,
        location: x,
        stepMode: C,
        type: w
        // size - for arrays, size is the number of elements in the array
      });
    }
  }
  return i.sort((o, l) => o.location - l.location), i;
}
function kF(t, e) {
  const i = [], s = t.getProgramParameter(e, 35971);
  for (let o = 0; o < s; o++) {
    const l = t.getTransformFeedbackVarying(e, o);
    if (!l)
      throw new Error("activeInfo");
    const { name: u, type: c, size: x } = l, { glType: w, components: C } = DA(c), M = new mu({ type: w, size: x * C }), P = { location: o, name: u, accessor: M };
    i.push(P);
  }
  return i.sort((o, l) => o.location - l.location), i;
}
function NF(t, e) {
  const i = [], s = t.getProgramParameter(e, 35718);
  for (let o = 0; o < s; o++) {
    const l = t.getActiveUniform(e, o);
    if (!l)
      throw new Error("activeInfo");
    const { name: u, size: c, type: x } = l, { name: w, isArray: C } = VF(u);
    let M = t.getUniformLocation(e, w);
    const P = {
      // WebGL locations are uniquely typed but just numbers
      location: M,
      name: w,
      size: c,
      type: x,
      isArray: C
    };
    if (i.push(P), P.size > 1)
      for (let j = 0; j < P.size; j++) {
        const Y = `${w}[${j}]`;
        M = t.getUniformLocation(e, Y);
        const Q = {
          ...P,
          name: Y,
          location: M
        };
        i.push(Q);
      }
  }
  return i;
}
function LF(t, e) {
  const i = (l, u) => t.getActiveUniformBlockParameter(e, l, u), s = [], o = t.getProgramParameter(e, 35382);
  for (let l = 0; l < o; l++) {
    const u = {
      name: t.getActiveUniformBlockName(e, l) || "",
      location: i(l, 35391),
      byteLength: i(l, 35392),
      vertex: i(l, 35396),
      fragment: i(l, 35398),
      uniformCount: i(l, 35394),
      uniforms: []
    }, c = i(l, 35395) || [], x = t.getActiveUniforms(e, c, 35383), w = t.getActiveUniforms(e, c, 35384), C = t.getActiveUniforms(e, c, 35387), M = t.getActiveUniforms(e, c, 35388);
    for (let P = 0; P < u.uniformCount; ++P) {
      const j = t.getActiveUniform(e, c[P]);
      if (!j)
        throw new Error("activeInfo");
      u.uniforms.push({
        name: j.name,
        format: DA(x[P]).format,
        type: x[P],
        arrayLength: w[P],
        byteOffset: C[P],
        byteStride: M[P]
        // matrixStride: uniformStride[i],
        // rowMajor: uniformRowMajor[i]
      });
    }
    s.push(u);
  }
  return s.sort((l, u) => l.location - u.location), s;
}
const UF = {
  35678: ["2d", "float"],
  35680: ["cube", "float"],
  35679: ["3d", "float"],
  35682: ["3d", "depth"],
  36289: ["2d-array", "float"],
  36292: ["2d-array", "depth"],
  36293: ["cube", "float"],
  36298: ["2d", "sint"],
  36299: ["3d", "sint"],
  36300: ["cube", "sint"],
  36303: ["2d-array", "uint"],
  36306: ["2d", "uint"],
  36307: ["3d", "uint"],
  36308: ["cube", "uint"],
  36311: ["2d-array", "uint"]
};
function zF(t) {
  const e = UF[t];
  if (!e)
    throw new Error("sampler");
  const [i, s] = e;
  return { viewDimension: i, sampleType: s };
}
function VF(t) {
  if (t[t.length - 1] !== "]")
    return {
      name: t,
      length: 1,
      isArray: !1
    };
  const i = /([^[]*)(\[[0-9]+\])?/.exec(t);
  if (!i || i.length < 2)
    throw new Error(`Failed to parse GLSL uniform name ${t}`);
  return {
    name: i[1],
    length: i[2] ? 1 : 0,
    isArray: !!i[2]
  };
}
function HF(t, e, i, s) {
  const o = t;
  let l = s;
  l === !0 && (l = 1), l === !1 && (l = 0);
  const u = typeof l == "number" ? [l] : l;
  switch (i) {
    case 35678:
    case 35680:
    case 35679:
    case 35682:
    case 36289:
    case 36292:
    case 36293:
    case 36298:
    case 36299:
    case 36300:
    case 36303:
    case 36306:
    case 36307:
    case 36308:
    case 36311:
      if (typeof s != "number")
        throw new Error("samplers must be set to integers");
      return t.uniform1i(e, s);
    case 5126:
      return t.uniform1fv(e, u);
    case 35664:
      return t.uniform2fv(e, u);
    case 35665:
      return t.uniform3fv(e, u);
    case 35666:
      return t.uniform4fv(e, u);
    case 5124:
      return t.uniform1iv(e, u);
    case 35667:
      return t.uniform2iv(e, u);
    case 35668:
      return t.uniform3iv(e, u);
    case 35669:
      return t.uniform4iv(e, u);
    case 35670:
      return t.uniform1iv(e, u);
    case 35671:
      return t.uniform2iv(e, u);
    case 35672:
      return t.uniform3iv(e, u);
    case 35673:
      return t.uniform4iv(e, u);
    case 5125:
      return o.uniform1uiv(e, u, 1);
    case 36294:
      return o.uniform2uiv(e, u, 2);
    case 36295:
      return o.uniform3uiv(e, u, 3);
    case 36296:
      return o.uniform4uiv(e, u, 4);
    case 35674:
      return t.uniformMatrix2fv(e, !1, u);
    case 35675:
      return t.uniformMatrix3fv(e, !1, u);
    case 35676:
      return t.uniformMatrix4fv(e, !1, u);
    case 35685:
      return o.uniformMatrix2x3fv(e, !1, u);
    case 35686:
      return o.uniformMatrix2x4fv(e, !1, u);
    case 35687:
      return o.uniformMatrix3x2fv(e, !1, u);
    case 35688:
      return o.uniformMatrix3x4fv(e, !1, u);
    case 35689:
      return o.uniformMatrix4x2fv(e, !1, u);
    case 35690:
      return o.uniformMatrix4x3fv(e, !1, u);
  }
  throw new Error("Illegal uniform");
}
function jF(t) {
  switch (t) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 3;
    case "line-loop-webgl":
      return 2;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 5;
    case "triangle-fan-webgl":
      return 6;
    default:
      throw new Error(t);
  }
}
function $F(t) {
  switch (t) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 1;
    case "line-loop-webgl":
      return 1;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 4;
    case "triangle-fan-webgl":
      return 4;
    default:
      throw new Error(t);
  }
}
const sx = 4;
class GF extends Dc {
  // TODO are these used?
  constructor(i, s) {
    super(i, s);
    /** The WebGL device that created this render pipeline */
    O(this, "device");
    /** Handle to underlying WebGL program */
    O(this, "handle");
    /** vertex shader */
    O(this, "vs");
    /** fragment shader */
    O(this, "fs");
    /** The layout extracted from shader by WebGL introspection APIs */
    O(this, "introspectedLayout");
    /** Uniforms set on this model */
    O(this, "uniforms", {});
    /** Bindings set on this model */
    O(this, "bindings", {});
    /** WebGL varyings */
    O(this, "varyings", null);
    O(this, "_uniformCount", 0);
    O(this, "_uniformSetters", {});
    this.device = i, this.handle = this.props.handle || this.device.gl.createProgram(), this.device.setSpectorMetadata(this.handle, { id: this.props.id }), this.vs = s.vs, this.fs = s.fs;
    const { varyings: o, bufferMode: l = 35981 } = s;
    switch (o && o.length > 0 && (this.varyings = o, this.device.gl.transformFeedbackVaryings(this.handle, o, l)), this._linkShaders(), $e.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.introspectedLayout = OF(this.device.gl, this.handle), $e.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.shaderLayout = hM(this.introspectedLayout, s.shaderLayout), this.props.topology) {
      case "triangle-fan-webgl":
      case "line-loop-webgl":
        $e.warn(`Primitive topology ${this.props.topology} is deprecated and will be removed in v9.1`);
        break;
    }
  }
  destroy() {
    this.handle && (this.device.gl.deleteProgram(this.handle), this.destroyed = !0);
  }
  /**
   * Bindings include: textures, samplers and uniform buffers
   * @todo needed for portable model
   */
  setBindings(i, s) {
    for (const [o, l] of Object.entries(i)) {
      const u = this.shaderLayout.bindings.find((c) => c.name === o) || this.shaderLayout.bindings.find((c) => c.name === `${o}Uniforms`);
      if (!u) {
        const c = this.shaderLayout.bindings.map((x) => `"${x.name}"`).join(", ");
        s != null && s.disableWarnings || $e.warn(`Unknown binding "${o}" in render pipeline "${this.id}", expected one of ${c}`)();
        continue;
      }
      switch (l || $e.warn(`Unsetting binding "${o}" in render pipeline "${this.id}"`)(), u.type) {
        case "uniform":
          if (!(l instanceof fa) && !(l.buffer instanceof fa))
            throw new Error("buffer value");
          break;
        case "texture":
          if (!(l instanceof vc || l instanceof qn || l instanceof _u))
            throw new Error("texture value");
          break;
        case "sampler":
          $e.warn(`Ignoring sampler ${o}`)();
          break;
        default:
          throw new Error(u.type);
      }
      this.bindings[o] = l;
    }
  }
  /** @todo needed for portable model
   * @note The WebGL API is offers many ways to draw things
   * This function unifies those ways into a single call using common parameters with sane defaults
   */
  draw(i) {
    var _e;
    const {
      renderPass: s,
      parameters: o = this.props.parameters,
      topology: l = this.props.topology,
      vertexArray: u,
      vertexCount: c,
      // indexCount,
      instanceCount: x,
      isInstanced: w = !1,
      firstVertex: C = 0,
      // firstIndex,
      // firstInstance,
      // baseVertex,
      transformFeedback: M
    } = i, P = jF(l), j = !!u.indexBuffer, Y = (_e = u.indexBuffer) == null ? void 0 : _e.glIndexType;
    if (this.linkStatus !== "success")
      return $e.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)(), !1;
    if (!this._areTexturesRenderable() || c === 0)
      return $e.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)(), !1;
    if (c === 0)
      return $e.info(2, `RenderPipeline:${this.id}.draw() aborted - no vertices to draw`)(), !0;
    this.device.gl.useProgram(this.handle), u.bindBeforeRender(s), M && M.begin(this.props.topology), this._applyBindings(), this._applyUniforms();
    const Q = s;
    return ZO(this.device, o, Q.glParameters, () => {
      j && w ? this.device.gl.drawElementsInstanced(
        P,
        c || 0,
        // indexCount?
        Y,
        C,
        x || 0
      ) : j ? this.device.gl.drawElements(P, c || 0, Y, C) : w ? this.device.gl.drawArraysInstanced(P, C, c || 0, x || 0) : this.device.gl.drawArrays(P, C, c || 0), M && M.end();
    }), u.unbindAfterRender(s), !0;
  }
  // DEPRECATED METHODS
  setUniformsWebGL(i) {
    const { bindings: s } = iy(i);
    Object.keys(s).forEach((o) => {
      $e.warn(`Unsupported value "${JSON.stringify(s[o])}" used in setUniforms() for key ${o}. Use setBindings() instead?`)();
    }), Object.assign(this.uniforms, i);
  }
  // PRIVATE METHODS
  // setAttributes(attributes: Record<string, Buffer>): void {}
  // setBindings(bindings: Record<string, Binding>): void {}
  async _linkShaders() {
    const { gl: i } = this.device;
    if (i.attachShader(this.handle, this.vs.handle), i.attachShader(this.handle, this.fs.handle), $e.time(sx, `linkProgram for ${this.id}`)(), i.linkProgram(this.handle), $e.timeEnd(sx, `linkProgram for ${this.id}`)(), $e.level, !this.device.features.has("compilation-status-async-webgl")) {
      const o = this._getLinkStatus();
      this._reportLinkStatus(o);
      return;
    }
    $e.once(1, "RenderPipeline linking is asynchronous")(), await this._waitForLinkComplete(), $e.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
    const s = this._getLinkStatus();
    this._reportLinkStatus(s);
  }
  /** Report link status. First, check for shader compilation failures if linking fails */
  _reportLinkStatus(i) {
    var s;
    switch (i) {
      case "success":
        return;
      default:
        throw this.vs.compilationStatus === "error" ? (this.vs.debugShader(), new Error(`Error during compilation of shader ${this.vs.id}`)) : ((s = this.fs) == null ? void 0 : s.compilationStatus) === "error" ? (this.fs.debugShader(), new Error(`Error during compilation of shader ${this.fs.id}`)) : new Error(`Error during ${i}: ${this.device.gl.getProgramInfoLog(this.handle)}`);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getLinkStatus() {
    const { gl: i } = this.device;
    return i.getProgramParameter(this.handle, 35714) ? (i.validateProgram(this.handle), i.getProgramParameter(this.handle, 35715) ? (this.linkStatus = "success", "success") : (this.linkStatus = "error", "validation")) : (this.linkStatus = "error", "linking");
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForLinkComplete() {
    const i = async (l) => await new Promise((u) => setTimeout(u, l));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await i(10);
      return;
    }
    const { gl: o } = this.device;
    for (; ; ) {
      if (o.getProgramParameter(this.handle, 37297))
        return;
      await i(10);
    }
  }
  /**
   * Checks if all texture-values uniforms are renderable (i.e. loaded)
   * Update a texture if needed (e.g. from video)
   * Note: This is currently done before every draw call
   */
  _areTexturesRenderable() {
    let i = !0;
    for (const [, s] of Object.entries(this.bindings))
      s instanceof qn && (s.update(), i = i && s.loaded);
    return i;
  }
  /** Apply any bindings (before each draw call) */
  _applyBindings() {
    if (this.linkStatus !== "success")
      return;
    const { gl: i } = this.device;
    i.useProgram(this.handle);
    let s = 0, o = 0;
    for (const l of this.shaderLayout.bindings) {
      const u = this.bindings[l.name] || this.bindings[l.name.replace(/Uniforms$/, "")];
      if (!u)
        throw new Error(`No value for binding ${l.name} in ${this.id}`);
      switch (l.type) {
        case "uniform":
          const { name: c } = l, x = i.getUniformBlockIndex(this.handle, c);
          if (x === 4294967295)
            throw new Error(`Invalid uniform block name ${c}`);
          i.uniformBlockBinding(this.handle, o, x), u instanceof fa ? i.bindBufferBase(35345, o, u.handle) : i.bindBufferRange(
            35345,
            o,
            // @ts-expect-error
            u.buffer.handle,
            // @ts-expect-error
            u.offset || 0,
            // @ts-expect-error
            u.size || u.buffer.byteLength - u.offset
          ), o += 1;
          break;
        case "texture":
          if (!(u instanceof vc || u instanceof qn || u instanceof _u))
            throw new Error("texture");
          let w;
          if (u instanceof vc)
            w = u.texture;
          else if (u instanceof qn)
            w = u;
          else if (u instanceof _u && u.colorAttachments[0] instanceof vc)
            $e.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(), w = u.colorAttachments[0].texture;
          else
            throw new Error("No texture");
          i.activeTexture(33984 + s), i.bindTexture(w.target, w.handle), s += 1;
          break;
        case "sampler":
          break;
        case "storage":
        case "read-only-storage":
          throw new Error(`binding type '${l.type}' not supported in WebGL`);
      }
    }
  }
  /**
   * Due to program sharing, uniforms need to be reset before every draw call
   * (though caching will avoid redundant WebGL calls)
   */
  _applyUniforms() {
    for (const i of this.shaderLayout.uniforms || []) {
      const { name: s, location: o, type: l, textureUnit: u } = i, c = this.uniforms[s] ?? u;
      c !== void 0 && HF(this.device.gl, o, l, c);
    }
  }
}
class XF extends eg {
  constructor(i) {
    super(i, {});
    O(this, "device");
    O(this, "commands", []);
    this.device = i;
  }
  submitCommands(i = this.commands) {
    for (const s of i)
      switch (s.name) {
        case "copy-buffer-to-buffer":
          WF(this.device, s.options);
          break;
        case "copy-buffer-to-texture":
          qF(this.device, s.options);
          break;
        case "copy-texture-to-buffer":
          ZF(this.device, s.options);
          break;
        case "copy-texture-to-texture":
          KF(this.device, s.options);
          break;
      }
  }
}
function WF(t, e) {
  const i = e.source, s = e.destination;
  t.gl.bindBuffer(36662, i.handle), t.gl.bindBuffer(36663, s.handle), t.gl.copyBufferSubData(36662, 36663, e.sourceOffset ?? 0, e.destinationOffset ?? 0, e.size), t.gl.bindBuffer(36662, null), t.gl.bindBuffer(36663, null);
}
function qF(t, e) {
  throw new Error("Not implemented");
}
function ZF(t, e) {
  const {
    /** Texture to copy to/from. */
    source: i,
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    mipLevel: s = 0,
    /** Defines which aspects of the texture to copy to/from. */
    aspect: o = "all",
    /** Width to copy */
    width: l = e.source.width,
    /** Height to copy */
    height: u = e.source.height,
    depthOrArrayLayers: c = 0,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    origin: x = [0, 0],
    /** Destination buffer */
    destination: w,
    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
    byteOffset: C = 0,
    /**
     * The stride, in bytes, between the beginning of each block row and the subsequent block row.
     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
     */
    bytesPerRow: M,
    /**
     * Number of block rows per single image of the texture.
     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
     * Required if there are multiple images (i.e. the copy depth is more than one).
     */
    rowsPerImage: P
  } = e;
  if (o !== "all")
    throw new Error("not supported");
  if (s !== 0 || c !== 0 || M || P)
    throw new Error("not implemented");
  const { framebuffer: j, destroyFramebuffer: Y } = OA(i);
  let Q;
  try {
    const _e = w, me = l || j.width, we = u || j.height, Ee = Xf(j.texture.props.format), Oe = Ee.dataFormat, Ne = Ee.type;
    t.gl.bindBuffer(35051, _e.handle), Q = t.gl.bindFramebuffer(36160, j.handle), t.gl.readPixels(x[0], x[1], me, we, Oe, Ne, C);
  } finally {
    t.gl.bindBuffer(35051, null), Q !== void 0 && t.gl.bindFramebuffer(36160, Q), Y && j.destroy();
  }
}
function KF(t, e) {
  const {
    /** Texture to copy to/from. */
    source: i,
    /**  Mip-map level of the texture to copy to (Default 0) */
    destinationMipLevel: s = 0,
    /** Defines which aspects of the texture to copy to/from. */
    // aspect = 'all',
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */
    origin: o = [0, 0],
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */
    destinationOrigin: l = [0, 0],
    /** Texture to copy to/from. */
    destination: u
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    // destinationMipLevel = options.mipLevel,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    // destinationOrigin = [0, 0],
    /** Defines which aspects of the texture to copy to/from. */
    // destinationAspect = options.aspect,
  } = e;
  let {
    width: c = e.destination.width,
    height: x = e.destination.height
    // depthOrArrayLayers = 0
  } = e;
  const { framebuffer: w, destroyFramebuffer: C } = OA(i), [M, P] = o, [j, Y, Q] = l, _e = t.gl.bindFramebuffer(36160, w.handle);
  let me = null, we;
  if (u instanceof qn)
    me = u, c = Number.isFinite(c) ? c : me.width, x = Number.isFinite(x) ? x : me.height, me.bind(0), we = me.target;
  else
    throw new Error("invalid destination");
  switch (we) {
    case 3553:
    case 34067:
      t.gl.copyTexSubImage2D(we, s, j, Y, M, P, c, x);
      break;
    case 35866:
    case 32879:
      t.gl.copyTexSubImage3D(we, s, j, Y, Q, M, P, c, x);
      break;
  }
  me && me.unbind(), t.gl.bindFramebuffer(36160, _e), C && w.destroy();
}
function OA(t) {
  if (t instanceof Ur) {
    const { width: e, height: i, id: s } = t;
    return { framebuffer: t.device.createFramebuffer({
      id: `framebuffer-for-${s}`,
      width: e,
      height: i,
      colorAttachments: [t]
    }), destroyFramebuffer: !0 };
  }
  return { framebuffer: t, destroyFramebuffer: !1 };
}
class JF extends Qm {
  constructor(i, s) {
    super(i, s);
    O(this, "device");
    O(this, "commandBuffer");
    this.device = i, this.commandBuffer = new XF(i);
  }
  destroy() {
  }
  finish() {
    this.commandBuffer.submitCommands();
  }
  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
  // finish(options?: {id?: string}): GPUCommandBuffer;
  copyBufferToBuffer(i) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-buffer", options: i });
  }
  copyBufferToTexture(i) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-texture", options: i });
  }
  copyTextureToBuffer(i) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-buffer", options: i });
  }
  copyTextureToTexture(i) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-texture", options: i });
  }
  pushDebugGroup(i) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(i) {
  }
  resolveQuerySet(i, s, o) {
  }
}
class Ay extends tg {
  // Create a VertexArray
  constructor(i, s) {
    super(i, s);
    O(this, "device");
    O(this, "handle");
    /** Attribute 0 buffer constant */
    O(this, "buffer", null);
    O(this, "bufferValue", null);
    this.device = i, this.handle = this.device.gl.createVertexArray();
  }
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
  static isConstantAttributeZeroSupported(i) {
    return oC() === "Chrome";
  }
  destroy() {
    var i;
    super.destroy(), this.buffer && ((i = this.buffer) == null || i.destroy()), this.handle && (this.device.gl.deleteVertexArray(this.handle), this.handle = void 0);
  }
  /**
  // Set (bind/unbind) an elements buffer, for indexed rendering.
  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
   *
   * @param elementBuffer
   */
  setIndexBuffer(i) {
    const s = i;
    if (s && s.glTarget !== 34963)
      throw new Error("Use .setBuffer()");
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34963, s ? s.handle : null), this.indexBuffer = s, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
  setBuffer(i, s) {
    const o = s;
    if (o.glTarget === 34963)
      throw new Error("Use .setIndexBuffer()");
    const { size: l, type: u, stride: c, offset: x, normalized: w, integer: C, divisor: M } = this._getAccessor(i);
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34962, o.handle), C ? this.device.gl.vertexAttribIPointer(i, l, u, c, x) : this.device.gl.vertexAttribPointer(i, l, u, w, c, x), this.device.gl.bindBuffer(34962, null), this.device.gl.enableVertexAttribArray(i), this.device.gl.vertexAttribDivisor(i, M || 0), this.attributes[i] = o, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a constant value, disables the location */
  setConstantWebGL(i, s) {
    this._enable(i, !1), this.attributes[i] = s;
  }
  bindBeforeRender() {
    this.device.gl.bindVertexArray(this.handle), this._applyConstantAttributes();
  }
  unbindAfterRender() {
    this.device.gl.bindVertexArray(null);
  }
  // Internal methods
  /**
   * Constant attributes need to be reset before every draw call
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @note Constant attributes are only supported in WebGL, not in WebGPU
   */
  _applyConstantAttributes() {
    for (let i = 0; i < this.maxVertexAttributes; ++i) {
      const s = this.attributes[i];
      ArrayBuffer.isView(s) && this.device.setConstantAttributeWebGL(i, s);
    }
  }
  /**
   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
   * @note requires vertex array to be bound
   */
  // protected _setAttributeLayout(location: number): void {
  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
  //   if (integer) {
  //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
  //   } else {
  //     // Attaches ARRAY_BUFFER with specified buffer format to location
  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
  //   }
  //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
  // }
  /** Get an accessor from the  */
  _getAccessor(i) {
    const s = this.attributeInfos[i];
    if (!s)
      throw new Error(`Unknown attribute location ${i}`);
    const o = CA(s.bufferDataType);
    return {
      size: s.bufferComponents,
      type: o,
      stride: s.byteStride,
      offset: s.byteOffset,
      normalized: s.normalized,
      // it is the shader attribute declaration, not the vertex memory format,
      // that determines if the data in the buffer will be treated as integers.
      //
      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
      // but as far as we can tell, WebGPU does not.
      integer: s.integer,
      divisor: s.stepMode === "instance" ? 1 : 0
    };
  }
  /**
   * Enabling an attribute location makes it reference the currently bound buffer
   * Disabling an attribute location makes it reference the global constant value
   * TODO - handle single values for size 1 attributes?
   * TODO - convert classic arrays based on known type?
   */
  _enable(i, s = !0) {
    const l = Ay.isConstantAttributeZeroSupported(this.device) || i !== 0;
    (s || l) && (i = Number(i), this.device.gl.bindVertexArray(this.handle), s ? this.device.gl.enableVertexAttribArray(i) : this.device.gl.disableVertexAttribArray(i), this.device.gl.bindVertexArray(null));
  }
  /**
   * Provide a means to create a buffer that is equivalent to a constant.
   * NOTE: Desktop OpenGL cannot disable attribute 0.
   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
   * this-has-significant-performance-penalty
   */
  getConstantBuffer(i, s) {
    const o = YF(s), l = o.byteLength * i, u = o.length * i;
    if (this.buffer && l !== this.buffer.byteLength)
      throw new Error(`Buffer size is immutable, byte length ${l} !== ${this.buffer.byteLength}.`);
    let c = !this.buffer;
    if (this.buffer = this.buffer || this.device.createBuffer({ byteLength: l }), c = c || !QF(o, this.bufferValue), c) {
      const x = pM(s.constructor, u);
      _M({ target: x, source: o, start: 0, count: u }), this.buffer.write(x), this.bufferValue = s;
    }
    return this.buffer;
  }
}
function YF(t) {
  return Array.isArray(t) ? new Float32Array(t) : t;
}
function QF(t, e) {
  if (!t || !e || t.length !== e.length || t.constructor !== e.constructor)
    return !1;
  for (let i = 0; i < t.length; ++i)
    if (t[i] !== e[i])
      return !1;
  return !0;
}
class ek extends ig {
  constructor(i, s) {
    super(i, s);
    O(this, "device");
    O(this, "gl");
    O(this, "handle");
    /**
     * NOTE: The Model already has this information while drawing, but
     * TransformFeedback currently needs it internally, to look up
     * varying information outside of a draw() call.
     */
    O(this, "layout");
    O(this, "buffers", {});
    O(this, "unusedBuffers", {});
    /**
     * Allows us to avoid a Chrome bug where a buffer that is already bound to a
     * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
     * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
     */
    O(this, "bindOnUse", !0);
    O(this, "_bound", !1);
    this.device = i, this.gl = i.gl, this.handle = this.props.handle || this.gl.createTransformFeedback(), this.layout = this.props.layout, s.buffers && this.setBuffers(s.buffers), Object.seal(this);
  }
  destroy() {
    this.gl.deleteTransformFeedback(this.handle), super.destroy();
  }
  begin(i = "point-list") {
    this.gl.bindTransformFeedback(36386, this.handle), this.bindOnUse && this._bindBuffers(), this.gl.beginTransformFeedback($F(i));
  }
  end() {
    this.gl.endTransformFeedback(), this.bindOnUse && this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null);
  }
  // SUBCLASS
  setBuffers(i) {
    this.buffers = {}, this.unusedBuffers = {}, this.bind(() => {
      for (const s in i)
        this.setBuffer(s, i[s]);
    });
  }
  setBuffer(i, s) {
    const o = this._getVaryingIndex(i), { buffer: l, byteLength: u, byteOffset: c } = this._getBufferRange(s);
    if (o < 0) {
      this.unusedBuffers[i] = l, $e.warn(`${this.id} unusedBuffers varying buffer ${i}`)();
      return;
    }
    this.buffers[o] = { buffer: l, byteLength: u, byteOffset: c }, this.bindOnUse || this._bindBuffer(o, l, c, u);
  }
  getBuffer(i) {
    if (rx(i))
      return this.buffers[i] || null;
    const s = this._getVaryingIndex(i);
    return s >= 0 ? this.buffers[s] : null;
  }
  bind(i = this.handle) {
    if (typeof i != "function")
      return this.gl.bindTransformFeedback(36386, i), this;
    let s;
    return this._bound ? s = i() : (this.gl.bindTransformFeedback(36386, this.handle), this._bound = !0, s = i(), this._bound = !1, this.gl.bindTransformFeedback(36386, null)), s;
  }
  unbind() {
    this.bind(null);
  }
  // PRIVATE METHODS
  /** Extract offsets for bindBufferRange */
  _getBufferRange(i) {
    if (i instanceof fa)
      return { buffer: i, byteOffset: 0, byteLength: i.byteLength };
    const { buffer: s, byteOffset: o = 0, byteLength: l = i.buffer.byteLength } = i;
    return { buffer: s, byteOffset: o, byteLength: l };
  }
  _getVaryingIndex(i) {
    if (rx(i))
      return Number(i);
    for (const s of this.layout.varyings)
      if (i === s.name)
        return s.location;
    return -1;
  }
  /**
   * Need to avoid chrome bug where buffer that is already bound to a different target
   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   */
  _bindBuffers() {
    for (const i in this.buffers) {
      const { buffer: s, byteLength: o, byteOffset: l } = this._getBufferRange(this.buffers[i]);
      this._bindBuffer(Number(i), s, l, o);
    }
  }
  _unbindBuffers() {
    for (const i in this.buffers)
      this.gl.bindBufferBase(35982, Number(i), null);
  }
  _bindBuffer(i, s, o = 0, l) {
    const u = s && s.handle;
    !u || l === void 0 ? this.gl.bindBufferBase(35982, i, u) : this.gl.bindBufferRange(35982, i, u, o, l);
  }
}
function rx(t) {
  return typeof t == "number" ? Number.isInteger(t) : /^\d+$/.test(t);
}
class tk extends sg {
  // Create a query class
  constructor(i, s) {
    super(i, s);
    O(this, "device");
    O(this, "handle");
    O(this, "target", null);
    O(this, "_queryPending", !1);
    O(this, "_pollingPromise", null);
    if (this.device = i, s.count > 1)
      throw new Error("WebGL QuerySet can only have one value");
    this.handle = this.device.gl.createQuery(), Object.seal(this);
  }
  get [Symbol.toStringTag]() {
    return "Query";
  }
  destroy() {
    this.device.gl.deleteQuery(this.handle);
  }
  // FOR RENDER PASS AND COMMAND ENCODER
  /**
   * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
   * Measures GPU time delta between this call and a matching `end` call in the
   * GPU instruction stream.
   */
  beginTimestampQuery() {
    return this._begin(35007);
  }
  endTimestampQuery() {
    this._end();
  }
  // Shortcut for occlusion queries
  beginOcclusionQuery(i) {
    return this._begin(i != null && i.conservative ? 36202 : 35887);
  }
  endOcclusionQuery() {
    this._end();
  }
  // Shortcut for transformFeedbackQuery
  beginTransformFeedbackQuery() {
    return this._begin(35976);
  }
  endTransformFeedbackQuery() {
    this._end();
  }
  async resolveQuery() {
    return [await this.pollQuery()];
  }
  // PRIVATE METHODS
  /**
   * Due to OpenGL API limitations, after calling `begin()` on one Query
   * instance, `end()` must be called on that same instance before
   * calling `begin()` on another query. While there can be multiple
   * outstanding queries representing disjoint `begin()`/`end()` intervals.
   * It is not possible to interleave or overlap `begin` and `end` calls.
   */
  _begin(i) {
    this._queryPending || (this.target = i, this.device.gl.beginQuery(this.target, this.handle));
  }
  // ends the current query
  _end() {
    this._queryPending || this.target && (this.device.gl.endQuery(this.target), this.target = null, this._queryPending = !0);
  }
  // Returns true if the query result is available
  isResultAvailable() {
    if (!this._queryPending)
      return !1;
    const i = this.device.gl.getQueryParameter(this.handle, 34919);
    return i && (this._queryPending = !1), i;
  }
  // Timing query is disjoint, i.e. results are invalid
  isTimerDisjoint() {
    return this.device.gl.getParameter(36795);
  }
  // Returns query result.
  getResult() {
    return this.device.gl.getQueryParameter(this.handle, 34918);
  }
  // Returns the query result, converted to milliseconds to match JavaScript conventions.
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  // Polls the query
  pollQuery(i = Number.POSITIVE_INFINITY) {
    if (this._pollingPromise)
      return this._pollingPromise;
    let s = 0;
    return this._pollingPromise = new Promise((o, l) => {
      const u = () => {
        this.isResultAvailable() ? (o(this.getResult()), this._pollingPromise = null) : s++ > i ? (l("Timed out"), this._pollingPromise = null) : requestAnimationFrame(u);
      };
      requestAnimationFrame(u);
    }), this._pollingPromise;
  }
}
function FA(t) {
  switch (t) {
    case 6406:
    case 33326:
    case 6403:
      return 1;
    case 33328:
    case 33319:
      return 2;
    case 6407:
    case 34837:
      return 3;
    case 6408:
    case 34836:
      return 4;
    default:
      return ri(!1), 0;
  }
}
function ik(t) {
  switch (t) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    default:
      return ri(!1), 0;
  }
}
function sk(t, e) {
  var _e, me;
  const {
    sourceX: i = 0,
    sourceY: s = 0,
    sourceFormat: o = 6408,
    sourceAttachment: l = 36064
    // TODO - support gl.readBuffer
  } = e || {};
  let {
    target: u = null,
    // following parameters are auto deduced if not provided
    sourceWidth: c,
    sourceHeight: x,
    sourceType: w
  } = e || {};
  const { framebuffer: C, deleteFramebuffer: M } = kA(t);
  ri(C);
  const { gl: P, handle: j } = C;
  c = c || C.width, x = x || C.height;
  const Y = l - 36064;
  w = w || ((me = (_e = C.colorAttachments[Y]) == null ? void 0 : _e.texture) == null ? void 0 : me.type) || 5121, u = ok(u, w, o, c, x), w = w || IF(u);
  const Q = P.bindFramebuffer(36160, j);
  return P.readPixels(i, s, c, x, o, w, u), P.bindFramebuffer(36160, Q || null), M && C.destroy(), u;
}
function rk(t, e) {
  const { target: i, sourceX: s = 0, sourceY: o = 0, sourceFormat: l = 6408, targetByteOffset: u = 0 } = e || {};
  let { sourceWidth: c, sourceHeight: x, sourceType: w } = e || {};
  const { framebuffer: C, deleteFramebuffer: M } = kA(t);
  ri(C), c = c || C.width, x = x || C.height;
  const P = C;
  w = w || 5121;
  let j = i;
  if (!j) {
    const Q = FA(l), _e = ik(w), me = u + c * x * Q * _e;
    j = P.device.createBuffer({ byteLength: me });
  }
  const Y = t.device.createCommandEncoder();
  return Y.copyTextureToBuffer({
    source: t,
    width: c,
    height: x,
    origin: [s, o],
    destination: j,
    byteOffset: u
  }), Y.destroy(), M && C.destroy(), j;
}
function kA(t) {
  return t instanceof kf ? { framebuffer: t, deleteFramebuffer: !1 } : { framebuffer: nk(t), deleteFramebuffer: !0 };
}
function nk(t, e) {
  const { device: i, width: s, height: o, id: l } = t;
  return i.createFramebuffer({
    ...e,
    id: `framebuffer-for-${l}`,
    width: s,
    height: o,
    colorAttachments: [t]
  });
}
function ok(t, e, i, s, o) {
  if (t)
    return t;
  e = e || 5121;
  const l = wg(e, { clamped: !1 }), u = FA(i);
  return new l(s * o * u);
}
const ak = 256, lk = 1024, ck = 16384, hk = "clear: bad arguments";
function uk(t, e) {
  const { framebuffer: i = null, color: s = null, depth: o = null, stencil: l = null } = e || {}, u = {};
  i && (u.framebuffer = i);
  let c = 0;
  s && (c |= ck, s !== !0 && (u.clearColor = s)), o && (c |= ak, o !== !0 && (u.clearDepth = o)), l && (c |= lk, o !== !0 && (u.clearStencil = o)), ri(c !== 0, hk);
  const x = t.gl;
  ua(x, u, () => {
    x.clear(c);
  });
}
const Qh = 1, Ya = class Ya extends Bc {
  //
  // Public API
  //
  constructor(i) {
    var x, w;
    super({ ...i, id: i.id || ba("webgl-device") });
    /** type of this device */
    O(this, "type", "webgl");
    /** The underlying WebGL context */
    O(this, "handle");
    O(this, "features");
    O(this, "limits");
    O(this, "info");
    O(this, "canvasContext");
    O(this, "lost");
    O(this, "_resolveContextLost");
    O(this, "renderPass", null);
    //
    // WebGL-only API (not part of `Device` API)
    //
    /** WebGL2 context. */
    O(this, "gl");
    O(this, "debug", !1);
    /** State used by luma.gl classes: TODO - move to canvasContext*/
    O(this, "_canvasSizeInfo", { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 });
    /** State used by luma.gl classes - TODO - not used? */
    O(this, "_extensions", {});
    O(this, "_polyfilled", !1);
    /** Instance of Spector.js (if initialized) */
    O(this, "spectorJS");
    /** Store constants */
    O(this, "_constants");
    const s = (x = i.gl) == null ? void 0 : x.device;
    if (s)
      throw new Error(`WebGL context already attached to device ${s.id}`);
    const o = ((w = i.gl) == null ? void 0 : w.canvas) || i.canvas;
    this.canvasContext = new aF(this, { ...i, canvas: o }), this.lost = new Promise((C) => {
      this._resolveContextLost = C;
    });
    let l = i.gl || null;
    if (l || (l = SO(this.canvasContext.canvas, {
      ...i,
      onContextLost: (C) => {
        var M;
        return (M = this._resolveContextLost) == null ? void 0 : M.call(this, {
          reason: "destroyed",
          message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
        });
      }
    })), !l)
      throw new Error("WebGL context creation failed");
    this.handle = l, this.gl = l, this.gl.device = this, this.gl._version = 2, i.spector && (this.spectorJS = dF({ ...this.props, canvas: this.handle.canvas })), this.info = CO(this.gl, this._extensions), this.limits = new WO(this.gl), this.features = new XO(this.gl, this._extensions, this.props.disabledFeatures), this.props.initalizeFeatures && this.features.initializeFeatures(), this.canvasContext.resize();
    const { enable: u = !0, copyState: c = !1 } = i;
    EA(this.gl, {
      enable: u,
      copyState: c,
      log: (...C) => $e.log(1, ...C)()
    }), i.debug && (this.gl = _F(this.gl, { ...i, throwOnError: !0 }), this.debug = !0, $e.level = Math.max($e.level, 1), $e.warn("WebGL debug mode activated. Performance reduced.")());
  }
  //
  // Static methods, expected to be present by `luma.createDevice()`
  //
  /** Check if WebGL 2 is available */
  static isSupported() {
    return typeof WebGL2RenderingContext < "u";
  }
  /**
   * Get a device instance from a GL context
   * Creates and instruments the device if not already created
   * @param gl
   * @returns
   */
  static attach(i) {
    if (i instanceof Ya)
      return i;
    if ((i == null ? void 0 : i.device) instanceof Bc)
      return i.device;
    if (!dk(i))
      throw new Error("Invalid WebGL2RenderingContext");
    return new Ya({ gl: i });
  }
  static async create(i = {}) {
    var c;
    $e.groupCollapsed(Qh, "WebGLDevice created")();
    const s = [];
    i.debug && s.push(pF()), i.spector && s.push(uF()), typeof i.canvas == "string" && s.push(ty.pageLoaded);
    const o = await Promise.allSettled(s);
    for (const x of o)
      x.status === "rejected" && $e.error(`Failed to initialize debug libraries ${x.reason}`)();
    if ($e.probe(Qh + 1, "DOM is loaded")(), (c = i.gl) != null && c.device)
      return $e.warn("reattaching existing device")(), Ya.attach(i.gl);
    const l = new Ya(i), u = `Created ${l.type}${l.debug ? " debug" : ""} context: ${l.info.vendor}, ${l.info.renderer} for canvas: ${l.canvasContext.id}`;
    return $e.probe(Qh, u)(), $e.table(Qh, l.info)(), $e.groupEnd(Qh)(), l;
  }
  /**
   * Destroys the context
   * @note Has no effect for WebGL browser contexts, there is no browser API for destroying contexts
   */
  destroy() {
  }
  get isLost() {
    return this.gl.isContextLost();
  }
  getSize() {
    return [this.gl.drawingBufferWidth, this.gl.drawingBufferHeight];
  }
  isTextureFormatSupported(i) {
    return wy(this.gl, i, this._extensions);
  }
  isTextureFormatFilterable(i) {
    return HO(this.gl, i, this._extensions);
  }
  isTextureFormatRenderable(i) {
    return jO(this.gl, i, this._extensions);
  }
  // IMPLEMENTATION OF ABSTRACT DEVICE
  createCanvasContext(i) {
    throw new Error("WebGL only supports a single canvas");
  }
  createBuffer(i) {
    const s = this._getBufferProps(i);
    return new fa(this, s);
  }
  _createTexture(i) {
    return new qn(this, i);
  }
  createExternalTexture(i) {
    throw new Error("createExternalTexture() not implemented");
  }
  createSampler(i) {
    return new xg(this, i);
  }
  createShader(i) {
    return new xF(this, i);
  }
  createFramebuffer(i) {
    return new _u(this, i);
  }
  createVertexArray(i) {
    return new Ay(this, i);
  }
  createTransformFeedback(i) {
    return new ek(this, i);
  }
  createQuerySet(i) {
    return new tk(this, i);
  }
  createRenderPipeline(i) {
    return new GF(this, i);
  }
  beginRenderPass(i) {
    return new SF(this, i);
  }
  createComputePipeline(i) {
    throw new Error("ComputePipeline not supported in WebGL");
  }
  beginComputePass(i) {
    throw new Error("ComputePass not supported in WebGL");
  }
  createCommandEncoder(i) {
    return new JF(this, i);
  }
  /**
   * Offscreen Canvas Support: Commit the frame
   * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
   * Chrome's offscreen canvas does not require gl.commit
   */
  submit() {
    var i;
    (i = this.renderPass) == null || i.end(), this.renderPass = null;
  }
  //
  // TEMPORARY HACKS - will be removed in v9.1
  //
  /** @deprecated - should use command encoder */
  readPixelsToArrayWebGL(i, s) {
    return sk(i, s);
  }
  /** @deprecated - should use command encoder */
  readPixelsToBufferWebGL(i, s) {
    return rk(i, s);
  }
  setParametersWebGL(i) {
    $c(this.gl, i);
  }
  getParametersWebGL(i) {
    return TA(this.gl, i);
  }
  withParametersWebGL(i, s) {
    return ua(this.gl, i, s);
  }
  clearWebGL(i) {
    uk(this, i);
  }
  resetWebGL() {
    $e.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(), bO(this.gl);
  }
  /**
   * Triggers device (or WebGL context) loss.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    var l;
    let i = !1;
    const o = this.getExtension("WEBGL_lose_context").WEBGL_lose_context;
    return o && (i = !0, o.loseContext()), (l = this._resolveContextLost) == null || l.call(this, {
      reason: "destroyed",
      message: "Application triggered context loss"
    }), i;
  }
  /** Save current WebGL context state onto an internal stack */
  pushState() {
    yp(this.gl);
  }
  /** Restores previously saved context state */
  popState() {
    Cu(this.gl);
  }
  /**
   * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
   * luma.gl ids and props can be inspected
   */
  setSpectorMetadata(i, s) {
    i.__SPECTOR_Metadata = s;
  }
  /**
   * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
   * Be aware that there are some duplicates especially for constants that are 0,
   * so this isn't guaranteed to return the right key in all cases.
   */
  getGLKey(i, s) {
    s = s || this.gl2 || this.gl;
    const o = Number(i);
    for (const l in s)
      if (s[l] === o)
        return `GL.${l}`;
    return String(i);
  }
  /**
   * Set a constant value for a location. Disabled attributes at that location will read from this value
   * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
   * so they need to be updated before every render
   * @todo - remember/cache values to avoid setting them unnecessarily?
   */
  setConstantAttributeWebGL(i, s) {
    const o = this.limits.maxVertexAttributes;
    this._constants = this._constants || new Array(o).fill(null);
    const l = this._constants[i];
    switch (l && mk(l, s) && $e.info(1, `setConstantAttributeWebGL(${i}) could have been skipped, value unchanged`)(), this._constants[i] = s, s.constructor) {
      case Float32Array:
        fk(this, i, s);
        break;
      case Int32Array:
        pk(this, i, s);
        break;
      case Uint32Array:
        _k(this, i, s);
        break;
      default:
        ri(!1);
    }
  }
  /** Ensure extensions are only requested once */
  getExtension(i) {
    return ga(this.gl, i, this._extensions), this._extensions;
  }
};
//
// Public `Device` API
//
/** type of this device */
O(Ya, "type", "webgl");
let gu = Ya;
function dk(t) {
  return typeof WebGL2RenderingContext < "u" && t instanceof WebGL2RenderingContext ? !0 : !!(t && Number.isFinite(t._version));
}
function fk(t, e, i) {
  switch (i.length) {
    case 1:
      t.gl.vertexAttrib1fv(e, i);
      break;
    case 2:
      t.gl.vertexAttrib2fv(e, i);
      break;
    case 3:
      t.gl.vertexAttrib3fv(e, i);
      break;
    case 4:
      t.gl.vertexAttrib4fv(e, i);
      break;
    default:
      ri(!1);
  }
}
function pk(t, e, i) {
  t.gl.vertexAttribI4iv(e, i);
}
function _k(t, e, i) {
  t.gl.vertexAttribI4uiv(e, i);
}
function mk(t, e) {
  if (!t || !e || t.length !== e.length || t.constructor !== e.constructor)
    return !1;
  for (let i = 0; i < t.length; ++i)
    if (t[i] !== e[i])
      return !1;
  return !0;
}
var NA = { exports: {} };
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(t) {
  (function(e, i, s, o) {
    var l = ["", "webkit", "Moz", "MS", "ms", "o"], u = i.createElement("div"), c = "function", x = Math.round, w = Math.abs, C = Date.now;
    function M(G, Z, ce) {
      return setTimeout(Ee(G, ce), Z);
    }
    function P(G, Z, ce) {
      return Array.isArray(G) ? (j(G, ce[Z], ce), !0) : !1;
    }
    function j(G, Z, ce) {
      var Me;
      if (G)
        if (G.forEach)
          G.forEach(Z, ce);
        else if (G.length !== o)
          for (Me = 0; Me < G.length; )
            Z.call(ce, G[Me], Me, G), Me++;
        else
          for (Me in G)
            G.hasOwnProperty(Me) && Z.call(ce, G[Me], Me, G);
    }
    function Y(G, Z, ce) {
      var Me = "DEPRECATED METHOD: " + Z + `
` + ce + ` AT 
`;
      return function() {
        var Ue = new Error("get-stack-trace"), lt = Ue && Ue.stack ? Ue.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", Dt = e.console && (e.console.warn || e.console.log);
        return Dt && Dt.call(e.console, Me, lt), G.apply(this, arguments);
      };
    }
    var Q;
    typeof Object.assign != "function" ? Q = function(Z) {
      if (Z === o || Z === null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var ce = Object(Z), Me = 1; Me < arguments.length; Me++) {
        var Ue = arguments[Me];
        if (Ue !== o && Ue !== null)
          for (var lt in Ue)
            Ue.hasOwnProperty(lt) && (ce[lt] = Ue[lt]);
      }
      return ce;
    } : Q = Object.assign;
    var _e = Y(function(Z, ce, Me) {
      for (var Ue = Object.keys(ce), lt = 0; lt < Ue.length; )
        (!Me || Me && Z[Ue[lt]] === o) && (Z[Ue[lt]] = ce[Ue[lt]]), lt++;
      return Z;
    }, "extend", "Use `assign`."), me = Y(function(Z, ce) {
      return _e(Z, ce, !0);
    }, "merge", "Use `assign`.");
    function we(G, Z, ce) {
      var Me = Z.prototype, Ue;
      Ue = G.prototype = Object.create(Me), Ue.constructor = G, Ue._super = Me, ce && Q(Ue, ce);
    }
    function Ee(G, Z) {
      return function() {
        return G.apply(Z, arguments);
      };
    }
    function Oe(G, Z) {
      return typeof G == c ? G.apply(Z && Z[0] || o, Z) : G;
    }
    function Ne(G, Z) {
      return G === o ? Z : G;
    }
    function ze(G, Z, ce) {
      j(at(Z), function(Me) {
        G.addEventListener(Me, ce, !1);
      });
    }
    function nt(G, Z, ce) {
      j(at(Z), function(Me) {
        G.removeEventListener(Me, ce, !1);
      });
    }
    function mt(G, Z) {
      for (; G; ) {
        if (G == Z)
          return !0;
        G = G.parentNode;
      }
      return !1;
    }
    function We(G, Z) {
      return G.indexOf(Z) > -1;
    }
    function at(G) {
      return G.trim().split(/\s+/g);
    }
    function it(G, Z, ce) {
      if (G.indexOf && !ce)
        return G.indexOf(Z);
      for (var Me = 0; Me < G.length; ) {
        if (ce && G[Me][ce] == Z || !ce && G[Me] === Z)
          return Me;
        Me++;
      }
      return -1;
    }
    function Ut(G) {
      return Array.prototype.slice.call(G, 0);
    }
    function Rt(G, Z, ce) {
      for (var Me = [], Ue = [], lt = 0; lt < G.length; ) {
        var Dt = G[lt][Z];
        it(Ue, Dt) < 0 && Me.push(G[lt]), Ue[lt] = Dt, lt++;
      }
      return Me = Me.sort(function(Gi, as) {
        return Gi[Z] > as[Z];
      }), Me;
    }
    function yt(G, Z) {
      for (var ce, Me, Ue = Z[0].toUpperCase() + Z.slice(1), lt = 0; lt < l.length; ) {
        if (ce = l[lt], Me = ce ? ce + Ue : Z, Me in G)
          return Me;
        lt++;
      }
      return o;
    }
    var di = 1;
    function Fs() {
      return di++;
    }
    function Hi(G) {
      var Z = G.ownerDocument || G;
      return Z.defaultView || Z.parentWindow || e;
    }
    var An = /mobile|tablet|ip(ad|hone|od)|android/i, Js = "ontouchstart" in e, ji = yt(e, "PointerEvent") !== o, Li = Js && An.test(navigator.userAgent), Pi = "touch", Tn = "pen", or = "mouse", ar = "kinect", En = 25, Qt = 1, Zi = 2, ni = 4, Bi = 8, Vr = 1, Ss = 2, ks = 4, Ns = 8, lr = 16, Ie = Ss | ks, Cs = Ns | lr, Sn = Ie | Cs, zt = ["x", "y"], oi = ["clientX", "clientY"];
    function Ji(G, Z) {
      var ce = this;
      this.manager = G, this.callback = Z, this.element = G.element, this.target = G.options.inputTarget, this.domHandler = function(Me) {
        Oe(G.options.enable, [G]) && ce.handler(Me);
      }, this.init();
    }
    Ji.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function() {
      },
      /**
       * bind the events
       */
      init: function() {
        this.evEl && ze(this.element, this.evEl, this.domHandler), this.evTarget && ze(this.target, this.evTarget, this.domHandler), this.evWin && ze(Hi(this.element), this.evWin, this.domHandler);
      },
      /**
       * unbind the events
       */
      destroy: function() {
        this.evEl && nt(this.element, this.evEl, this.domHandler), this.evTarget && nt(this.target, this.evTarget, this.domHandler), this.evWin && nt(Hi(this.element), this.evWin, this.domHandler);
      }
    };
    function Hr(G) {
      var Z, ce = G.options.inputClass;
      return ce ? Z = ce : ji ? Z = re : Li ? Z = le : Js ? Z = je : Z = wt, new Z(G, Ar);
    }
    function Ar(G, Z, ce) {
      var Me = ce.pointers.length, Ue = ce.changedPointers.length, lt = Z & Qt && Me - Ue === 0, Dt = Z & (ni | Bi) && Me - Ue === 0;
      ce.isFirst = !!lt, ce.isFinal = !!Dt, lt && (G.session = {}), ce.eventType = Z, Cn(G, ce), G.emit("hammer.input", ce), G.recognize(ce), G.session.prevInput = ce;
    }
    function Cn(G, Z) {
      var ce = G.session, Me = Z.pointers, Ue = Me.length;
      ce.firstInput || (ce.firstInput = In(Z)), Ue > 1 && !ce.firstMultiple ? ce.firstMultiple = In(Z) : Ue === 1 && (ce.firstMultiple = !1);
      var lt = ce.firstInput, Dt = ce.firstMultiple, $i = Dt ? Dt.center : lt.center, Gi = Z.center = He(Me);
      Z.timeStamp = C(), Z.deltaTime = Z.timeStamp - lt.timeStamp, Z.angle = cr($i, Gi), Z.distance = Is($i, Gi), Ls(ce, Z), Z.offsetDirection = Yi(Z.deltaX, Z.deltaY);
      var as = Ys(Z.deltaTime, Z.deltaX, Z.deltaY);
      Z.overallVelocityX = as.x, Z.overallVelocityY = as.y, Z.overallVelocity = w(as.x) > w(as.y) ? as.x : as.y, Z.scale = Dt ? It(Dt.pointers, Me) : 1, Z.rotation = Dt ? qe(Dt.pointers, Me) : 0, Z.maxPointers = ce.prevInput ? Z.pointers.length > ce.prevInput.maxPointers ? Z.pointers.length : ce.prevInput.maxPointers : Z.pointers.length, Jn(ce, Z);
      var Qi = G.element;
      mt(Z.srcEvent.target, Qi) && (Qi = Z.srcEvent.target), Z.target = Qi;
    }
    function Ls(G, Z) {
      var ce = Z.center, Me = G.offsetDelta || {}, Ue = G.prevDelta || {}, lt = G.prevInput || {};
      (Z.eventType === Qt || lt.eventType === ni) && (Ue = G.prevDelta = {
        x: lt.deltaX || 0,
        y: lt.deltaY || 0
      }, Me = G.offsetDelta = {
        x: ce.x,
        y: ce.y
      }), Z.deltaX = Ue.x + (ce.x - Me.x), Z.deltaY = Ue.y + (ce.y - Me.y);
    }
    function Jn(G, Z) {
      var ce = G.lastInterval || Z, Me = Z.timeStamp - ce.timeStamp, Ue, lt, Dt, $i;
      if (Z.eventType != Bi && (Me > En || ce.velocity === o)) {
        var Gi = Z.deltaX - ce.deltaX, as = Z.deltaY - ce.deltaY, Qi = Ys(Me, Gi, as);
        lt = Qi.x, Dt = Qi.y, Ue = w(Qi.x) > w(Qi.y) ? Qi.x : Qi.y, $i = Yi(Gi, as), G.lastInterval = Z;
      } else
        Ue = ce.velocity, lt = ce.velocityX, Dt = ce.velocityY, $i = ce.direction;
      Z.velocity = Ue, Z.velocityX = lt, Z.velocityY = Dt, Z.direction = $i;
    }
    function In(G) {
      for (var Z = [], ce = 0; ce < G.pointers.length; )
        Z[ce] = {
          clientX: x(G.pointers[ce].clientX),
          clientY: x(G.pointers[ce].clientY)
        }, ce++;
      return {
        timeStamp: C(),
        pointers: Z,
        center: He(Z),
        deltaX: G.deltaX,
        deltaY: G.deltaY
      };
    }
    function He(G) {
      var Z = G.length;
      if (Z === 1)
        return {
          x: x(G[0].clientX),
          y: x(G[0].clientY)
        };
      for (var ce = 0, Me = 0, Ue = 0; Ue < Z; )
        ce += G[Ue].clientX, Me += G[Ue].clientY, Ue++;
      return {
        x: x(ce / Z),
        y: x(Me / Z)
      };
    }
    function Ys(G, Z, ce) {
      return {
        x: Z / G || 0,
        y: ce / G || 0
      };
    }
    function Yi(G, Z) {
      return G === Z ? Vr : w(G) >= w(Z) ? G < 0 ? Ss : ks : Z < 0 ? Ns : lr;
    }
    function Is(G, Z, ce) {
      ce || (ce = zt);
      var Me = Z[ce[0]] - G[ce[0]], Ue = Z[ce[1]] - G[ce[1]];
      return Math.sqrt(Me * Me + Ue * Ue);
    }
    function cr(G, Z, ce) {
      ce || (ce = zt);
      var Me = Z[ce[0]] - G[ce[0]], Ue = Z[ce[1]] - G[ce[1]];
      return Math.atan2(Ue, Me) * 180 / Math.PI;
    }
    function qe(G, Z) {
      return cr(Z[1], Z[0], oi) + cr(G[1], G[0], oi);
    }
    function It(G, Z) {
      return Is(Z[0], Z[1], oi) / Is(G[0], G[1], oi);
    }
    var xt = {
      mousedown: Qt,
      mousemove: Zi,
      mouseup: ni
    }, ds = "mousedown", Qs = "mousemove mouseup";
    function wt() {
      this.evEl = ds, this.evWin = Qs, this.pressed = !1, Ji.apply(this, arguments);
    }
    we(wt, Ji, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(Z) {
        var ce = xt[Z.type];
        ce & Qt && Z.button === 0 && (this.pressed = !0), ce & Zi && Z.which !== 1 && (ce = ni), this.pressed && (ce & ni && (this.pressed = !1), this.callback(this.manager, ce, {
          pointers: [Z],
          changedPointers: [Z],
          pointerType: or,
          srcEvent: Z
        }));
      }
    });
    var hr = {
      pointerdown: Qt,
      pointermove: Zi,
      pointerup: ni,
      pointercancel: Bi,
      pointerout: Bi
    }, Tr = {
      2: Pi,
      3: Tn,
      4: or,
      5: ar
      // see https://twitter.com/jacobrossi/status/480596438489890816
    }, Er = "pointerdown", er = "pointermove pointerup pointercancel";
    e.MSPointerEvent && !e.PointerEvent && (Er = "MSPointerDown", er = "MSPointerMove MSPointerUp MSPointerCancel");
    function re() {
      this.evEl = Er, this.evWin = er, Ji.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
    }
    we(re, Ji, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(Z) {
        var ce = this.store, Me = !1, Ue = Z.type.toLowerCase().replace("ms", ""), lt = hr[Ue], Dt = Tr[Z.pointerType] || Z.pointerType, $i = Dt == Pi, Gi = it(ce, Z.pointerId, "pointerId");
        lt & Qt && (Z.button === 0 || $i) ? Gi < 0 && (ce.push(Z), Gi = ce.length - 1) : lt & (ni | Bi) && (Me = !0), !(Gi < 0) && (ce[Gi] = Z, this.callback(this.manager, lt, {
          pointers: ce,
          changedPointers: [Z],
          pointerType: Dt,
          srcEvent: Z
        }), Me && ce.splice(Gi, 1));
      }
    });
    var z = {
      touchstart: Qt,
      touchmove: Zi,
      touchend: ni,
      touchcancel: Bi
    }, U = "touchstart", W = "touchstart touchmove touchend touchcancel";
    function ee() {
      this.evTarget = U, this.evWin = W, this.started = !1, Ji.apply(this, arguments);
    }
    we(ee, Ji, {
      handler: function(Z) {
        var ce = z[Z.type];
        if (ce === Qt && (this.started = !0), !!this.started) {
          var Me = ue.call(this, Z, ce);
          ce & (ni | Bi) && Me[0].length - Me[1].length === 0 && (this.started = !1), this.callback(this.manager, ce, {
            pointers: Me[0],
            changedPointers: Me[1],
            pointerType: Pi,
            srcEvent: Z
          });
        }
      }
    });
    function ue(G, Z) {
      var ce = Ut(G.touches), Me = Ut(G.changedTouches);
      return Z & (ni | Bi) && (ce = Rt(ce.concat(Me), "identifier")), [ce, Me];
    }
    var pe = {
      touchstart: Qt,
      touchmove: Zi,
      touchend: ni,
      touchcancel: Bi
    }, xe = "touchstart touchmove touchend touchcancel";
    function le() {
      this.evTarget = xe, this.targetIds = {}, Ji.apply(this, arguments);
    }
    we(le, Ji, {
      handler: function(Z) {
        var ce = pe[Z.type], Me = Be.call(this, Z, ce);
        Me && this.callback(this.manager, ce, {
          pointers: Me[0],
          changedPointers: Me[1],
          pointerType: Pi,
          srcEvent: Z
        });
      }
    });
    function Be(G, Z) {
      var ce = Ut(G.touches), Me = this.targetIds;
      if (Z & (Qt | Zi) && ce.length === 1)
        return Me[ce[0].identifier] = !0, [ce, ce];
      var Ue, lt, Dt = Ut(G.changedTouches), $i = [], Gi = this.target;
      if (lt = ce.filter(function(as) {
        return mt(as.target, Gi);
      }), Z === Qt)
        for (Ue = 0; Ue < lt.length; )
          Me[lt[Ue].identifier] = !0, Ue++;
      for (Ue = 0; Ue < Dt.length; )
        Me[Dt[Ue].identifier] && $i.push(Dt[Ue]), Z & (ni | Bi) && delete Me[Dt[Ue].identifier], Ue++;
      if ($i.length)
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          Rt(lt.concat($i), "identifier"),
          $i
        ];
    }
    var ke = 2500, Re = 25;
    function je() {
      Ji.apply(this, arguments);
      var G = Ee(this.handler, this);
      this.touch = new le(this.manager, G), this.mouse = new wt(this.manager, G), this.primaryTouch = null, this.lastTouches = [];
    }
    we(je, Ji, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function(Z, ce, Me) {
        var Ue = Me.pointerType == Pi, lt = Me.pointerType == or;
        if (!(lt && Me.sourceCapabilities && Me.sourceCapabilities.firesTouchEvents)) {
          if (Ue)
            pt.call(this, ce, Me);
          else if (lt && Lt.call(this, Me))
            return;
          this.callback(Z, ce, Me);
        }
      },
      /**
       * remove the event listeners
       */
      destroy: function() {
        this.touch.destroy(), this.mouse.destroy();
      }
    });
    function pt(G, Z) {
      G & Qt ? (this.primaryTouch = Z.changedPointers[0].identifier, gt.call(this, Z)) : G & (ni | Bi) && gt.call(this, Z);
    }
    function gt(G) {
      var Z = G.changedPointers[0];
      if (Z.identifier === this.primaryTouch) {
        var ce = { x: Z.clientX, y: Z.clientY };
        this.lastTouches.push(ce);
        var Me = this.lastTouches, Ue = function() {
          var lt = Me.indexOf(ce);
          lt > -1 && Me.splice(lt, 1);
        };
        setTimeout(Ue, ke);
      }
    }
    function Lt(G) {
      for (var Z = G.srcEvent.clientX, ce = G.srcEvent.clientY, Me = 0; Me < this.lastTouches.length; Me++) {
        var Ue = this.lastTouches[Me], lt = Math.abs(Z - Ue.x), Dt = Math.abs(ce - Ue.y);
        if (lt <= Re && Dt <= Re)
          return !0;
      }
      return !1;
    }
    var St = yt(u.style, "touchAction"), Ft = St !== o, Pt = "compute", Ei = "auto", li = "manipulation", Ct = "none", Vt = "pan-x", Zt = "pan-y", Si = Rn();
    function Ui(G, Z) {
      this.manager = G, this.set(Z);
    }
    Ui.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function(G) {
        G == Pt && (G = this.compute()), Ft && this.manager.element.style && Si[G] && (this.manager.element.style[St] = G), this.actions = G.toLowerCase().trim();
      },
      /**
       * just re-set the touchAction value
       */
      update: function() {
        this.set(this.manager.options.touchAction);
      },
      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function() {
        var G = [];
        return j(this.manager.recognizers, function(Z) {
          Oe(Z.options.enable, [Z]) && (G = G.concat(Z.getTouchAction()));
        }), ns(G.join(" "));
      },
      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function(G) {
        var Z = G.srcEvent, ce = G.offsetDirection;
        if (this.manager.session.prevented) {
          Z.preventDefault();
          return;
        }
        var Me = this.actions, Ue = We(Me, Ct) && !Si[Ct], lt = We(Me, Zt) && !Si[Zt], Dt = We(Me, Vt) && !Si[Vt];
        if (Ue) {
          var $i = G.pointers.length === 1, Gi = G.distance < 2, as = G.deltaTime < 250;
          if ($i && Gi && as)
            return;
        }
        if (!(Dt && lt) && (Ue || lt && ce & Ie || Dt && ce & Cs))
          return this.preventSrc(Z);
      },
      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function(G) {
        this.manager.session.prevented = !0, G.preventDefault();
      }
    };
    function ns(G) {
      if (We(G, Ct))
        return Ct;
      var Z = We(G, Vt), ce = We(G, Zt);
      return Z && ce ? Ct : Z || ce ? Z ? Vt : Zt : We(G, li) ? li : Ei;
    }
    function Rn() {
      if (!Ft)
        return !1;
      var G = {}, Z = e.CSS && e.CSS.supports;
      return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(ce) {
        G[ce] = Z ? e.CSS.supports("touch-action", ce) : !0;
      }), G;
    }
    var jt = 1, fs = 2, jr = 4, Di = 8, Ci = Di, Yn = 16, Ii = 32;
    function Ri(G) {
      this.options = Q({}, this.defaults, G || {}), this.id = Fs(), this.manager = null, this.options.enable = Ne(this.options.enable, !0), this.state = jt, this.simultaneous = {}, this.requireFail = [];
    }
    Ri.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},
      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function(G) {
        return Q(this.options, G), this.manager && this.manager.touchAction.update(), this;
      },
      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function(G) {
        if (P(G, "recognizeWith", this))
          return this;
        var Z = this.simultaneous;
        return G = xi(G, this), Z[G.id] || (Z[G.id] = G, G.recognizeWith(this)), this;
      },
      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function(G) {
        return P(G, "dropRecognizeWith", this) ? this : (G = xi(G, this), delete this.simultaneous[G.id], this);
      },
      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function(G) {
        if (P(G, "requireFailure", this))
          return this;
        var Z = this.requireFail;
        return G = xi(G, this), it(Z, G) === -1 && (Z.push(G), G.requireFailure(this)), this;
      },
      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function(G) {
        if (P(G, "dropRequireFailure", this))
          return this;
        G = xi(G, this);
        var Z = it(this.requireFail, G);
        return Z > -1 && this.requireFail.splice(Z, 1), this;
      },
      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function() {
        return this.requireFail.length > 0;
      },
      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function(G) {
        return !!this.simultaneous[G.id];
      },
      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function(G) {
        var Z = this, ce = this.state;
        function Me(Ue) {
          Z.manager.emit(Ue, G);
        }
        ce < Di && Me(Z.options.event + on(ce)), Me(Z.options.event), G.additionalEvent && Me(G.additionalEvent), ce >= Di && Me(Z.options.event + on(ce));
      },
      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function(G) {
        if (this.canEmit())
          return this.emit(G);
        this.state = Ii;
      },
      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function() {
        for (var G = 0; G < this.requireFail.length; ) {
          if (!(this.requireFail[G].state & (Ii | jt)))
            return !1;
          G++;
        }
        return !0;
      },
      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function(G) {
        var Z = Q({}, G);
        if (!Oe(this.options.enable, [this, Z])) {
          this.reset(), this.state = Ii;
          return;
        }
        this.state & (Ci | Yn | Ii) && (this.state = jt), this.state = this.process(Z), this.state & (fs | jr | Di | Yn) && this.tryEmit(Z);
      },
      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function(G) {
      },
      // jshint ignore:line
      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function() {
      },
      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function() {
      }
    };
    function on(G) {
      return G & Yn ? "cancel" : G & Di ? "end" : G & jr ? "move" : G & fs ? "start" : "";
    }
    function $r(G) {
      return G == lr ? "down" : G == Ns ? "up" : G == Ss ? "left" : G == ks ? "right" : "";
    }
    function xi(G, Z) {
      var ce = Z.manager;
      return ce ? ce.get(G) : G;
    }
    function os() {
      Ri.apply(this, arguments);
    }
    we(os, Ri, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
      },
      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function(G) {
        var Z = this.options.pointers;
        return Z === 0 || G.pointers.length === Z;
      },
      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function(G) {
        var Z = this.state, ce = G.eventType, Me = Z & (fs | jr), Ue = this.attrTest(G);
        return Me && (ce & Bi || !Ue) ? Z | Yn : Me || Ue ? ce & ni ? Z | Di : Z & fs ? Z | jr : fs : Ii;
      }
    });
    function ps() {
      os.apply(this, arguments), this.pX = null, this.pY = null;
    }
    we(ps, os, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
        event: "pan",
        threshold: 10,
        pointers: 1,
        direction: Sn
      },
      getTouchAction: function() {
        var G = this.options.direction, Z = [];
        return G & Ie && Z.push(Zt), G & Cs && Z.push(Vt), Z;
      },
      directionTest: function(G) {
        var Z = this.options, ce = !0, Me = G.distance, Ue = G.direction, lt = G.deltaX, Dt = G.deltaY;
        return Ue & Z.direction || (Z.direction & Ie ? (Ue = lt === 0 ? Vr : lt < 0 ? Ss : ks, ce = lt != this.pX, Me = Math.abs(G.deltaX)) : (Ue = Dt === 0 ? Vr : Dt < 0 ? Ns : lr, ce = Dt != this.pY, Me = Math.abs(G.deltaY))), G.direction = Ue, ce && Me > Z.threshold && Ue & Z.direction;
      },
      attrTest: function(G) {
        return os.prototype.attrTest.call(this, G) && (this.state & fs || !(this.state & fs) && this.directionTest(G));
      },
      emit: function(G) {
        this.pX = G.deltaX, this.pY = G.deltaY;
        var Z = $r(G.direction);
        Z && (G.additionalEvent = this.options.event + Z), this._super.emit.call(this, G);
      }
    });
    function wi() {
      os.apply(this, arguments);
    }
    we(wi, os, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "pinch",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [Ct];
      },
      attrTest: function(G) {
        return this._super.attrTest.call(this, G) && (Math.abs(G.scale - 1) > this.options.threshold || this.state & fs);
      },
      emit: function(G) {
        if (G.scale !== 1) {
          var Z = G.scale < 1 ? "in" : "out";
          G.additionalEvent = this.options.event + Z;
        }
        this._super.emit.call(this, G);
      }
    });
    function Mn() {
      Ri.apply(this, arguments), this._timer = null, this._input = null;
    }
    we(Mn, Ri, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
        event: "press",
        pointers: 1,
        time: 251,
        // minimal time of the pointer to be pressed
        threshold: 9
        // a minimal movement is ok, but keep it low
      },
      getTouchAction: function() {
        return [Ei];
      },
      process: function(G) {
        var Z = this.options, ce = G.pointers.length === Z.pointers, Me = G.distance < Z.threshold, Ue = G.deltaTime > Z.time;
        if (this._input = G, !Me || !ce || G.eventType & (ni | Bi) && !Ue)
          this.reset();
        else if (G.eventType & Qt)
          this.reset(), this._timer = M(function() {
            this.state = Ci, this.tryEmit();
          }, Z.time, this);
        else if (G.eventType & ni)
          return Ci;
        return Ii;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function(G) {
        this.state === Ci && (G && G.eventType & ni ? this.manager.emit(this.options.event + "up", G) : (this._input.timeStamp = C(), this.manager.emit(this.options.event, this._input)));
      }
    });
    function Rs() {
      os.apply(this, arguments);
    }
    we(Rs, os, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
        event: "rotate",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [Ct];
      },
      attrTest: function(G) {
        return this._super.attrTest.call(this, G) && (Math.abs(G.rotation) > this.options.threshold || this.state & fs);
      }
    });
    function Qn() {
      os.apply(this, arguments);
    }
    we(Qn, os, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
        event: "swipe",
        threshold: 10,
        velocity: 0.3,
        direction: Ie | Cs,
        pointers: 1
      },
      getTouchAction: function() {
        return ps.prototype.getTouchAction.call(this);
      },
      attrTest: function(G) {
        var Z = this.options.direction, ce;
        return Z & (Ie | Cs) ? ce = G.overallVelocity : Z & Ie ? ce = G.overallVelocityX : Z & Cs && (ce = G.overallVelocityY), this._super.attrTest.call(this, G) && Z & G.offsetDirection && G.distance > this.options.threshold && G.maxPointers == this.options.pointers && w(ce) > this.options.velocity && G.eventType & ni;
      },
      emit: function(G) {
        var Z = $r(G.offsetDirection);
        Z && this.manager.emit(this.options.event + Z, G), this.manager.emit(this.options.event, G);
      }
    });
    function _s() {
      Ri.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;
    }
    we(_s, Ri, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "tap",
        pointers: 1,
        taps: 1,
        interval: 300,
        // max time between the multi-tap taps
        time: 250,
        // max time of the pointer to be down (like finger on the screen)
        threshold: 9,
        // a minimal movement is ok, but keep it low
        posThreshold: 10
        // a multi-tap can be a bit off the initial position
      },
      getTouchAction: function() {
        return [li];
      },
      process: function(G) {
        var Z = this.options, ce = G.pointers.length === Z.pointers, Me = G.distance < Z.threshold, Ue = G.deltaTime < Z.time;
        if (this.reset(), G.eventType & Qt && this.count === 0)
          return this.failTimeout();
        if (Me && Ue && ce) {
          if (G.eventType != ni)
            return this.failTimeout();
          var lt = this.pTime ? G.timeStamp - this.pTime < Z.interval : !0, Dt = !this.pCenter || Is(this.pCenter, G.center) < Z.posThreshold;
          this.pTime = G.timeStamp, this.pCenter = G.center, !Dt || !lt ? this.count = 1 : this.count += 1, this._input = G;
          var $i = this.count % Z.taps;
          if ($i === 0)
            return this.hasRequireFailures() ? (this._timer = M(function() {
              this.state = Ci, this.tryEmit();
            }, Z.interval, this), fs) : Ci;
        }
        return Ii;
      },
      failTimeout: function() {
        return this._timer = M(function() {
          this.state = Ii;
        }, this.options.interval, this), Ii;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function() {
        this.state == Ci && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
      }
    });
    function Gr(G, Z) {
      return Z = Z || {}, Z.recognizers = Ne(Z.recognizers, Gr.defaults.preset), new ur(G, Z);
    }
    Gr.VERSION = "2.0.7", Gr.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: !1,
      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: Pt,
      /**
       * @type {Boolean}
       * @default true
       */
      enable: !0,
      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,
      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,
      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [Rs, { enable: !1 }],
        [wi, { enable: !1 }, ["rotate"]],
        [Qn, { direction: Ie }],
        [ps, { direction: Ie }, ["swipe"]],
        [_s],
        [_s, { event: "doubletap", taps: 2 }, ["tap"]],
        [Mn]
      ],
      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: "none",
        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: "none",
        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: "none",
        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: "none",
        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: "none",
        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: "rgba(0,0,0,0)"
      }
    };
    var Eo = 1, Xr = 2;
    function ur(G, Z) {
      this.options = Q({}, Gr.defaults, Z || {}), this.options.inputTarget = this.options.inputTarget || G, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = G, this.input = Hr(this), this.touchAction = new Ui(this, this.options.touchAction), Ht(this, !0), j(this.options.recognizers, function(ce) {
        var Me = this.add(new ce[0](ce[1]));
        ce[2] && Me.recognizeWith(ce[2]), ce[3] && Me.requireFailure(ce[3]);
      }, this);
    }
    ur.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function(G) {
        return Q(this.options, G), G.touchAction && this.touchAction.update(), G.inputTarget && (this.input.destroy(), this.input.target = G.inputTarget, this.input.init()), this;
      },
      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function(G) {
        this.session.stopped = G ? Xr : Eo;
      },
      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function(G) {
        var Z = this.session;
        if (!Z.stopped) {
          this.touchAction.preventDefaults(G);
          var ce, Me = this.recognizers, Ue = Z.curRecognizer;
          (!Ue || Ue && Ue.state & Ci) && (Ue = Z.curRecognizer = null);
          for (var lt = 0; lt < Me.length; )
            ce = Me[lt], Z.stopped !== Xr && // 1
            (!Ue || ce == Ue || // 2
            ce.canRecognizeWith(Ue)) ? ce.recognize(G) : ce.reset(), !Ue && ce.state & (fs | jr | Di) && (Ue = Z.curRecognizer = ce), lt++;
        }
      },
      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function(G) {
        if (G instanceof Ri)
          return G;
        for (var Z = this.recognizers, ce = 0; ce < Z.length; ce++)
          if (Z[ce].options.event == G)
            return Z[ce];
        return null;
      },
      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function(G) {
        if (P(G, "add", this))
          return this;
        var Z = this.get(G.options.event);
        return Z && this.remove(Z), this.recognizers.push(G), G.manager = this, this.touchAction.update(), G;
      },
      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function(G) {
        if (P(G, "remove", this))
          return this;
        if (G = this.get(G), G) {
          var Z = this.recognizers, ce = it(Z, G);
          ce !== -1 && (Z.splice(ce, 1), this.touchAction.update());
        }
        return this;
      },
      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function(G, Z) {
        if (G !== o && Z !== o) {
          var ce = this.handlers;
          return j(at(G), function(Me) {
            ce[Me] = ce[Me] || [], ce[Me].push(Z);
          }), this;
        }
      },
      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function(G, Z) {
        if (G !== o) {
          var ce = this.handlers;
          return j(at(G), function(Me) {
            Z ? ce[Me] && ce[Me].splice(it(ce[Me], Z), 1) : delete ce[Me];
          }), this;
        }
      },
      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function(G, Z) {
        this.options.domEvents && va(G, Z);
        var ce = this.handlers[G] && this.handlers[G].slice();
        if (!(!ce || !ce.length)) {
          Z.type = G, Z.preventDefault = function() {
            Z.srcEvent.preventDefault();
          };
          for (var Me = 0; Me < ce.length; )
            ce[Me](Z), Me++;
        }
      },
      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function() {
        this.element && Ht(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
      }
    };
    function Ht(G, Z) {
      var ce = G.element;
      if (ce.style) {
        var Me;
        j(G.options.cssProps, function(Ue, lt) {
          Me = yt(ce.style, lt), Z ? (G.oldCssProps[Me] = ce.style[Me], ce.style[Me] = Ue) : ce.style[Me] = G.oldCssProps[Me] || "";
        }), Z || (G.oldCssProps = {});
      }
    }
    function va(G, Z) {
      var ce = i.createEvent("Event");
      ce.initEvent(G, !0, !0), ce.gesture = Z, Z.target.dispatchEvent(ce);
    }
    Q(Gr, {
      INPUT_START: Qt,
      INPUT_MOVE: Zi,
      INPUT_END: ni,
      INPUT_CANCEL: Bi,
      STATE_POSSIBLE: jt,
      STATE_BEGAN: fs,
      STATE_CHANGED: jr,
      STATE_ENDED: Di,
      STATE_RECOGNIZED: Ci,
      STATE_CANCELLED: Yn,
      STATE_FAILED: Ii,
      DIRECTION_NONE: Vr,
      DIRECTION_LEFT: Ss,
      DIRECTION_RIGHT: ks,
      DIRECTION_UP: Ns,
      DIRECTION_DOWN: lr,
      DIRECTION_HORIZONTAL: Ie,
      DIRECTION_VERTICAL: Cs,
      DIRECTION_ALL: Sn,
      Manager: ur,
      Input: Ji,
      TouchAction: Ui,
      TouchInput: le,
      MouseInput: wt,
      PointerEventInput: re,
      TouchMouseInput: je,
      SingleTouchInput: ee,
      Recognizer: Ri,
      AttrRecognizer: os,
      Tap: _s,
      Pan: ps,
      Swipe: Qn,
      Pinch: wi,
      Rotate: Rs,
      Press: Mn,
      on: ze,
      off: nt,
      each: j,
      merge: me,
      extend: _e,
      assign: Q,
      inherit: we,
      bindFn: Ee,
      prefixed: yt
    });
    var xa = typeof e < "u" ? e : typeof self < "u" ? self : {};
    xa.Hammer = Gr, t.exports ? t.exports = Gr : e[s] = Gr;
  })(window, document, "Hammer");
})(NA);
var Uu = NA.exports;
const gk = /* @__PURE__ */ z1(Uu), Vn = /* @__PURE__ */ U1({
  __proto__: null,
  default: gk
}, [Uu]), LA = 1, UA = 2, Ag = 4, yk = {
  mousedown: LA,
  mousemove: UA,
  mouseup: Ag
};
function bk(t, e) {
  for (let i = 0; i < t.length; i++)
    if (e(t[i]))
      return !0;
  return !1;
}
function vk(t) {
  const e = t.prototype.handler;
  t.prototype.handler = function(s) {
    const o = this.store;
    s.button > 0 && s.type === "pointerdown" && (bk(o, (l) => l.pointerId === s.pointerId) || o.push(s)), e.call(this, s);
  };
}
function xk(t) {
  t.prototype.handler = function(i) {
    let s = yk[i.type];
    s & LA && i.button >= 0 && (this.pressed = !0), s & UA && i.buttons === 0 && (s = Ag), this.pressed && (s & Ag && (this.pressed = !1), this.callback(this.manager, s, {
      pointers: [i],
      changedPointers: [i],
      pointerType: "mouse",
      srcEvent: i
    }));
  };
}
vk(Uu.PointerEventInput);
xk(Uu.MouseInput);
const wk = Uu.Manager;
class vp {
  constructor(e, i, s) {
    this.element = e, this.callback = i, this.options = { enable: !0, ...s };
  }
}
const Ak = Vn ? [
  [Vn.Pan, { event: "tripan", pointers: 3, threshold: 0, enable: !1 }],
  [Vn.Rotate, { enable: !1 }],
  [Vn.Pinch, { enable: !1 }],
  [Vn.Swipe, { enable: !1 }],
  [Vn.Pan, { threshold: 0, enable: !1 }],
  [Vn.Press, { enable: !1 }],
  [Vn.Tap, { event: "doubletap", taps: 2, enable: !1 }],
  // TODO - rename to 'tap' and 'singletap' in the next major release
  [Vn.Tap, { event: "anytap", enable: !1 }],
  [Vn.Tap, { enable: !1 }]
] : null, nx = {
  tripan: ["rotate", "pinch", "pan"],
  rotate: ["pinch"],
  pinch: ["pan"],
  pan: ["press", "doubletap", "anytap", "tap"],
  doubletap: ["anytap"],
  anytap: ["tap"]
}, Tk = {
  doubletap: ["tap"]
}, Ek = {
  pointerdown: "pointerdown",
  pointermove: "pointermove",
  pointerup: "pointerup",
  touchstart: "pointerdown",
  touchmove: "pointermove",
  touchend: "pointerup",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup"
}, Ty = {
  KEY_EVENTS: ["keydown", "keyup"],
  MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
  WHEEL_EVENTS: [
    // Chrome, Safari
    "wheel",
    // IE
    "mousewheel"
  ]
}, Sk = {
  tap: "tap",
  anytap: "anytap",
  doubletap: "doubletap",
  press: "press",
  pinch: "pinch",
  pinchin: "pinch",
  pinchout: "pinch",
  pinchstart: "pinch",
  pinchmove: "pinch",
  pinchend: "pinch",
  pinchcancel: "pinch",
  rotate: "rotate",
  rotatestart: "rotate",
  rotatemove: "rotate",
  rotateend: "rotate",
  rotatecancel: "rotate",
  tripan: "tripan",
  tripanstart: "tripan",
  tripanmove: "tripan",
  tripanup: "tripan",
  tripandown: "tripan",
  tripanleft: "tripan",
  tripanright: "tripan",
  tripanend: "tripan",
  tripancancel: "tripan",
  pan: "pan",
  panstart: "pan",
  panmove: "pan",
  panup: "pan",
  pandown: "pan",
  panleft: "pan",
  panright: "pan",
  panend: "pan",
  pancancel: "pan",
  swipe: "swipe",
  swipeleft: "swipe",
  swiperight: "swipe",
  swipeup: "swipe",
  swipedown: "swipe"
}, ox = {
  click: "tap",
  anyclick: "anytap",
  dblclick: "doubletap",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup",
  mouseover: "pointerover",
  mouseout: "pointerout",
  mouseleave: "pointerleave"
}, Ck = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", xc = typeof window < "u" ? window : global;
let Tg = !1;
try {
  const t = {
    // This function will be called when the browser
    // attempts to access the passive property.
    get passive() {
      return Tg = !0, !0;
    }
  };
  xc.addEventListener("test", null, t), xc.removeEventListener("test", null);
} catch {
  Tg = !1;
}
const Ik = Ck.indexOf("firefox") !== -1, { WHEEL_EVENTS: Rk } = Ty, ax = "wheel", lx = 4.000244140625, Mk = 40, Pk = 0.25;
class Bk extends vp {
  constructor(e, i, s) {
    super(e, i, s), this.handleEvent = (o) => {
      if (!this.options.enable)
        return;
      let l = o.deltaY;
      xc.WheelEvent && (Ik && o.deltaMode === xc.WheelEvent.DOM_DELTA_PIXEL && (l /= xc.devicePixelRatio), o.deltaMode === xc.WheelEvent.DOM_DELTA_LINE && (l *= Mk)), l !== 0 && l % lx === 0 && (l = Math.floor(l / lx)), o.shiftKey && l && (l = l * Pk), this.callback({
        type: ax,
        center: {
          x: o.clientX,
          y: o.clientY
        },
        delta: -l,
        srcEvent: o,
        pointerType: "mouse",
        target: o.target
      });
    }, this.events = (this.options.events || []).concat(Rk), this.events.forEach((o) => e.addEventListener(o, this.handleEvent, Tg ? { passive: !1 } : !1));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, i) {
    e === ax && (this.options.enable = i);
  }
}
const { MOUSE_EVENTS: Dk } = Ty, cx = "pointermove", hx = "pointerover", ux = "pointerout", dx = "pointerenter", fx = "pointerleave";
class Ok extends vp {
  constructor(e, i, s) {
    super(e, i, s), this.handleEvent = (l) => {
      this.handleOverEvent(l), this.handleOutEvent(l), this.handleEnterEvent(l), this.handleLeaveEvent(l), this.handleMoveEvent(l);
    }, this.pressed = !1;
    const { enable: o } = this.options;
    this.enableMoveEvent = o, this.enableLeaveEvent = o, this.enableEnterEvent = o, this.enableOutEvent = o, this.enableOverEvent = o, this.events = (this.options.events || []).concat(Dk), this.events.forEach((l) => e.addEventListener(l, this.handleEvent));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, i) {
    e === cx && (this.enableMoveEvent = i), e === hx && (this.enableOverEvent = i), e === ux && (this.enableOutEvent = i), e === dx && (this.enableEnterEvent = i), e === fx && (this.enableLeaveEvent = i);
  }
  handleOverEvent(e) {
    this.enableOverEvent && e.type === "mouseover" && this._emit(hx, e);
  }
  handleOutEvent(e) {
    this.enableOutEvent && e.type === "mouseout" && this._emit(ux, e);
  }
  handleEnterEvent(e) {
    this.enableEnterEvent && e.type === "mouseenter" && this._emit(dx, e);
  }
  handleLeaveEvent(e) {
    this.enableLeaveEvent && e.type === "mouseleave" && this._emit(fx, e);
  }
  handleMoveEvent(e) {
    if (this.enableMoveEvent)
      switch (e.type) {
        case "mousedown":
          e.button >= 0 && (this.pressed = !0);
          break;
        case "mousemove":
          e.buttons === 0 && (this.pressed = !1), this.pressed || this._emit(cx, e);
          break;
        case "mouseup":
          this.pressed = !1;
          break;
      }
  }
  _emit(e, i) {
    this.callback({
      type: e,
      center: {
        x: i.clientX,
        y: i.clientY
      },
      srcEvent: i,
      pointerType: "mouse",
      target: i.target
    });
  }
}
const { KEY_EVENTS: Fk } = Ty, px = "keydown", _x = "keyup";
class kk extends vp {
  constructor(e, i, s) {
    super(e, i, s), this.handleEvent = (o) => {
      const l = o.target || o.srcElement;
      l.tagName === "INPUT" && l.type === "text" || l.tagName === "TEXTAREA" || (this.enableDownEvent && o.type === "keydown" && this.callback({
        type: px,
        srcEvent: o,
        key: o.key,
        target: o.target
      }), this.enableUpEvent && o.type === "keyup" && this.callback({
        type: _x,
        srcEvent: o,
        key: o.key,
        target: o.target
      }));
    }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, this.events = (this.options.events || []).concat(Fk), e.tabIndex = this.options.tabIndex || 0, e.style.outline = "none", this.events.forEach((o) => e.addEventListener(o, this.handleEvent));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, i) {
    e === px && (this.enableDownEvent = i), e === _x && (this.enableUpEvent = i);
  }
}
const mx = "contextmenu";
class Nk extends vp {
  constructor(e, i, s) {
    super(e, i, s), this.handleEvent = (o) => {
      this.options.enable && this.callback({
        type: mx,
        center: {
          x: o.clientX,
          y: o.clientY
        },
        srcEvent: o,
        pointerType: "mouse",
        target: o.target
      });
    }, e.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, i) {
    e === mx && (this.options.enable = i);
  }
}
const gx = 1, Eg = 2, yx = 4, Lk = {
  pointerdown: gx,
  pointermove: Eg,
  pointerup: yx,
  mousedown: gx,
  mousemove: Eg,
  mouseup: yx
}, Uk = 0, zk = 1, Vk = 2, Hk = 1, jk = 2, $k = 4;
function Gk(t) {
  const e = Lk[t.srcEvent.type];
  if (!e)
    return null;
  const { buttons: i, button: s } = t.srcEvent;
  let o = !1, l = !1, u = !1;
  return e === Eg ? (o = !!(i & Hk), l = !!(i & $k), u = !!(i & jk)) : (o = s === Uk, l = s === zk, u = s === Vk), { leftButton: o, middleButton: l, rightButton: u };
}
function Xk(t, e) {
  const i = t.center;
  if (!i)
    return null;
  const s = e.getBoundingClientRect(), o = s.width / e.offsetWidth || 1, l = s.height / e.offsetHeight || 1, u = {
    x: (i.x - s.left - e.clientLeft) / o,
    y: (i.y - s.top - e.clientTop) / l
  };
  return { center: i, offsetCenter: u };
}
const _m = {
  srcElement: "root",
  priority: 0
};
class Wk {
  constructor(e) {
    this.handleEvent = (i) => {
      if (this.isEmpty())
        return;
      const s = this._normalizeEvent(i);
      let o = i.srcEvent.target;
      for (; o && o !== s.rootElement; ) {
        if (this._emit(s, o), s.handled)
          return;
        o = o.parentNode;
      }
      this._emit(s, "root");
    }, this.eventManager = e, this.handlers = [], this.handlersByElement = /* @__PURE__ */ new Map(), this._active = !1;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(e, i, s, o = !1, l = !1) {
    const { handlers: u, handlersByElement: c } = this;
    let x = _m;
    typeof s == "string" || s && s.addEventListener ? x = { ..._m, srcElement: s } : s && (x = { ..._m, ...s });
    let w = c.get(x.srcElement);
    w || (w = [], c.set(x.srcElement, w));
    const C = {
      type: e,
      handler: i,
      srcElement: x.srcElement,
      priority: x.priority
    };
    o && (C.once = !0), l && (C.passive = !0), u.push(C), this._active = this._active || !C.passive;
    let M = w.length - 1;
    for (; M >= 0 && !(w[M].priority >= C.priority); )
      M--;
    w.splice(M + 1, 0, C);
  }
  remove(e, i) {
    const { handlers: s, handlersByElement: o } = this;
    for (let l = s.length - 1; l >= 0; l--) {
      const u = s[l];
      if (u.type === e && u.handler === i) {
        s.splice(l, 1);
        const c = o.get(u.srcElement);
        c.splice(c.indexOf(u), 1), c.length === 0 && o.delete(u.srcElement);
      }
    }
    this._active = s.some((l) => !l.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(e, i) {
    const s = this.handlersByElement.get(i);
    if (s) {
      let o = !1;
      const l = () => {
        e.handled = !0;
      }, u = () => {
        e.handled = !0, o = !0;
      }, c = [];
      for (let x = 0; x < s.length; x++) {
        const { type: w, handler: C, once: M } = s[x];
        if (C({
          ...e,
          // @ts-ignore
          type: w,
          stopPropagation: l,
          stopImmediatePropagation: u
        }), M && c.push(s[x]), o)
          break;
      }
      for (let x = 0; x < c.length; x++) {
        const { type: w, handler: C } = c[x];
        this.remove(w, C);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(e) {
    const i = this.eventManager.getElement();
    return {
      ...e,
      ...Gk(e),
      ...Xk(e, i),
      preventDefault: () => {
        e.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: !1,
      rootElement: i
    };
  }
}
const qk = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  recognizerOptions: {},
  // Manager class
  Manager: wk,
  // allow browser default touch action
  // https://github.com/uber/react-map-gl/issues/506
  touchAction: "none",
  tabIndex: 0
};
class Zk {
  constructor(e = null, i) {
    this._onBasicInput = (o) => {
      const { srcEvent: l } = o, u = Ek[l.type];
      u && this.manager.emit(u, o);
    }, this._onOtherEvent = (o) => {
      this.manager.emit(o.type, o);
    }, this.options = { ...qk, ...i }, this.events = /* @__PURE__ */ new Map(), this.setElement(e);
    const { events: s } = this.options;
    s && this.on(s);
  }
  getElement() {
    return this.element;
  }
  setElement(e) {
    if (this.element && this.destroy(), this.element = e, !e)
      return;
    const { options: i } = this, s = i.Manager;
    this.manager = new s(e, {
      touchAction: i.touchAction,
      recognizers: i.recognizers || Ak
    }).on("hammer.input", this._onBasicInput), i.recognizers || Object.keys(nx).forEach((o) => {
      const l = this.manager.get(o);
      l && nx[o].forEach((u) => {
        l.recognizeWith(u);
      });
    });
    for (const o in i.recognizerOptions) {
      const l = this.manager.get(o);
      if (l) {
        const u = i.recognizerOptions[o];
        delete u.enable, l.set(u);
      }
    }
    this.wheelInput = new Bk(e, this._onOtherEvent, {
      enable: !1
    }), this.moveInput = new Ok(e, this._onOtherEvent, {
      enable: !1
    }), this.keyInput = new kk(e, this._onOtherEvent, {
      enable: !1,
      tabIndex: i.tabIndex
    }), this.contextmenuInput = new Nk(e, this._onOtherEvent, {
      enable: !1
    });
    for (const [o, l] of this.events)
      l.isEmpty() || (this._toggleRecognizer(l.recognizerName, !0), this.manager.on(o, l.handleEvent));
  }
  // Tear down internal event management implementations.
  destroy() {
    this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy(), this.wheelInput = null, this.moveInput = null, this.keyInput = null, this.contextmenuInput = null, this.manager = null, this.element = null);
  }
  /** Register an event handler function to be called on `event` */
  on(e, i, s) {
    this._addEventHandler(e, i, s, !1);
  }
  once(e, i, s) {
    this._addEventHandler(e, i, s, !0);
  }
  watch(e, i, s) {
    this._addEventHandler(e, i, s, !1, !0);
  }
  off(e, i) {
    this._removeEventHandler(e, i);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(e, i) {
    const { manager: s } = this;
    if (!s)
      return;
    const o = s.get(e);
    if (o && o.options.enable !== i) {
      o.set({ enable: i });
      const l = Tk[e];
      l && !this.options.recognizers && l.forEach((u) => {
        const c = s.get(u);
        i ? (c.requireFailure(e), o.dropRequireFailure(u)) : c.dropRequireFailure(e);
      });
    }
    this.wheelInput.enableEventType(e, i), this.moveInput.enableEventType(e, i), this.keyInput.enableEventType(e, i), this.contextmenuInput.enableEventType(e, i);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(e, i, s, o, l) {
    if (typeof e != "string") {
      s = i;
      for (const C in e)
        this._addEventHandler(C, e[C], s, o, l);
      return;
    }
    const { manager: u, events: c } = this, x = ox[e] || e;
    let w = c.get(x);
    w || (w = new Wk(this), c.set(x, w), w.recognizerName = Sk[x] || x, u && u.on(x, w.handleEvent)), w.add(e, i, s, o, l), w.isEmpty() || this._toggleRecognizer(w.recognizerName, !0);
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(e, i) {
    if (typeof e != "string") {
      for (const u in e)
        this._removeEventHandler(u, e[u]);
      return;
    }
    const { events: s } = this, o = ox[e] || e, l = s.get(o);
    if (l && (l.remove(e, i), l.isEmpty())) {
      const { recognizerName: u } = l;
      let c = !1;
      for (const x of s.values())
        if (x.recognizerName === u && !x.isEmpty()) {
          c = !0;
          break;
        }
      c || this._toggleRecognizer(u, !1);
    }
  }
}
function na() {
}
const Kk = ({ isDragging: t }) => t ? "grabbing" : "grab", zA = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  parameters: {},
  parent: null,
  device: null,
  deviceProps: { type: "webgl" },
  gl: null,
  glOptions: {},
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  // Rely on external controller, e.g. react-map-gl
  useDevicePixels: !0,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: !1,
  _pickable: !0,
  _typedArrayManagerProps: {},
  _customRender: null,
  widgets: [],
  onDeviceInitialized: na,
  onWebGLInitialized: na,
  onResize: na,
  onViewStateChange: na,
  onInteractionStateChange: na,
  onBeforeRender: na,
  onAfterRender: na,
  onLoad: na,
  onError: (t) => Jt.error(t.message, t.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor: Kk,
  getTooltip: null,
  debug: !1,
  drawPickingColors: !1
};
class Iu {
  constructor(e) {
    this.width = 0, this.height = 0, this.userData = {}, this.device = null, this.canvas = null, this.viewManager = null, this.layerManager = null, this.effectManager = null, this.deckRenderer = null, this.deckPicker = null, this.eventManager = null, this.widgetManager = null, this.tooltip = null, this.animationLoop = null, this.cursorState = {
      isHovering: !1,
      isDragging: !1
    }, this.stats = new jc({ id: "deck.gl" }), this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    }, this._metricsCounter = 0, this._needsRedraw = "Initial render", this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    }, this._lastPointerDownInfo = null, this._onPointerMove = (s) => {
      const { _pickRequest: o } = this;
      if (s.type === "pointerleave")
        o.x = -1, o.y = -1, o.radius = 0;
      else {
        if (s.leftButton || s.rightButton)
          return;
        {
          const l = s.offsetCenter;
          if (!l)
            return;
          o.x = l.x, o.y = l.y, o.radius = this.props.pickingRadius;
        }
      }
      this.layerManager && (this.layerManager.context.mousePosition = { x: o.x, y: o.y }), o.event = s;
    }, this._onEvent = (s) => {
      const o = dg[s.type], l = s.offsetCenter;
      if (!o || !l || !this.layerManager)
        return;
      const u = this.layerManager.getLayers(), c = this.deckPicker.getLastPickedObject({
        x: l.x,
        y: l.y,
        layers: u,
        viewports: this.getViewports(l)
      }, this._lastPointerDownInfo), { layer: x } = c, w = x && (x[o.handler] || x.props[o.handler]), C = this.props[o.handler];
      let M = !1;
      w && (M = w.call(x, c, s)), M || (C == null || C(c, s), this.widgetManager.onEvent(c, s));
    }, this._onPointerDown = (s) => {
      const o = s.offsetCenter, l = this._pick("pickObject", "pickObject Time", {
        x: o.x,
        y: o.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = l.result[0] || l.emptyInfo;
    }, this.props = { ...zA, ...e }, e = this.props, e.viewState && e.initialViewState && Jt.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), this.viewState = this.props.initialViewState, e.device ? this.device = e.device : e.gl && (e.gl instanceof WebGLRenderingContext && Jt.error("WebGL1 context not supported.")(), this.device = gu.attach(e.gl));
    let i = this.device;
    i || (Ec.registerDevices([gu]), i = Ec.createDevice({
      ...e.deviceProps,
      canvas: this._createCanvas(e)
    })), this.animationLoop = this._createAnimationLoop(i, e), this.setProps(e), e._typedArrayManagerProps && Eu.setOptions(e._typedArrayManagerProps), this.animationLoop.start();
  }
  /** Stop rendering and dispose all resources */
  finalize() {
    var e, i, s, o, l, u, c, x, w, C;
    (e = this.animationLoop) == null || e.stop(), (i = this.animationLoop) == null || i.destroy(), this.animationLoop = null, this._lastPointerDownInfo = null, (s = this.layerManager) == null || s.finalize(), this.layerManager = null, (o = this.viewManager) == null || o.finalize(), this.viewManager = null, (l = this.effectManager) == null || l.finalize(), this.effectManager = null, (u = this.deckRenderer) == null || u.finalize(), this.deckRenderer = null, (c = this.deckPicker) == null || c.finalize(), this.deckPicker = null, (x = this.eventManager) == null || x.destroy(), this.eventManager = null, (w = this.widgetManager) == null || w.finalize(), this.widgetManager = null, !this.props.canvas && !this.props.device && !this.props.gl && this.canvas && ((C = this.canvas.parentElement) == null || C.removeChild(this.canvas), this.canvas = null);
  }
  /** Partially update props */
  setProps(e) {
    var s;
    this.stats.get("setProps Time").timeStart(), "onLayerHover" in e && Jt.removed("onLayerHover", "onHover")(), "onLayerClick" in e && Jt.removed("onLayerClick", "onClick")(), e.initialViewState && // depth = 3 when comparing viewStates: viewId.position.0
    !gn(this.props.initialViewState, e.initialViewState, 3) && (this.viewState = e.initialViewState), Object.assign(this.props, e), this._setCanvasSize(this.props);
    const i = Object.create(this.props);
    Object.assign(i, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    }), (s = this.animationLoop) == null || s.setProps(i), this.layerManager && (this.viewManager.setProps(i), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(i), this.effectManager.setProps(i), this.deckRenderer.setProps(i), this.deckPicker.setProps(i), this.widgetManager.setProps(i)), this.stats.get("setProps Time").timeEnd();
  }
  // Public API
  /**
   * Check if a redraw is needed
   * @returns `false` or a string summarizing the redraw reason
   */
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    if (!this.layerManager)
      return !1;
    if (this.props._animate)
      return "Deck._animate";
    let i = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    const s = this.viewManager.needsRedraw(e), o = this.layerManager.needsRedraw(e), l = this.effectManager.needsRedraw(e), u = this.deckRenderer.needsRedraw(e);
    return i = i || s || o || l || u, i;
  }
  /**
   * Redraw the GL context
   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.
   * @returns
   */
  redraw(e) {
    if (!this.layerManager)
      return;
    let i = this.needsRedraw({ clearRedrawFlags: !0 });
    i = e || i, i && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(i) : this._drawLayers(i));
  }
  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */
  get isInitialized() {
    return this.viewManager !== null;
  }
  /** Get a list of views that are currently rendered */
  getViews() {
    return hs(this.viewManager), this.viewManager.views;
  }
  /** Get a list of viewports that are currently rendered.
   * @param rect If provided, only returns viewports within the given bounding box.
   */
  getViewports(e) {
    return hs(this.viewManager), this.viewManager.getViewports(e);
  }
  /** Get the current canvas element. */
  getCanvas() {
    return this.canvas;
  }
  /** Query the object rendered on top at a given point */
  pickObject(e) {
    const i = this._pick("pickObject", "pickObject Time", e).result;
    return i.length ? i[0] : null;
  }
  /* Query all rendered objects at a given point */
  pickMultipleObjects(e) {
    return e.depth = e.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", e).result;
  }
  /* Query all objects rendered on top within a bounding box */
  pickObjects(e) {
    return this._pick("pickObjects", "pickObjects Time", e);
  }
  /** Experimental
   * Add a global resource for sharing among layers
   */
  _addResources(e, i = !1) {
    for (const s in e)
      this.layerManager.resourceManager.add({ resourceId: s, data: e[s], forceUpdate: i });
  }
  /** Experimental
   * Remove a global resource
   */
  _removeResources(e) {
    for (const i of e)
      this.layerManager.resourceManager.remove(i);
  }
  /** Experimental
   * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first
   */
  _addDefaultEffect(e) {
    this.effectManager.addDefaultEffect(e);
  }
  _addDefaultShaderModule(e) {
    this.layerManager.addDefaultShaderModule(e);
  }
  _removeDefaultShaderModule(e) {
    var i;
    (i = this.layerManager) == null || i.removeDefaultShaderModule(e);
  }
  _pick(e, i, s) {
    hs(this.deckPicker);
    const { stats: o } = this;
    o.get("Pick Count").incrementCount(), o.get(i).timeStart();
    const l = this.deckPicker[e]({
      // layerManager, viewManager and effectManager are always defined if deckPicker is
      layers: this.layerManager.getLayers(s),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(s),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...s
    });
    return o.get(i).timeEnd(), l;
  }
  /** Resolve props.canvas to element */
  _createCanvas(e) {
    let i = e.canvas;
    return typeof i == "string" && (i = document.getElementById(i), hs(i)), i || (i = document.createElement("canvas"), i.id = e.id || "deckgl-overlay", (e.parent || document.body).appendChild(i)), Object.assign(i.style, e.style), i;
  }
  /** Updates canvas width and/or height, if provided as props */
  _setCanvasSize(e) {
    var o;
    if (!this.canvas)
      return;
    const { width: i, height: s } = e;
    if (i || i === 0) {
      const l = Number.isFinite(i) ? `${i}px` : i;
      this.canvas.style.width = l;
    }
    if (s || s === 0) {
      const l = Number.isFinite(s) ? `${s}px` : s;
      this.canvas.style.position = ((o = e.style) == null ? void 0 : o.position) || "absolute", this.canvas.style.height = l;
    }
  }
  /** If canvas size has changed, reads out the new size and update */
  _updateCanvasSize() {
    var o, l;
    const { canvas: e } = this;
    if (!e)
      return;
    const i = e.clientWidth ?? e.width, s = e.clientHeight ?? e.height;
    (i !== this.width || s !== this.height) && (this.width = i, this.height = s, (o = this.viewManager) == null || o.setProps({ width: i, height: s }), (l = this.layerManager) == null || l.activateViewport(this.getViewports()[0]), this.props.onResize({ width: i, height: s }));
  }
  _createAnimationLoop(e, i) {
    const {
      // width,
      // height,
      gl: s,
      // deviceProps,
      // glOptions,
      // debug,
      onError: o,
      // onBeforeRender,
      // onAfterRender,
      useDevicePixels: l
    } = i;
    return new vD({
      device: e,
      useDevicePixels: l,
      // TODO v9
      autoResizeDrawingBuffer: !s,
      // do not auto resize external context
      autoResizeViewport: !1,
      // @ts-expect-error luma.gl needs to accept Promise<void> return value
      onInitialize: (u) => this._setDevice(u.device),
      onRender: this._onRenderFrame.bind(this),
      // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null
      onError: o
      // onBeforeRender,
      // onAfterRender,
    });
  }
  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  // Get the view descriptor list
  _getViews() {
    const { views: e } = this.props, i = Array.isArray(e) ? e : (
      // If null, default to a full screen map view port
      e ? [e] : [new by({ id: "default-view" })]
    );
    return i.length && this.props.controller && (i[0].props.controller = this.props.controller), i;
  }
  _onContextLost() {
    const { onError: e } = this.props;
    this.animationLoop && e && e(new Error("WebGL context is lost"));
  }
  /** Actually run picking */
  _pickAndCallback() {
    var i, s, o;
    const { _pickRequest: e } = this;
    if (e.event) {
      const { result: l, emptyInfo: u } = this._pick("pickObject", "pickObject Time", e);
      this.cursorState.isHovering = l.length > 0;
      let c = u, x = !1;
      for (const w of l)
        c = w, x = ((i = w.layer) == null ? void 0 : i.onHover(w, e.event)) || x;
      x || ((o = (s = this.props).onHover) == null || o.call(s, c, e.event), this.widgetManager.onHover(c, e.event)), e.event = null;
    }
  }
  _updateCursor() {
    const e = this.props.parent || this.canvas;
    e && (e.style.cursor = this.props.getCursor(this.cursorState));
  }
  _setDevice(e) {
    var o, l;
    if (this.device = e, !this.animationLoop)
      return;
    this.canvas || (this.canvas = (o = this.device.canvasContext) == null ? void 0 : o.canvas), this.device.setParametersWebGL({
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthTest: !0,
      depthFunc: 515
    }), this.props.onDeviceInitialized(this.device), this.device instanceof gu && this.props.onWebGLInitialized(this.device.gl);
    const i = new yA();
    i.play(), this.animationLoop.attachTimeline(i), this.eventManager = new Zk(this.props.parent || this.canvas, {
      touchAction: this.props.touchAction,
      recognizerOptions: this.props.eventRecognizerOptions,
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const u in dg)
      this.eventManager.on(u, this._onEvent);
    this.viewManager = new LD({
      timeline: i,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const s = this.viewManager.getViewports()[0];
    this.layerManager = new ND(this.device, {
      deck: this,
      stats: this.stats,
      viewport: s,
      timeline: i
    }), this.effectManager = new tO({
      deck: this,
      device: this.device
    }), this.deckRenderer = new rO(this.device), this.deckPicker = new hO(this.device), this.widgetManager = new fO({
      deck: this,
      parentElement: (l = this.canvas) == null ? void 0 : l.parentElement
    }), this.widgetManager.addDefault(new _O()), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad();
  }
  /** Internal only: default render function (redraw all layers and views) */
  _drawLayers(e, i) {
    var u;
    const { device: s, gl: o } = this.layerManager.context;
    this.props.onBeforeRender({ device: s, gl: o });
    const l = {
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...i
    };
    (u = this.deckRenderer) == null || u.renderLayers(l), l.pass === "screen" && this.widgetManager.onRedraw({
      viewports: l.viewports,
      layers: l.layers
    }), this.props.onAfterRender({ device: s, gl: o });
  }
  // Callbacks
  _onRenderFrame() {
    this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), Jt.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.layerManager.updateLayers(), this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates();
  }
  // Callbacks
  _onViewStateChange(e) {
    const i = this.props.onViewStateChange(e) || e.viewState;
    this.viewState && (this.viewState = { ...this.viewState, [e.viewId]: i }, this.props.viewState || this.viewManager && this.viewManager.setProps({ viewState: this.viewState }));
  }
  _onInteractionStateChange(e) {
    this.cursorState.isDragging = e.isDragging || !1, this.props.onInteractionStateChange(e);
  }
  _getFrameStats() {
    const { stats: e } = this;
    e.get("frameRate").timeEnd(), e.get("frameRate").timeStart();
    const i = this.animationLoop.stats;
    e.get("GPU Time").addTime(i.get("GPU Time").lastTiming), e.get("CPU Time").addTime(i.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const { metrics: e, stats: i } = this;
    e.fps = i.get("frameRate").getHz(), e.setPropsTime = i.get("setProps Time").time, e.updateAttributesTime = i.get("Update Attributes").time, e.framesRedrawn = i.get("Redraw Count").count, e.pickTime = i.get("pickObject Time").time + i.get("pickMultipleObjects Time").time + i.get("pickObjects Time").time, e.pickCount = i.get("Pick Count").count, e.gpuTime = i.get("GPU Time").time, e.cpuTime = i.get("CPU Time").time, e.gpuTimePerFrame = i.get("GPU Time").getAverageTime(), e.cpuTimePerFrame = i.get("CPU Time").getAverageTime();
    const s = Ec.stats.get("Memory Usage");
    e.bufferMemory = s.get("Buffer Memory").count, e.textureMemory = s.get("Texture Memory").count, e.renderbufferMemory = s.get("Renderbuffer Memory").count, e.gpuMemory = s.get("GPU Memory").count;
  }
}
Iu.defaultProps = zA;
Iu.VERSION = KI;
function Jk(t) {
  switch (t) {
    case "float64":
      return Float64Array;
    case "uint8":
    case "unorm8":
      return Uint8ClampedArray;
    default:
      return Rw(t);
  }
}
const Yk = Iw;
function nf(t, e) {
  return {
    attribute: t,
    // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure
    format: e.size > 1 ? `${e.type}x${e.size}` : e.type,
    byteOffset: e.offset || 0
    // Note stride is set on the top level
  };
}
function tl(t) {
  return t.stride || t.size * t.bytesPerElement;
}
function Qk(t, e) {
  return t.type === e.type && t.size === e.size && tl(t) === tl(e) && (t.offset || 0) === (e.offset || 0);
}
function Sg(t, e) {
  e.offset && Jt.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  const i = tl(t), s = e.vertexOffset !== void 0 ? e.vertexOffset : t.vertexOffset || 0, o = e.elementOffset || 0, l = (
    // offsets defined by the attribute
    s * i + o * t.bytesPerElement + // offsets defined by external buffers if any
    (t.offset || 0)
  );
  return {
    ...e,
    offset: l,
    stride: i
  };
}
function eN(t, e) {
  const i = Sg(t, e);
  return {
    high: i,
    low: {
      ...i,
      offset: i.offset + t.size * 4
    }
  };
}
class tN {
  /* eslint-disable max-statements */
  constructor(e, i, s) {
    this._buffer = null, this.device = e, this.id = i.id || "", this.size = i.size || 1;
    const o = i.logicalType || i.type, l = o === "float64";
    let { defaultValue: u } = i;
    u = Number.isFinite(u) ? [u] : u || new Array(this.size).fill(0);
    let c;
    l ? c = "float32" : !o && i.isIndexed ? c = "uint32" : c = o || "float32";
    let x = Jk(o || c);
    this.doublePrecision = l, l && i.fp64 === !1 && (x = Float32Array), this.value = null, this.settings = {
      ...i,
      defaultType: x,
      defaultValue: u,
      logicalType: o,
      type: c,
      normalized: c.includes("norm"),
      size: this.size,
      bytesPerElement: x.BYTES_PER_ELEMENT
    }, this.state = {
      ...s,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: !1
    };
  }
  /* eslint-enable max-statements */
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    return this._buffer;
  }
  get byteOffset() {
    const e = this.getAccessor();
    return e.vertexOffset ? e.vertexOffset * tl(e) : 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(e) {
    this.state.numInstances = e;
  }
  delete() {
    this._buffer && (this._buffer.delete(), this._buffer = null), Eu.release(this.state.allocatedValue);
  }
  getBuffer() {
    return this.state.constant ? null : this.state.externalBuffer || this._buffer;
  }
  getValue(e = this.id, i = null) {
    const s = {};
    if (this.state.constant) {
      const o = this.value;
      if (i) {
        const l = Sg(this.getAccessor(), i), u = l.offset / o.BYTES_PER_ELEMENT, c = l.size || this.size;
        s[e] = o.subarray(u, u + c);
      } else
        s[e] = o;
    } else
      s[e] = this.getBuffer();
    return this.doublePrecision && (this.value instanceof Float64Array ? s[`${e}64Low`] = s[e] : s[`${e}64Low`] = new Float32Array(this.size)), s;
  }
  _getBufferLayout(e = this.id, i = null) {
    const s = this.getAccessor(), o = [], l = {
      name: this.id,
      byteStride: tl(s),
      attributes: o
    };
    if (this.doublePrecision) {
      const u = eN(s, i || {});
      o.push(nf(e, { ...s, ...u.high }), nf(`${e}64Low`, {
        ...s,
        ...u.low
      }));
    } else if (i) {
      const u = Sg(s, i);
      o.push(nf(e, { ...s, ...u }));
    } else
      o.push(nf(e, s));
    return l;
  }
  setAccessor(e) {
    this.state.bufferAccessor = e;
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  // Returns [min: Array(size), max: Array(size)]
  /* eslint-disable max-depth */
  getBounds() {
    if (this.state.bounds)
      return this.state.bounds;
    let e = null;
    if (this.state.constant && this.value) {
      const i = Array.from(this.value);
      e = [i, i];
    } else {
      const { value: i, numInstances: s, size: o } = this, l = s * o;
      if (i && l && i.length >= l) {
        const u = new Array(o).fill(1 / 0), c = new Array(o).fill(-1 / 0);
        for (let x = 0; x < l; )
          for (let w = 0; w < o; w++) {
            const C = i[x++];
            C < u[w] && (u[w] = C), C > c[w] && (c[w] = C);
          }
        e = [u, c];
      }
    }
    return this.state.bounds = e, e;
  }
  // returns true if success
  // eslint-disable-next-line max-statements
  setData(e) {
    const { state: i } = this;
    let s;
    ArrayBuffer.isView(e) ? s = { value: e } : e instanceof Vi ? s = { buffer: e } : s = e;
    const o = { ...this.settings, ...s };
    if (ArrayBuffer.isView(s.value)) {
      if (!s.type)
        if (this.doublePrecision && s.value instanceof Float64Array)
          o.type = "float32";
        else {
          const u = Yk(s.value);
          o.type = o.normalized ? u.replace("int", "norm") : u;
        }
      o.bytesPerElement = s.value.BYTES_PER_ELEMENT, o.stride = tl(o);
    }
    if (i.bounds = null, s.constant) {
      let l = s.value;
      if (l = this._normalizeValue(l, [], 0), this.settings.normalized && (l = this.normalizeConstant(l)), !(!i.constant || !this._areValuesEqual(l, this.value)))
        return !1;
      i.externalBuffer = null, i.constant = !0, this.value = ArrayBuffer.isView(l) ? l : new Float32Array(l);
    } else if (s.buffer) {
      const l = s.buffer;
      i.externalBuffer = l, i.constant = !1, this.value = s.value || null;
    } else if (s.value) {
      this._checkExternalBuffer(s);
      let l = s.value;
      i.externalBuffer = null, i.constant = !1, this.value = l;
      let { buffer: u } = this;
      const c = tl(o), x = (o.vertexOffset || 0) * c;
      if (this.doublePrecision && l instanceof Float64Array && (l = im(l, o)), this.settings.isIndexed) {
        const C = this.settings.defaultType;
        l.constructor !== C && (l = new C(l));
      }
      const w = l.byteLength + x + c * 2;
      (!u || u.byteLength < w) && (u = this._createBuffer(w)), u.write(l, x);
    }
    return this.setAccessor(o), !0;
  }
  updateSubBuffer(e = {}) {
    this.state.bounds = null;
    const i = this.value, { startOffset: s = 0, endOffset: o } = e;
    this.buffer.write(this.doublePrecision && i instanceof Float64Array ? im(i, {
      size: this.size,
      startIndex: s,
      endIndex: o
    }) : i.subarray(s, o), s * i.BYTES_PER_ELEMENT + this.byteOffset);
  }
  allocate(e, i = !1) {
    const { state: s } = this, o = s.allocatedValue, l = Eu.allocate(o, e + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: i
    });
    this.value = l;
    const { byteOffset: u } = this;
    let { buffer: c } = this;
    return (!c || c.byteLength < l.byteLength + u) && (c = this._createBuffer(l.byteLength + u), i && o && c.write(o instanceof Float64Array ? im(o, this) : o, u)), s.allocatedValue = l, s.constant = !1, s.externalBuffer = null, this.setAccessor(this.settings), !0;
  }
  // PRIVATE HELPER METHODS
  _checkExternalBuffer(e) {
    const { value: i } = e;
    if (!ArrayBuffer.isView(i))
      throw new Error(`Attribute ${this.id} value is not TypedArray`);
    const s = this.settings.defaultType;
    let o = !1;
    if (this.doublePrecision && (o = i.BYTES_PER_ELEMENT < 4), o)
      throw new Error(`Attribute ${this.id} does not support ${i.constructor.name}`);
    !(i instanceof s) && this.settings.normalized && !("normalized" in e) && Jt.warn(`Attribute ${this.id} is normalized`)();
  }
  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
  normalizeConstant(e) {
    switch (this.settings.type) {
      case "snorm8":
        return new Float32Array(e).map((i) => (i + 128) / 255 * 2 - 1);
      case "snorm16":
        return new Float32Array(e).map((i) => (i + 32768) / 65535 * 2 - 1);
      case "unorm8":
        return new Float32Array(e).map((i) => i / 255);
      case "unorm16":
        return new Float32Array(e).map((i) => i / 65535);
      default:
        return e;
    }
  }
  /* check user supplied values and apply fallback */
  _normalizeValue(e, i, s) {
    const { defaultValue: o, size: l } = this.settings;
    if (Number.isFinite(e))
      return i[s] = e, i;
    if (!e) {
      let u = l;
      for (; --u >= 0; )
        i[s + u] = o[u];
      return i;
    }
    switch (l) {
      case 4:
        i[s + 3] = Number.isFinite(e[3]) ? e[3] : o[3];
      case 3:
        i[s + 2] = Number.isFinite(e[2]) ? e[2] : o[2];
      case 2:
        i[s + 1] = Number.isFinite(e[1]) ? e[1] : o[1];
      case 1:
        i[s + 0] = Number.isFinite(e[0]) ? e[0] : o[0];
        break;
      default:
        let u = l;
        for (; --u >= 0; )
          i[s + u] = Number.isFinite(e[u]) ? e[u] : o[u];
    }
    return i;
  }
  _areValuesEqual(e, i) {
    if (!e || !i)
      return !1;
    const { size: s } = this;
    for (let o = 0; o < s; o++)
      if (e[o] !== i[o])
        return !1;
    return !0;
  }
  _createBuffer(e) {
    var o;
    this._buffer && this._buffer.destroy();
    const { isIndexed: i, type: s } = this.settings;
    return this._buffer = this.device.createBuffer({
      ...(o = this._buffer) == null ? void 0 : o.props,
      id: this.id,
      usage: i ? Vi.INDEX : Vi.VERTEX,
      indexType: i ? s : void 0,
      byteLength: e
    }), this._buffer;
  }
}
const bx = [], vx = [];
function VA(t, e = 0, i = 1 / 0) {
  let s = bx;
  const o = {
    index: -1,
    data: t,
    // visitor can optionally utilize this to avoid constructing a new array for every object
    target: []
  };
  return t ? typeof t[Symbol.iterator] == "function" ? s = t : t.length > 0 && (vx.length = t.length, s = vx) : s = bx, (e > 0 || Number.isFinite(i)) && (s = (Array.isArray(s) ? s : Array.from(s)).slice(e, i), o.index = e - 1), { iterable: s, objectInfo: o };
}
function HA(t) {
  return t && t[Symbol.asyncIterator];
}
function iN(t, e) {
  const { size: i, stride: s, offset: o, startIndices: l, nested: u } = e, c = t.BYTES_PER_ELEMENT, x = s ? s / c : i, w = o ? o / c : 0, C = Math.floor((t.length - w) / x);
  return (M, { index: P, target: j }) => {
    if (!l) {
      const me = P * x + w;
      for (let we = 0; we < i; we++)
        j[we] = t[me + we];
      return j;
    }
    const Y = l[P], Q = l[P + 1] || C;
    let _e;
    if (u) {
      _e = new Array(Q - Y);
      for (let me = Y; me < Q; me++) {
        const we = me * x + w;
        j = new Array(i);
        for (let Ee = 0; Ee < i; Ee++)
          j[Ee] = t[we + Ee];
        _e[me - Y] = j;
      }
    } else if (x === i)
      _e = t.subarray(Y * i + w, Q * i + w);
    else {
      _e = new t.constructor((Q - Y) * i);
      let me = 0;
      for (let we = Y; we < Q; we++) {
        const Ee = we * x + w;
        for (let Oe = 0; Oe < i; Oe++)
          _e[me++] = t[Ee + Oe];
      }
    }
    return _e;
  };
}
const sN = [], Af = [[0, 1 / 0]];
function rN(t, e) {
  if (t === Af || (e[0] < 0 && (e[0] = 0), e[0] >= e[1]))
    return t;
  const i = [], s = t.length;
  let o = 0;
  for (let l = 0; l < s; l++) {
    const u = t[l];
    u[1] < e[0] ? (i.push(u), o = l + 1) : u[0] > e[1] ? i.push(u) : e = [Math.min(u[0], e[0]), Math.max(u[1], e[1])];
  }
  return i.splice(o, 0, e), i;
}
const nN = {
  interpolation: {
    duration: 0,
    easing: (t) => t
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function jA(t, e) {
  if (!t)
    return null;
  Number.isFinite(t) && (t = { type: "interpolation", duration: t });
  const i = t.type || "interpolation";
  return {
    ...nN[i],
    ...e,
    ...t,
    type: i
  };
}
class $A extends tN {
  constructor(e, i) {
    super(e, i, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: !0,
      needsRedraw: !1,
      layoutChanged: !1,
      updateRanges: Af
    }), this.constant = !1, this.settings.update = i.update || (i.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(e) {
    this.state.startIndices = e;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw({ clearChangedFlags: e = !1 } = {}) {
    const i = this.state.needsRedraw;
    return this.state.needsRedraw = i && !e, i;
  }
  layoutChanged() {
    return this.state.layoutChanged;
  }
  setAccessor(e) {
    var i;
    (i = this.state).layoutChanged || (i.layoutChanged = !Qk(e, this.getAccessor())), super.setAccessor(e);
  }
  getUpdateTriggers() {
    const { accessor: e } = this.settings;
    return [this.id].concat(typeof e != "function" && e || []);
  }
  supportsTransition() {
    return !!this.settings.transition;
  }
  // Resolve transition settings object if transition is enabled, otherwise `null`
  getTransitionSetting(e) {
    if (!e || !this.supportsTransition())
      return null;
    const { accessor: i } = this.settings, s = this.settings.transition, o = Array.isArray(i) ? (
      // @ts-ignore
      e[i.find((l) => e[l])]
    ) : (
      // @ts-ignore
      e[i]
    );
    return jA(o, s);
  }
  setNeedsUpdate(e = this.id, i) {
    if (this.state.needsUpdate = this.state.needsUpdate || e, this.setNeedsRedraw(e), i) {
      const { startRow: s = 0, endRow: o = 1 / 0 } = i;
      this.state.updateRanges = rN(this.state.updateRanges, [s, o]);
    } else
      this.state.updateRanges = Af;
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = !1, this.state.updateRanges = sN;
  }
  setNeedsRedraw(e = this.id) {
    this.state.needsRedraw = this.state.needsRedraw || e;
  }
  allocate(e) {
    const { state: i, settings: s } = this;
    return s.noAlloc ? !1 : s.update ? (super.allocate(e, i.updateRanges !== Af), !0) : !1;
  }
  updateBuffer({ numInstances: e, data: i, props: s, context: o }) {
    if (!this.needsUpdate())
      return !1;
    const { state: { updateRanges: l }, settings: { update: u, noAlloc: c } } = this;
    let x = !0;
    if (u) {
      for (const [w, C] of l)
        u.call(o, this, { data: i, startRow: w, endRow: C, props: s, numInstances: e });
      if (this.value) if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset)
        this.setData({
          value: this.value,
          constant: this.constant
        }), this.constant = !1;
      else
        for (const [w, C] of l) {
          const M = Number.isFinite(w) ? this.getVertexOffset(w) : 0, P = Number.isFinite(C) ? this.getVertexOffset(C) : c || !Number.isFinite(e) ? this.value.length : e * this.size;
          super.updateSubBuffer({ startOffset: M, endOffset: P });
        }
      this._checkAttributeArray();
    } else
      x = !1;
    return this.clearNeedsUpdate(), this.setNeedsRedraw(), x;
  }
  // Use generic value
  // Returns true if successful
  setConstantValue(e) {
    return e === void 0 || typeof e == "function" ? !1 : (this.setData({ constant: !0, value: e }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), !0);
  }
  // Use external buffer
  // Returns true if successful
  // eslint-disable-next-line max-statements
  setExternalBuffer(e) {
    const { state: i } = this;
    return e ? (this.clearNeedsUpdate(), i.lastExternalBuffer === e || (i.lastExternalBuffer = e, this.setNeedsRedraw(), this.setData(e)), !0) : (i.lastExternalBuffer = null, !1);
  }
  // Binary value is a typed array packed from mapping the source data with the accessor
  // If the returned value from the accessor is the same as the attribute value, set it directly
  // Otherwise use the auto updater for transform/normalization
  setBinaryValue(e, i = null) {
    const { state: s, settings: o } = this;
    if (!e)
      return s.binaryValue = null, s.binaryAccessor = null, !1;
    if (o.noAlloc)
      return !1;
    if (s.binaryValue === e)
      return this.clearNeedsUpdate(), !0;
    if (s.binaryValue = e, this.setNeedsRedraw(), o.transform || i !== this.startIndices) {
      ArrayBuffer.isView(e) && (e = { value: e });
      const u = e;
      hs(ArrayBuffer.isView(u.value), `invalid ${o.accessor}`);
      const c = !!u.size && u.size !== this.size;
      return s.binaryAccessor = iN(u.value, {
        size: u.size || this.size,
        stride: u.stride,
        offset: u.offset,
        startIndices: i,
        nested: c
      }), !1;
    }
    return this.clearNeedsUpdate(), this.setData(e), !0;
  }
  getVertexOffset(e) {
    const { startIndices: i } = this;
    return (i ? e < i.length ? i[e] : this.numInstances : e) * this.size;
  }
  getValue() {
    const e = this.settings.shaderAttributes, i = super.getValue();
    if (!e)
      return i;
    for (const s in e)
      Object.assign(i, super.getValue(s, e[s]));
    return i;
  }
  /** Generate WebGPU-style buffer layout descriptor from this attribute */
  getBufferLayout(e) {
    this.state.layoutChanged = !1;
    const i = this.settings.shaderAttributes, s = super._getBufferLayout(), { stepMode: o } = this.settings;
    if (o === "dynamic" ? s.stepMode = e ? e.isInstanced ? "instance" : "vertex" : "instance" : s.stepMode = o ?? "vertex", !i)
      return s;
    for (const l in i) {
      const u = super._getBufferLayout(l, i[l]);
      s.attributes.push(...u.attributes);
    }
    return s;
  }
  /* eslint-disable max-depth, max-statements */
  _autoUpdater(e, { data: i, startRow: s, endRow: o, props: l, numInstances: u }) {
    if (e.constant)
      return;
    const { settings: c, state: x, value: w, size: C, startIndices: M } = e, { accessor: P, transform: j } = c, Y = x.binaryAccessor || // @ts-ignore
    (typeof P == "function" ? P : l[P]);
    hs(typeof Y == "function", `accessor "${P}" is not a function`);
    let Q = e.getVertexOffset(s);
    const { iterable: _e, objectInfo: me } = VA(i, s, o);
    for (const we of _e) {
      me.index++;
      let Ee = Y(we, me);
      if (j && (Ee = j.call(this, Ee)), M) {
        const Oe = (me.index < M.length - 1 ? M[me.index + 1] : u) - M[me.index];
        if (Ee && Array.isArray(Ee[0])) {
          let Ne = Q;
          for (const ze of Ee)
            e._normalizeValue(ze, w, Ne), Ne += C;
        } else Ee && Ee.length > C ? w.set(Ee, Q) : (e._normalizeValue(Ee, me.target, 0), BD({
          target: w,
          source: me.target,
          start: Q,
          count: Oe
        }));
        Q += Oe * C;
      } else
        e._normalizeValue(Ee, w, Q), Q += C;
    }
  }
  /* eslint-enable max-depth, max-statements */
  // Validate deck.gl level fields
  _validateAttributeUpdaters() {
    const { settings: e } = this;
    if (!(e.noAlloc || typeof e.update == "function"))
      throw new Error(`Attribute ${this.id} missing update or accessor`);
  }
  // check that the first few elements of the attribute are reasonable
  /* eslint-disable no-fallthrough */
  _checkAttributeArray() {
    const { value: e } = this, i = Math.min(4, this.size);
    if (e && e.length >= i) {
      let s = !0;
      switch (i) {
        case 4:
          s = s && Number.isFinite(e[3]);
        case 3:
          s = s && Number.isFinite(e[2]);
        case 2:
          s = s && Number.isFinite(e[1]);
        case 1:
          s = s && Number.isFinite(e[0]);
          break;
        default:
          s = !1;
      }
      if (!s)
        throw new Error(`Illegal attribute generated for ${this.id}`);
    }
  }
}
function mm(t) {
  const { source: e, target: i, start: s = 0, size: o, getData: l } = t, u = t.end || i.length, c = e.length, x = u - s;
  if (c > x) {
    i.set(e.subarray(0, x), s);
    return;
  }
  if (i.set(e, s), !l)
    return;
  let w = c;
  for (; w < x; ) {
    const C = l(w, e);
    for (let M = 0; M < o; M++)
      i[s + w] = C[M] || 0, w++;
  }
}
function oN({ source: t, target: e, size: i, getData: s, sourceStartIndices: o, targetStartIndices: l }) {
  if (!o || !l)
    return mm({
      source: t,
      target: e,
      size: i,
      getData: s
    }), e;
  let u = 0, c = 0;
  const x = s && ((C, M) => s(C + c, M)), w = Math.min(o.length, l.length);
  for (let C = 1; C < w; C++) {
    const M = o[C] * i, P = l[C] * i;
    mm({
      source: t.subarray(u, M),
      target: e,
      start: c,
      end: P,
      size: i,
      getData: x
    }), u = M, c = P;
  }
  return c < e.length && mm({
    // @ts-ignore
    source: [],
    target: e,
    start: c,
    size: i,
    getData: x
  }), e;
}
function aN(t) {
  const { device: e, settings: i, value: s } = t, o = new $A(e, i);
  return o.setData({
    value: s instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
    normalized: i.normalized
  }), o;
}
function GA(t) {
  switch (t) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`No defined attribute type for size "${t}"`);
  }
}
function XA(t) {
  switch (t) {
    case 1:
      return "float32";
    case 2:
      return "float32x2";
    case 3:
      return "float32x3";
    case 4:
      return "float32x4";
    default:
      throw new Error("invalid type size");
  }
}
function WA(t) {
  t.push(t.shift());
}
function lN(t, e) {
  const { doublePrecision: i, settings: s, value: o, size: l } = t, u = i && o instanceof Float64Array ? 2 : 1;
  let c = 0;
  const { shaderAttributes: x } = t.settings;
  if (x)
    for (const w of Object.values(x))
      c = Math.max(c, w.vertexOffset ?? 0);
  return (s.noAlloc ? o.length : (e + c) * l) * u;
}
function qA({ device: t, source: e, target: i }) {
  return (!i || i.byteLength < e.byteLength) && (i == null || i.destroy(), i = t.createBuffer({
    byteLength: e.byteLength,
    usage: e.usage
  })), i;
}
function ZA({ device: t, buffer: e, attribute: i, fromLength: s, toLength: o, fromStartIndices: l, getData: u = (c) => c }) {
  const c = i.doublePrecision && i.value instanceof Float64Array ? 2 : 1, x = i.size * c, w = i.byteOffset, C = i.settings.bytesPerElement < 4 ? w / i.settings.bytesPerElement * 4 : w, M = i.startIndices, P = l && M, j = i.isConstant;
  if (!P && e && s >= o)
    return e;
  const Y = i.value instanceof Float64Array ? Float32Array : i.value.constructor, Q = j ? i.value : (
    // TODO(v9.1): Avoid non-portable synchronous reads.
    new Y(i.getBuffer().readSyncWebGL(w, o * Y.BYTES_PER_ELEMENT).buffer)
  );
  if (i.settings.normalized && !j) {
    const Ee = u;
    u = (Oe, Ne) => i.normalizeConstant(Ee(Oe, Ne));
  }
  const _e = j ? (Ee, Oe) => u(Q, Oe) : (Ee, Oe) => u(Q.subarray(Ee + w, Ee + w + x), Oe), me = e ? new Float32Array(e.readSyncWebGL(C, s * 4).buffer) : new Float32Array(0), we = new Float32Array(o);
  return oN({
    source: me,
    target: we,
    sourceStartIndices: l,
    targetStartIndices: M,
    size: x,
    getData: _e
  }), (!e || e.byteLength < we.byteLength + C) && (e == null || e.destroy(), e = t.createBuffer({
    byteLength: we.byteLength + C,
    usage: 35050
  })), e.write(we, C), e;
}
class KA {
  constructor({ device: e, attribute: i, timeline: s }) {
    this.buffers = [], this.currentLength = 0, this.device = e, this.transition = new gp(s), this.attribute = i, this.attributeInTransition = aN(i), this.currentStartIndices = i.startIndices;
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(e, i, s = 1 / 0) {
    this.settings = e, this.currentStartIndices = this.attribute.startIndices, this.currentLength = lN(this.attribute, i), this.transition.start({ ...e, duration: s });
  }
  update() {
    const e = this.transition.update();
    return e && this.onUpdate(), e;
  }
  setBuffer(e) {
    this.attributeInTransition.setData({
      buffer: e,
      normalized: this.attribute.settings.normalized,
      // Retain placeholder value to generate correct shader layout
      value: this.attributeInTransition.value
    });
  }
  cancel() {
    this.transition.cancel();
  }
  delete() {
    this.cancel();
    for (const e of this.buffers)
      e.destroy();
    this.buffers.length = 0;
  }
}
class cN extends KA {
  constructor({ device: e, attribute: i, timeline: s }) {
    super({ device: e, attribute: i, timeline: s }), this.type = "interpolation", this.transform = dN(e, i);
  }
  start(e, i) {
    const s = this.currentLength, o = this.currentStartIndices;
    if (super.start(e, i, e.duration), e.duration <= 0) {
      this.transition.cancel();
      return;
    }
    const { buffers: l, attribute: u } = this;
    WA(l), l[0] = ZA({
      device: this.device,
      buffer: l[0],
      attribute: u,
      fromLength: s,
      toLength: this.currentLength,
      fromStartIndices: o,
      getData: e.enter
    }), l[1] = qA({
      device: this.device,
      source: l[0],
      target: l[1]
    }), this.setBuffer(l[1]);
    const { transform: c } = this, x = c.model;
    let w = Math.floor(this.currentLength / u.size);
    JA(u) && (w /= 2), x.setVertexCount(w), u.isConstant ? (x.setAttributes({ aFrom: l[0] }), x.setConstantAttributes({ aTo: u.value })) : x.setAttributes({
      aFrom: l[0],
      aTo: u.getBuffer()
    }), c.transformFeedback.setBuffers({ vCurrent: l[1] });
  }
  onUpdate() {
    const { duration: e, easing: i } = this.settings, { time: s } = this.transition;
    let o = s / e;
    i && (o = i(o));
    const { model: l } = this.transform;
    l.setUniforms({ time: o }), this.transform.run({ discard: !0 });
  }
  delete() {
    super.delete(), this.transform.destroy();
  }
}
const hN = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

uniform float time;
in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, time);
  gl_Position = vec4(0.0);
}
`, uN = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

uniform float time;
in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
function JA(t) {
  return t.doublePrecision && t.value instanceof Float64Array;
}
function dN(t, e) {
  const i = e.size, s = GA(i), o = XA(i), l = e.getBufferLayout();
  return JA(e) ? new Su(t, {
    vs: uN,
    bufferLayout: [
      {
        name: "aFrom",
        byteStride: 8 * i,
        attributes: [
          { attribute: "aFrom", format: o, byteOffset: 0 },
          { attribute: "aFrom64Low", format: o, byteOffset: 4 * i }
        ]
      },
      {
        name: "aTo",
        byteStride: 8 * i,
        attributes: [
          { attribute: "aTo", format: o, byteOffset: 0 },
          { attribute: "aTo64Low", format: o, byteOffset: 4 * i }
        ]
      }
    ],
    modules: [TP],
    defines: {
      ATTRIBUTE_TYPE: s,
      ATTRIBUTE_SIZE: i
    },
    // Default uniforms are not set without this
    moduleSettings: {},
    varyings: ["vCurrent", "vCurrent64Low"],
    // @ts-expect-error WebGLRenderPipeline only prop TODO - support in RenderPipeline?
    bufferMode: 35980,
    disableWarnings: !0
  }) : new Su(t, {
    vs: hN,
    bufferLayout: [
      { name: "aFrom", format: o },
      { name: "aTo", format: l.attributes[0].format }
    ],
    defines: {
      ATTRIBUTE_TYPE: s
    },
    varyings: ["vCurrent"],
    disableWarnings: !0
  });
}
class fN extends KA {
  constructor({ device: e, attribute: i, timeline: s }) {
    super({ device: e, attribute: i, timeline: s }), this.type = "spring", this.texture = gN(e), this.framebuffer = yN(e, this.texture), this.transform = mN(e, i);
  }
  start(e, i) {
    const s = this.currentLength, o = this.currentStartIndices;
    super.start(e, i);
    const { buffers: l, attribute: u } = this;
    for (let x = 0; x < 2; x++)
      l[x] = ZA({
        device: this.device,
        buffer: l[x],
        attribute: u,
        fromLength: s,
        toLength: this.currentLength,
        fromStartIndices: o,
        getData: e.enter
      });
    l[2] = qA({
      device: this.device,
      source: l[0],
      target: l[2]
    }), this.setBuffer(l[1]);
    const { model: c } = this.transform;
    c.setVertexCount(Math.floor(this.currentLength / u.size)), u.isConstant ? c.setConstantAttributes({ aTo: u.value }) : c.setAttributes({ aTo: u.getBuffer() });
  }
  onUpdate() {
    const { buffers: e, transform: i, framebuffer: s, transition: o } = this, l = this.settings;
    i.model.setAttributes({
      aPrev: e[0],
      aCur: e[1]
    }), i.transformFeedback.setBuffers({ vNext: e[2] }), i.model.setUniforms({
      stiffness: l.stiffness,
      damping: l.damping
    }), i.run({
      framebuffer: s,
      discard: !1,
      parameters: { viewport: [0, 0, 1, 1] },
      clearColor: [0, 0, 0, 0]
    }), WA(e), this.setBuffer(e[1]), this.device.readPixelsToArrayWebGL(s)[0] > 0 || o.end();
  }
  delete() {
    super.delete(), this.transform.destroy(), this.texture.destroy(), this.framebuffer.destroy();
  }
}
const pN = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

uniform float stiffness;
uniform float damping;
in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE spring = delta * stiffness;
  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;
  return spring + damper + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`, _N = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
function mN(t, e) {
  const i = GA(e.size), s = XA(e.size);
  return new Su(t, {
    vs: pN,
    fs: _N,
    bufferLayout: [
      { name: "aPrev", format: s },
      { name: "aCur", format: s },
      { name: "aTo", format: e.getBufferLayout().attributes[0].format }
    ],
    varyings: ["vNext"],
    defines: { ATTRIBUTE_TYPE: i },
    parameters: {
      depthCompare: "always",
      blendColorOperation: "max",
      blendColorSrcFactor: "one",
      blendColorDstFactor: "one",
      blendAlphaOperation: "max",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one"
    }
  });
}
function gN(t) {
  return t.createTexture({
    data: new Uint8Array(4),
    format: "rgba8unorm",
    mipmaps: !1,
    // dataFormat: GL.RGBA,
    width: 1,
    height: 1
  });
}
function yN(t, e) {
  return t.createFramebuffer({
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    colorAttachments: [e]
  });
}
const bN = {
  interpolation: cN,
  spring: fN
};
class vN {
  constructor(e, { id: i, timeline: s }) {
    if (!e)
      throw new Error("AttributeTransitionManager is constructed without device");
    this.id = i, this.device = e, this.timeline = s, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1;
  }
  finalize() {
    for (const e in this.transitions)
      this._removeTransition(e);
  }
  /* Public methods */
  // Called when attribute manager updates
  // Check the latest attributes for updates.
  update({ attributes: e, transitions: i, numInstances: s }) {
    this.numInstances = s || 1;
    for (const o in e) {
      const l = e[o], u = l.getTransitionSetting(i);
      u && this._updateAttribute(o, l, u);
    }
    for (const o in this.transitions) {
      const l = e[o];
      (!l || !l.getTransitionSetting(i)) && this._removeTransition(o);
    }
  }
  // Returns `true` if attribute is transition-enabled
  hasAttribute(e) {
    const i = this.transitions[e];
    return i && i.inProgress;
  }
  // Get all the animated attributes
  getAttributes() {
    const e = {};
    for (const i in this.transitions) {
      const s = this.transitions[i];
      s.inProgress && (e[i] = s.attributeInTransition);
    }
    return e;
  }
  /* eslint-disable max-statements */
  // Called every render cycle, run transform feedback
  // Returns `true` if anything changes
  run() {
    if (this.numInstances === 0)
      return !1;
    for (const i in this.transitions)
      this.transitions[i].update() && (this.needsRedraw = !0);
    const e = this.needsRedraw;
    return this.needsRedraw = !1, e;
  }
  /* eslint-enable max-statements */
  /* Private methods */
  _removeTransition(e) {
    this.transitions[e].delete(), delete this.transitions[e];
  }
  // Check an attributes for updates
  // Returns a transition object if a new transition is triggered.
  _updateAttribute(e, i, s) {
    const o = this.transitions[e];
    let l = !o || o.type !== s.type;
    if (l) {
      o && this._removeTransition(e);
      const u = bN[s.type];
      u ? this.transitions[e] = new u({
        attribute: i,
        timeline: this.timeline,
        device: this.device
      }) : (Jt.error(`unsupported transition type '${s.type}'`)(), l = !1);
    }
    (l || i.needsRedraw()) && (this.needsRedraw = !0, this.transitions[e].start(s, this.numInstances));
  }
}
const xx = "attributeManager.invalidate", xN = "attributeManager.updateStart", wN = "attributeManager.updateEnd", AN = "attribute.updateStart", TN = "attribute.allocate", EN = "attribute.updateEnd";
class SN {
  constructor(e, { id: i = "attribute-manager", stats: s, timeline: o } = {}) {
    this.mergeBoundsMemoized = Nu(cD), this.id = i, this.device = e, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = s, this.attributeTransitionManager = new vN(e, {
      id: `${i}-transitions`,
      timeline: o
    }), Object.seal(this);
  }
  finalize() {
    for (const e in this.attributes)
      this.attributes[e].delete();
    this.attributeTransitionManager.finalize();
  }
  // Returns the redraw flag, optionally clearing it.
  // Redraw flag will be set if any attributes attributes changed since
  // flag was last cleared.
  //
  // @param {String} [clearRedrawFlags=false] - whether to clear the flag
  // @return {false|String} - reason a redraw is needed.
  getNeedsRedraw(e = { clearRedrawFlags: !1 }) {
    const i = this.needsRedraw;
    return this.needsRedraw = this.needsRedraw && !e.clearRedrawFlags, i && this.id;
  }
  // Sets the redraw flag.
  // @param {Boolean} redraw=true
  setNeedsRedraw() {
    this.needsRedraw = !0;
  }
  // Adds attributes
  add(e) {
    this._add(e);
  }
  // Adds attributes
  addInstanced(e) {
    this._add(e, { stepMode: "instance" });
  }
  /**
   * Removes attributes
   * Takes an array of attribute names and delete them from
   * the attribute map if they exists
   *
   * @example
   * attributeManager.remove(['position']);
   *
   * @param {Object} attributeNameArray - attribute name array (see above)
   */
  remove(e) {
    for (const i of e)
      this.attributes[i] !== void 0 && (this.attributes[i].delete(), delete this.attributes[i]);
  }
  // Marks an attribute for update
  invalidate(e, i) {
    const s = this._invalidateTrigger(e, i);
    qs(xx, this, e, s);
  }
  invalidateAll(e) {
    for (const i in this.attributes)
      this.attributes[i].setNeedsUpdate(i, e);
    qs(xx, this, "all");
  }
  // Ensure all attribute buffers are updated from props or data.
  // eslint-disable-next-line complexity
  update({ data: e, numInstances: i, startIndices: s = null, transitions: o, props: l = {}, buffers: u = {}, context: c = {} }) {
    let x = !1;
    qs(xN, this), this.stats && this.stats.get("Update Attributes").timeStart();
    for (const w in this.attributes) {
      const C = this.attributes[w], M = C.settings.accessor;
      C.startIndices = s, C.numInstances = i, l[w] && Jt.removed(`props.${w}`, `data.attributes.${w}`)(), C.setExternalBuffer(u[w]) || C.setBinaryValue(typeof M == "string" ? u[M] : void 0, e.startIndices) || typeof M == "string" && !u[M] && C.setConstantValue(l[M]) || C.needsUpdate() && (x = !0, this._updateAttribute({
        attribute: C,
        numInstances: i,
        data: e,
        props: l,
        context: c
      })), this.needsRedraw = this.needsRedraw || C.needsRedraw();
    }
    x && qs(wN, this, i), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances: i,
      transitions: o
    });
  }
  // Update attribute transition to the current timestamp
  // Returns `true` if any transition is in progress
  updateTransition() {
    const { attributeTransitionManager: e } = this, i = e.run();
    return this.needsRedraw = this.needsRedraw || i, i;
  }
  /**
   * Returns all attribute descriptors
   * Note: Format matches luma.gl Model/Program.setAttributes()
   * @return {Object} attributes - descriptors
   */
  getAttributes() {
    return { ...this.attributes, ...this.attributeTransitionManager.getAttributes() };
  }
  /**
   * Computes the spatial bounds of a given set of attributes
   */
  getBounds(e) {
    const i = e.map((s) => {
      var o;
      return (o = this.attributes[s]) == null ? void 0 : o.getBounds();
    });
    return this.mergeBoundsMemoized(i);
  }
  /**
   * Returns changed attribute descriptors
   * This indicates which WebGLBuffers need to be updated
   * @return {Object} attributes - descriptors
   */
  getChangedAttributes(e = { clearChangedFlags: !1 }) {
    const { attributes: i, attributeTransitionManager: s } = this, o = { ...s.getAttributes() };
    for (const l in i) {
      const u = i[l];
      u.needsRedraw(e) && !s.hasAttribute(l) && (o[l] = u);
    }
    return o;
  }
  /** Generate WebGPU-style buffer layout descriptors from all attributes */
  getBufferLayouts(e) {
    return Object.values(this.getAttributes()).map((i) => i.getBufferLayout(e));
  }
  // PRIVATE METHODS
  /** Register new attributes */
  _add(e, i) {
    for (const s in e) {
      const o = e[s], l = {
        ...o,
        id: s,
        size: o.isIndexed && 1 || o.size || 1,
        ...i
      };
      this.attributes[s] = new $A(this.device, l);
    }
    this._mapUpdateTriggersToAttributes();
  }
  // build updateTrigger name to attribute name mapping
  _mapUpdateTriggersToAttributes() {
    const e = {};
    for (const i in this.attributes)
      this.attributes[i].getUpdateTriggers().forEach((o) => {
        e[o] || (e[o] = []), e[o].push(i);
      });
    this.updateTriggers = e;
  }
  _invalidateTrigger(e, i) {
    const { attributes: s, updateTriggers: o } = this, l = o[e];
    return l && l.forEach((u) => {
      const c = s[u];
      c && c.setNeedsUpdate(c.id, i);
    }), l;
  }
  _updateAttribute(e) {
    const { attribute: i, numInstances: s } = e;
    if (qs(AN, i), i.constant) {
      i.setConstantValue(i.value);
      return;
    }
    i.allocate(s) && qs(TN, i, s), i.updateBuffer(e) && (this.needsRedraw = !0, qs(EN, i, s));
  }
}
class CN extends gp {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const { time: e, settings: { fromValue: i, toValue: s, duration: o, easing: l } } = this, u = l(e / o);
    this._value = zf(i, s, u);
  }
}
const wx = 1e-5;
function Ax(t, e, i, s, o) {
  const l = e - t, c = (i - e) * o, x = -l * s;
  return c + x + l + e;
}
function IN(t, e, i, s, o) {
  if (Array.isArray(i)) {
    const l = [];
    for (let u = 0; u < i.length; u++)
      l[u] = Ax(t[u], e[u], i[u], s, o);
    return l;
  }
  return Ax(t, e, i, s, o);
}
function Tx(t, e) {
  if (Array.isArray(t)) {
    let i = 0;
    for (let s = 0; s < t.length; s++) {
      const o = t[s] - e[s];
      i += o * o;
    }
    return Math.sqrt(i);
  }
  return Math.abs(t - e);
}
class RN extends gp {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const { fromValue: e, toValue: i, damping: s, stiffness: o } = this.settings, { _prevValue: l = e, _currValue: u = e } = this;
    let c = IN(l, u, i, s, o);
    const x = Tx(c, i), w = Tx(c, u);
    x < wx && w < wx && (c = i, this.end()), this._prevValue = u, this._currValue = c;
  }
}
const MN = {
  interpolation: CN,
  spring: RN
};
class PN {
  constructor(e) {
    this.transitions = /* @__PURE__ */ new Map(), this.timeline = e;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(e, i, s, o) {
    const { transitions: l } = this;
    if (l.has(e)) {
      const x = l.get(e), { value: w = x.settings.fromValue } = x;
      i = w, this.remove(e);
    }
    if (o = jA(o), !o)
      return;
    const u = MN[o.type];
    if (!u) {
      Jt.error(`unsupported transition type '${o.type}'`)();
      return;
    }
    const c = new u(this.timeline);
    c.start({
      ...o,
      fromValue: i,
      toValue: s
    }), l.set(e, c);
  }
  remove(e) {
    const { transitions: i } = this;
    i.has(e) && (i.get(e).cancel(), i.delete(e));
  }
  update() {
    const e = {};
    for (const [i, s] of this.transitions)
      s.update(), e[i] = s.value, s.inProgress || this.remove(i);
    return e;
  }
  clear() {
    for (const e of this.transitions.keys())
      this.remove(e);
  }
}
function BN(t) {
  const e = t[da];
  for (const i in e) {
    const s = e[i], { validate: o } = s;
    if (o && !o(t[i], s))
      throw new Error(`Invalid prop ${i}: ${t[i]}`);
  }
}
function DN(t, e) {
  const i = YA({
    newProps: t,
    oldProps: e,
    propTypes: t[da],
    ignoreProps: { data: null, updateTriggers: null, extensions: null, transitions: null }
  }), s = FN(t, e);
  let o = !1;
  return s || (o = kN(t, e)), {
    dataChanged: s,
    propsChanged: i,
    updateTriggersChanged: o,
    extensionsChanged: NN(t, e),
    transitionsChanged: ON(t, e)
  };
}
function ON(t, e) {
  if (!t.transitions)
    return !1;
  const i = {}, s = t[da];
  let o = !1;
  for (const l in t.transitions) {
    const u = s[l], c = u && u.type;
    (c === "number" || c === "color" || c === "array") && Cg(t[l], e[l], u) && (i[l] = !0, o = !0);
  }
  return o ? i : !1;
}
function YA({ newProps: t, oldProps: e, ignoreProps: i = {}, propTypes: s = {}, triggerName: o = "props" }) {
  if (e === t)
    return !1;
  if (typeof t != "object" || t === null)
    return `${o} changed shallowly`;
  if (typeof e != "object" || e === null)
    return `${o} changed shallowly`;
  for (const l of Object.keys(t))
    if (!(l in i)) {
      if (!(l in e))
        return `${o}.${l} added`;
      const u = Cg(t[l], e[l], s[l]);
      if (u)
        return `${o}.${l} ${u}`;
    }
  for (const l of Object.keys(e))
    if (!(l in i)) {
      if (!(l in t))
        return `${o}.${l} dropped`;
      if (!Object.hasOwnProperty.call(t, l)) {
        const u = Cg(t[l], e[l], s[l]);
        if (u)
          return `${o}.${l} ${u}`;
      }
    }
  return !1;
}
function Cg(t, e, i) {
  let s = i && i.equal;
  return s && !s(t, e, i) || !s && (s = t && e && t.equals, s && !s.call(t, e)) ? "changed deeply" : !s && e !== t ? "changed shallowly" : null;
}
function FN(t, e) {
  if (e === null)
    return "oldProps is null, initial diff";
  let i = !1;
  const { dataComparator: s, _dataDiff: o } = t;
  return s ? s(t.data, e.data) || (i = "Data comparator detected a change") : t.data !== e.data && (i = "A new data container was supplied"), i && o && (i = o(t.data, e.data) || i), i;
}
function kN(t, e) {
  if (e === null)
    return { all: !0 };
  if ("all" in t.updateTriggers && Ex(t, e, "all"))
    return { all: !0 };
  const i = {};
  let s = !1;
  for (const o in t.updateTriggers)
    o !== "all" && Ex(t, e, o) && (i[o] = !0, s = !0);
  return s ? i : !1;
}
function NN(t, e) {
  if (e === null)
    return !0;
  const i = e.extensions, { extensions: s } = t;
  if (s === i)
    return !1;
  if (!i || !s || s.length !== i.length)
    return !0;
  for (let o = 0; o < s.length; o++)
    if (!s[o].equals(i[o]))
      return !0;
  return !1;
}
function Ex(t, e, i) {
  let s = t.updateTriggers[i];
  s = s ?? {};
  let o = e.updateTriggers[i];
  return o = o ?? {}, YA({
    oldProps: o,
    newProps: s,
    triggerName: i
  });
}
const LN = "count(): argument not an object", UN = "count(): argument not a container";
function zN(t) {
  if (!HN(t))
    throw new Error(LN);
  if (typeof t.count == "function")
    return t.count();
  if (Number.isFinite(t.size))
    return t.size;
  if (Number.isFinite(t.length))
    return t.length;
  if (VN(t))
    return Object.keys(t).length;
  throw new Error(UN);
}
function VN(t) {
  return t !== null && typeof t == "object" && t.constructor === Object;
}
function HN(t) {
  return t !== null && typeof t == "object";
}
function Sx(t, e) {
  if (!e)
    return t;
  const i = { ...t, ...e };
  if ("defines" in e && (i.defines = { ...t.defines, ...e.defines }), "modules" in e && (i.modules = (t.modules || []).concat(e.modules), e.modules.some((s) => s.name === "project64"))) {
    const s = i.modules.findIndex((o) => o.name === "project32");
    s >= 0 && i.modules.splice(s, 1);
  }
  if ("inject" in e)
    if (!t.inject)
      i.inject = e.inject;
    else {
      const s = { ...t.inject };
      for (const o in e.inject)
        s[o] = (s[o] || "") + e.inject[o];
      i.inject = s;
    }
  return i;
}
const jN = {
  minFilter: "linear",
  mipmapFilter: "linear",
  magFilter: "linear",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
}, Ig = {};
function $N(t, e, i, s) {
  if (i instanceof Ur)
    return i;
  i.constructor && i.constructor.name !== "Object" && (i = { data: i });
  let o = null;
  i.compressed && (o = {
    minFilter: "linear",
    mipmapFilter: i.data.length > 1 ? "nearest" : "linear"
  });
  const l = e.createTexture({
    ...i,
    sampler: {
      ...jN,
      ...o,
      ...s
    }
  });
  return Ig[l.id] = t, l;
}
function GN(t, e) {
  !e || !(e instanceof Ur) || Ig[e.id] === t && (e.delete(), delete Ig[e.id]);
}
const XN = {
  boolean: {
    validate(t, e) {
      return !0;
    },
    equal(t, e, i) {
      return !!t == !!e;
    }
  },
  number: {
    validate(t, e) {
      return Number.isFinite(t) && (!("max" in e) || t <= e.max) && (!("min" in e) || t >= e.min);
    }
  },
  color: {
    validate(t, e) {
      return e.optional && !t || Rg(t) && (t.length === 3 || t.length === 4);
    },
    equal(t, e, i) {
      return gn(t, e, 1);
    }
  },
  accessor: {
    validate(t, e) {
      const i = Wf(t);
      return i === "function" || i === Wf(e.value);
    },
    equal(t, e, i) {
      return typeof e == "function" ? !0 : gn(t, e, 1);
    }
  },
  array: {
    validate(t, e) {
      return e.optional && !t || Rg(t);
    },
    equal(t, e, i) {
      const { compare: s } = i, o = Number.isInteger(s) ? s : s ? 1 : 0;
      return s ? gn(t, e, o) : t === e;
    }
  },
  object: {
    equal(t, e, i) {
      if (i.ignore)
        return !0;
      const { compare: s } = i, o = Number.isInteger(s) ? s : s ? 1 : 0;
      return s ? gn(t, e, o) : t === e;
    }
  },
  function: {
    validate(t, e) {
      return e.optional && !t || typeof t == "function";
    },
    equal(t, e, i) {
      return !i.compare && i.ignore !== !1 || t === e;
    }
  },
  data: {
    transform: (t, e, i) => {
      if (!t)
        return t;
      const { dataTransform: s } = i.props;
      return s ? s(t) : typeof t.shape == "string" && t.shape.endsWith("-table") && Array.isArray(t.data) ? t.data : t;
    }
  },
  image: {
    transform: (t, e, i) => {
      const s = i.context;
      return !s || !s.device ? null : $N(i.id, s.device, t, {
        ...e.parameters,
        ...i.props.textureParameters
      });
    },
    release: (t, e, i) => {
      GN(i.id, t);
    }
  }
};
function WN(t) {
  const e = {}, i = {}, s = {};
  for (const [o, l] of Object.entries(t)) {
    const u = l == null ? void 0 : l.deprecatedFor;
    if (u)
      s[o] = Array.isArray(u) ? u : [u];
    else {
      const c = qN(o, l);
      e[o] = c, i[o] = c.value;
    }
  }
  return { propTypes: e, defaultProps: i, deprecatedProps: s };
}
function qN(t, e) {
  switch (Wf(e)) {
    case "object":
      return eu(t, e);
    case "array":
      return eu(t, { type: "array", value: e, compare: !1 });
    case "boolean":
      return eu(t, { type: "boolean", value: e });
    case "number":
      return eu(t, { type: "number", value: e });
    case "function":
      return eu(t, { type: "function", value: e, compare: !0 });
    default:
      return { name: t, type: "unknown", value: e };
  }
}
function eu(t, e) {
  return "type" in e ? { name: t, ...XN[e.type], ...e } : "value" in e ? { name: t, type: Wf(e.value), ...e } : { name: t, type: "object", value: e };
}
function Rg(t) {
  return Array.isArray(t) || ArrayBuffer.isView(t);
}
function Wf(t) {
  return Rg(t) ? "array" : t === null ? "null" : typeof t;
}
function ZN(t, e) {
  let i;
  for (let l = e.length - 1; l >= 0; l--) {
    const u = e[l];
    "extensions" in u && (i = u.extensions);
  }
  const s = Mg(t.constructor, i), o = Object.create(s);
  o[Gf] = t, o[al] = {}, o[ha] = {};
  for (let l = 0; l < e.length; ++l) {
    const u = e[l];
    for (const c in u)
      o[c] = u[c];
  }
  return Object.freeze(o), o;
}
const KN = "_mergedDefaultProps";
function Mg(t, e) {
  if (!(t instanceof xp.constructor))
    return {};
  let i = KN;
  if (e)
    for (const o of e) {
      const l = o.constructor;
      l && (i += `:${l.extensionName || l.name}`);
    }
  const s = QA(t, i);
  return s || (t[i] = JN(t, e || []));
}
function JN(t, e) {
  if (!t.prototype)
    return null;
  const s = Object.getPrototypeOf(t), o = Mg(s), l = QA(t, "defaultProps") || {}, u = WN(l), c = Object.assign(/* @__PURE__ */ Object.create(null), o, u.defaultProps), x = Object.assign(/* @__PURE__ */ Object.create(null), o == null ? void 0 : o[da], u.propTypes), w = Object.assign(/* @__PURE__ */ Object.create(null), o == null ? void 0 : o[nm], u.deprecatedProps);
  for (const C of e) {
    const M = Mg(C.constructor);
    M && (Object.assign(c, M), Object.assign(x, M[da]), Object.assign(w, M[nm]));
  }
  return YN(c, t), eL(c, x), QN(c, w), c[da] = x, c[nm] = w, e.length === 0 && !Ey(t, "_propTypes") && (t._propTypes = x), c;
}
function YN(t, e) {
  const i = iL(e);
  Object.defineProperties(t, {
    // `id` is treated specially because layer might need to override it
    id: {
      writable: !0,
      value: i
    }
  });
}
function QN(t, e) {
  for (const i in e)
    Object.defineProperty(t, i, {
      enumerable: !1,
      set(s) {
        const o = `${this.id}: ${i}`;
        for (const l of e[i])
          Ey(this, l) || (this[l] = s);
        Jt.deprecated(o, e[i].join("/"))();
      }
    });
}
function eL(t, e) {
  const i = {}, s = {};
  for (const o in e) {
    const l = e[o], { name: u, value: c } = l;
    l.async && (i[u] = c, s[u] = tL(u));
  }
  t[Mc] = i, t[al] = {}, Object.defineProperties(t, s);
}
function tL(t) {
  return {
    enumerable: !0,
    // Save the provided value for async props in a special map
    set(e) {
      typeof e == "string" || e instanceof Promise || HA(e) ? this[al][t] = e : this[ha][t] = e;
    },
    // Only the component's state knows the true value of async prop
    get() {
      if (this[ha]) {
        if (t in this[ha])
          return this[ha][t] || this[Mc][t];
        if (t in this[al]) {
          const e = this[Gf] && this[Gf].internalState;
          if (e && e.hasAsyncProp(t))
            return e.getAsyncProp(t) || this[Mc][t];
        }
      }
      return this[Mc][t];
    }
  };
}
function Ey(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function QA(t, e) {
  return Ey(t, e) && t[e];
}
function iL(t) {
  const e = t.componentName;
  return e || Jt.warn(`${t.name}.componentName not specified`)(), e || t.name;
}
let sL = 0;
class xp {
  constructor(...e) {
    this.props = ZN(this, e), this.id = this.props.id, this.count = sL++;
  }
  // clone this layer with modified props
  clone(e) {
    const { props: i } = this, s = {};
    for (const o in i[Mc])
      o in i[ha] ? s[o] = i[ha][o] : o in i[al] && (s[o] = i[al][o]);
    return new this.constructor({ ...i, ...s, ...e });
  }
}
xp.componentName = "Component";
xp.defaultProps = {};
const rL = Object.freeze({});
class nL {
  constructor(e) {
    this.component = e, this.asyncProps = {}, this.onAsyncPropUpdated = () => {
    }, this.oldProps = null, this.oldAsyncProps = null;
  }
  finalize() {
    for (const e in this.asyncProps) {
      const i = this.asyncProps[e];
      i && i.type && i.type.release && i.type.release(i.resolvedValue, i.type, this.component);
    }
    this.asyncProps = {}, this.component = null, this.resetOldProps();
  }
  /* Layer-facing props API */
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || rL;
  }
  resetOldProps() {
    this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null;
  }
  // Checks if a prop is overridden
  hasAsyncProp(e) {
    return e in this.asyncProps;
  }
  // Returns value of an overriden prop
  getAsyncProp(e) {
    const i = this.asyncProps[e];
    return i && i.resolvedValue;
  }
  isAsyncPropLoading(e) {
    if (e) {
      const i = this.asyncProps[e];
      return !!(i && i.pendingLoadCount > 0 && i.pendingLoadCount !== i.resolvedLoadCount);
    }
    for (const i in this.asyncProps)
      if (this.isAsyncPropLoading(i))
        return !0;
    return !1;
  }
  // Without changing the original prop value, swap out the data resolution under the hood
  reloadAsyncProp(e, i) {
    this._watchPromise(e, Promise.resolve(i));
  }
  // Updates all async/overridden props (when new props come in)
  // Checks if urls have changed, starts loading, or removes override
  setAsyncProps(e) {
    this.component = e[Gf] || this.component;
    const i = e[ha] || {}, s = e[al] || e, o = e[Mc] || {};
    for (const l in i) {
      const u = i[l];
      this._createAsyncPropData(l, o[l]), this._updateAsyncProp(l, u), i[l] = this.getAsyncProp(l);
    }
    for (const l in s) {
      const u = s[l];
      this._createAsyncPropData(l, o[l]), this._updateAsyncProp(l, u);
    }
  }
  /* Placeholder methods for subclassing */
  _fetch(e, i) {
    return null;
  }
  _onResolve(e, i) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  _onError(e, i) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  // Intercept strings (URLs) and Promises and activates loading and prop rewriting
  _updateAsyncProp(e, i) {
    if (this._didAsyncInputValueChange(e, i)) {
      if (typeof i == "string" && (i = this._fetch(e, i)), i instanceof Promise) {
        this._watchPromise(e, i);
        return;
      }
      if (HA(i)) {
        this._resolveAsyncIterable(e, i);
        return;
      }
      this._setPropValue(e, i);
    }
  }
  // Whenever async props are changing, we need to make a copy of oldProps
  // otherwise the prop rewriting will affect the value both in props and oldProps.
  // While the copy is relatively expensive, this only happens on load completion.
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const e in this.asyncProps)
        Object.defineProperty(this.oldAsyncProps, e, {
          enumerable: !0,
          value: this.oldProps[e]
        });
    }
  }
  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)
  _didAsyncInputValueChange(e, i) {
    const s = this.asyncProps[e];
    return i === s.resolvedValue || i === s.lastValue ? !1 : (s.lastValue = i, !0);
  }
  // Set normal, non-async value
  _setPropValue(e, i) {
    this._freezeAsyncOldProps();
    const s = this.asyncProps[e];
    s && (i = this._postProcessValue(s, i), s.resolvedValue = i, s.pendingLoadCount++, s.resolvedLoadCount = s.pendingLoadCount);
  }
  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously
  _setAsyncPropValue(e, i, s) {
    const o = this.asyncProps[e];
    o && s >= o.resolvedLoadCount && i !== void 0 && (this._freezeAsyncOldProps(), o.resolvedValue = i, o.resolvedLoadCount = s, this.onAsyncPropUpdated(e, i));
  }
  // Tracks a promise, sets the prop when loaded, handles load count
  _watchPromise(e, i) {
    const s = this.asyncProps[e];
    if (s) {
      s.pendingLoadCount++;
      const o = s.pendingLoadCount;
      i.then((l) => {
        this.component && (l = this._postProcessValue(s, l), this._setAsyncPropValue(e, l, o), this._onResolve(e, l));
      }).catch((l) => {
        this._onError(e, l);
      });
    }
  }
  async _resolveAsyncIterable(e, i) {
    if (e !== "data") {
      this._setPropValue(e, i);
      return;
    }
    const s = this.asyncProps[e];
    if (!s)
      return;
    s.pendingLoadCount++;
    const o = s.pendingLoadCount;
    let l = [], u = 0;
    for await (const c of i) {
      if (!this.component)
        return;
      const { dataTransform: x } = this.component.props;
      x ? l = x(c, l) : l = l.concat(c), Object.defineProperty(l, "__diff", {
        enumerable: !1,
        value: [{ startRow: u, endRow: l.length }]
      }), u = l.length, this._setAsyncPropValue(e, l, o);
    }
    this._onResolve(e, l);
  }
  // Give the app a chance to post process the loaded data
  _postProcessValue(e, i) {
    const s = e.type;
    return s && this.component && (s.release && s.release(e.resolvedValue, s, this.component), s.transform) ? s.transform(i, s, this.component) : i;
  }
  // Creating an asyncProp record if needed
  _createAsyncPropData(e, i) {
    if (!this.asyncProps[e]) {
      const o = this.component && this.component.props[da];
      this.asyncProps[e] = {
        type: o && o[e],
        lastValue: null,
        resolvedValue: i,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
}
class oL extends nL {
  constructor({ attributeManager: e, layer: i }) {
    super(i), this.attributeManager = e, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1;
  }
  get layer() {
    return this.component;
  }
  /* Override base Component methods with Layer-specific handling */
  _fetch(e, i) {
    const s = this.layer, o = s == null ? void 0 : s.props.fetch;
    return o ? o(i, { propName: e, layer: s }) : super._fetch(e, i);
  }
  _onResolve(e, i) {
    const s = this.layer;
    if (s) {
      const o = s.props.onDataLoad;
      e === "data" && o && o(i, { propName: e, layer: s });
    }
  }
  _onError(e, i) {
    const s = this.layer;
    s && s.raiseError(i, `loading ${e} of ${this.layer}`);
  }
}
const aL = "layer.changeFlag", lL = "layer.initialize", cL = "layer.update", hL = "layer.finalize", uL = "layer.matched", Cx = 2 ** 24 - 1, dL = Object.freeze([]), fL = Nu(({ oldViewport: t, viewport: e }) => t.equals(e));
let Hn = new Uint8ClampedArray(0);
const pL = {
  // data: Special handling for null, see below
  data: { type: "data", value: dL, async: !0 },
  dataComparator: { type: "function", value: null, optional: !0 },
  _dataDiff: {
    type: "function",
    // @ts-ignore __diff is not defined on data
    value: (t) => t && t.__diff,
    optional: !0
  },
  dataTransform: { type: "function", value: null, optional: !0 },
  onDataLoad: { type: "function", value: null, optional: !0 },
  onError: { type: "function", value: null, optional: !0 },
  fetch: {
    type: "function",
    value: (t, { propName: e, layer: i, loaders: s, loadOptions: o, signal: l }) => {
      const { resourceManager: u } = i.context;
      o = o || i.getLoadOptions(), s = s || i.props.loaders, l && (o = {
        ...o,
        fetch: {
          ...o == null ? void 0 : o.fetch,
          signal: l
        }
      });
      let c = u.contains(t);
      return !c && !o && (u.add({ resourceId: t, data: pa(t, s), persistent: !1 }), c = !0), c ? u.subscribe({
        resourceId: t,
        onChange: (x) => {
          var w;
          return (w = i.internalState) == null ? void 0 : w.reloadAsyncProp(e, x);
        },
        consumerId: i.id,
        requestId: e
      }) : pa(t, s, o);
    }
  },
  updateTriggers: {},
  // Update triggers: a core change detection mechanism in deck.gl
  visible: !0,
  pickable: !1,
  opacity: { type: "number", min: 0, max: 1, value: 1 },
  operation: "draw",
  onHover: { type: "function", value: null, optional: !0 },
  onClick: { type: "function", value: null, optional: !0 },
  onDragStart: { type: "function", value: null, optional: !0 },
  onDrag: { type: "function", value: null, optional: !0 },
  onDragEnd: { type: "function", value: null, optional: !0 },
  coordinateSystem: Wt.DEFAULT,
  coordinateOrigin: { type: "array", value: [0, 0, 0], compare: !0 },
  modelMatrix: { type: "array", value: null, compare: !0, optional: !0 },
  wrapLongitude: !1,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: { type: "object", value: {}, optional: !0, compare: 2 },
  loadOptions: { type: "object", value: null, optional: !0, ignore: !0 },
  transitions: null,
  extensions: [],
  loaders: { type: "array", value: [], optional: !0, ignore: !0 },
  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: {
    type: "function",
    value: ({ layerIndex: t }) => [0, -t * 100]
  },
  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: !1,
  highlightColor: { type: "accessor", value: [0, 0, 128, 128] }
};
class Gc extends xp {
  constructor() {
    super(...arguments), this.internalState = null, this.lifecycle = pc.NO_STATE, this.parent = null;
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  toString() {
    return `${this.constructor.layerName || this.constructor.name}({id: '${this.props.id}'})`;
  }
  // Public API for users
  /** Projects a point with current view state from the current layer's coordinate system to screen */
  project(e) {
    hs(this.internalState);
    const i = this.internalState.viewport || this.context.viewport, s = gA(e, {
      viewport: i,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    }), [o, l, u] = pA(s, i.pixelProjectionMatrix);
    return e.length === 2 ? [o, l] : [o, l, u];
  }
  /** Unprojects a screen pixel to the current view's default coordinate system
      Note: this does not reverse `project`. */
  unproject(e) {
    return hs(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(e);
  }
  /** Projects a point with current view state from the current layer's coordinate system to the world space */
  projectPosition(e, i) {
    hs(this.internalState);
    const s = this.internalState.viewport || this.context.viewport;
    return _D(e, {
      viewport: s,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...i
    });
  }
  // Public API for custom layer implementation
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !1;
  }
  /** Updates selected state members and marks the layer for redraw */
  setState(e) {
    this.setChangeFlags({ stateChanged: !0 }), Object.assign(this.state, e), this.setNeedsRedraw();
  }
  /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */
  setNeedsRedraw() {
    this.internalState && (this.internalState.needsRedraw = !0);
  }
  /** Mark this layer as needs a deep update */
  setNeedsUpdate() {
    this.internalState && (this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = !0);
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : !1;
  }
  /** Returns true if using shader-based WGS84 longitude wrapping */
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  /** @deprecated Returns true if the layer is visible in the picking pass */
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  /** Returns an array of models used by this layer, can be overriden by layer subclass */
  getModels() {
    const e = this.state;
    return e && (e.models || e.model && [e.model]) || [];
  }
  // TODO deprecate in favour of setShaderModuleProps
  /** Update shader module parameters */
  setModuleParameters(e) {
    for (const i of this.getModels())
      i.updateModuleSettings(e);
  }
  /** Update shader input parameters */
  setShaderModuleProps(...e) {
    for (const i of this.getModels())
      i.shaderInputs.setProps(...e);
  }
  /** Returns the attribute manager of this layer */
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  /** Returns the most recent layer that matched to this state
    (When reacting to an async event, this layer may no longer be the latest) */
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  /** Returns the default parse options for async props */
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const { coordinateSystem: e } = this.props;
    return e === Wt.DEFAULT || e === Wt.LNGLAT || e === Wt.CARTESIAN;
  }
  // Event handling
  onHover(e, i) {
    return this.props.onHover && this.props.onHover(e, i) || !1;
  }
  onClick(e, i) {
    return this.props.onClick && this.props.onClick(e, i) || !1;
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  // @return {Array} - a black color
  nullPickingColor() {
    return [0, 0, 0];
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  encodePickingColor(e, i = []) {
    return i[0] = e + 1 & 255, i[1] = e + 1 >> 8 & 255, i[2] = e + 1 >> 8 >> 8 & 255, i;
  }
  // Returns the index corresponding to a picking color that doesn't match any subfeature
  // @param {Uint8Array} color - color array to be decoded
  // @return {Array} - the decoded picking color
  decodePickingColor(e) {
    hs(e instanceof Uint8Array);
    const [i, s, o] = e;
    return i + s * 256 + o * 65536 - 1;
  }
  /** Deduces number of instances. Intention is to support:
    - Explicit setting of numInstances
    - Auto-deduction for ES6 containers that define a size member
    - Auto-deduction for Classic Arrays via the built-in length attribute
    - Auto-deduction via arrays */
  getNumInstances() {
    return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : zN(this.props.data);
  }
  /** Buffer layout describes how many attribute values are packed for each data object
      The default (null) is one value each object.
      Some data formats (e.g. paths, polygons) have various length. Their buffer layout
      is in the form of [L0, L1, L2, ...] */
  getStartIndices() {
    return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null;
  }
  // Default implementation
  getBounds() {
    var e;
    return (e = this.getAttributeManager()) == null ? void 0 : e.getBounds(["positions", "instancePositions"]);
  }
  getShaders(e) {
    e = Sx(e, {
      disableWarnings: !0,
      modules: this.context.defaultShaderModules
    });
    for (const i of this.props.extensions)
      e = Sx(e, i.getShaders.call(this, i));
    return e;
  }
  /** Controls if updateState should be called. By default returns true if any prop has changed */
  shouldUpdateState(e) {
    return e.changeFlags.propsOrDataChanged;
  }
  /** Default implementation, all attributes will be invalidated and updated when data changes */
  // eslint-disable-next-line complexity
  updateState(e) {
    const i = this.getAttributeManager(), { dataChanged: s } = e.changeFlags;
    if (s && i)
      if (Array.isArray(s))
        for (const o of s)
          i.invalidateAll(o);
      else
        i.invalidateAll();
    if (i) {
      const { props: o } = e, l = this.internalState.hasPickingBuffer, u = Number.isInteger(o.highlightedObjectIndex) || o.pickable || o.extensions.some((c) => c.getNeedsPickingBuffer.call(this, c));
      if (l !== u) {
        this.internalState.hasPickingBuffer = u;
        const { pickingColors: c, instancePickingColors: x } = i.attributes, w = c || x;
        w && (u && w.constant && (w.constant = !1, i.invalidate(w.id)), !w.value && !u && (w.constant = !0, w.value = [0, 0, 0]));
      }
    }
  }
  /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */
  finalizeState(e) {
    for (const s of this.getModels())
      s.destroy();
    const i = this.getAttributeManager();
    i && i.finalize(), this.context && this.context.resourceManager.unsubscribe({ consumerId: this.id }), this.internalState && (this.internalState.uniformTransitions.clear(), this.internalState.finalize());
  }
  // If state has a model, draw it with supplied uniforms
  draw(e) {
    for (const i of this.getModels())
      i.draw(e);
  }
  // called to populate the info object that is passed to the event handler
  // @return null to cancel event
  getPickingInfo({ info: e, mode: i, sourceLayer: s }) {
    const { index: o } = e;
    return o >= 0 && Array.isArray(this.props.data) && (e.object = this.props.data[o]), e;
  }
  // END LIFECYCLE METHODS
  // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker
  /** (Internal) Propagate an error event through the system */
  raiseError(e, i) {
    var s, o, l, u;
    i && (e = new Error(`${i}: ${e.message}`, { cause: e })), (o = (s = this.props).onError) != null && o.call(s, e) || (u = (l = this.context) == null ? void 0 : l.onError) == null || u.call(l, e, this);
  }
  /** (Internal) Checks if this layer needs redraw */
  getNeedsRedraw(e = { clearRedrawFlags: !1 }) {
    return this._getNeedsRedraw(e);
  }
  /** (Internal) Checks if this layer needs a deep update */
  needsUpdate() {
    return this.internalState ? this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams()) : !1;
  }
  /** Checks if this layer has ongoing uniform transition */
  hasUniformTransition() {
    var e;
    return ((e = this.internalState) == null ? void 0 : e.uniformTransitions.active) || !1;
  }
  /** Called when this layer is rendered into the given viewport */
  activateViewport(e) {
    if (!this.internalState)
      return;
    const i = this.internalState.viewport;
    this.internalState.viewport = e, (!i || !fL({ oldViewport: i, viewport: e })) && (this.setChangeFlags({ viewportChanged: !0 }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update());
  }
  /** Default implementation of attribute invalidation, can be redefined */
  invalidateAttribute(e = "all") {
    const i = this.getAttributeManager();
    i && (e === "all" ? i.invalidateAll() : i.invalidate(e));
  }
  /** Send updated attributes to the WebGL model */
  updateAttributes(e) {
    let i = !1;
    for (const s in e)
      e[s].layoutChanged() && (i = !0);
    for (const s of this.getModels())
      this._setModelAttributes(s, e, i);
  }
  /** Recalculate any attributes if needed */
  _updateAttributes() {
    const e = this.getAttributeManager();
    if (!e)
      return;
    const i = this.props, s = this.getNumInstances(), o = this.getStartIndices();
    e.update({
      data: i.data,
      numInstances: s,
      startIndices: o,
      props: i,
      transitions: i.transitions,
      // @ts-ignore (TS2339) property attribute is not present on some acceptable data types
      buffers: i.data.attributes,
      context: this
    });
    const l = e.getChangedAttributes({ clearChangedFlags: !0 });
    this.updateAttributes(l);
  }
  /** Update attribute transitions. This is called in drawLayer, no model updates required. */
  _updateAttributeTransition() {
    const e = this.getAttributeManager();
    e && e.updateTransition();
  }
  /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */
  _updateUniformTransition() {
    const { uniformTransitions: e } = this.internalState;
    if (e.active) {
      const i = e.update(), s = Object.create(this.props);
      for (const o in i)
        Object.defineProperty(s, o, { value: i[o] });
      return s;
    }
    return this.props;
  }
  /** Updater for the automatically populated instancePickingColors attribute */
  calculateInstancePickingColors(e, { numInstances: i }) {
    if (e.constant)
      return;
    const s = Math.floor(Hn.length / 4);
    if (this.internalState.usesPickingColorCache = !0, s < i) {
      i > Cx && Jt.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), Hn = Eu.allocate(Hn, i, {
        size: 4,
        copy: !0,
        maxCount: Math.max(i, Cx)
      });
      const o = Math.floor(Hn.length / 4), l = [];
      for (let u = s; u < o; u++)
        this.encodePickingColor(u, l), Hn[u * 4 + 0] = l[0], Hn[u * 4 + 1] = l[1], Hn[u * 4 + 2] = l[2];
    }
    e.value = Hn.subarray(0, i * 4);
  }
  /** Apply changed attributes to model */
  _setModelAttributes(e, i, s = !1) {
    var c;
    if (!Object.keys(i).length)
      return;
    if (s) {
      const x = this.getAttributeManager();
      e.setBufferLayout(x.getBufferLayouts(e)), i = x.getAttributes();
    }
    const o = ((c = e.userData) == null ? void 0 : c.excludeAttributes) || {}, l = {}, u = {};
    for (const x in i) {
      if (o[x])
        continue;
      const w = i[x].getValue();
      for (const C in w) {
        const M = w[C];
        M instanceof Vi ? i[x].settings.isIndexed ? e.setIndexBuffer(M) : l[C] = M : M && (u[C] = M);
      }
    }
    e.setAttributes(l), e.setConstantAttributes(u);
  }
  /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.
     This method may be overriden by layer implementations */
  disablePickingIndex(e) {
    const i = this.props.data;
    if (!("attributes" in i)) {
      this._disablePickingIndex(e);
      return;
    }
    const { pickingColors: s, instancePickingColors: o } = this.getAttributeManager().attributes, l = s || o, u = l && i.attributes && i.attributes[l.id];
    if (u && u.value) {
      const c = u.value, x = this.encodePickingColor(e);
      for (let w = 0; w < i.length; w++) {
        const C = l.getVertexOffset(w);
        c[C] === x[0] && c[C + 1] === x[1] && c[C + 2] === x[2] && this._disablePickingIndex(w);
      }
    } else
      this._disablePickingIndex(e);
  }
  // TODO - simplify subclassing interface
  _disablePickingIndex(e) {
    const { pickingColors: i, instancePickingColors: s } = this.getAttributeManager().attributes, o = i || s;
    if (!o)
      return;
    const l = o.getVertexOffset(e), u = o.getVertexOffset(e + 1);
    o.buffer.write(new Uint8Array(u - l), l);
  }
  /** (Internal) Re-enable all picking indices after multi-depth picking */
  restorePickingColors() {
    const { pickingColors: e, instancePickingColors: i } = this.getAttributeManager().attributes, s = e || i;
    s && // @ts-ignore (TS2531) this method is only called internally with internalState defined
    (this.internalState.usesPickingColorCache && s.value.buffer !== Hn.buffer && (s.value = Hn.subarray(0, s.value.length)), s.updateSubBuffer({ startOffset: 0 }));
  }
  /* eslint-disable max-statements */
  /* (Internal) Called by layer manager when a new layer is found */
  _initialize() {
    hs(!this.internalState), hs(Number.isFinite(this.props.coordinateSystem)), qs(lL, this);
    const e = this._getAttributeManager();
    e && e.addInstanced({
      instancePickingColors: {
        type: "uint8",
        size: 4,
        noAlloc: !0,
        // Updaters are always called with `this` pointing to the layer
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateInstancePickingColors
      }
    }), this.internalState = new oL({
      attributeManager: e,
      layer: this
    }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
      get: () => (Jt.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), e)
    }), this.internalState.uniformTransitions = new PN(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
    for (const i of this.props.extensions)
      i.initializeState.call(this, this.context, i);
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: !0,
      extensionsChanged: !0
    }), this._update();
  }
  /** (Internal) Called by layer manager to transfer state from an old layer */
  _transferState(e) {
    qs(uL, this, this === e);
    const { state: i, internalState: s } = e;
    this !== e && (this.internalState = s, this.state = i, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()));
  }
  /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */
  _update() {
    const e = this.needsUpdate();
    if (qs(cL, this, e), !e)
      return;
    const i = this.props, s = this.context, o = this.internalState, l = s.viewport, u = this._updateUniformTransition();
    o.propsInTransition = u, s.viewport = o.viewport || l, this.props = u;
    try {
      const c = this._getUpdateParams(), x = this.getModels();
      if (s.device)
        this.updateState(c);
      else
        try {
          this.updateState(c);
        } catch {
        }
      for (const C of this.props.extensions)
        C.updateState.call(this, c, C);
      const w = this.getModels()[0] !== x[0];
      this._postUpdate(c, w);
    } finally {
      s.viewport = l, this.props = i, this._clearChangeFlags(), o.needsUpdate = !1, o.resetOldProps();
    }
  }
  /* eslint-enable max-statements */
  /** (Internal) Called by manager when layer is about to be disposed
      Note: not guaranteed to be called on application shutdown */
  _finalize() {
    qs(hL, this), this.finalizeState(this.context);
    for (const e of this.props.extensions)
      e.finalizeState.call(this, this.context, e);
  }
  // Calculates uniforms
  _drawLayer({ renderPass: e, moduleParameters: i = null, uniforms: s = {}, parameters: o = {} }) {
    this._updateAttributeTransition();
    const l = this.props, u = this.context;
    this.props = this.internalState.propsInTransition || l;
    const c = this.props.opacity;
    s.opacity = Math.pow(c, 1 / 2.2);
    try {
      if (i) {
        const { isActive: C, isAttribute: M } = i.picking;
        this.setModuleParameters(i), this.setShaderModuleProps({ picking: { isActive: C, isAttribute: M } });
      }
      const { getPolygonOffset: x } = this.props, w = x && x(s) || [0, 0];
      u.device.setParametersWebGL({ polygonOffset: w });
      for (const C of this.getModels())
        C.setParameters(o);
      u.device.withParametersWebGL(o, () => {
        const C = { renderPass: e, moduleParameters: i, uniforms: s, parameters: o, context: u };
        for (const M of this.props.extensions)
          M.draw.call(this, C, M);
        this.draw(C);
      });
    } finally {
      this.props = l;
    }
  }
  // Helper methods
  /** Returns the current change flags */
  getChangeFlags() {
    var e;
    return (e = this.internalState) == null ? void 0 : e.changeFlags;
  }
  /* eslint-disable complexity */
  /** Dirty some change flags, will be handled by updateLayer */
  setChangeFlags(e) {
    if (!this.internalState)
      return;
    const { changeFlags: i } = this.internalState;
    for (const o in e)
      if (e[o]) {
        let l = !1;
        switch (o) {
          case "dataChanged":
            const u = e[o], c = i[o];
            u && Array.isArray(c) && (i.dataChanged = Array.isArray(u) ? c.concat(u) : u, l = !0);
          default:
            i[o] || (i[o] = e[o], l = !0);
        }
        l && qs(aL, this, o, e);
      }
    const s = !!(i.dataChanged || i.updateTriggersChanged || i.propsChanged || i.extensionsChanged);
    i.propsOrDataChanged = s, i.somethingChanged = s || i.viewportChanged || i.stateChanged;
  }
  /* eslint-enable complexity */
  /** Clear all changeFlags, typically after an update */
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: !1,
      propsChanged: !1,
      updateTriggersChanged: !1,
      viewportChanged: !1,
      stateChanged: !1,
      extensionsChanged: !1,
      propsOrDataChanged: !1,
      somethingChanged: !1
    };
  }
  /** Compares the layers props with old props from a matched older layer
      and extracts change flags that describe what has change so that state
      can be update correctly with minimal effort */
  _diffProps(e, i) {
    var o;
    const s = DN(e, i);
    if (s.updateTriggersChanged)
      for (const l in s.updateTriggersChanged)
        s.updateTriggersChanged[l] && this.invalidateAttribute(l);
    if (s.transitionsChanged)
      for (const l in s.transitionsChanged)
        this.internalState.uniformTransitions.add(l, i[l], e[l], (o = e.transitions) == null ? void 0 : o[l]);
    return this.setChangeFlags(s);
  }
  /** (Internal) called by layer manager to perform extra props validation (in development only) */
  validateProps() {
    BN(this.props);
  }
  /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */
  updateAutoHighlight(e) {
    this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(e);
  }
  // May be overriden by subclasses
  // TODO - simplify subclassing interface
  /** Update picking module parameters to highlight the hovered object */
  _updateAutoHighlight(e) {
    const i = {
      // @ts-expect-error stricter luma gl types
      highlightedObjectColor: e.picked ? e.color : null
    }, { highlightColor: s } = this.props;
    e.picked && typeof s == "function" && (i.highlightColor = s(e)), this.setShaderModuleProps({ picking: i }), this.setNeedsRedraw();
  }
  /** Create new attribute manager */
  _getAttributeManager() {
    const e = this.context;
    return new SN(e.device, {
      id: this.props.id,
      stats: e.stats,
      timeline: e.timeline
    });
  }
  // Private methods
  /** Called after updateState to perform common tasks */
  _postUpdate(e, i) {
    const { props: s, oldProps: o } = e;
    this.setNeedsRedraw(), this._updateAttributes();
    const l = this.state.model;
    l != null && l.isInstanced && l.setInstanceCount(this.getNumInstances());
    const { autoHighlight: u, highlightedObjectIndex: c, highlightColor: x } = s;
    if (i || o.autoHighlight !== u || o.highlightedObjectIndex !== c || o.highlightColor !== x) {
      const w = {};
      Array.isArray(x) && (w.highlightColor = x), (i || o.autoHighlight !== u || c !== o.highlightedObjectIndex) && (w.highlightedObjectColor = Number.isFinite(c) && c >= 0 ? this.encodePickingColor(c) : null), this.setShaderModuleProps({ picking: w });
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      changeFlags: this.internalState.changeFlags
    };
  }
  /** Checks state of attributes and model */
  _getNeedsRedraw(e) {
    if (!this.internalState)
      return !1;
    let i = !1;
    i = i || this.internalState.needsRedraw && this.id;
    const s = this.getAttributeManager(), o = s ? s.getNeedsRedraw(e) : !1;
    if (i = i || o, i)
      for (const l of this.props.extensions)
        l.onNeedsRedraw.call(this, l);
    return this.internalState.needsRedraw = this.internalState.needsRedraw && !e.clearRedrawFlags, i;
  }
  /** Callback when asyn prop is loaded */
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate();
  }
}
Gc.defaultProps = pL;
Gc.layerName = "Layer";
const _L = "compositeLayer.renderLayers";
class eT extends Gc {
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !0;
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every((e) => e.isLoaded);
  }
  /** Return last rendered sub layers */
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  // initializeState is usually not needed for composite layers
  // Provide empty definition to disable check for missing definition
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  initializeState(e) {
  }
  /** Updates selected state members and marks the composite layer to need rerender */
  setState(e) {
    super.setState(e), this.setNeedsUpdate();
  }
  /** called to augment the info object that is bubbled up from a sublayer
      override Layer.getPickingInfo() because decoding / setting uniform do
      not apply to a composite layer. */
  getPickingInfo({ info: e }) {
    const { object: i } = e;
    return i && i.__source && i.__source.parent && i.__source.parent.id === this.id && (e.object = i.__source.object, e.index = i.__source.index), e;
  }
  /**
   * Filters sub layers at draw time. Return true if the sub layer should be drawn.
   */
  filterSubLayer(e) {
    return !0;
  }
  /** Returns true if sub layer needs to be rendered */
  shouldRenderSubLayer(e, i) {
    return i && i.length;
  }
  /** Returns sub layer class for a specific sublayer */
  getSubLayerClass(e, i) {
    const { _subLayerProps: s } = this.props;
    return s && s[e] && s[e].type || i;
  }
  /** When casting user data into another format to pass to sublayers,
      add reference to the original object and object index */
  getSubLayerRow(e, i, s) {
    return e.__source = {
      parent: this,
      object: i,
      index: s
    }, e;
  }
  /** Some composite layers cast user data into another format before passing to sublayers
    We need to unwrap them before calling the accessor so that they see the original data
    objects */
  getSubLayerAccessor(e) {
    if (typeof e == "function") {
      const i = {
        index: -1,
        // @ts-ignore accessing resolved data
        data: this.props.data,
        target: []
      };
      return (s, o) => s && s.__source ? (i.index = s.__source.index, e(s.__source.object, i)) : e(s, o);
    }
    return e;
  }
  /** Returns sub layer props for a specific sublayer */
  // eslint-disable-next-line complexity
  getSubLayerProps(e = {}) {
    var nt;
    const { opacity: i, pickable: s, visible: o, parameters: l, getPolygonOffset: u, highlightedObjectIndex: c, autoHighlight: x, highlightColor: w, coordinateSystem: C, coordinateOrigin: M, wrapLongitude: P, positionFormat: j, modelMatrix: Y, extensions: Q, fetch: _e, operation: me, _subLayerProps: we } = this.props, Ee = {
      id: "",
      updateTriggers: {},
      opacity: i,
      pickable: s,
      visible: o,
      parameters: l,
      getPolygonOffset: u,
      highlightedObjectIndex: c,
      autoHighlight: x,
      highlightColor: w,
      coordinateSystem: C,
      coordinateOrigin: M,
      wrapLongitude: P,
      positionFormat: j,
      modelMatrix: Y,
      extensions: Q,
      fetch: _e,
      operation: me
    }, Oe = we && e.id && we[e.id], Ne = Oe && Oe.updateTriggers, ze = e.id || "sublayer";
    if (Oe) {
      const mt = this.props[da], We = e.type ? e.type._propTypes : {};
      for (const at in Oe) {
        const it = We[at] || mt[at];
        it && it.type === "accessor" && (Oe[at] = this.getSubLayerAccessor(Oe[at]));
      }
    }
    Object.assign(
      Ee,
      e,
      // experimental feature that allows users to override sublayer props via parent layer prop
      Oe
    ), Ee.id = `${this.props.id}-${ze}`, Ee.updateTriggers = {
      all: (nt = this.props.updateTriggers) == null ? void 0 : nt.all,
      ...e.updateTriggers,
      ...Ne
    };
    for (const mt of Q) {
      const We = mt.getSubLayerProps.call(this, mt);
      We && Object.assign(Ee, We, {
        updateTriggers: Object.assign(Ee.updateTriggers, We.updateTriggers)
      });
    }
    return Ee;
  }
  /** Update sub layers to highlight the hovered object */
  _updateAutoHighlight(e) {
    for (const i of this.getSubLayers())
      i.updateAutoHighlight(e);
  }
  /** Override base Layer method */
  _getAttributeManager() {
    return null;
  }
  /** (Internal) Called after an update to rerender sub layers */
  _postUpdate(e, i) {
    let s = this.internalState.subLayers;
    const o = !s || this.needsUpdate();
    if (o) {
      const l = this.renderLayers();
      s = Nc(l, Boolean), this.internalState.subLayers = s;
    }
    qs(_L, this, o, s);
    for (const l of s)
      l.parent = this;
  }
}
eT.layerName = "CompositeLayer";
const mL = `#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
uniform float opacity;
uniform float radiusPixels;
uniform int sizeUnits;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, gL = `#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, tT = [0, 0, 0, 255], iT = [0, 0, 1], yL = {
  sizeUnits: "pixels",
  pointSize: { type: "number", min: 0, value: 10 },
  //  point radius in pixels
  getPosition: { type: "accessor", value: (t) => t.position },
  getNormal: { type: "accessor", value: iT },
  getColor: { type: "accessor", value: tT },
  material: !0,
  // Depreated
  radiusPixels: { deprecatedFor: "pointSize" }
};
function bL(t) {
  const { header: e, attributes: i } = t;
  if (!(!e || !i) && (t.length = e.vertexCount, i.POSITION && (i.instancePositions = i.POSITION), i.NORMAL && (i.instanceNormals = i.NORMAL), i.COLOR_0)) {
    const { size: s, value: o } = i.COLOR_0;
    i.instanceColors = { size: s, type: "unorm8", value: o };
  }
}
class Sy extends Gc {
  getShaders() {
    return super.getShaders({ vs: mL, fs: gL, modules: [py, tB, gy] });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: !0,
        accessor: "getNormal",
        defaultValue: iT
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getColor",
        defaultValue: tT
      }
    });
  }
  updateState(e) {
    var o;
    const { changeFlags: i, props: s } = e;
    super.updateState(e), i.extensionsChanged && ((o = this.state.model) == null || o.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll()), i.dataChanged && bL(s.data);
  }
  draw({ uniforms: e }) {
    const { pointSize: i, sizeUnits: s } = this.props, o = this.state.model;
    o.setUniforms(e), o.setUniforms({
      sizeUnits: ug[s],
      radiusPixels: i
    }), o.draw(this.context.renderPass);
  }
  _getModel() {
    const e = [];
    for (let i = 0; i < 3; i++) {
      const s = i / 3 * Math.PI * 2;
      e.push(Math.cos(s) * 2, Math.sin(s) * 2, 0);
    }
    return new ma(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Ic({
        topology: "triangle-list",
        attributes: {
          positions: new Float32Array(e)
        }
      }),
      isInstanced: !0
    });
  }
}
Sy.layerName = "PointCloudLayer";
Sy.defaultProps = yL;
const Lr = {
  OUTSIDE: -1,
  // Represents that an object is not contained within the frustum.
  INTERSECTING: 0,
  // Represents that an object intersects one of the frustum's planes.
  INSIDE: 1
  // Represents that an object is fully within the frustum.
};
new Se();
new Se();
const tu = new Se(), Ix = new Se();
class zu {
  /** Creates a bounding sphere */
  constructor(e = [0, 0, 0], i = 0) {
    this.radius = -0, this.center = new Se(), this.fromCenterRadius(e, i);
  }
  /** Sets the bounding sphere from `center` and `radius`. */
  fromCenterRadius(e, i) {
    return this.center.from(e), this.radius = i, this;
  }
  /**
   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
   * tightly and fully encompasses the box.
   */
  fromCornerPoints(e, i) {
    return i = tu.from(i), this.center = new Se().from(e).add(i).scale(0.5), this.radius = this.center.distance(i), this;
  }
  /** Compares the provided BoundingSphere component wise */
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.radius === e.radius;
  }
  /** Duplicates a BoundingSphere instance. */
  clone() {
    return new zu(this.center, this.radius);
  }
  /** Computes a bounding sphere that contains both the left and right bounding spheres. */
  union(e) {
    const i = this.center, s = this.radius, o = e.center, l = e.radius, u = tu.copy(o).subtract(i), c = u.magnitude();
    if (s >= c + l)
      return this.clone();
    if (l >= c + s)
      return e.clone();
    const x = (s + c + l) * 0.5;
    return Ix.copy(u).scale((-s + x) / c).add(i), this.center.copy(Ix), this.radius = x, this;
  }
  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */
  expand(e) {
    const s = tu.from(e).subtract(this.center).magnitude();
    return s > this.radius && (this.radius = s), this;
  }
  // BoundingVolume interface
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param sphere The bounding sphere to apply the transformation to.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns self.
   */
  transform(e) {
    this.center.transform(e);
    const i = u3(tu, e);
    return this.radius = Math.max(i[0], Math.max(i[1], i[2])) * this.radius, this;
  }
  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */
  distanceSquaredTo(e) {
    const i = this.distanceTo(e);
    return i * i;
  }
  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */
  distanceTo(e) {
    const s = tu.from(e).subtract(this.center);
    return Math.max(0, s.len() - this.radius);
  }
  /** Determines which side of a plane a sphere is located. */
  intersectPlane(e) {
    const i = this.center, s = this.radius, l = e.normal.dot(i) + e.distance;
    return l < -s ? Lr.OUTSIDE : l < s ? Lr.INTERSECTING : Lr.INSIDE;
  }
}
const vL = new Se(), xL = new Se(), of = new Se(), af = new Se(), lf = new Se(), wL = new Se(), AL = new Se(), _o = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};
class Vu {
  constructor(e = [0, 0, 0], i = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
    this.center = new Se().from(e), this.halfAxes = new qi(i);
  }
  /** Returns an array with three halfSizes for the bounding box */
  get halfSize() {
    const e = this.halfAxes.getColumn(0), i = this.halfAxes.getColumn(1), s = this.halfAxes.getColumn(2);
    return [new Se(e).len(), new Se(i).len(), new Se(s).len()];
  }
  /** Returns a quaternion describing the orientation of the bounding box */
  get quaternion() {
    const e = this.halfAxes.getColumn(0), i = this.halfAxes.getColumn(1), s = this.halfAxes.getColumn(2), o = new Se(e).normalize(), l = new Se(i).normalize(), u = new Se(s).normalize();
    return new Au().fromMatrix3(new qi([...o, ...l, ...u]));
  }
  /**
   * Create OrientedBoundingBox from quaternion based OBB,
   */
  fromCenterHalfSizeQuaternion(e, i, s) {
    const o = new Au(s), l = new qi().fromQuaternion(o);
    return l[0] = l[0] * i[0], l[1] = l[1] * i[0], l[2] = l[2] * i[0], l[3] = l[3] * i[1], l[4] = l[4] * i[1], l[5] = l[5] * i[1], l[6] = l[6] * i[2], l[7] = l[7] * i[2], l[8] = l[8] * i[2], this.center = new Se().from(e), this.halfAxes = l, this;
  }
  /** Duplicates a OrientedBoundingBox instance. */
  clone() {
    return new Vu(this.center, this.halfAxes);
  }
  /** Compares the provided OrientedBoundingBox component wise and returns */
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.halfAxes.equals(e.halfAxes);
  }
  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */
  getBoundingSphere(e = new zu()) {
    const i = this.halfAxes, s = i.getColumn(0, of), o = i.getColumn(1, af), l = i.getColumn(2, lf), u = vL.copy(s).add(o).add(l);
    return e.center.copy(this.center), e.radius = u.magnitude(), e;
  }
  /** Determines which side of a plane the oriented bounding box is located. */
  intersectPlane(e) {
    const i = this.center, s = e.normal, o = this.halfAxes, l = s.x, u = s.y, c = s.z, x = Math.abs(l * o[_o.COLUMN0ROW0] + u * o[_o.COLUMN0ROW1] + c * o[_o.COLUMN0ROW2]) + Math.abs(l * o[_o.COLUMN1ROW0] + u * o[_o.COLUMN1ROW1] + c * o[_o.COLUMN1ROW2]) + Math.abs(l * o[_o.COLUMN2ROW0] + u * o[_o.COLUMN2ROW1] + c * o[_o.COLUMN2ROW2]), w = s.dot(i) + e.distance;
    return w <= -x ? Lr.OUTSIDE : w >= x ? Lr.INSIDE : Lr.INTERSECTING;
  }
  /** Computes the estimated distance from the closest point on a bounding box to a point. */
  distanceTo(e) {
    return Math.sqrt(this.distanceSquaredTo(e));
  }
  /**
   * Computes the estimated distance squared from the closest point
   * on a bounding box to a point.
   * See Geometric Tools for Computer Graphics 10.4.2
   */
  distanceSquaredTo(e) {
    const i = xL.from(e).subtract(this.center), s = this.halfAxes, o = s.getColumn(0, of), l = s.getColumn(1, af), u = s.getColumn(2, lf), c = o.magnitude(), x = l.magnitude(), w = u.magnitude();
    o.normalize(), l.normalize(), u.normalize();
    let C = 0, M;
    return M = Math.abs(i.dot(o)) - c, M > 0 && (C += M * M), M = Math.abs(i.dot(l)) - x, M > 0 && (C += M * M), M = Math.abs(i.dot(u)) - w, M > 0 && (C += M * M), C;
  }
  /**
   * The distances calculated by the vector from the center of the bounding box
   * to position projected onto direction.
   *
   * - If you imagine the infinite number of planes with normal direction,
   *   this computes the smallest distance to the closest and farthest planes
   *   from `position` that intersect the bounding box.
   *
   * @param position The position to calculate the distance from.
   * @param direction The direction from position.
   * @param result An Interval (array of length 2) to store the nearest and farthest distances.
   * @returns Interval (array of length 2) with nearest and farthest distances
   *   on the bounding box from position in direction.
   */
  // eslint-disable-next-line max-statements
  computePlaneDistances(e, i, s = [-0, -0]) {
    let o = Number.POSITIVE_INFINITY, l = Number.NEGATIVE_INFINITY;
    const u = this.center, c = this.halfAxes, x = c.getColumn(0, of), w = c.getColumn(1, af), C = c.getColumn(2, lf), M = wL.copy(x).add(w).add(C).add(u), P = AL.copy(M).subtract(e);
    let j = i.dot(P);
    return o = Math.min(j, o), l = Math.max(j, l), M.copy(u).add(x).add(w).subtract(C), P.copy(M).subtract(e), j = i.dot(P), o = Math.min(j, o), l = Math.max(j, l), M.copy(u).add(x).subtract(w).add(C), P.copy(M).subtract(e), j = i.dot(P), o = Math.min(j, o), l = Math.max(j, l), M.copy(u).add(x).subtract(w).subtract(C), P.copy(M).subtract(e), j = i.dot(P), o = Math.min(j, o), l = Math.max(j, l), u.copy(M).subtract(x).add(w).add(C), P.copy(M).subtract(e), j = i.dot(P), o = Math.min(j, o), l = Math.max(j, l), u.copy(M).subtract(x).add(w).subtract(C), P.copy(M).subtract(e), j = i.dot(P), o = Math.min(j, o), l = Math.max(j, l), u.copy(M).subtract(x).subtract(w).add(C), P.copy(M).subtract(e), j = i.dot(P), o = Math.min(j, o), l = Math.max(j, l), u.copy(M).subtract(x).subtract(w).subtract(C), P.copy(M).subtract(e), j = i.dot(P), o = Math.min(j, o), l = Math.max(j, l), s[0] = o, s[1] = l, s;
  }
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns itself, i.e. the modified BoundingVolume.
   */
  transform(e) {
    this.center.transformAsPoint(e);
    const i = this.halfAxes.getColumn(0, of);
    i.transformAsPoint(e);
    const s = this.halfAxes.getColumn(1, af);
    s.transformAsPoint(e);
    const o = this.halfAxes.getColumn(2, lf);
    return o.transformAsPoint(e), this.halfAxes = new qi([...i, ...s, ...o]), this;
  }
  getTransform() {
    throw new Error("not implemented");
  }
}
const Rx = new Se(), Mx = new Se();
class $n {
  constructor(e = [0, 0, 1], i = 0) {
    this.normal = new Se(), this.distance = -0, this.fromNormalDistance(e, i);
  }
  /** Creates a plane from a normal and a distance from the origin. */
  fromNormalDistance(e, i) {
    return pn(Number.isFinite(i)), this.normal.from(e).normalize(), this.distance = i, this;
  }
  /** Creates a plane from a normal and a point on the plane. */
  fromPointNormal(e, i) {
    e = Rx.from(e), this.normal.from(i).normalize();
    const s = -this.normal.dot(e);
    return this.distance = s, this;
  }
  /** Creates a plane from the general equation */
  fromCoefficients(e, i, s, o) {
    return this.normal.set(e, i, s), pn(bn(this.normal.len(), 1)), this.distance = o, this;
  }
  /** Duplicates a Plane instance. */
  clone() {
    return new $n(this.normal, this.distance);
  }
  /** Compares the provided Planes by normal and distance */
  equals(e) {
    return bn(this.distance, e.distance) && bn(this.normal, e.normal);
  }
  /** Computes the signed shortest distance of a point to a plane.
   * The sign of the distance determines which side of the plane the point is on.
   */
  getPointDistance(e) {
    return this.normal.dot(e) + this.distance;
  }
  /** Transforms the plane by the given transformation matrix. */
  transform(e) {
    const i = Mx.copy(this.normal).transformAsVector(e).normalize(), s = this.normal.scale(-this.distance).transform(e);
    return this.fromPointNormal(s, i);
  }
  projectPointOntoPlane(e, i = [0, 0, 0]) {
    const s = Rx.from(e), o = this.getPointDistance(s), l = Mx.copy(this.normal).scale(o);
    return s.subtract(l).to(i);
  }
}
const Px = [new Se([1, 0, 0]), new Se([0, 1, 0]), new Se([0, 0, 1])], Bx = new Se(), TL = new Se();
class en {
  /**
   * Create a new `CullingVolume` bounded by an array of clipping planed
   * @param planes Array of clipping planes.
   * */
  constructor(e = []) {
    this.planes = e;
  }
  /**
   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
   * The planes are aligned to the x, y, and z axes in world coordinates.
   */
  fromBoundingSphere(e) {
    this.planes.length = 2 * Px.length;
    const i = e.center, s = e.radius;
    let o = 0;
    for (const l of Px) {
      let u = this.planes[o], c = this.planes[o + 1];
      u || (u = this.planes[o] = new $n()), c || (c = this.planes[o + 1] = new $n());
      const x = Bx.copy(l).scale(-s).add(i);
      u.fromPointNormal(x, l);
      const w = Bx.copy(l).scale(s).add(i), C = TL.copy(l).negate();
      c.fromPointNormal(w, C), o += 2;
    }
    return this;
  }
  /** Determines whether a bounding volume intersects the culling volume. */
  computeVisibility(e) {
    let i = Lr.INSIDE;
    for (const s of this.planes)
      switch (e.intersectPlane(s)) {
        case Lr.OUTSIDE:
          return Lr.OUTSIDE;
        case Lr.INTERSECTING:
          i = Lr.INTERSECTING;
          break;
      }
    return i;
  }
  /**
   * Determines whether a bounding volume intersects the culling volume.
   *
   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
   *   the parent (and therefore this) volume is completely inside plane[planeIndex]
   *   and that plane check can be skipped.
   */
  computeVisibilityWithPlaneMask(e, i) {
    if (pn(Number.isFinite(i), "parentPlaneMask is required."), i === en.MASK_OUTSIDE || i === en.MASK_INSIDE)
      return i;
    let s = en.MASK_INSIDE;
    const o = this.planes;
    for (let l = 0; l < this.planes.length; ++l) {
      const u = l < 31 ? 1 << l : 0;
      if (l < 31 && !(i & u))
        continue;
      const c = o[l], x = e.intersectPlane(c);
      if (x === Lr.OUTSIDE)
        return en.MASK_OUTSIDE;
      x === Lr.INTERSECTING && (s |= u);
    }
    return s;
  }
}
en.MASK_OUTSIDE = 4294967295;
en.MASK_INSIDE = 0;
en.MASK_INDETERMINATE = 2147483647;
new Se();
new Se();
new Se();
new Se();
new Se();
new Se();
new Se();
new Se();
new Se();
new Se();
new Se();
new Se();
new Se();
new Se();
new Se();
new Se();
new Se();
const jn = new qi(), EL = new qi(), SL = new qi(), cf = new qi(), Dx = new qi();
function CL(t, e = {}) {
  const i = K3, s = 10;
  let o = 0, l = 0;
  const u = EL, c = SL;
  u.identity(), c.copy(t);
  const x = i * IL(c);
  for (; l < s && RL(c) > x; )
    ML(c, cf), Dx.copy(cf).transpose(), c.multiplyRight(cf), c.multiplyLeft(Dx), u.multiplyRight(cf), ++o > 2 && (++l, o = 0);
  return e.unitary = u.toTarget(e.unitary), e.diagonal = c.toTarget(e.diagonal), e;
}
function IL(t) {
  let e = 0;
  for (let i = 0; i < 9; ++i) {
    const s = t[i];
    e += s * s;
  }
  return Math.sqrt(e);
}
const Pg = [1, 0, 0], Bg = [2, 2, 1];
function RL(t) {
  let e = 0;
  for (let i = 0; i < 3; ++i) {
    const s = t[jn.getElementIndex(Bg[i], Pg[i])];
    e += 2 * s * s;
  }
  return Math.sqrt(e);
}
function ML(t, e) {
  const i = sA;
  let s = 0, o = 1;
  for (let w = 0; w < 3; ++w) {
    const C = Math.abs(t[jn.getElementIndex(Bg[w], Pg[w])]);
    C > s && (o = w, s = C);
  }
  const l = Pg[o], u = Bg[o];
  let c = 1, x = 0;
  if (Math.abs(t[jn.getElementIndex(u, l)]) > i) {
    const w = t[jn.getElementIndex(u, u)], C = t[jn.getElementIndex(l, l)], M = t[jn.getElementIndex(u, l)], P = (w - C) / 2 / M;
    let j;
    P < 0 ? j = -1 / (-P + Math.sqrt(1 + P * P)) : j = 1 / (P + Math.sqrt(1 + P * P)), c = 1 / Math.sqrt(1 + j * j), x = j * c;
  }
  return qi.IDENTITY.to(e), e[jn.getElementIndex(l, l)] = e[jn.getElementIndex(u, u)] = c, e[jn.getElementIndex(u, l)] = x, e[jn.getElementIndex(l, u)] = -x, e;
}
const oa = new Se(), PL = new Se(), BL = new Se(), DL = new Se(), OL = new Se(), FL = new qi(), kL = {
  diagonal: new qi(),
  unitary: new qi()
};
function NL(t, e = new Vu()) {
  if (!t || t.length === 0)
    return e.halfAxes = new qi([0, 0, 0, 0, 0, 0, 0, 0, 0]), e.center = new Se(), e;
  const i = t.length, s = new Se(0, 0, 0);
  for (const We of t)
    s.add(We);
  const o = 1 / i;
  s.multiplyByScalar(o);
  let l = 0, u = 0, c = 0, x = 0, w = 0, C = 0;
  for (const We of t) {
    const at = oa.copy(We).subtract(s);
    l += at.x * at.x, u += at.x * at.y, c += at.x * at.z, x += at.y * at.y, w += at.y * at.z, C += at.z * at.z;
  }
  l *= o, u *= o, c *= o, x *= o, w *= o, C *= o;
  const M = FL;
  M[0] = l, M[1] = u, M[2] = c, M[3] = u, M[4] = x, M[5] = w, M[6] = c, M[7] = w, M[8] = C;
  const { unitary: P } = CL(M, kL), j = e.halfAxes.copy(P);
  let Y = j.getColumn(0, BL), Q = j.getColumn(1, DL), _e = j.getColumn(2, OL), me = -Number.MAX_VALUE, we = -Number.MAX_VALUE, Ee = -Number.MAX_VALUE, Oe = Number.MAX_VALUE, Ne = Number.MAX_VALUE, ze = Number.MAX_VALUE;
  for (const We of t)
    oa.copy(We), me = Math.max(oa.dot(Y), me), we = Math.max(oa.dot(Q), we), Ee = Math.max(oa.dot(_e), Ee), Oe = Math.min(oa.dot(Y), Oe), Ne = Math.min(oa.dot(Q), Ne), ze = Math.min(oa.dot(_e), ze);
  Y = Y.multiplyByScalar(0.5 * (Oe + me)), Q = Q.multiplyByScalar(0.5 * (Ne + we)), _e = _e.multiplyByScalar(0.5 * (ze + Ee)), e.center.copy(Y).add(Q).add(_e);
  const nt = PL.set(me - Oe, we - Ne, Ee - ze).multiplyByScalar(0.5), mt = new qi([nt[0], 0, 0, 0, nt[1], 0, 0, 0, nt[2]]);
  return e.halfAxes.multiplyRight(mt), e;
}
const gm = Math.PI / 180, hf = new Float32Array(16), Ox = new Float32Array(12);
function Fx(t, e, i) {
  const s = e[0] * gm, o = e[1] * gm, l = e[2] * gm, u = Math.sin(l), c = Math.sin(s), x = Math.sin(o), w = Math.cos(l), C = Math.cos(s), M = Math.cos(o), P = i[0], j = i[1], Y = i[2];
  t[0] = P * M * C, t[1] = P * x * C, t[2] = P * -c, t[3] = j * (-x * w + M * c * u), t[4] = j * (M * w + x * c * u), t[5] = j * C * u, t[6] = Y * (x * u + M * c * w), t[7] = Y * (-M * u + x * c * w), t[8] = Y * C * w;
}
function kx(t) {
  return t[0] = t[0], t[1] = t[1], t[2] = t[2], t[3] = t[4], t[4] = t[5], t[5] = t[6], t[6] = t[8], t[7] = t[9], t[8] = t[10], t[9] = t[12], t[10] = t[13], t[11] = t[14], t.subarray(0, 12);
}
const sT = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrixCol0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrixCol1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrixCol2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(t, { startRow: e, endRow: i }) {
    const { data: s, getOrientation: o, getScale: l, getTranslation: u, getTransformMatrix: c } = this.props, x = Array.isArray(c), w = x && c.length === 16, C = Array.isArray(l), M = Array.isArray(o), P = Array.isArray(u), j = w || !x && !!c(s[0]);
    j ? t.constant = w : t.constant = M && C && P;
    const Y = t.value;
    if (t.constant) {
      let Q;
      j ? (hf.set(c), Q = kx(hf)) : (Q = Ox, Fx(Q, o, l), Q.set(u, 9)), t.value = new Float32Array(Q);
    } else {
      let Q = e * t.size;
      const { iterable: _e, objectInfo: me } = VA(s, e, i);
      for (const we of _e) {
        me.index++;
        let Ee;
        if (j)
          hf.set(w ? c : c(we, me)), Ee = kx(hf);
        else {
          Ee = Ox;
          const Oe = M ? o : o(we, me), Ne = C ? l : l(we, me);
          Fx(Ee, Oe, Ne), Ee.set(P ? u : u(we, me), 9);
        }
        Y[Q++] = Ee[0], Y[Q++] = Ee[1], Y[Q++] = Ee[2], Y[Q++] = Ee[3], Y[Q++] = Ee[4], Y[Q++] = Ee[5], Y[Q++] = Ee[6], Y[Q++] = Ee[7], Y[Q++] = Ee[8], Y[Q++] = Ee[9], Y[Q++] = Ee[10], Y[Q++] = Ee[11];
      }
    }
  }
};
function rT(t, e) {
  return e === Wt.CARTESIAN || e === Wt.METER_OFFSETS || e === Wt.DEFAULT && !t.isGeospatial;
}
const LL = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
uniform float sizeScale;
uniform bool composeModelMatrix;
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = texCoords;
geometry.pickingColor = instancePickingColors;
vTexCoord = texCoords;
cameraPosition = project_uCameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;
if (composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
geometry.position = position_commonspace;
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
}
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, UL = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
geometry.uv = vTexCoord;
vec3 normal;
if (flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
DECKGL_FILTER_COLOR(color, geometry);
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * opacity);
}
`;
function ym(t) {
  const e = t.positions || t.POSITION;
  Jt.assert(e, 'no "postions" or "POSITION" attribute in mesh');
  const i = e.value.length / e.size;
  let s = t.COLOR_0 || t.colors;
  s || (s = { size: 3, value: new Float32Array(i * 3).fill(1) });
  let o = t.NORMAL || t.normals;
  o || (o = { size: 3, value: new Float32Array(i * 3).fill(0) });
  let l = t.TEXCOORD_0 || t.texCoords;
  return l || (l = { size: 2, value: new Float32Array(i * 2).fill(0) }), {
    positions: e,
    colors: s,
    normals: o,
    texCoords: l
  };
}
function Nx(t) {
  return t instanceof Ic ? (t.attributes = ym(t.attributes), t) : t.attributes ? new Ic({
    ...t,
    topology: "triangle-list",
    attributes: ym(t.attributes)
  }) : new Ic({
    topology: "triangle-list",
    attributes: ym(t)
  });
}
const zL = [0, 0, 0, 255], VL = {
  mesh: { type: "object", value: null, async: !0 },
  texture: { type: "image", value: null, async: !0 },
  sizeScale: { type: "number", value: 1, min: 0 },
  // _instanced is a hack to use world position instead of meter offsets in mesh
  // TODO - formalize API
  _instanced: !0,
  // NOTE(Tarek): Quick and dirty wireframe. Just draws
  // the same mesh with LINE_STRIPS. Won't follow edges
  // of the original mesh.
  wireframe: !1,
  // Optional material for 'lighting' shader module
  material: !0,
  getPosition: { type: "accessor", value: (t) => t.position },
  getColor: { type: "accessor", value: zL },
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: { type: "accessor", value: [0, 0, 0] },
  getScale: { type: "accessor", value: [1, 1, 1] },
  getTranslation: { type: "accessor", value: [0, 0, 0] },
  // 4x4 matrix
  getTransformMatrix: { type: "accessor", value: [] },
  textureParameters: { type: "object", ignore: !0, value: null }
};
class Cy extends Gc {
  getShaders() {
    return super.getShaders({
      vs: LL,
      fs: UL,
      modules: [py, iB, gy]
    });
  }
  getBounds() {
    var s;
    if (this.props._instanced)
      return super.getBounds();
    let e = this.state.positionBounds;
    if (e)
      return e;
    const { mesh: i } = this.props;
    if (!i)
      return null;
    if (e = (s = i.header) == null ? void 0 : s.boundingBox, !e) {
      const { attributes: o } = Nx(i);
      o.POSITION = o.POSITION || o.positions, e = uw(o);
    }
    return this.state.positionBounds = e, e;
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        transition: !0,
        type: "float64",
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: "unorm8",
        transition: !0,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: sT
    }), this.setState({
      // Avoid luma.gl's missing uniform warning
      // TODO - add feature to luma.gl to specify ignored uniforms?
      emptyTexture: this.context.device.createTexture({
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(e) {
    var l;
    super.updateState(e);
    const { props: i, oldProps: s, changeFlags: o } = e;
    if (i.mesh !== s.mesh || o.extensionsChanged) {
      if (this.state.positionBounds = null, (l = this.state.model) == null || l.destroy(), i.mesh) {
        this.state.model = this.getModel(i.mesh);
        const u = i.mesh.attributes || i.mesh;
        this.setState({
          hasNormals: !!(u.NORMAL || u.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    i.texture !== s.texture && i.texture instanceof Ur && this.setTexture(i.texture), this.state.model && this.state.model.setTopology(this.props.wireframe ? "line-strip" : "triangle-list");
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.emptyTexture.delete();
  }
  draw({ uniforms: e }) {
    const { model: i } = this.state;
    if (!i)
      return;
    const { viewport: s, renderPass: o } = this.context, { sizeScale: l, coordinateSystem: u, _instanced: c } = this.props;
    i.setUniforms(e), i.setUniforms({
      sizeScale: l,
      composeModelMatrix: !c || rT(s, u),
      flatShading: !this.state.hasNormals
    }), i.draw(o);
  }
  get isLoaded() {
    var e;
    return !!((e = this.state) != null && e.model && super.isLoaded);
  }
  getModel(e) {
    const i = new ma(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: Nx(e),
      isInstanced: !0
    }), { texture: s } = this.props, { emptyTexture: o } = this.state;
    return i.setBindings({
      sampler: s || o
    }), i.setUniforms({
      hasTexture: !!s
    }), i;
  }
  setTexture(e) {
    const { emptyTexture: i, model: s } = this.state;
    s && (s.setBindings({
      sampler: e || i
    }), s.setUniforms({
      hasTexture: !!e
    }));
  }
}
Cy.defaultProps = VL;
Cy.layerName = "SimpleMeshLayer";
var _n;
(function(t) {
  t[t.FUNC_ADD = 32774] = "FUNC_ADD", t[t.ONE = 1] = "ONE", t[t.SRC_ALPHA = 770] = "SRC_ALPHA", t[t.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", t[t.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", t[t.LINEAR = 9729] = "LINEAR", t[t.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", t[t.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL";
})(_n || (_n = {}));
function nT(t, e, i, s) {
  const o = {
    defines: {
      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)
      MANUAL_SRGB: 1,
      SRGB_FAST_APPROXIMATION: 1
    },
    bindings: {},
    uniforms: {
      // TODO: find better values?
      u_Camera: [0, 0, 0],
      // Model should override
      u_MetallicRoughnessValues: [1, 1]
      // Default is 1 and 1
    },
    parameters: {},
    glParameters: {},
    generatedTextures: []
  };
  o.defines.USE_TEX_LOD = 1;
  const { imageBasedLightingEnvironment: l } = s;
  return l && (o.bindings.u_DiffuseEnvSampler = l.diffuseEnvSampler, o.bindings.u_SpecularEnvSampler = l.specularEnvSampler, o.bindings.u_brdfLUT = l.brdfLutTexture, o.uniforms.u_ScaleIBLAmbient = [1, 1]), s != null && s.pbrDebug && (o.defines.PBR_DEBUG = 1, o.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0], o.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0]), i.NORMAL && (o.defines.HAS_NORMALS = 1), i.TANGENT && (s != null && s.useTangents) && (o.defines.HAS_TANGENTS = 1), i.TEXCOORD_0 && (o.defines.HAS_UV = 1), s != null && s.imageBasedLightingEnvironment && (o.defines.USE_IBL = 1), s != null && s.lights && (o.defines.USE_LIGHTS = 1), e && HL(t, e, o), o;
}
function HL(t, e, i) {
  if (i.uniforms.pbr_uUnlit = !!e.unlit, e.pbrMetallicRoughness && jL(t, e.pbrMetallicRoughness, i), e.normalTexture) {
    yu(t, e.normalTexture, "u_NormalSampler", "HAS_NORMALMAP", i);
    const { scale: s = 1 } = e.normalTexture;
    i.uniforms.u_NormalScale = s;
  }
  if (e.occlusionTexture) {
    yu(t, e.occlusionTexture, "u_OcclusionSampler", "HAS_OCCLUSIONMAP", i);
    const { strength: s = 1 } = e.occlusionTexture;
    i.uniforms.u_OcclusionStrength = s;
  }
  switch (e.emissiveTexture && (yu(t, e.emissiveTexture, "u_EmissiveSampler", "HAS_EMISSIVEMAP", i), i.uniforms.u_EmissiveFactor = e.emissiveFactor || [0, 0, 0]), e.alphaMode) {
    case "MASK":
      const { alphaCutoff: s = 0.5 } = e;
      i.defines.ALPHA_CUTOFF = 1, i.uniforms.u_AlphaCutoff = s;
      break;
    case "BLEND":
      $e.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")(), i.parameters.blendColorOperation = "add", i.parameters.blendColorSrcFactor = "src-alpha", i.parameters.blendColorDstFactor = "one-minus-src-alpha", i.parameters.blendAlphaOperation = "add", i.parameters.blendAlphaSrcFactor = "one", i.parameters.blendAlphaDstFactor = "one-minus-src-alpha", i.glParameters.blend = !0, i.glParameters.blendEquation = _n.FUNC_ADD, i.glParameters.blendFunc = [
        _n.SRC_ALPHA,
        _n.ONE_MINUS_SRC_ALPHA,
        _n.ONE,
        _n.ONE_MINUS_SRC_ALPHA
      ];
      break;
  }
}
function jL(t, e, i) {
  e.baseColorTexture && yu(t, e.baseColorTexture, "u_BaseColorSampler", "HAS_BASECOLORMAP", i), i.uniforms.u_BaseColorFactor = e.baseColorFactor || [1, 1, 1, 1], e.metallicRoughnessTexture && yu(t, e.metallicRoughnessTexture, "u_MetallicRoughnessSampler", "HAS_METALROUGHNESSMAP", i);
  const { metallicFactor: s = 1, roughnessFactor: o = 1 } = e;
  i.uniforms.u_MetallicRoughnessValues = [s, o];
}
function yu(t, e, i, s = null, o) {
  var C, M;
  const l = ((M = (C = e == null ? void 0 : e.texture) == null ? void 0 : C.sampler) == null ? void 0 : M.parameters) || {}, u = e.texture.source.image;
  let c, x = {};
  u.compressed ? (c = u, x = {
    [_n.TEXTURE_MIN_FILTER]: u.data.length > 1 ? _n.LINEAR_MIPMAP_NEAREST : _n.LINEAR
  }) : c = { data: u };
  const w = t.createTexture({
    id: e.uniformName || e.id,
    parameters: {
      ...l,
      ...x
    },
    pixelStore: {
      [_n.UNPACK_FLIP_Y_WEBGL]: !1
    },
    ...c
  });
  o.bindings[i] = w, s && (o.defines[s] = 1), o.generatedTextures.push(w);
}
const $L = "4.3.1", qf = {
  /** Basis transcoder, javascript wrapper part */
  TRANSCODER: "basis_transcoder.js",
  /** Basis transcoder, compiled web assembly part */
  TRANSCODER_WASM: "basis_transcoder.wasm",
  /** Basis encoder, javascript wrapper part */
  ENCODER: "basis_encoder.js",
  /** Basis encoder, compiled web assembly part */
  ENCODER_WASM: "basis_encoder.wasm"
};
let Lx;
async function Ux(t) {
  xC(t.modules);
  const e = wC("basis");
  return e || (Lx || (Lx = XL(t)), await Lx);
}
async function XL(t) {
  let e = null, i = null;
  return [e, i] = await Promise.all([
    await sl(qf.TRANSCODER, "textures", t),
    await sl(qf.TRANSCODER_WASM, "textures", t)
  ]), e = e || globalThis.BASIS, await WL(e, i);
}
function WL(t, e) {
  const i = {};
  return e && (i.wasmBinary = e), new Promise((s) => {
    t(i).then((o) => {
      const { BasisFile: l, initializeBasis: u } = o;
      u(), s({ BasisFile: l });
    });
  });
}
let bm;
async function zx(t) {
  const e = t.modules || {};
  return e.basisEncoder ? e.basisEncoder : (bm = bm || qL(t), await bm);
}
async function qL(t) {
  let e = null, i = null;
  return [e, i] = await Promise.all([
    await sl(qf.ENCODER, "textures", t),
    await sl(qf.ENCODER_WASM, "textures", t)
  ]), e = e || globalThis.BASIS, await ZL(e, i);
}
function ZL(t, e) {
  const i = {};
  return e && (i.wasmBinary = e), new Promise((s) => {
    t(i).then((o) => {
      const { BasisFile: l, KTX2File: u, initializeBasis: c, BasisEncoder: x } = o;
      c(), s({ BasisFile: l, KTX2File: u, BasisEncoder: x });
    });
  });
}
const uc = {
  // WEBGL_compressed_texture_s3tc
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  // WEBGL_compressed_texture_es3
  COMPRESSED_R11_EAC: 37488,
  COMPRESSED_SIGNED_R11_EAC: 37489,
  COMPRESSED_RG11_EAC: 37490,
  COMPRESSED_SIGNED_RG11_EAC: 37491,
  COMPRESSED_RGB8_ETC2: 37492,
  COMPRESSED_RGBA8_ETC2_EAC: 37493,
  COMPRESSED_SRGB8_ETC2: 37494,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
  // WEBGL_compressed_texture_pvrtc
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
  // WEBGL_compressed_texture_etc1
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  // WEBGL_compressed_texture_atc
  COMPRESSED_RGB_ATC_WEBGL: 35986,
  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
  // WEBGL_compressed_texture_astc
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
  COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
  COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
  COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
  COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
  COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
  COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
  COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
  COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
  COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
  COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
  COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
  COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
  COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
  // EXT_texture_compression_rgtc
  COMPRESSED_RED_RGTC1_EXT: 36283,
  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
  // WEBGL_compressed_texture_s3tc_srgb
  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
}, KL = ["", "WEBKIT_", "MOZ_"], Vx = {
  /* eslint-disable camelcase */
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
  /* eslint-enable camelcase */
};
let uf = null;
function JL(t) {
  if (!uf) {
    t = t || YL() || void 0, uf = /* @__PURE__ */ new Set();
    for (const e of KL)
      for (const i in Vx)
        if (t && t.getExtension(`${e}${i}`)) {
          const s = Vx[i];
          uf.add(s);
        }
  }
  return uf;
}
function YL() {
  try {
    return document.createElement("canvas").getContext("webgl");
  } catch {
    return null;
  }
}
const kr = [
  // '', 'K', 'T', 'X', '2', '0', '', '\r', '\n', '\x1A', '\n'
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function QL(t) {
  const e = new Uint8Array(t);
  return !(e.byteLength < kr.length || e[0] !== kr[0] || // ''
  e[1] !== kr[1] || // 'K'
  e[2] !== kr[2] || // 'T'
  e[3] !== kr[3] || // 'X'
  e[4] !== kr[4] || // ' '
  e[5] !== kr[5] || // '2'
  e[6] !== kr[6] || // '0'
  e[7] !== kr[7] || // ''
  e[8] !== kr[8] || // '\r'
  e[9] !== kr[9] || // '\n'
  e[10] !== kr[10] || // '\x1A'
  e[11] !== kr[11]);
}
const eU = {
  etc1: {
    basisFormat: 0,
    compressed: !0,
    format: uc.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: { basisFormat: 1, compressed: !0 },
  bc1: {
    basisFormat: 2,
    compressed: !0,
    format: uc.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: !0,
    format: uc.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: { basisFormat: 4, compressed: !0 },
  bc5: { basisFormat: 5, compressed: !0 },
  "bc7-m6-opaque-only": { basisFormat: 6, compressed: !0 },
  "bc7-m5": { basisFormat: 7, compressed: !0 },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: !0,
    format: uc.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: !0,
    format: uc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: !0,
    format: uc.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": { basisFormat: 11, compressed: !0 },
  "atc-rgba-interpolated-alpha": { basisFormat: 12, compressed: !0 },
  rgba32: { basisFormat: 13, compressed: !1 },
  rgb565: { basisFormat: 14, compressed: !1 },
  bgr565: { basisFormat: 15, compressed: !1 },
  rgba4444: { basisFormat: 16, compressed: !1 }
};
async function tU(t, e) {
  if (e.basis.containerFormat === "auto") {
    if (QL(t)) {
      const s = await zx(e);
      return Hx(s.KTX2File, t, e);
    }
    const { BasisFile: i } = await Ux(e);
    return vm(i, t, e);
  }
  switch (e.basis.module) {
    case "encoder":
      const i = await zx(e);
      switch (e.basis.containerFormat) {
        case "ktx2":
          return Hx(i.KTX2File, t, e);
        case "basis":
        default:
          return vm(i.BasisFile, t, e);
      }
    case "transcoder":
    default:
      const { BasisFile: s } = await Ux(e);
      return vm(s, t, e);
  }
}
function vm(t, e, i) {
  const s = new t(new Uint8Array(e));
  try {
    if (!s.startTranscoding())
      throw new Error("Failed to start basis transcoding");
    const o = s.getNumImages(), l = [];
    for (let u = 0; u < o; u++) {
      const c = s.getNumLevels(u), x = [];
      for (let w = 0; w < c; w++)
        x.push(iU(s, u, w, i));
      l.push(x);
    }
    return l;
  } finally {
    s.close(), s.delete();
  }
}
function iU(t, e, i, s) {
  const o = t.getImageWidth(e, i), l = t.getImageHeight(e, i), u = t.getHasAlpha(
    /* imageIndex, levelIndex */
  ), { compressed: c, format: x, basisFormat: w } = oT(s, u), C = t.getImageTranscodedSizeInBytes(e, i, w), M = new Uint8Array(C);
  if (!t.transcodeImage(M, e, i, w, 0, 0))
    throw new Error("failed to start Basis transcoding");
  return {
    // standard loaders.gl image category payload
    width: o,
    height: l,
    data: M,
    compressed: c,
    format: x,
    // Additional fields
    // Add levelSize field.
    hasAlpha: u
  };
}
function Hx(t, e, i) {
  const s = new t(new Uint8Array(e));
  try {
    if (!s.startTranscoding())
      throw new Error("failed to start KTX2 transcoding");
    const o = s.getLevels(), l = [];
    for (let u = 0; u < o; u++)
      l.push(sU(s, u, i));
    return [l];
  } finally {
    s.close(), s.delete();
  }
}
function sU(t, e, i) {
  const { alphaFlag: s, height: o, width: l } = t.getImageLevelInfo(e, 0, 0), { compressed: u, format: c, basisFormat: x } = oT(i, s), w = t.getImageTranscodedSizeInBytes(e, 0, 0, x), C = new Uint8Array(w);
  if (!t.transcodeImage(
    C,
    e,
    0,
    0,
    x,
    0,
    -1,
    -1
    /* channel1 */
  ))
    throw new Error("Failed to transcode KTX2 image");
  return {
    // standard loaders.gl image category payload
    width: l,
    height: o,
    data: C,
    compressed: u,
    // Additional fields
    levelSize: w,
    hasAlpha: s,
    format: c
  };
}
function oT(t, e) {
  let i = t && t.basis && t.basis.format;
  return i === "auto" && (i = aT()), typeof i == "object" && (i = e ? i.alpha : i.noAlpha), i = i.toLowerCase(), eU[i];
}
function aT() {
  const t = JL();
  return t.has("astc") ? "astc-4x4" : t.has("dxt") ? {
    alpha: "bc3",
    noAlpha: "bc1"
  } : t.has("pvrtc") ? {
    alpha: "pvrtc1-4-rgba",
    noAlpha: "pvrtc1-4-rgb"
  } : t.has("etc1") ? "etc1" : t.has("etc2") ? "etc2" : "rgb565";
}
const rU = {
  dataType: null,
  batchType: null,
  name: "Basis",
  id: "basis",
  module: "textures",
  version: $L,
  worker: !0,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: !0,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
}, nU = {
  ...rU,
  parse: tU
}, oU = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, aU = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
class lU {
  constructor(e) {
    O(this, "name");
    O(this, "startTime", 0);
    O(this, "playing", !0);
    O(this, "speed", 1);
    O(this, "channels", []);
    Object.assign(this, e);
  }
  animate(e) {
    if (!this.playing)
      return;
    const s = (e / 1e3 - this.startTime) * this.speed;
    this.channels.forEach(({ sampler: o, target: l, path: u }) => {
      _U(s, o, l, u), uU(l, l._node);
    });
  }
}
class cU {
  constructor(e) {
    O(this, "animations");
    this.animations = e.animations.map((i, s) => {
      const o = i.name || `Animation-${s}`, l = i.samplers.map(({ input: c, interpolation: x = "LINEAR", output: w }) => ({
        input: jx(e.accessors[c]),
        interpolation: x,
        output: jx(e.accessors[w])
      })), u = i.channels.map(({ sampler: c, target: x }) => ({
        sampler: l[c],
        target: e.nodes[x.node],
        path: x.path
      }));
      return new lU({ name: o, channels: u });
    });
  }
  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */
  animate(e) {
    this.setTime(e);
  }
  setTime(e) {
    this.animations.forEach((i) => i.animate(e));
  }
  getAnimations() {
    return this.animations;
  }
}
function jx(t) {
  if (!t._animation) {
    const e = aU[t.componentType], i = oU[t.type], s = i * t.count, { buffer: o, byteOffset: l } = t.bufferView.data, u = new e(o, l + (t.byteOffset || 0), s);
    if (i === 1)
      t._animation = Array.from(u);
    else {
      const c = [];
      for (let x = 0; x < u.length; x += i)
        c.push(Array.from(u.slice(x, x + i)));
      t._animation = c;
    }
  }
  return t._animation;
}
const hU = new Xt();
function uU(t, e) {
  if (e.matrix.identity(), t.translation && e.matrix.translate(t.translation), t.rotation) {
    const i = hU.fromQuaternion(t.rotation);
    e.matrix.multiplyRight(i);
  }
  t.scale && e.matrix.scale(t.scale);
}
const xm = new Au();
function dU(t, e, i, s, o) {
  if (e === "rotation") {
    xm.slerp({ start: i, target: s, ratio: o });
    for (let l = 0; l < xm.length; l++)
      t[e][l] = xm[l];
  } else
    for (let l = 0; l < i.length; l++)
      t[e][l] = o * s[l] + (1 - o) * i[l];
}
function fU(t, e, { p0: i, outTangent0: s, inTangent1: o, p1: l, tDiff: u, ratio: c }) {
  for (let x = 0; x < t[e].length; x++) {
    const w = s[x] * u, C = o[x] * u;
    t[e][x] = (2 * Math.pow(c, 3) - 3 * Math.pow(c, 2) + 1) * i[x] + (Math.pow(c, 3) - 2 * Math.pow(c, 2) + c) * w + (-2 * Math.pow(c, 3) + 3 * Math.pow(c, 2)) * l[x] + (Math.pow(c, 3) - Math.pow(c, 2)) * C;
  }
}
function pU(t, e, i) {
  for (let s = 0; s < i.length; s++)
    t[e][s] = i[s];
}
function _U(t, { input: e, interpolation: i, output: s }, o, l) {
  const u = e[e.length - 1], c = t % u, x = e.findIndex((P) => P >= c), w = Math.max(0, x - 1);
  if (!Array.isArray(o[l]))
    switch (l) {
      case "translation":
        o[l] = [0, 0, 0];
        break;
      case "rotation":
        o[l] = [0, 0, 0, 1];
        break;
      case "scale":
        o[l] = [1, 1, 1];
        break;
      default:
        $e.warn(`Bad animation path ${l}`)();
    }
  ri(o[l].length === s[w].length);
  const C = e[w], M = e[x];
  switch (i) {
    case "STEP":
      pU(o, l, s[w]);
      break;
    case "LINEAR":
      if (M > C) {
        const P = (c - C) / (M - C);
        dU(o, l, s[w], s[x], P);
      }
      break;
    case "CUBICSPLINE":
      if (M > C) {
        const P = (c - C) / (M - C), j = M - C, Y = s[3 * w + 1], Q = s[3 * w + 2], _e = s[3 * x + 0], me = s[3 * x + 1];
        fU(o, l, { p0: Y, outTangent0: Q, inTangent1: _e, p1: me, tDiff: j, ratio: P });
      }
      break;
    default:
      $e.warn(`Interpolation ${i} not supported`)();
      break;
  }
}
const mU = `
#pragma vscode_glsllint_stage: vert
#if (__VERSION__ < 300)
  #define _attr attribute
#else
  #define _attr in
#endif

  // _attr vec4 POSITION;
  _attr vec4 positions;

  #ifdef HAS_NORMALS
    // _attr vec4 NORMAL;
    _attr vec4 normals;
  #endif

  #ifdef HAS_TANGENTS
    _attr vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // _attr vec2 TEXCOORD_0;
    _attr vec2 texCoords;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * positions;
  }
`, gU = `
#pragma vscode_glsllint_stage: frag
#if (__VERSION__ < 300)
  #define fragmentColor gl_FragColor
#else
  out vec4 fragmentColor;
#endif

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`;
function yU(t, e) {
  const { id: i, geometry: s, material: o, vertexCount: l, materialOptions: u, modelOptions: c } = e, x = nT(t, o, s.attributes, u);
  $e.info(4, "createGLTFModel defines: ", x.defines)();
  const w = [], C = {
    depthWriteEnabled: !0,
    depthCompare: "less",
    depthFormat: "depth24plus",
    cullMode: "back"
  }, M = {
    id: i,
    geometry: s,
    topology: s.topology,
    vertexCount: l,
    modules: [dy],
    vs: $x(t, mU),
    fs: $x(t, gU),
    ...c,
    bindings: { ...x.bindings, ...c.bindings },
    defines: { ...x.defines, ...c.defines },
    parameters: { ...C, ...x.parameters, ...c.parameters },
    uniforms: { ...x.uniforms, ...c.uniforms }
  }, P = new ma(t, M);
  return new yg({ managedResources: w, model: P });
}
function $x(t, e) {
  return `#version 300 es
${e}`;
}
const bU = {
  modelOptions: {},
  pbrDebug: !1,
  imageBasedLightingEnvironment: null,
  lights: !0,
  useTangents: !1
};
class vU {
  constructor(e, i = {}) {
    O(this, "device");
    O(this, "options");
    O(this, "gltf");
    this.device = e, this.options = { ...bU, ...i };
  }
  instantiate(e) {
    return this.gltf = e, (e.scenes || []).map((s) => this.createScene(s));
  }
  createAnimator() {
    return Array.isArray(this.gltf.animations) ? new cU(this.gltf) : null;
  }
  createScene(e) {
    const s = (e.nodes || []).map((l) => this.createNode(l));
    return new Rc({
      id: e.name || e.id,
      children: s
    });
  }
  createNode(e) {
    if (!e._node) {
      const s = (e.children || []).map((l) => this.createNode(l));
      e.mesh && s.push(this.createMesh(e.mesh));
      const o = new Rc({
        id: e.name || e.id,
        children: s
      });
      if (e.matrix)
        o.setMatrix(e.matrix);
      else {
        if (o.matrix.identity(), e.translation && o.matrix.translate(e.translation), e.rotation) {
          const l = new Xt().fromQuaternion(e.rotation);
          o.matrix.multiplyRight(l);
        }
        e.scale && o.matrix.scale(e.scale);
      }
      e._node = o;
    }
    return e._node;
  }
  createMesh(e) {
    if (!e._mesh) {
      const s = (e.primitives || []).map((l, u) => this.createPrimitive(l, u, e)), o = new Rc({
        id: e.name || e.id,
        children: s
      });
      e._mesh = o;
    }
    return e._mesh;
  }
  createPrimitive(e, i, s) {
    const o = e.name || `${s.name || s.id}-primitive-${i}`, l = xU(e.mode || 4), u = e.indices ? e.indices.count : this.getVertexCount(e.attributes), c = yU(this.device, {
      id: o,
      geometry: this.createGeometry(o, e, l),
      material: e.material,
      materialOptions: this.options,
      modelOptions: this.options.modelOptions,
      vertexCount: u
    });
    return c.bounds = [
      e.attributes.POSITION.min,
      e.attributes.POSITION.max
    ], c;
  }
  getVertexCount(e) {
    throw new Error("getVertexCount not implemented");
  }
  createGeometry(e, i, s) {
    const o = {};
    for (const [l, u] of Object.entries(i.attributes)) {
      const { components: c, size: x, value: w } = u;
      o[l] = { size: x ?? c, value: w };
    }
    return new Ic({
      id: e,
      topology: s,
      indices: i.indices.value,
      attributes: o
    });
  }
  createBuffer(e, i) {
    e.bufferView || (e.bufferView = {});
    const { bufferView: s } = e;
    return s.lumaBuffers || (s.lumaBuffers = {}), s.lumaBuffers[i] || (s.lumaBuffers[i] = this.device.createBuffer({
      id: `from-${s.id}`,
      // Draco decoded files have attribute.value
      data: s.data || e.value
    })), s.lumaBuffers[i];
  }
  // TODO - create sampler in WebGL2
  createSampler(e) {
    return e;
  }
  // Helper methods (move to GLTFLoader.resolve...?)
  needsPOT() {
    return !1;
  }
}
var mo;
(function(t) {
  t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(mo || (mo = {}));
function xU(t) {
  switch (t) {
    case mo.POINTS:
      return "point-list";
    case mo.LINES:
      return "line-list";
    case mo.LINE_STRIP:
      return "line-strip";
    case mo.LINE_LOOP:
      return "line-loop-webgl";
    case mo.TRIANGLES:
      return "triangle-list";
    case mo.TRIANGLE_STRIP:
      return "triangle-strip";
    case mo.TRIANGLE_FAN:
      return "triangle-fan-webgl";
    default:
      throw new Error(t);
  }
}
function wU(t, e, i) {
  const s = new vU(t, i), o = s.instantiate(e), l = s.createAnimator();
  return { scenes: o, animator: l };
}
function zr(t, e) {
  if (!t)
    throw new Error(e || "assert failed: gltf");
}
const lT = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, cT = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
}, AU = 1.33, Gx = ["SCALAR", "VEC2", "VEC3", "VEC4"], TU = [
  [Int8Array, 5120],
  [Uint8Array, 5121],
  [Int16Array, 5122],
  [Uint16Array, 5123],
  [Uint32Array, 5125],
  [Float32Array, 5126],
  [Float64Array, 5130]
], EU = new Map(TU), SU = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, CU = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, IU = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function hT(t) {
  return Gx[t - 1] || Gx[0];
}
function wp(t) {
  const e = EU.get(t.constructor);
  if (!e)
    throw new Error("Illegal typed array");
  return e;
}
function Iy(t, e) {
  const i = IU[t.componentType], s = SU[t.type], o = CU[t.componentType], l = t.count * s, u = t.count * s * o;
  zr(u >= 0 && u <= e.byteLength);
  const c = cT[t.componentType], x = lT[t.type];
  return { ArrayType: i, length: l, byteLength: u, componentByteSize: c, numberOfComponentsInElement: x };
}
function uT(t) {
  let { images: e, bufferViews: i } = t;
  e = e || [], i = i || [];
  const s = e.map((u) => u.bufferView);
  i = i.filter((u) => !s.includes(u));
  const o = i.reduce((u, c) => u + c.byteLength, 0), l = e.reduce((u, c) => {
    const { width: x, height: w } = c.image;
    return u + x * w;
  }, 0);
  return o + Math.ceil(4 * l * AU);
}
function RU(t, e, i) {
  const s = t.bufferViews[i];
  zr(s);
  const o = s.buffer, l = e[o];
  zr(l);
  const u = (s.byteOffset || 0) + l.byteOffset;
  return new Uint8Array(l.arrayBuffer, u, s.byteLength);
}
function MU(t, e, i) {
  var Q, _e;
  const s = typeof i == "number" ? (Q = t.accessors) == null ? void 0 : Q[i] : i;
  if (!s)
    throw new Error(`No gltf accessor ${JSON.stringify(i)}`);
  const o = (_e = t.bufferViews) == null ? void 0 : _e[s.bufferView || 0];
  if (!o)
    throw new Error(`No gltf buffer view for accessor ${o}`);
  const { arrayBuffer: l, byteOffset: u } = e[o.buffer], c = (u || 0) + (s.byteOffset || 0) + (o.byteOffset || 0), { ArrayType: x, length: w, componentByteSize: C, numberOfComponentsInElement: M } = Iy(s, o), P = C * M, j = o.byteStride || P;
  if (typeof o.byteStride > "u" || o.byteStride === P)
    return new x(l, c, w);
  const Y = new x(w);
  for (let me = 0; me < s.count; me++) {
    const we = new x(l, c + me * j, M);
    Y.set(we, me * M);
  }
  return Y;
}
function PU() {
  return {
    asset: {
      version: "2.0",
      generator: "loaders.gl"
    },
    buffers: [],
    extensions: {},
    extensionsRequired: [],
    extensionsUsed: []
  };
}
class Es {
  // TODO - why is this not GLTFWithBuffers - what happens to images?
  constructor(e) {
    // internal
    O(this, "gltf");
    O(this, "sourceBuffers");
    O(this, "byteLength");
    this.gltf = {
      json: (e == null ? void 0 : e.json) || PU(),
      buffers: (e == null ? void 0 : e.buffers) || [],
      images: (e == null ? void 0 : e.images) || []
    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);
  }
  // Accessors
  get json() {
    return this.gltf.json;
  }
  getApplicationData(e) {
    return this.json[e];
  }
  getExtraData(e) {
    return (this.json.extras || {})[e];
  }
  hasExtension(e) {
    const i = this.getUsedExtensions().find((o) => o === e), s = this.getRequiredExtensions().find((o) => o === e);
    return typeof i == "string" || typeof s == "string";
  }
  getExtension(e) {
    const i = this.getUsedExtensions().find((o) => o === e), s = this.json.extensions || {};
    return i ? s[e] : null;
  }
  getRequiredExtension(e) {
    return this.getRequiredExtensions().find((s) => s === e) ? this.getExtension(e) : null;
  }
  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }
  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }
  getRemovedExtensions() {
    return this.json.extensionsRemoved || [];
  }
  getObjectExtension(e, i) {
    return (e.extensions || {})[i];
  }
  getScene(e) {
    return this.getObject("scenes", e);
  }
  getNode(e) {
    return this.getObject("nodes", e);
  }
  getSkin(e) {
    return this.getObject("skins", e);
  }
  getMesh(e) {
    return this.getObject("meshes", e);
  }
  getMaterial(e) {
    return this.getObject("materials", e);
  }
  getAccessor(e) {
    return this.getObject("accessors", e);
  }
  // getCamera(index: number): object | null {
  //   return null; // TODO: fix thi: object  as null;
  // }
  getTexture(e) {
    return this.getObject("textures", e);
  }
  getSampler(e) {
    return this.getObject("samplers", e);
  }
  getImage(e) {
    return this.getObject("images", e);
  }
  getBufferView(e) {
    return this.getObject("bufferViews", e);
  }
  getBuffer(e) {
    return this.getObject("buffers", e);
  }
  getObject(e, i) {
    if (typeof i == "object")
      return i;
    const s = this.json[e] && this.json[e][i];
    if (!s)
      throw new Error(`glTF file error: Could not find ${e}[${i}]`);
    return s;
  }
  /**
   * Accepts buffer view index or buffer view object
   * @returns a `Uint8Array`
   */
  getTypedArrayForBufferView(e) {
    e = this.getBufferView(e);
    const i = e.buffer, s = this.gltf.buffers[i];
    zr(s);
    const o = (e.byteOffset || 0) + s.byteOffset;
    return new Uint8Array(s.arrayBuffer, o, e.byteLength);
  }
  /** Accepts accessor index or accessor object
   * @returns a typed array with type that matches the types
   */
  getTypedArrayForAccessor(e) {
    const i = this.getAccessor(e);
    return MU(this.gltf.json, this.gltf.buffers, i);
  }
  /** accepts accessor index or accessor object
   * returns a `Uint8Array`
   */
  getTypedArrayForImageData(e) {
    e = this.getAccessor(e);
    const i = this.getBufferView(e.bufferView), o = this.getBuffer(i.buffer).data, l = i.byteOffset || 0;
    return new Uint8Array(o, l, i.byteLength);
  }
  // MODIFERS
  /**
   * Add an extra application-defined key to the top-level data structure
   */
  addApplicationData(e, i) {
    return this.json[e] = i, this;
  }
  /**
   * `extras` - Standard GLTF field for storing application specific data
   */
  addExtraData(e, i) {
    return this.json.extras = this.json.extras || {}, this.json.extras[e] = i, this;
  }
  addObjectExtension(e, i, s) {
    return e.extensions = e.extensions || {}, e.extensions[i] = s, this.registerUsedExtension(i), this;
  }
  setObjectExtension(e, i, s) {
    const o = e.extensions || {};
    o[i] = s;
  }
  removeObjectExtension(e, i) {
    const s = (e == null ? void 0 : e.extensions) || {};
    if (s[i]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const o = this.json.extensionsRemoved;
      o.includes(i) || o.push(i);
    }
    delete s[i];
  }
  /**
   * Add to standard GLTF top level extension object, mark as used
   */
  addExtension(e, i = {}) {
    return zr(i), this.json.extensions = this.json.extensions || {}, this.json.extensions[e] = i, this.registerUsedExtension(e), i;
  }
  /**
   * Standard GLTF top level extension object, mark as used and required
   */
  addRequiredExtension(e, i = {}) {
    return zr(i), this.addExtension(e, i), this.registerRequiredExtension(e), i;
  }
  /**
   * Add extensionName to list of used extensions
   */
  registerUsedExtension(e) {
    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find((i) => i === e) || this.json.extensionsUsed.push(e);
  }
  /**
   * Add extensionName to list of required extensions
   */
  registerRequiredExtension(e) {
    this.registerUsedExtension(e), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find((i) => i === e) || this.json.extensionsRequired.push(e);
  }
  /**
   * Removes an extension from the top-level list
   */
  removeExtension(e) {
    var i;
    if ((i = this.json.extensions) != null && i[e]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const s = this.json.extensionsRemoved;
      s.includes(e) || s.push(e);
    }
    this.json.extensions && delete this.json.extensions[e], this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, e), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, e);
  }
  /**
   *  Set default scene which is to be displayed at load time
   */
  setDefaultScene(e) {
    this.json.scene = e;
  }
  /**
   * @todo: add more properties for scene initialization:
   *   name`, `extensions`, `extras`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene
   */
  addScene(e) {
    const { nodeIndices: i } = e;
    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({ nodes: i }), this.json.scenes.length - 1;
  }
  /**
   * @todo: add more properties for node initialization:
   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node
   */
  addNode(e) {
    const { meshIndex: i, matrix: s } = e;
    this.json.nodes = this.json.nodes || [];
    const o = { mesh: i };
    return s && (o.matrix = s), this.json.nodes.push(o), this.json.nodes.length - 1;
  }
  /** Adds a mesh to the json part */
  addMesh(e) {
    const { attributes: i, indices: s, material: o, mode: l = 4 } = e, c = {
      primitives: [
        {
          attributes: this._addAttributes(i),
          mode: l
        }
      ]
    };
    if (s) {
      const x = this._addIndices(s);
      c.primitives[0].indices = x;
    }
    return Number.isFinite(o) && (c.primitives[0].material = o), this.json.meshes = this.json.meshes || [], this.json.meshes.push(c), this.json.meshes.length - 1;
  }
  addPointCloud(e) {
    const s = {
      primitives: [
        {
          attributes: this._addAttributes(e),
          mode: 0
          // GL.POINTS
        }
      ]
    };
    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(s), this.json.meshes.length - 1;
  }
  /**
   * Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes as glTF image
   * @param imageData
   * @param mimeType
   */
  addImage(e, i) {
    const s = Yg(e), o = i || (s == null ? void 0 : s.mimeType), u = {
      bufferView: this.addBufferView(e),
      mimeType: o
    };
    return this.json.images = this.json.images || [], this.json.images.push(u), this.json.images.length - 1;
  }
  /**
   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
   * @param buffer
   */
  addBufferView(e, i = 0, s = this.byteLength) {
    const o = e.byteLength;
    zr(Number.isFinite(o)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(e);
    const l = {
      buffer: i,
      // Write offset from the start of the binary body
      byteOffset: s,
      byteLength: o
    };
    return this.byteLength += Du(o, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(l), this.json.bufferViews.length - 1;
  }
  /**
   * Adds an accessor to a bufferView
   * @param bufferViewIndex
   * @param accessor
   */
  addAccessor(e, i) {
    const s = {
      bufferView: e,
      // @ts-ignore
      type: hT(i.size),
      // @ts-ignore
      componentType: i.componentType,
      // @ts-ignore
      count: i.count,
      // @ts-ignore
      max: i.max,
      // @ts-ignore
      min: i.min
    };
    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(s), this.json.accessors.length - 1;
  }
  /**
   * Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes buffers as glTF accessors, but this could be optimized
   * @param sourceBuffer
   * @param accessor
   */
  addBinaryBuffer(e, i = { size: 3 }) {
    const s = this.addBufferView(e);
    let o = { min: i.min, max: i.max };
    (!o.min || !o.max) && (o = this._getAccessorMinMax(e, i.size));
    const l = {
      // @ts-ignore
      size: i.size,
      componentType: wp(e),
      // @ts-ignore
      count: Math.round(e.length / i.size),
      min: o.min,
      max: o.max
    };
    return this.addAccessor(s, Object.assign(l, i));
  }
  /**
   * Adds a texture to the json part
   * @todo: add more properties for texture initialization
   * `sampler`, `name`, `extensions`, `extras`
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture
   */
  addTexture(e) {
    const { imageIndex: i } = e, s = {
      source: i
    };
    return this.json.textures = this.json.textures || [], this.json.textures.push(s), this.json.textures.length - 1;
  }
  /** Adds a material to the json part */
  addMaterial(e) {
    return this.json.materials = this.json.materials || [], this.json.materials.push(e), this.json.materials.length - 1;
  }
  /** Pack the binary chunk */
  createBinaryChunk() {
    var l, u;
    const e = this.byteLength, i = new ArrayBuffer(e), s = new Uint8Array(i);
    let o = 0;
    for (const c of this.sourceBuffers || [])
      o = WC(c, s, o);
    (u = (l = this.json) == null ? void 0 : l.buffers) != null && u[0] ? this.json.buffers[0].byteLength = e : this.json.buffers = [{ byteLength: e }], this.gltf.binary = i, this.sourceBuffers = [i], this.gltf.buffers = [{ arrayBuffer: i, byteOffset: 0, byteLength: i.byteLength }];
  }
  // PRIVATE
  _removeStringFromArray(e, i) {
    let s = !0;
    for (; s; ) {
      const o = e.indexOf(i);
      o > -1 ? e.splice(o, 1) : s = !1;
    }
  }
  /**
   * Add attributes to buffers and create `attributes` object which is part of `mesh`
   */
  _addAttributes(e = {}) {
    const i = {};
    for (const s in e) {
      const o = e[s], l = this._getGltfAttributeName(s), u = this.addBinaryBuffer(o.value, o);
      i[l] = u;
    }
    return i;
  }
  /**
   * Add indices to buffers
   */
  _addIndices(e) {
    return this.addBinaryBuffer(e, { size: 1 });
  }
  /**
   * Deduce gltf specific attribue name from input attribute name
   */
  _getGltfAttributeName(e) {
    switch (e.toLowerCase()) {
      case "position":
      case "positions":
      case "vertices":
        return "POSITION";
      case "normal":
      case "normals":
        return "NORMAL";
      case "color":
      case "colors":
        return "COLOR_0";
      case "texcoord":
      case "texcoords":
        return "TEXCOORD_0";
      default:
        return e;
    }
  }
  /**
   * Calculate `min` and `max` arrays of accessor according to spec:
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor
   */
  _getAccessorMinMax(e, i) {
    const s = { min: null, max: null };
    if (e.length < i)
      return s;
    s.min = [], s.max = [];
    const o = e.subarray(0, i);
    for (const l of o)
      s.min.push(l), s.max.push(l);
    for (let l = i; l < e.length; l += i)
      for (let u = 0; u < i; u++)
        s.min[0 + u] = Math.min(
          // @ts-ignore
          s.min[0 + u],
          e[l + u]
        ), s.max[0 + u] = Math.max(
          // @ts-ignore
          s.max[0 + u],
          e[l + u]
        );
    return s;
  }
}
function Xx(t) {
  return (t % 1 + 1) % 1;
}
const dT = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16,
  BOOLEAN: 1,
  STRING: 1,
  ENUM: 1
}, BU = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: BigInt64Array,
  UINT64: BigUint64Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
}, fT = {
  INT8: 1,
  UINT8: 1,
  INT16: 2,
  UINT16: 2,
  INT32: 4,
  UINT32: 4,
  INT64: 8,
  UINT64: 8,
  FLOAT32: 4,
  FLOAT64: 8
};
function Ry(t, e) {
  return fT[e] * dT[t];
}
function Ap(t, e, i, s) {
  if (i !== "UINT8" && i !== "UINT16" && i !== "UINT32" && i !== "UINT64")
    return null;
  const o = t.getTypedArrayForBufferView(e), l = Tp(
    o,
    "SCALAR",
    // offsets consist of ONE component
    i,
    s + 1
    // The number of offsets is equal to the property table `count` plus one.
  );
  return l instanceof BigInt64Array || l instanceof BigUint64Array ? null : l;
}
function Tp(t, e, i, s = 1) {
  const o = dT[e], l = BU[i], u = fT[i], c = s * o, x = c * u;
  let w = t.buffer, C = t.byteOffset;
  return C % u !== 0 && (w = new Uint8Array(w).slice(C, C + x).buffer, C = 0), new l(w, C, c);
}
function My(t, e, i) {
  var w, C, M, P, j;
  const s = `TEXCOORD_${e.texCoord || 0}`, o = i.attributes[s], l = t.getTypedArrayForAccessor(o), u = t.gltf.json, c = e.index, x = (C = (w = u.textures) == null ? void 0 : w[c]) == null ? void 0 : C.source;
  if (typeof x < "u") {
    const Y = (P = (M = u.images) == null ? void 0 : M[x]) == null ? void 0 : P.mimeType, Q = (j = t.gltf.images) == null ? void 0 : j[x];
    if (Q && typeof Q.width < "u") {
      const _e = [];
      for (let me = 0; me < l.length; me += 2) {
        const we = DU(Q, Y, l, me, e.channels);
        _e.push(we);
      }
      return _e;
    }
  }
  return [];
}
function pT(t, e, i, s, o) {
  if (!(i != null && i.length))
    return;
  const l = [];
  for (const C of i) {
    let M = s.findIndex((P) => P === C);
    M === -1 && (M = s.push(C) - 1), l.push(M);
  }
  const u = new Uint32Array(l), c = t.gltf.buffers.push({
    arrayBuffer: u.buffer,
    byteOffset: u.byteOffset,
    byteLength: u.byteLength
  }) - 1, x = t.addBufferView(u, c, 0), w = t.addAccessor(x, {
    size: 1,
    componentType: wp(u),
    count: u.length
  });
  o.attributes[e] = w;
}
function DU(t, e, i, s, o = [0]) {
  const l = {
    r: { offset: 0, shift: 0 },
    g: { offset: 1, shift: 8 },
    b: { offset: 2, shift: 16 },
    a: { offset: 3, shift: 24 }
  }, u = i[s], c = i[s + 1];
  let x = 1;
  e && (e.indexOf("image/jpeg") !== -1 || e.indexOf("image/png") !== -1) && (x = 4);
  const w = OU(u, c, t, x);
  let C = 0;
  for (const M of o) {
    const P = typeof M == "number" ? Object.values(l)[M] : l[M], j = w + P.offset, Y = dw(t);
    if (Y.data.length <= j)
      throw new Error(`${Y.data.length} <= ${j}`);
    const Q = Y.data[j];
    C |= Q << P.shift;
  }
  return C;
}
function OU(t, e, i, s = 1) {
  const o = i.width, l = Xx(t) * (o - 1), u = Math.round(l), c = i.height, x = Xx(e) * (c - 1), w = Math.round(x), C = i.components ? i.components : s;
  return (w * o + u) * C;
}
function _T(t, e, i, s, o) {
  const l = [];
  for (let u = 0; u < e; u++) {
    const c = i[u], x = i[u + 1] - i[u];
    if (x + c > s)
      break;
    const w = c / o, C = x / o;
    l.push(t.slice(w, w + C));
  }
  return l;
}
function mT(t, e, i) {
  const s = [];
  for (let o = 0; o < e; o++) {
    const l = o * i;
    s.push(t.slice(l, l + i));
  }
  return s;
}
function gT(t, e, i, s) {
  if (i)
    throw new Error("Not implemented - arrayOffsets for strings is specified");
  if (s) {
    const o = [], l = new TextDecoder("utf8");
    let u = 0;
    for (let c = 0; c < t; c++) {
      const x = s[c + 1] - s[c];
      if (x + u <= e.length) {
        const w = e.subarray(u, x + u), C = l.decode(w);
        o.push(C), u += x;
      }
    }
    return o;
  }
  return [];
}
const Pc = "EXT_mesh_features", FU = Pc;
async function kU(t, e) {
  const i = new Es(t);
  LU(i, e);
}
function NU(t, e) {
  const i = new Es(t);
  return zU(i), i.createBinaryChunk(), i.gltf;
}
function LU(t, e) {
  const i = t.gltf.json;
  if (i.meshes)
    for (const s of i.meshes)
      for (const o of s.primitives)
        UU(t, o, e);
}
function UU(t, e, i) {
  var l, u, c;
  if (!((l = i == null ? void 0 : i.gltf) != null && l.loadBuffers))
    return;
  const s = (u = e.extensions) == null ? void 0 : u[Pc], o = s == null ? void 0 : s.featureIds;
  if (o)
    for (const x of o) {
      let w;
      if (typeof x.attribute < "u") {
        const C = `_FEATURE_ID_${x.attribute}`, M = e.attributes[C];
        w = t.getTypedArrayForAccessor(M);
      } else typeof x.texture < "u" && ((c = i == null ? void 0 : i.gltf) != null && c.loadImages) ? w = My(t, x.texture, e) : w = [];
      x.data = w;
    }
}
function zU(t, e) {
  const i = t.gltf.json.meshes;
  if (i)
    for (const s of i)
      for (const o of s.primitives)
        HU(t, o);
}
function VU(t, e, i, s) {
  e.extensions || (e.extensions = {});
  let o = e.extensions[Pc];
  o || (o = { featureIds: [] }, e.extensions[Pc] = o);
  const { featureIds: l } = o, u = {
    featureCount: i.length,
    propertyTable: s,
    data: i
  };
  l.push(u), t.addObjectExtension(e, Pc, o);
}
function HU(t, e) {
  var o;
  const i = (o = e.extensions) == null ? void 0 : o[Pc];
  if (!i)
    return;
  const s = i.featureIds;
  s.forEach((l, u) => {
    if (l.data) {
      const { accessorKey: c, index: x } = jU(e.attributes), w = new Uint32Array(l.data);
      s[u] = {
        featureCount: w.length,
        propertyTable: l.propertyTable,
        attribute: x
      }, t.gltf.buffers.push({
        arrayBuffer: w.buffer,
        byteOffset: w.byteOffset,
        byteLength: w.byteLength
      });
      const C = t.addBufferView(w), M = t.addAccessor(C, {
        size: 1,
        componentType: wp(w),
        count: w.length
      });
      e.attributes[c] = M;
    }
  });
}
function jU(t) {
  const e = "_FEATURE_ID_", i = Object.keys(t).filter((l) => l.indexOf(e) === 0);
  let s = -1;
  for (const l of i) {
    const u = Number(l.substring(e.length));
    u > s && (s = u);
  }
  return s++, { accessorKey: `${e}${s}`, index: s };
}
const $U = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExtMeshFeatures: VU,
  decode: kU,
  encode: NU,
  name: FU
}, Symbol.toStringTag, { value: "Module" })), Lc = "EXT_structural_metadata", GU = Lc;
async function XU(t, e) {
  const i = new Es(t);
  qU(i, e);
}
function WU(t, e) {
  const i = new Es(t);
  return h4(i), i.createBinaryChunk(), i.gltf;
}
function qU(t, e) {
  var s, o;
  if (!((s = e.gltf) != null && s.loadBuffers))
    return;
  const i = t.getExtension(Lc);
  i && ((o = e.gltf) != null && o.loadImages && ZU(t, i), KU(t, i));
}
function ZU(t, e) {
  const i = e.propertyTextures, s = t.gltf.json;
  if (i && s.meshes)
    for (const o of s.meshes)
      for (const l of o.primitives)
        YU(t, i, l, e);
}
function KU(t, e) {
  const i = e.schema;
  if (!i)
    return;
  const s = i.classes, o = e.propertyTables;
  if (s && o)
    for (const l in s) {
      const u = JU(o, l);
      u && e4(t, i, u);
    }
}
function JU(t, e) {
  for (const i of t)
    if (i.class === e)
      return i;
  return null;
}
function YU(t, e, i, s) {
  var u;
  if (!e)
    return;
  const o = (u = i.extensions) == null ? void 0 : u[Lc], l = o == null ? void 0 : o.propertyTextures;
  if (l)
    for (const c of l) {
      const x = e[c];
      QU(t, x, i, s);
    }
}
function QU(t, e, i, s) {
  var l;
  if (!e.properties)
    return;
  s.dataAttributeNames || (s.dataAttributeNames = []);
  const o = e.class;
  for (const u in e.properties) {
    const c = `${o}_${u}`, x = (l = e.properties) == null ? void 0 : l[u];
    if (!x)
      continue;
    x.data || (x.data = []);
    const w = x.data, C = My(t, x, i);
    C !== null && (pT(t, c, C, w, i), x.data = w, s.dataAttributeNames.push(c));
  }
}
function e4(t, e, i) {
  var l, u;
  const s = (l = e.classes) == null ? void 0 : l[i.class];
  if (!s)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${i.class}`);
  const o = i.count;
  for (const c in s.properties) {
    const x = s.properties[c], w = (u = i.properties) == null ? void 0 : u[c];
    if (w) {
      const C = t4(t, e, x, o, w);
      w.data = C;
    }
  }
}
function t4(t, e, i, s, o) {
  let l = [];
  const u = o.values, c = t.getTypedArrayForBufferView(u), x = i4(t, i, o, s), w = s4(t, o, s);
  switch (i.type) {
    case "SCALAR":
    case "VEC2":
    case "VEC3":
    case "VEC4":
    case "MAT2":
    case "MAT3":
    case "MAT4": {
      l = r4(i, s, c, x);
      break;
    }
    case "BOOLEAN":
      throw new Error(`Not implemented - classProperty.type=${i.type}`);
    case "STRING": {
      l = gT(s, c, x, w);
      break;
    }
    case "ENUM": {
      l = n4(e, i, s, c, x);
      break;
    }
    default:
      throw new Error(`Unknown classProperty type ${i.type}`);
  }
  return l;
}
function i4(t, e, i, s) {
  return e.array && // `count` is a number of array elements. May only be defined when `array` is true.
  // If `count` is NOT defined, it's a VARIABLE-length array
  typeof e.count > "u" && // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.
  typeof i.arrayOffsets < "u" ? Ap(t, i.arrayOffsets, i.arrayOffsetType || "UINT32", s) : null;
}
function s4(t, e, i) {
  return typeof e.stringOffsets < "u" ? Ap(t, e.stringOffsets, e.stringOffsetType || "UINT32", i) : null;
}
function r4(t, e, i, s) {
  const o = t.array, l = t.count, u = Ry(t.type, t.componentType), c = i.byteLength / u;
  let x;
  return t.componentType ? x = Tp(
    i,
    t.type,
    // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.
    t.componentType,
    c
  ) : x = i, o ? s ? _T(x, e, s, i.length, u) : l ? mT(x, e, l) : [] : x;
}
function n4(t, e, i, s, o) {
  var M;
  const l = e.enumType;
  if (!l)
    throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");
  const u = (M = t.enums) == null ? void 0 : M[l];
  if (!u)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${l}`);
  const c = u.valueType || "UINT16", x = Ry(e.type, c), w = s.byteLength / x;
  let C = Tp(s, e.type, c, w);
  if (C || (C = s), e.array) {
    if (o)
      return o4({
        valuesData: C,
        numberOfElements: i,
        arrayOffsets: o,
        valuesDataBytesLength: s.length,
        elementSize: x,
        enumEntry: u
      });
    const P = e.count;
    return P ? a4(C, i, P, u) : [];
  }
  return Py(C, 0, i, u);
}
function o4(t) {
  const { valuesData: e, numberOfElements: i, arrayOffsets: s, valuesDataBytesLength: o, elementSize: l, enumEntry: u } = t, c = [];
  for (let x = 0; x < i; x++) {
    const w = s[x], C = s[x + 1] - s[x];
    if (C + w > o)
      break;
    const M = w / l, P = C / l, j = Py(e, M, P, u);
    c.push(j);
  }
  return c;
}
function a4(t, e, i, s) {
  const o = [];
  for (let l = 0; l < e; l++) {
    const u = i * l, c = Py(t, u, i, s);
    o.push(c);
  }
  return o;
}
function Py(t, e, i, s) {
  const o = [];
  for (let l = 0; l < i; l++)
    if (t instanceof BigInt64Array || t instanceof BigUint64Array)
      o.push("");
    else {
      const u = t[e + l], c = l4(s, u);
      c ? o.push(c.name) : o.push("");
    }
  return o;
}
function l4(t, e) {
  for (const i of t.values)
    if (i.value === e)
      return i;
  return null;
}
const c4 = "schemaClassId";
function h4(t, e) {
  var s, o;
  const i = t.getExtension(Lc);
  if (i && i.propertyTables)
    for (const l of i.propertyTables) {
      const u = l.class, c = (o = (s = i.schema) == null ? void 0 : s.classes) == null ? void 0 : o[u];
      l.properties && c && u4(l, c, t);
    }
}
function u4(t, e, i) {
  for (const s in t.properties) {
    const o = t.properties[s].data;
    if (o) {
      const l = e.properties[s];
      if (l) {
        const u = _4(o, l, i);
        t.properties[s] = u;
      }
    }
  }
}
function d4(t, e, i = c4) {
  let s = t.getExtension(Lc);
  s || (s = t.addExtension(Lc)), s.schema = f4(e, i, s.schema);
  const o = p4(e, i, s.schema);
  return s.propertyTables || (s.propertyTables = []), s.propertyTables.push(o) - 1;
}
function f4(t, e, i) {
  const s = i ?? {
    id: "schema_id"
  }, o = {
    properties: {}
  };
  for (const l of t) {
    const u = {
      type: l.elementType,
      componentType: l.componentType
    };
    o.properties[l.name] = u;
  }
  return s.classes = {}, s.classes[e] = o, s;
}
function p4(t, e, i) {
  var u;
  const s = {
    class: e,
    count: 0
  };
  let o = 0;
  const l = (u = i.classes) == null ? void 0 : u[e];
  for (const c of t) {
    if (o === 0 && (o = c.values.length), o !== c.values.length && c.values.length)
      throw new Error("Illegal values in attributes");
    (l == null ? void 0 : l.properties[c.name]) && (s.properties || (s.properties = {}), s.properties[c.name] = { values: 0, data: c.values });
  }
  return s.count = o, s;
}
function _4(t, e, i) {
  const s = { values: 0 };
  if (e.type === "STRING") {
    const { stringData: o, stringOffsets: l } = y4(t);
    s.stringOffsets = wm(l, i), s.values = wm(o, i);
  } else if (e.type === "SCALAR" && e.componentType) {
    const o = g4(t, e.componentType);
    s.values = wm(o, i);
  }
  return s;
}
const m4 = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: Int32Array,
  UINT64: Uint32Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
};
function g4(t, e) {
  const i = [];
  for (const o of t)
    i.push(Number(o));
  const s = m4[e];
  if (!s)
    throw new Error("Illegal component type");
  return new s(i);
}
function y4(t) {
  const e = new TextEncoder(), i = [];
  let s = 0;
  for (const x of t) {
    const w = e.encode(x);
    s += w.length, i.push(w);
  }
  const o = new Uint8Array(s), l = [];
  let u = 0;
  for (const x of i)
    o.set(x, u), l.push(u), u += x.length;
  l.push(u);
  const c = new Uint32Array(l);
  return { stringData: o, stringOffsets: c };
}
function wm(t, e) {
  return e.gltf.buffers.push({
    arrayBuffer: t.buffer,
    byteOffset: t.byteOffset,
    byteLength: t.byteLength
  }), e.addBufferView(t);
}
const b4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExtStructuralMetadata: d4,
  decode: XU,
  encode: WU,
  name: GU
}, Symbol.toStringTag, { value: "Module" })), yT = "EXT_feature_metadata", v4 = yT;
async function x4(t, e) {
  const i = new Es(t);
  w4(i, e);
}
function w4(t, e) {
  var s, o;
  if (!((s = e.gltf) != null && s.loadBuffers))
    return;
  const i = t.getExtension(yT);
  i && ((o = e.gltf) != null && o.loadImages && A4(t, i), T4(t, i));
}
function A4(t, e) {
  const i = e.schema;
  if (!i)
    return;
  const s = i.classes, { featureTextures: o } = e;
  if (s && o)
    for (const l in s) {
      const u = s[l], c = S4(o, l);
      c && I4(t, c, u);
    }
}
function T4(t, e) {
  const i = e.schema;
  if (!i)
    return;
  const s = i.classes, o = e.featureTables;
  if (s && o)
    for (const l in s) {
      const u = E4(o, l);
      u && C4(t, i, u);
    }
}
function E4(t, e) {
  for (const i in t) {
    const s = t[i];
    if (s.class === e)
      return s;
  }
  return null;
}
function S4(t, e) {
  for (const i in t) {
    const s = t[i];
    if (s.class === e)
      return s;
  }
  return null;
}
function C4(t, e, i) {
  var l, u;
  if (!i.class)
    return;
  const s = (l = e.classes) == null ? void 0 : l[i.class];
  if (!s)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${i.class}`);
  const o = i.count;
  for (const c in s.properties) {
    const x = s.properties[c], w = (u = i.properties) == null ? void 0 : u[c];
    if (w) {
      const C = R4(t, e, x, o, w);
      w.data = C;
    }
  }
}
function I4(t, e, i) {
  var o;
  const s = e.class;
  for (const l in i.properties) {
    const u = (o = e == null ? void 0 : e.properties) == null ? void 0 : o[l];
    if (u) {
      const c = O4(t, u, s);
      u.data = c;
    }
  }
}
function R4(t, e, i, s, o) {
  let l = [];
  const u = o.bufferView, c = t.getTypedArrayForBufferView(u), x = M4(t, i, o, s), w = P4(t, i, o, s);
  return i.type === "STRING" || i.componentType === "STRING" ? l = gT(s, c, x, w) : B4(i) && (l = D4(i, s, c, x)), l;
}
function M4(t, e, i, s) {
  return e.type === "ARRAY" && // `componentCount` is a number of fixed-length array elements.
  // If `componentCount` is NOT defined, it's a VARIABLE-length array
  typeof e.componentCount > "u" && // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.
  typeof i.arrayOffsetBufferView < "u" ? Ap(
    t,
    i.arrayOffsetBufferView,
    i.offsetType || "UINT32",
    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
    s
  ) : null;
}
function P4(t, e, i, s) {
  return typeof i.stringOffsetBufferView < "u" ? Ap(
    t,
    i.stringOffsetBufferView,
    i.offsetType || "UINT32",
    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
    s
  ) : null;
}
function B4(t) {
  const e = [
    "UINT8",
    "INT16",
    "UINT16",
    "INT32",
    "UINT32",
    "INT64",
    "UINT64",
    "FLOAT32",
    "FLOAT64"
  ];
  return e.includes(t.type) || typeof t.componentType < "u" && e.includes(t.componentType);
}
function D4(t, e, i, s) {
  const o = t.type === "ARRAY", l = t.componentCount, u = "SCALAR", c = t.componentType || t.type, x = Ry(u, c), w = i.byteLength / x, C = Tp(i, u, c, w);
  return o ? s ? _T(C, e, s, i.length, x) : l ? mT(C, e, l) : [] : C;
}
function O4(t, e, i) {
  const s = t.gltf.json;
  if (!s.meshes)
    return [];
  const o = [];
  for (const l of s.meshes)
    for (const u of l.primitives)
      F4(t, i, e, o, u);
  return o;
}
function F4(t, e, i, s, o) {
  const l = {
    channels: i.channels,
    ...i.texture
  }, u = My(t, l, o);
  u && pT(t, e, u, s, o);
}
const k4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: x4,
  name: v4
}, Symbol.toStringTag, { value: "Module" })), N4 = "4.3.1", Uc = !0, Wx = 1735152710, By = 12, Zf = 8, L4 = 1313821514, U4 = 5130562, z4 = 0, V4 = 0, H4 = 1;
function j4(t, e = 0) {
  return `${String.fromCharCode(t.getUint8(e + 0))}${String.fromCharCode(t.getUint8(e + 1))}${String.fromCharCode(t.getUint8(e + 2))}${String.fromCharCode(t.getUint8(e + 3))}`;
}
function $4(t, e = 0, i = {}) {
  const s = new DataView(t), { magic: o = Wx } = i, l = s.getUint32(e, !1);
  return l === o || l === Wx;
}
function G4(t, e, i = 0, s = {}) {
  const o = new DataView(e), l = j4(o, i + 0), u = o.getUint32(i + 4, Uc), c = o.getUint32(i + 8, Uc);
  switch (Object.assign(t, {
    // Put less important stuff in a header, to avoid clutter
    header: {
      byteOffset: i,
      // Byte offset into the initial arrayBuffer
      byteLength: c,
      hasBinChunk: !1
    },
    type: l,
    version: u,
    json: {},
    binChunks: []
  }), i += By, t.version) {
    case 1:
      return X4(t, o, i);
    case 2:
      return W4(t, o, i, s = {});
    default:
      throw new Error(`Invalid GLB version ${t.version}. Only supports version 1 and 2.`);
  }
}
function X4(t, e, i) {
  Ai(t.header.byteLength > By + Zf);
  const s = e.getUint32(i + 0, Uc), o = e.getUint32(i + 4, Uc);
  return i += Zf, Ai(o === z4), Dg(t, e, i, s), i += s, i += Og(t, e, i, t.header.byteLength), i;
}
function W4(t, e, i, s) {
  return Ai(t.header.byteLength > By + Zf), q4(t, e, i, s), i + t.header.byteLength;
}
function q4(t, e, i, s) {
  for (; i + 8 <= t.header.byteLength; ) {
    const o = e.getUint32(i + 0, Uc), l = e.getUint32(i + 4, Uc);
    switch (i += Zf, l) {
      case L4:
        Dg(t, e, i, o);
        break;
      case U4:
        Og(t, e, i, o);
        break;
      case V4:
        s.strict || Dg(t, e, i, o);
        break;
      case H4:
        s.strict || Og(t, e, i, o);
        break;
    }
    i += Du(o, 4);
  }
  return i;
}
function Dg(t, e, i, s) {
  const o = new Uint8Array(e.buffer, i, s), u = new TextDecoder("utf8").decode(o);
  return t.json = JSON.parse(u), Du(s, 4);
}
function Og(t, e, i, s) {
  return t.header.hasBinChunk = !0, t.binChunks.push({
    byteOffset: i,
    byteLength: s,
    arrayBuffer: e.buffer
    // TODO - copy, or create typed array view?
  }), Du(s, 4);
}
function bT(t, e) {
  if (t.startsWith("data:") || t.startsWith("http:") || t.startsWith("https:"))
    return t;
  const s = e.baseUri || e.uri;
  if (!s)
    throw new Error(`'baseUri' must be provided to resolve relative url ${t}`);
  return s.substr(0, s.lastIndexOf("/") + 1) + t;
}
const Z4 = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", K4 = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", J4 = new Uint8Array([
  0,
  97,
  115,
  109,
  1,
  0,
  0,
  0,
  1,
  4,
  1,
  96,
  0,
  0,
  3,
  3,
  2,
  0,
  0,
  5,
  3,
  1,
  0,
  1,
  12,
  1,
  0,
  10,
  22,
  2,
  12,
  0,
  65,
  0,
  65,
  0,
  65,
  0,
  252,
  10,
  0,
  0,
  11,
  7,
  0,
  65,
  0,
  253,
  15,
  26,
  11
]), Y4 = new Uint8Array([
  32,
  0,
  65,
  253,
  3,
  1,
  2,
  34,
  4,
  106,
  6,
  5,
  11,
  8,
  7,
  20,
  13,
  33,
  12,
  16,
  128,
  9,
  116,
  64,
  19,
  113,
  127,
  15,
  10,
  21,
  22,
  14,
  255,
  66,
  24,
  54,
  136,
  107,
  18,
  23,
  192,
  26,
  114,
  118,
  132,
  17,
  77,
  101,
  130,
  144,
  27,
  87,
  131,
  44,
  45,
  74,
  156,
  154,
  70,
  167
]), Q4 = {
  // legacy index-based enums for glTF
  0: "",
  1: "meshopt_decodeFilterOct",
  2: "meshopt_decodeFilterQuat",
  3: "meshopt_decodeFilterExp",
  // string-based enums for glTF
  NONE: "",
  OCTAHEDRAL: "meshopt_decodeFilterOct",
  QUATERNION: "meshopt_decodeFilterQuat",
  EXPONENTIAL: "meshopt_decodeFilterExp"
}, e6 = {
  // legacy index-based enums for glTF
  0: "meshopt_decodeVertexBuffer",
  1: "meshopt_decodeIndexBuffer",
  2: "meshopt_decodeIndexSequence",
  // string-based enums for glTF
  ATTRIBUTES: "meshopt_decodeVertexBuffer",
  TRIANGLES: "meshopt_decodeIndexBuffer",
  INDICES: "meshopt_decodeIndexSequence"
};
async function t6(t, e, i, s, o, l = "NONE") {
  const u = await i6();
  n6(u, u.exports[e6[o]], t, e, i, s, u.exports[Q4[l || "NONE"]]);
}
let Am;
async function i6() {
  return Am || (Am = s6()), Am;
}
async function s6() {
  let t = Z4;
  WebAssembly.validate(J4) && (t = K4, console.log("Warning: meshopt_decoder is using experimental SIMD support"));
  const e = await WebAssembly.instantiate(r6(t), {});
  return await e.instance.exports.__wasm_call_ctors(), e.instance;
}
function r6(t) {
  const e = new Uint8Array(t.length);
  for (let s = 0; s < t.length; ++s) {
    const o = t.charCodeAt(s);
    e[s] = o > 96 ? o - 71 : o > 64 ? o - 65 : o > 47 ? o + 4 : o > 46 ? 63 : 62;
  }
  let i = 0;
  for (let s = 0; s < t.length; ++s)
    e[i++] = e[s] < 60 ? Y4[e[s]] : (e[s] - 60) * 64 + e[++s];
  return e.buffer.slice(0, i);
}
function n6(t, e, i, s, o, l, u) {
  const c = t.exports.sbrk, x = s + 3 & -4, w = c(x * o), C = c(l.length), M = new Uint8Array(t.exports.memory.buffer);
  M.set(l, C);
  const P = e(w, s, o, C, l.length);
  if (P === 0 && u && u(w, x, o), i.set(M.subarray(w, w + s * o)), c(w - c(0)), P !== 0)
    throw new Error(`Malformed buffer data: ${P}`);
}
const Kf = "EXT_meshopt_compression", o6 = Kf;
async function a6(t, e) {
  var o, l;
  const i = new Es(t);
  if (!((o = e == null ? void 0 : e.gltf) != null && o.decompressMeshes) || !((l = e.gltf) != null && l.loadBuffers))
    return;
  const s = [];
  for (const u of t.json.bufferViews || [])
    s.push(l6(i, u));
  await Promise.all(s), i.removeExtension(Kf);
}
async function l6(t, e) {
  const i = t.getObjectExtension(e, Kf);
  if (i) {
    const { byteOffset: s = 0, byteLength: o = 0, byteStride: l, count: u, mode: c, filter: x = "NONE", buffer: w } = i, C = t.gltf.buffers[w], M = new Uint8Array(C.arrayBuffer, C.byteOffset + s, o), P = new Uint8Array(t.gltf.buffers[e.buffer].arrayBuffer, e.byteOffset, e.byteLength);
    await t6(P, u, l, M, c, x), t.removeObjectExtension(e, Kf);
  }
}
const c6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: a6,
  name: o6
}, Symbol.toStringTag, { value: "Module" })), _c = "EXT_texture_webp", h6 = _c;
function u6(t, e) {
  const i = new Es(t);
  if (!HI("image/webp")) {
    if (i.getRequiredExtensions().includes(_c))
      throw new Error(`gltf: Required extension ${_c} not supported by browser`);
    return;
  }
  const { json: s } = i;
  for (const o of s.textures || []) {
    const l = i.getObjectExtension(o, _c);
    l && (o.source = l.source), i.removeObjectExtension(o, _c);
  }
  i.removeExtension(_c);
}
const d6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: h6,
  preprocess: u6
}, Symbol.toStringTag, { value: "Module" })), Tf = "KHR_texture_basisu", f6 = Tf;
function p6(t, e) {
  const i = new Es(t), { json: s } = i;
  for (const o of s.textures || []) {
    const l = i.getObjectExtension(o, Tf);
    l && (o.source = l.source, i.removeObjectExtension(o, Tf));
  }
  i.removeExtension(Tf);
}
const _6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: f6,
  preprocess: p6
}, Symbol.toStringTag, { value: "Module" })), m6 = "4.3.1", g6 = {
  dataType: null,
  batchType: null,
  name: "Draco",
  id: "draco",
  module: "draco",
  // shapes: ['mesh'],
  version: m6,
  worker: !0,
  extensions: ["drc"],
  mimeTypes: ["application/octet-stream"],
  binary: !0,
  tests: ["DRACO"],
  options: {
    draco: {
      decoderType: typeof WebAssembly == "object" ? "wasm" : "js",
      // 'js' for IE11
      libraryPath: "libs/",
      extraAttributes: {},
      attributeNameEntry: void 0
    }
  }
};
function y6(t, e, i) {
  const s = vT(e.metadata), o = [], l = b6(e.attributes);
  for (const u in t) {
    const c = t[u], x = qx(u, c, l[u]);
    o.push(x);
  }
  if (i) {
    const u = qx("indices", i);
    o.push(u);
  }
  return { fields: o, metadata: s };
}
function b6(t) {
  const e = {};
  for (const i in t) {
    const s = t[i];
    e[s.name || "undefined"] = s;
  }
  return e;
}
function qx(t, e, i) {
  const s = i ? vT(i.metadata) : void 0;
  return lI(t, e, s);
}
function vT(t) {
  Object.entries(t);
  const e = {};
  for (const i in t)
    e[`${i}.string`] = JSON.stringify(t[i]);
  return e;
}
const Zx = {
  POSITION: "POSITION",
  NORMAL: "NORMAL",
  COLOR: "COLOR_0",
  TEX_COORD: "TEXCOORD_0"
}, v6 = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  // 7: BigInt64Array,
  // 8: BigUint64Array,
  9: Float32Array
  // 10: Float64Array
  // 11: BOOL - What array type do we use for this?
}, x6 = 4;
class w6 {
  // draco - the draco decoder, either import `draco3d` or load dynamically
  constructor(e) {
    O(this, "draco");
    O(this, "decoder");
    O(this, "metadataQuerier");
    this.draco = e, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();
  }
  /**
   * Destroy draco resources
   */
  destroy() {
    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);
  }
  /**
   * NOTE: caller must call `destroyGeometry` on the return value after using it
   * @param arrayBuffer
   * @param options
   */
  parseSync(e, i = {}) {
    const s = new this.draco.DecoderBuffer();
    s.Init(new Int8Array(e), e.byteLength), this._disableAttributeTransforms(i);
    const o = this.decoder.GetEncodedGeometryType(s), l = o === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
    try {
      let u;
      switch (o) {
        case this.draco.TRIANGULAR_MESH:
          u = this.decoder.DecodeBufferToMesh(s, l);
          break;
        case this.draco.POINT_CLOUD:
          u = this.decoder.DecodeBufferToPointCloud(s, l);
          break;
        default:
          throw new Error("DRACO: Unknown geometry type.");
      }
      if (!u.ok() || !l.ptr) {
        const P = `DRACO decompression failed: ${u.error_msg()}`;
        throw new Error(P);
      }
      const c = this._getDracoLoaderData(l, o, i), x = this._getMeshData(l, c, i), w = uw(x.attributes), C = y6(x.attributes, c, x.indices);
      return {
        loader: "draco",
        loaderData: c,
        header: {
          vertexCount: l.num_points(),
          boundingBox: w
        },
        ...x,
        schema: C
      };
    } finally {
      this.draco.destroy(s), l && this.draco.destroy(l);
    }
  }
  // Draco specific "loader data"
  /**
   * Extract
   * @param dracoGeometry
   * @param geometry_type
   * @param options
   * @returns
   */
  _getDracoLoaderData(e, i, s) {
    const o = this._getTopLevelMetadata(e), l = this._getDracoAttributes(e, s);
    return {
      geometry_type: i,
      num_attributes: e.num_attributes(),
      num_points: e.num_points(),
      num_faces: e instanceof this.draco.Mesh ? e.num_faces() : 0,
      metadata: o,
      attributes: l
    };
  }
  /**
   * Extract all draco provided information and metadata for each attribute
   * @param dracoGeometry
   * @param options
   * @returns
   */
  _getDracoAttributes(e, i) {
    const s = {};
    for (let o = 0; o < e.num_attributes(); o++) {
      const l = this.decoder.GetAttribute(e, o), u = this._getAttributeMetadata(e, o);
      s[l.unique_id()] = {
        unique_id: l.unique_id(),
        attribute_type: l.attribute_type(),
        data_type: l.data_type(),
        num_components: l.num_components(),
        byte_offset: l.byte_offset(),
        byte_stride: l.byte_stride(),
        normalized: l.normalized(),
        attribute_index: o,
        metadata: u
      };
      const c = this._getQuantizationTransform(l, i);
      c && (s[l.unique_id()].quantization_transform = c);
      const x = this._getOctahedronTransform(l, i);
      x && (s[l.unique_id()].octahedron_transform = x);
    }
    return s;
  }
  /**
   * Get standard loaders.gl mesh category data
   * Extracts the geometry from draco
   * @param dracoGeometry
   * @param options
   */
  _getMeshData(e, i, s) {
    const o = this._getMeshAttributes(i, e, s);
    if (!o.POSITION)
      throw new Error("DRACO: No position attribute found.");
    if (e instanceof this.draco.Mesh)
      switch (s.topology) {
        case "triangle-strip":
          return {
            topology: "triangle-strip",
            mode: 4,
            // GL.TRIANGLES
            attributes: o,
            indices: {
              value: this._getTriangleStripIndices(e),
              size: 1
            }
          };
        case "triangle-list":
        default:
          return {
            topology: "triangle-list",
            mode: 5,
            // GL.TRIANGLE_STRIP
            attributes: o,
            indices: {
              value: this._getTriangleListIndices(e),
              size: 1
            }
          };
      }
    return {
      topology: "point-list",
      mode: 0,
      // GL.POINTS
      attributes: o
    };
  }
  _getMeshAttributes(e, i, s) {
    const o = {};
    for (const l of Object.values(e.attributes)) {
      const u = this._deduceAttributeName(l, s);
      l.name = u;
      const c = this._getAttributeValues(i, l);
      if (c) {
        const { value: x, size: w } = c;
        o[u] = {
          value: x,
          size: w,
          byteOffset: l.byte_offset,
          byteStride: l.byte_stride,
          normalized: l.normalized
        };
      }
    }
    return o;
  }
  // MESH INDICES EXTRACTION
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleListIndices(e) {
    const s = e.num_faces() * 3, o = s * x6, l = this.draco._malloc(o);
    try {
      return this.decoder.GetTrianglesUInt32Array(e, o, l), new Uint32Array(this.draco.HEAPF32.buffer, l, s).slice();
    } finally {
      this.draco._free(l);
    }
  }
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleStripIndices(e) {
    const i = new this.draco.DracoInt32Array();
    try {
      return this.decoder.GetTriangleStripsFromMesh(e, i), E6(i);
    } finally {
      this.draco.destroy(i);
    }
  }
  /**
   *
   * @param dracoGeometry
   * @param dracoAttribute
   * @param attributeName
   */
  _getAttributeValues(e, i) {
    const s = v6[i.data_type];
    if (!s)
      return console.warn(`DRACO: Unsupported attribute type ${i.data_type}`), null;
    const o = i.num_components, u = e.num_points() * o, c = u * s.BYTES_PER_ELEMENT, x = A6(this.draco, s);
    let w;
    const C = this.draco._malloc(c);
    try {
      const M = this.decoder.GetAttribute(e, i.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(e, M, x, c, C), w = new s(this.draco.HEAPF32.buffer, C, u).slice();
    } finally {
      this.draco._free(C);
    }
    return { value: w, size: o };
  }
  // Attribute names
  /**
   * DRACO does not store attribute names - We need to deduce an attribute name
   * for each attribute
  _getAttributeNames(
    dracoGeometry: Mesh | PointCloud,
    options: DracoParseOptions
  ): {[unique_id: number]: string} {
    const attributeNames: {[unique_id: number]: string} = {};
    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
      const attributeName = this._deduceAttributeName(dracoAttribute, options);
      attributeNames[attributeName] = attributeName;
    }
    return attributeNames;
  }
   */
  /**
   * Deduce an attribute name.
   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)
   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized
   * types
   * @param attributeData
   */
  _deduceAttributeName(e, i) {
    const s = e.unique_id;
    for (const [u, c] of Object.entries(i.extraAttributes || {}))
      if (c === s)
        return u;
    const o = e.attribute_type;
    for (const u in Zx)
      if (this.draco[u] === o)
        return Zx[u];
    const l = i.attributeNameEntry || "name";
    return e.metadata[l] ? e.metadata[l].string : `CUSTOM_ATTRIBUTE_${s}`;
  }
  // METADATA EXTRACTION
  /** Get top level metadata */
  _getTopLevelMetadata(e) {
    const i = this.decoder.GetMetadata(e);
    return this._getDracoMetadata(i);
  }
  /** Get per attribute metadata */
  _getAttributeMetadata(e, i) {
    const s = this.decoder.GetAttributeMetadata(e, i);
    return this._getDracoMetadata(s);
  }
  /**
   * Extract metadata field values
   * @param dracoMetadata
   * @returns
   */
  _getDracoMetadata(e) {
    if (!e || !e.ptr)
      return {};
    const i = {}, s = this.metadataQuerier.NumEntries(e);
    for (let o = 0; o < s; o++) {
      const l = this.metadataQuerier.GetEntryName(e, o);
      i[l] = this._getDracoMetadataField(e, l);
    }
    return i;
  }
  /**
   * Extracts possible values for one metadata entry by name
   * @param dracoMetadata
   * @param entryName
   */
  _getDracoMetadataField(e, i) {
    const s = new this.draco.DracoInt32Array();
    try {
      this.metadataQuerier.GetIntEntryArray(e, i, s);
      const o = T6(s);
      return {
        int: this.metadataQuerier.GetIntEntry(e, i),
        string: this.metadataQuerier.GetStringEntry(e, i),
        double: this.metadataQuerier.GetDoubleEntry(e, i),
        intArray: o
      };
    } finally {
      this.draco.destroy(s);
    }
  }
  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)
  /** Skip transforms for specific attribute types */
  _disableAttributeTransforms(e) {
    const { quantizedAttributes: i = [], octahedronAttributes: s = [] } = e, o = [...i, ...s];
    for (const l of o)
      this.decoder.SkipAttributeTransform(this.draco[l]);
  }
  /**
   * Extract (and apply?) Position Transform
   * @todo not used
   */
  _getQuantizationTransform(e, i) {
    const { quantizedAttributes: s = [] } = i, o = e.attribute_type();
    if (s.map((u) => this.decoder[u]).includes(o)) {
      const u = new this.draco.AttributeQuantizationTransform();
      try {
        if (u.InitFromAttribute(e))
          return {
            quantization_bits: u.quantization_bits(),
            range: u.range(),
            min_values: new Float32Array([1, 2, 3]).map((c) => u.min_value(c))
          };
      } finally {
        this.draco.destroy(u);
      }
    }
    return null;
  }
  _getOctahedronTransform(e, i) {
    const { octahedronAttributes: s = [] } = i, o = e.attribute_type();
    if (s.map((u) => this.decoder[u]).includes(o)) {
      const u = new this.draco.AttributeQuantizationTransform();
      try {
        if (u.InitFromAttribute(e))
          return {
            quantization_bits: u.quantization_bits()
          };
      } finally {
        this.draco.destroy(u);
      }
    }
    return null;
  }
}
function A6(t, e) {
  switch (e) {
    case Float32Array:
      return t.DT_FLOAT32;
    case Int8Array:
      return t.DT_INT8;
    case Int16Array:
      return t.DT_INT16;
    case Int32Array:
      return t.DT_INT32;
    case Uint8Array:
      return t.DT_UINT8;
    case Uint16Array:
      return t.DT_UINT16;
    case Uint32Array:
      return t.DT_UINT32;
    default:
      return t.DT_INVALID;
  }
}
function T6(t) {
  const e = t.size(), i = new Int32Array(e);
  for (let s = 0; s < e; s++)
    i[s] = t.GetValue(s);
  return i;
}
function E6(t) {
  const e = t.size(), i = new Int32Array(e);
  for (let s = 0; s < e; s++)
    i[s] = t.GetValue(s);
  return i;
}
const S6 = "1.5.6", C6 = "1.4.1", Tm = `https://www.gstatic.com/draco/versioned/decoders/${S6}`, xr = {
  /** The primary Draco3D encoder, javascript wrapper part */
  DECODER: "draco_wasm_wrapper.js",
  /** The primary draco decoder, compiled web assembly part */
  DECODER_WASM: "draco_decoder.wasm",
  /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */
  FALLBACK_DECODER: "draco_decoder.js",
  /** Draco encoder */
  ENCODER: "draco_encoder.js"
}, Em = {
  [xr.DECODER]: `${Tm}/${xr.DECODER}`,
  [xr.DECODER_WASM]: `${Tm}/${xr.DECODER_WASM}`,
  [xr.FALLBACK_DECODER]: `${Tm}/${xr.FALLBACK_DECODER}`,
  [xr.ENCODER]: `https://raw.githubusercontent.com/google/draco/${C6}/javascript/${xr.ENCODER}`
};
let Sm;
async function I6(t) {
  const e = t.modules || {};
  return e.draco3d ? Sm || (Sm = e.draco3d.createDecoderModule({}).then((i) => ({ draco: i }))) : Sm || (Sm = R6(t)), await Sm;
}
async function R6(t) {
  let e, i;
  switch (t.draco && t.draco.decoderType) {
    case "js":
      e = await sl(Em[xr.FALLBACK_DECODER], "draco", t, xr.FALLBACK_DECODER);
      break;
    case "wasm":
    default:
      [e, i] = await Promise.all([
        await sl(Em[xr.DECODER], "draco", t, xr.DECODER),
        await sl(Em[xr.DECODER_WASM], "draco", t, xr.DECODER_WASM)
      ]);
  }
  return e = e || globalThis.DracoDecoderModule, await M6(e, i);
}
function M6(t, e) {
  const i = {};
  return e && (i.wasmBinary = e), new Promise((s) => {
    t({
      ...i,
      onModuleLoaded: (o) => s({ draco: o })
      // Module is Promise-like. Wrap in object to avoid loop.
    });
  });
}
const xT = {
  ...g6,
  parse: P6
};
async function P6(t, e) {
  const { draco: i } = await I6(e), s = new w6(i);
  try {
    return s.parseSync(t, e == null ? void 0 : e.draco);
  } finally {
    s.destroy();
  }
}
function B6(t) {
  const e = {};
  for (const i in t) {
    const s = t[i];
    if (i !== "indices") {
      const o = wT(s);
      e[i] = o;
    }
  }
  return e;
}
function wT(t) {
  const { buffer: e, size: i, count: s } = D6(t);
  return {
    // glTF Accessor values
    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)
    // bufferView: null,
    // TODO: Deprecate `value` in favor of bufferView?
    // @ts-ignore
    value: e,
    size: i,
    // Decoded `type` (e.g. SCALAR)
    byteOffset: 0,
    count: s,
    type: hT(i),
    componentType: wp(e)
  };
}
function D6(t) {
  let e = t, i = 1, s = 0;
  return t && t.value && (e = t.value, i = t.size || 1), e && (ArrayBuffer.isView(e) || (e = O6(e, Float32Array)), s = e.length / i), { buffer: e, size: i, count: s };
}
function O6(t, e, i = !1) {
  return t ? Array.isArray(t) ? new e(t) : i && !(t instanceof e) ? new e(t) : t : null;
}
const cl = "KHR_draco_mesh_compression", F6 = cl;
function k6(t, e, i) {
  const s = new Es(t);
  for (const o of AT(s))
    s.getObjectExtension(o, cl);
}
async function N6(t, e, i) {
  var l;
  if (!((l = e == null ? void 0 : e.gltf) != null && l.decompressMeshes))
    return;
  const s = new Es(t), o = [];
  for (const u of AT(s))
    s.getObjectExtension(u, cl) && o.push(U6(s, u, e, i));
  await Promise.all(o), s.removeExtension(cl);
}
function L6(t, e = {}) {
  const i = new Es(t);
  for (const s of i.json.meshes || [])
    z6(), i.addRequiredExtension(cl);
}
async function U6(t, e, i, s) {
  const o = t.getObjectExtension(e, cl);
  if (!o)
    return;
  const l = t.getTypedArrayForBufferView(o.bufferView), u = Gg(l.buffer, l.byteOffset), c = { ...i };
  delete c["3d-tiles"];
  const x = await Bu(u, xT, c, s), w = B6(x.attributes);
  for (const [C, M] of Object.entries(w))
    if (C in e.attributes) {
      const P = e.attributes[C], j = t.getAccessor(P);
      j != null && j.min && (j != null && j.max) && (M.min = j.min, M.max = j.max);
    }
  e.attributes = w, x.indices && (e.indices = wT(x.indices)), t.removeObjectExtension(e, cl), V6(e);
}
function z6(t, e, i = 4, s, o) {
  if (!s.DracoWriter)
    throw new Error("options.gltf.DracoWriter not provided");
}
function V6(t) {
  if (!t.attributes && Object.keys(t.attributes).length > 0)
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
}
function* AT(t) {
  for (const e of t.json.meshes || [])
    for (const i of e.primitives)
      yield i;
}
const H6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: N6,
  encode: L6,
  name: F6,
  preprocess: k6
}, Symbol.toStringTag, { value: "Module" })), Ep = "KHR_texture_transform", j6 = Ep, df = new Se(), $6 = new qi(), G6 = new qi();
async function X6(t, e) {
  var l;
  if (!new Es(t).hasExtension(Ep) || !((l = e.gltf) != null && l.loadBuffers))
    return;
  const o = t.json.materials || [];
  for (let u = 0; u < o.length; u++)
    W6(u, t);
}
function W6(t, e) {
  var l, u, c, x;
  const i = (l = e.json.materials) == null ? void 0 : l[t], s = [
    (u = i == null ? void 0 : i.pbrMetallicRoughness) == null ? void 0 : u.baseColorTexture,
    i == null ? void 0 : i.emissiveTexture,
    i == null ? void 0 : i.normalTexture,
    i == null ? void 0 : i.occlusionTexture,
    (c = i == null ? void 0 : i.pbrMetallicRoughness) == null ? void 0 : c.metallicRoughnessTexture
  ], o = [];
  for (const w of s)
    w && ((x = w == null ? void 0 : w.extensions) != null && x[Ep]) && q6(e, t, w, o);
}
function q6(t, e, i, s) {
  const o = Z6(i, s);
  if (!o)
    return;
  const l = t.json.meshes || [];
  for (const u of l)
    for (const c of u.primitives) {
      const x = c.material;
      Number.isFinite(x) && e === x && K6(t, c, o);
    }
}
function Z6(t, e) {
  var u;
  const i = (u = t.extensions) == null ? void 0 : u[Ep], { texCoord: s = 0 } = t, { texCoord: o = s } = i;
  if (!(e.findIndex(([c, x]) => c === s && x === o) !== -1)) {
    const c = Q6(i);
    return s !== o && (t.texCoord = o), e.push([s, o]), { originalTexCoord: s, texCoord: o, matrix: c };
  }
  return null;
}
function K6(t, e, i) {
  var c, x;
  const { originalTexCoord: s, texCoord: o, matrix: l } = i, u = e.attributes[`TEXCOORD_${s}`];
  if (Number.isFinite(u)) {
    const w = (c = t.json.accessors) == null ? void 0 : c[u];
    if (w && w.bufferView) {
      const C = (x = t.json.bufferViews) == null ? void 0 : x[w.bufferView];
      if (C) {
        const { arrayBuffer: M, byteOffset: P } = t.buffers[C.buffer], j = (P || 0) + (w.byteOffset || 0) + (C.byteOffset || 0), { ArrayType: Y, length: Q } = Iy(w, C), _e = cT[w.componentType], me = lT[w.type], we = C.byteStride || _e * me, Ee = new Float32Array(Q);
        for (let Oe = 0; Oe < w.count; Oe++) {
          const Ne = new Y(M, j + Oe * we, 2);
          df.set(Ne[0], Ne[1], 1), df.transformByMatrix3(l), Ee.set([df[0], df[1]], Oe * me);
        }
        s === o ? J6(w, C, t.buffers, Ee) : Y6(o, w, e, t, Ee);
      }
    }
  }
}
function J6(t, e, i, s) {
  t.componentType = 5126, i.push({
    arrayBuffer: s.buffer,
    byteOffset: 0,
    byteLength: s.buffer.byteLength
  }), e.buffer = i.length - 1, e.byteLength = s.buffer.byteLength, e.byteOffset = 0, delete e.byteStride;
}
function Y6(t, e, i, s, o) {
  s.buffers.push({
    arrayBuffer: o.buffer,
    byteOffset: 0,
    byteLength: o.buffer.byteLength
  });
  const l = s.json.bufferViews;
  if (!l)
    return;
  l.push({
    buffer: s.buffers.length - 1,
    byteLength: o.buffer.byteLength,
    byteOffset: 0
  });
  const u = s.json.accessors;
  u && (u.push({
    bufferView: (l == null ? void 0 : l.length) - 1,
    byteOffset: 0,
    componentType: 5126,
    count: e.count,
    type: "VEC2"
  }), i.attributes[`TEXCOORD_${t}`] = u.length - 1);
}
function Q6(t) {
  const { offset: e = [0, 0], rotation: i = 0, scale: s = [1, 1] } = t, o = new qi().set(1, 0, 0, 0, 1, 0, e[0], e[1], 1), l = $6.set(Math.cos(i), Math.sin(i), 0, -Math.sin(i), Math.cos(i), 0, 0, 0, 1), u = G6.set(s[0], 0, 0, 0, s[1], 0, 0, 0, 1);
  return o.multiplyRight(l).multiplyRight(u);
}
const ez = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: X6,
  name: j6
}, Symbol.toStringTag, { value: "Module" })), il = "KHR_lights_punctual", tz = il;
async function iz(t) {
  const e = new Es(t), { json: i } = e, s = e.getExtension(il);
  s && (e.json.lights = s.lights, e.removeExtension(il));
  for (const o of i.nodes || []) {
    const l = e.getObjectExtension(o, il);
    l && (o.light = l.light), e.removeObjectExtension(o, il);
  }
}
async function sz(t) {
  const e = new Es(t), { json: i } = e;
  if (i.lights) {
    const s = e.addExtension(il);
    zr(!s.lights), s.lights = i.lights, delete i.lights;
  }
  if (e.json.lights) {
    for (const s of e.json.lights) {
      const o = s.node;
      e.addObjectExtension(o, il, s);
    }
    delete e.json.lights;
  }
}
const rz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: iz,
  encode: sz,
  name: tz
}, Symbol.toStringTag, { value: "Module" })), Ru = "KHR_materials_unlit", nz = Ru;
async function oz(t) {
  const e = new Es(t), { json: i } = e;
  for (const s of i.materials || [])
    s.extensions && s.extensions.KHR_materials_unlit && (s.unlit = !0), e.removeObjectExtension(s, Ru);
  e.removeExtension(Ru);
}
function az(t) {
  const e = new Es(t), { json: i } = e;
  if (e.materials)
    for (const s of i.materials || [])
      s.unlit && (delete s.unlit, e.addObjectExtension(s, Ru, {}), e.addExtension(Ru));
}
const lz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: oz,
  encode: az,
  name: nz
}, Symbol.toStringTag, { value: "Module" })), hu = "KHR_techniques_webgl", cz = hu;
async function hz(t) {
  const e = new Es(t), { json: i } = e, s = e.getExtension(hu);
  if (s) {
    const o = dz(s, e);
    for (const l of i.materials || []) {
      const u = e.getObjectExtension(l, hu);
      u && (l.technique = Object.assign(
        {},
        u,
        // @ts-ignore
        o[u.technique]
      ), l.technique.values = fz(l.technique, e)), e.removeObjectExtension(l, hu);
    }
    e.removeExtension(hu);
  }
}
async function uz(t, e) {
}
function dz(t, e) {
  const { programs: i = [], shaders: s = [], techniques: o = [] } = t, l = new TextDecoder();
  return s.forEach((u) => {
    if (Number.isFinite(u.bufferView))
      u.code = l.decode(e.getTypedArrayForBufferView(u.bufferView));
    else
      throw new Error("KHR_techniques_webgl: no shader code");
  }), i.forEach((u) => {
    u.fragmentShader = s[u.fragmentShader], u.vertexShader = s[u.vertexShader];
  }), o.forEach((u) => {
    u.program = i[u.program];
  }), o;
}
function fz(t, e) {
  const i = Object.assign({}, t.values);
  return Object.keys(t.uniforms || {}).forEach((s) => {
    t.uniforms[s].value && !(s in i) && (i[s] = t.uniforms[s].value);
  }), Object.keys(i).forEach((s) => {
    typeof i[s] == "object" && i[s].index !== void 0 && (i[s].texture = e.getTexture(i[s].index));
  }), i;
}
const pz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: hz,
  encode: uz,
  name: cz
}, Symbol.toStringTag, { value: "Module" })), TT = [
  // 1.0
  // KHR_binary_gltf is handled separately - must be processed before other parsing starts
  // KHR_binary_gltf,
  // 2.0
  b4,
  $U,
  c6,
  d6,
  // Basisu should come after webp, we want basisu to be preferred if both are provided
  _6,
  H6,
  rz,
  lz,
  pz,
  ez,
  k4
];
function _z(t, e = {}, i) {
  var o;
  const s = TT.filter((l) => ET(l.name, e));
  for (const l of s)
    (o = l.preprocess) == null || o.call(l, t, e, i);
}
async function mz(t, e = {}, i) {
  var o;
  const s = TT.filter((l) => ET(l.name, e));
  for (const l of s)
    await ((o = l.decode) == null ? void 0 : o.call(l, t, e, i));
}
function ET(t, e) {
  var o;
  const i = ((o = e == null ? void 0 : e.gltf) == null ? void 0 : o.excludeExtensions) || {};
  return !(t in i && !i[t]);
}
const Cm = "KHR_binary_glTF";
function gz(t) {
  const e = new Es(t), { json: i } = e;
  for (const s of i.images || []) {
    const o = e.getObjectExtension(s, Cm);
    o && Object.assign(s, o), e.removeObjectExtension(s, Cm);
  }
  i.buffers && i.buffers[0] && delete i.buffers[0].uri, e.removeExtension(Cm);
}
const Kx = {
  accessors: "accessor",
  animations: "animation",
  buffers: "buffer",
  bufferViews: "bufferView",
  images: "image",
  materials: "material",
  meshes: "mesh",
  nodes: "node",
  samplers: "sampler",
  scenes: "scene",
  skins: "skin",
  textures: "texture"
}, yz = {
  accessor: "accessors",
  animations: "animation",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  material: "materials",
  mesh: "meshes",
  node: "nodes",
  sampler: "samplers",
  scene: "scenes",
  skin: "skins",
  texture: "textures"
};
class bz {
  constructor() {
    O(this, "idToIndexMap", {
      animations: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      images: {},
      materials: {},
      meshes: {},
      nodes: {},
      samplers: {},
      scenes: {},
      skins: {},
      textures: {}
    });
    O(this, "json");
  }
  // constructor() {}
  /**
   * Convert (normalize) glTF < 2.0 to glTF 2.0
   * @param gltf - object with json and binChunks
   * @param options
   * @param options normalize Whether to actually normalize
   */
  normalize(e, i) {
    this.json = e.json;
    const s = e.json;
    switch (s.asset && s.asset.version) {
      case "2.0":
        return;
      case void 0:
      case "1.0":
        break;
      default:
        console.warn(`glTF: Unknown version ${s.asset.version}`);
        return;
    }
    if (!i.normalize)
      throw new Error("glTF v1 is not supported.");
    console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail."), this._addAsset(s), this._convertTopLevelObjectsToArrays(s), gz(e), this._convertObjectIdsToArrayIndices(s), this._updateObjects(s), this._updateMaterial(s);
  }
  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639
  _addAsset(e) {
    e.asset = e.asset || {}, e.asset.version = "2.0", e.asset.generator = e.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
  }
  _convertTopLevelObjectsToArrays(e) {
    for (const i in Kx)
      this._convertTopLevelObjectToArray(e, i);
  }
  /** Convert one top level object to array */
  _convertTopLevelObjectToArray(e, i) {
    const s = e[i];
    if (!(!s || Array.isArray(s))) {
      e[i] = [];
      for (const o in s) {
        const l = s[o];
        l.id = l.id || o;
        const u = e[i].length;
        e[i].push(l), this.idToIndexMap[i][o] = u;
      }
    }
  }
  /** Go through all objects in all top-level arrays and replace ids with indices */
  _convertObjectIdsToArrayIndices(e) {
    for (const i in Kx)
      this._convertIdsToIndices(e, i);
    "scene" in e && (e.scene = this._convertIdToIndex(e.scene, "scene"));
    for (const i of e.textures)
      this._convertTextureIds(i);
    for (const i of e.meshes)
      this._convertMeshIds(i);
    for (const i of e.nodes)
      this._convertNodeIds(i);
    for (const i of e.scenes)
      this._convertSceneIds(i);
  }
  _convertTextureIds(e) {
    e.source && (e.source = this._convertIdToIndex(e.source, "image"));
  }
  _convertMeshIds(e) {
    for (const i of e.primitives) {
      const { attributes: s, indices: o, material: l } = i;
      for (const u in s)
        s[u] = this._convertIdToIndex(s[u], "accessor");
      o && (i.indices = this._convertIdToIndex(o, "accessor")), l && (i.material = this._convertIdToIndex(l, "material"));
    }
  }
  _convertNodeIds(e) {
    e.children && (e.children = e.children.map((i) => this._convertIdToIndex(i, "node"))), e.meshes && (e.meshes = e.meshes.map((i) => this._convertIdToIndex(i, "mesh")));
  }
  _convertSceneIds(e) {
    e.nodes && (e.nodes = e.nodes.map((i) => this._convertIdToIndex(i, "node")));
  }
  /** Go through all objects in a top-level array and replace ids with indices */
  _convertIdsToIndices(e, i) {
    e[i] || (console.warn(`gltf v1: json doesn't contain attribute ${i}`), e[i] = []);
    for (const s of e[i])
      for (const o in s) {
        const l = s[o], u = this._convertIdToIndex(l, o);
        s[o] = u;
      }
  }
  _convertIdToIndex(e, i) {
    const s = yz[i];
    if (s in this.idToIndexMap) {
      const o = this.idToIndexMap[s][e];
      if (!Number.isFinite(o))
        throw new Error(`gltf v1: failed to resolve ${i} with id ${e}`);
      return o;
    }
    return e;
  }
  /**
   *
   * @param {*} json
   */
  _updateObjects(e) {
    for (const i of this.json.buffers)
      delete i.type;
  }
  /**
   * Update material (set pbrMetallicRoughness)
   * @param {*} json
   */
  _updateMaterial(e) {
    var i, s, o;
    for (const l of e.materials) {
      l.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const u = ((i = l.values) == null ? void 0 : i.tex) || ((s = l.values) == null ? void 0 : s.texture2d_0) || ((o = l.values) == null ? void 0 : o.diffuseTex), c = e.textures.findIndex((x) => x.id === u);
      c !== -1 && (l.pbrMetallicRoughness.baseColorTexture = { index: c });
    }
  }
}
function vz(t, e = {}) {
  return new bz().normalize(t, e);
}
async function xz(t, e, i = 0, s, o) {
  var l, u, c;
  return wz(t, e, i, s), vz(t, { normalize: (l = s == null ? void 0 : s.gltf) == null ? void 0 : l.normalize }), _z(t, s, o), (u = s == null ? void 0 : s.gltf) != null && u.loadBuffers && t.json.buffers && await Az(t, s, o), (c = s == null ? void 0 : s.gltf) != null && c.loadImages && await Tz(t, s, o), await mz(t, s, o), t;
}
function wz(t, e, i, s) {
  if (s.uri && (t.baseUri = s.uri), e instanceof ArrayBuffer && !$4(e, i, s) && (e = new TextDecoder().decode(e)), typeof e == "string")
    t.json = jC(e);
  else if (e instanceof ArrayBuffer) {
    const u = {};
    i = G4(u, e, i, s.glb), zr(u.type === "glTF", `Invalid GLB magic string ${u.type}`), t._glb = u, t.json = u.json;
  } else
    zr(!1, "GLTF: must be ArrayBuffer or string");
  const o = t.json.buffers || [];
  if (t.buffers = new Array(o.length).fill(null), t._glb && t._glb.header.hasBinChunk) {
    const { binChunks: u } = t._glb;
    t.buffers[0] = {
      arrayBuffer: u[0].arrayBuffer,
      byteOffset: u[0].byteOffset,
      byteLength: u[0].byteLength
    };
  }
  const l = t.json.images || [];
  t.images = new Array(l.length).fill({});
}
async function Az(t, e, i) {
  var o, l;
  const s = t.json.buffers || [];
  for (let u = 0; u < s.length; ++u) {
    const c = s[u];
    if (c.uri) {
      const { fetch: x } = i;
      zr(x);
      const w = bT(c.uri, e), C = await ((o = i == null ? void 0 : i.fetch) == null ? void 0 : o.call(i, w)), M = await ((l = C == null ? void 0 : C.arrayBuffer) == null ? void 0 : l.call(C));
      t.buffers[u] = {
        arrayBuffer: M,
        byteOffset: 0,
        byteLength: M.byteLength
      }, delete c.uri;
    } else t.buffers[u] === null && (t.buffers[u] = {
      arrayBuffer: new ArrayBuffer(c.byteLength),
      byteOffset: 0,
      byteLength: c.byteLength
    });
  }
}
async function Tz(t, e, i) {
  const s = Ez(t), o = t.json.images || [], l = [];
  for (const u of s)
    l.push(Sz(t, o[u], u, e, i));
  return await Promise.all(l);
}
function Ez(t) {
  const e = /* @__PURE__ */ new Set(), i = t.json.textures || [];
  for (const s of i)
    s.source !== void 0 && e.add(s.source);
  return Array.from(e).sort();
}
async function Sz(t, e, i, s, o) {
  let l;
  if (e.uri && !e.hasOwnProperty("bufferView")) {
    const c = bT(e.uri, s), { fetch: x } = o;
    l = await (await x(c)).arrayBuffer(), e.bufferView = {
      data: l
    };
  }
  if (Number.isFinite(e.bufferView)) {
    const c = RU(t.json, t.buffers, e.bufferView);
    l = Gg(c.buffer, c.byteOffset, c.byteLength);
  }
  zr(l, "glTF image has no data");
  let u = await Bu(l, [_w, nU], {
    ...s,
    mimeType: e.mimeType,
    basis: s.basis || { format: aT() }
  }, o);
  u && u[0] && (u = {
    compressed: !0,
    // @ts-expect-error
    mipmaps: !1,
    width: u[0].width,
    height: u[0].height,
    data: u[0]
  }), t.images = t.images || [], t.images[i] = u;
}
const Mu = {
  dataType: null,
  batchType: null,
  name: "glTF",
  id: "gltf",
  module: "gltf",
  version: N4,
  extensions: ["gltf", "glb"],
  mimeTypes: ["model/gltf+json", "model/gltf-binary"],
  text: !0,
  binary: !0,
  tests: ["glTF"],
  parse: Cz,
  options: {
    gltf: {
      normalize: !0,
      // Normalize glTF v1 to glTF v2 format (not yet stable)
      loadBuffers: !0,
      // Fetch any linked .BIN buffers, decode base64
      loadImages: !0,
      // Create image objects
      decompressMeshes: !0
      // Decompress Draco encoded meshes
    },
    // common?
    log: console
    // eslint-disable-line
  }
};
async function Cz(t, e = {}, i) {
  e = { ...Mu.options, ...e }, e.gltf = { ...Mu.options.gltf, ...e.gltf };
  const { byteOffset: s = 0 } = e;
  return await xz({}, t, s, e, i);
}
const Iz = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Rz = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
}, Qr = {
  // Sampler parameters
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  // Sampler default values
  REPEAT: 10497,
  LINEAR: 9729,
  NEAREST_MIPMAP_LINEAR: 9986
}, Mz = {
  magFilter: Qr.TEXTURE_MAG_FILTER,
  minFilter: Qr.TEXTURE_MIN_FILTER,
  wrapS: Qr.TEXTURE_WRAP_S,
  wrapT: Qr.TEXTURE_WRAP_T
}, Pz = {
  [Qr.TEXTURE_MAG_FILTER]: Qr.LINEAR,
  [Qr.TEXTURE_MIN_FILTER]: Qr.NEAREST_MIPMAP_LINEAR,
  [Qr.TEXTURE_WRAP_S]: Qr.REPEAT,
  [Qr.TEXTURE_WRAP_T]: Qr.REPEAT
};
function Bz() {
  return {
    id: "default-sampler",
    parameters: Pz
  };
}
function Dz(t) {
  return Rz[t];
}
function Oz(t) {
  return Iz[t];
}
class Fz {
  constructor() {
    O(this, "baseUri", "");
    // @ts-expect-error
    O(this, "jsonUnprocessed");
    // @ts-expect-error
    O(this, "json");
    O(this, "buffers", []);
    O(this, "images", []);
  }
  postProcess(e, i = {}) {
    const { json: s, buffers: o = [], images: l = [] } = e, { baseUri: u = "" } = e;
    return zr(s), this.baseUri = u, this.buffers = o, this.images = l, this.jsonUnprocessed = s, this.json = this._resolveTree(e.json, i), this.json;
  }
  // Convert indexed glTF structure into tree structure
  // cross-link index resolution, enum lookup, convenience calculations
  // eslint-disable-next-line complexity, max-statements
  _resolveTree(e, i = {}) {
    const s = { ...e };
    return this.json = s, e.bufferViews && (s.bufferViews = e.bufferViews.map((o, l) => this._resolveBufferView(o, l))), e.images && (s.images = e.images.map((o, l) => this._resolveImage(o, l))), e.samplers && (s.samplers = e.samplers.map((o, l) => this._resolveSampler(o, l))), e.textures && (s.textures = e.textures.map((o, l) => this._resolveTexture(o, l))), e.accessors && (s.accessors = e.accessors.map((o, l) => this._resolveAccessor(o, l))), e.materials && (s.materials = e.materials.map((o, l) => this._resolveMaterial(o, l))), e.meshes && (s.meshes = e.meshes.map((o, l) => this._resolveMesh(o, l))), e.nodes && (s.nodes = e.nodes.map((o, l) => this._resolveNode(o, l)), s.nodes = s.nodes.map((o, l) => this._resolveNodeChildren(o))), e.skins && (s.skins = e.skins.map((o, l) => this._resolveSkin(o, l))), e.scenes && (s.scenes = e.scenes.map((o, l) => this._resolveScene(o, l))), typeof this.json.scene == "number" && s.scenes && (s.scene = s.scenes[this.json.scene]), s;
  }
  getScene(e) {
    return this._get(this.json.scenes, e);
  }
  getNode(e) {
    return this._get(this.json.nodes, e);
  }
  getSkin(e) {
    return this._get(this.json.skins, e);
  }
  getMesh(e) {
    return this._get(this.json.meshes, e);
  }
  getMaterial(e) {
    return this._get(this.json.materials, e);
  }
  getAccessor(e) {
    return this._get(this.json.accessors, e);
  }
  getCamera(e) {
    return this._get(this.json.cameras, e);
  }
  getTexture(e) {
    return this._get(this.json.textures, e);
  }
  getSampler(e) {
    return this._get(this.json.samplers, e);
  }
  getImage(e) {
    return this._get(this.json.images, e);
  }
  getBufferView(e) {
    return this._get(this.json.bufferViews, e);
  }
  getBuffer(e) {
    return this._get(this.json.buffers, e);
  }
  _get(e, i) {
    if (typeof i == "object")
      return i;
    const s = e && e[i];
    return s || console.warn(`glTF file error: Could not find ${e}[${i}]`), s;
  }
  // PARSING HELPERS
  _resolveScene(e, i) {
    return {
      ...e,
      // @ts-ignore
      id: e.id || `scene-${i}`,
      nodes: (e.nodes || []).map((s) => this.getNode(s))
    };
  }
  _resolveNode(e, i) {
    const s = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: (e == null ? void 0 : e.id) || `node-${i}`
    };
    return e.mesh !== void 0 && (s.mesh = this.getMesh(e.mesh)), e.camera !== void 0 && (s.camera = this.getCamera(e.camera)), e.skin !== void 0 && (s.skin = this.getSkin(e.skin)), e.meshes !== void 0 && e.meshes.length && (s.mesh = e.meshes.reduce((o, l) => {
      const u = this.getMesh(l);
      return o.id = u.id, o.primitives = o.primitives.concat(u.primitives), o;
    }, { primitives: [] })), s;
  }
  _resolveNodeChildren(e) {
    return e.children && (e.children = e.children.map((i) => this.getNode(i))), e;
  }
  _resolveSkin(e, i) {
    const s = typeof e.inverseBindMatrices == "number" ? this.getAccessor(e.inverseBindMatrices) : void 0;
    return {
      ...e,
      id: e.id || `skin-${i}`,
      inverseBindMatrices: s
    };
  }
  _resolveMesh(e, i) {
    const s = {
      ...e,
      id: e.id || `mesh-${i}`,
      primitives: []
    };
    return e.primitives && (s.primitives = e.primitives.map((o) => {
      const l = {
        ...o,
        attributes: {},
        indices: void 0,
        material: void 0
      }, u = o.attributes;
      for (const c in u)
        l.attributes[c] = this.getAccessor(u[c]);
      return o.indices !== void 0 && (l.indices = this.getAccessor(o.indices)), o.material !== void 0 && (l.material = this.getMaterial(o.material)), l;
    })), s;
  }
  _resolveMaterial(e, i) {
    const s = {
      ...e,
      // @ts-expect-error
      id: e.id || `material-${i}`
    };
    if (s.normalTexture && (s.normalTexture = { ...s.normalTexture }, s.normalTexture.texture = this.getTexture(s.normalTexture.index)), s.occlusionTexture && (s.occlusionTexture = { ...s.occlusionTexture }, s.occlusionTexture.texture = this.getTexture(s.occlusionTexture.index)), s.emissiveTexture && (s.emissiveTexture = { ...s.emissiveTexture }, s.emissiveTexture.texture = this.getTexture(s.emissiveTexture.index)), s.emissiveFactor || (s.emissiveFactor = s.emissiveTexture ? [1, 1, 1] : [0, 0, 0]), s.pbrMetallicRoughness) {
      s.pbrMetallicRoughness = { ...s.pbrMetallicRoughness };
      const o = s.pbrMetallicRoughness;
      o.baseColorTexture && (o.baseColorTexture = { ...o.baseColorTexture }, o.baseColorTexture.texture = this.getTexture(o.baseColorTexture.index)), o.metallicRoughnessTexture && (o.metallicRoughnessTexture = { ...o.metallicRoughnessTexture }, o.metallicRoughnessTexture.texture = this.getTexture(o.metallicRoughnessTexture.index));
    }
    return s;
  }
  _resolveAccessor(e, i) {
    const s = Dz(e.componentType), o = Oz(e.type), l = s * o, u = {
      ...e,
      // @ts-expect-error
      id: e.id || `accessor-${i}`,
      bytesPerComponent: s,
      components: o,
      bytesPerElement: l,
      value: void 0,
      bufferView: void 0,
      sparse: void 0
    };
    if (e.bufferView !== void 0 && (u.bufferView = this.getBufferView(e.bufferView)), u.bufferView) {
      const c = u.bufferView.buffer, { ArrayType: x, byteLength: w } = Iy(u, u.bufferView), C = (u.bufferView.byteOffset || 0) + (u.byteOffset || 0) + c.byteOffset;
      let M = c.arrayBuffer.slice(C, C + w);
      u.bufferView.byteStride && (M = this._getValueFromInterleavedBuffer(c, C, u.bufferView.byteStride, u.bytesPerElement, u.count)), u.value = new x(M);
    }
    return u;
  }
  /**
   * Take values of particular accessor from interleaved buffer
   * various parts of the buffer
   * @param buffer
   * @param byteOffset
   * @param byteStride
   * @param bytesPerElement
   * @param count
   * @returns
   */
  _getValueFromInterleavedBuffer(e, i, s, o, l) {
    const u = new Uint8Array(l * o);
    for (let c = 0; c < l; c++) {
      const x = i + c * s;
      u.set(new Uint8Array(e.arrayBuffer.slice(x, x + o)), c * o);
    }
    return u.buffer;
  }
  _resolveTexture(e, i) {
    return {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `texture-${i}`,
      sampler: typeof e.sampler == "number" ? this.getSampler(e.sampler) : Bz(),
      source: typeof e.source == "number" ? this.getImage(e.source) : void 0
    };
  }
  _resolveSampler(e, i) {
    const s = {
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `sampler-${i}`,
      ...e,
      parameters: {}
    };
    for (const o in s) {
      const l = this._enumSamplerParameter(o);
      l !== void 0 && (s.parameters[l] = s[o]);
    }
    return s;
  }
  _enumSamplerParameter(e) {
    return Mz[e];
  }
  _resolveImage(e, i) {
    const s = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `image-${i}`,
      image: null,
      bufferView: e.bufferView !== void 0 ? this.getBufferView(e.bufferView) : void 0
    }, o = this.images[i];
    return o && (s.image = o), s;
  }
  _resolveBufferView(e, i) {
    const s = e.buffer, o = this.buffers[s].arrayBuffer;
    let l = this.buffers[s].byteOffset || 0;
    return e.byteOffset && (l += e.byteOffset), {
      // // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: `bufferView-${i}`,
      ...e,
      // ...this.buffers[bufferIndex],
      buffer: this.buffers[s],
      data: new Uint8Array(o, l, e.byteLength)
    };
  }
  _resolveCamera(e, i) {
    const s = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `camera-${i}`
    };
    return s.perspective, s.orthographic, s;
  }
}
function Dy(t, e) {
  return new Fz().postProcess(t, e);
}
async function kz(t) {
  const e = [];
  return t.scenes.forEach((i) => {
    i.traverse((s) => {
      Object.values(s.model.uniforms).forEach((o) => {
        o.loaded === !1 && e.push(o);
      });
    });
  }), await Nz(() => e.some((i) => !i.loaded));
}
async function Nz(t) {
  for (; t(); )
    await new Promise((e) => requestAnimationFrame(e));
}
const Lz = `#version 300 es
#define SHADER_NAME scenegraph-layer-vertex-shader
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform mat4 sceneModelMatrix;
uniform bool composeModelMatrix;
in vec3 positions;
#ifdef HAS_UV
in vec2 texCoords;
#endif
#ifdef MODULE_PBR
#ifdef HAS_NORMALS
in vec3 normals;
#endif
#endif
out vec4 vColor;
#ifndef MODULE_PBR
#ifdef HAS_UV
out vec2 vTEXCOORD_0;
#endif
#endif
void main(void) {
#if defined(HAS_UV) && !defined(MODULE_PBR)
vTEXCOORD_0 = texCoords;
geometry.uv = texCoords;
#endif
geometry.worldPosition = instancePositions;
geometry.pickingColor = instancePickingColors;
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 normal = vec3(0.0, 0.0, 1.0);
#ifdef MODULE_PBR
#ifdef HAS_NORMALS
normal = instanceModelMatrix * (sceneModelMatrix * vec4(normals, 0.0)).xyz;
#endif
#endif
float originalSize = project_size_to_pixel(sizeScale);
float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);
vec3 pos = (instanceModelMatrix * (sceneModelMatrix * vec4(positions, 1.0)).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;
if(composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
geometry.normal = project_normal(normal);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
geometry.normal = project_normal(normal);
}
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef MODULE_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = texCoords;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, Uz = `#version 300 es
#define SHADER_NAME scenegraph-layer-fragment-shader
uniform float opacity;
in vec4 vColor;
out vec4 fragColor;
#ifndef MODULE_PBR
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
in vec2 vTEXCOORD_0;
uniform sampler2D u_BaseColorSampler;
#endif
#endif
void main(void) {
#ifdef MODULE_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
#else
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
fragColor = vColor * texture(u_BaseColorSampler, vTEXCOORD_0);
geometry.uv = vTEXCOORD_0;
#else
fragColor = vColor;
#endif
#endif
fragColor.a *= opacity;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, ST = [255, 255, 255, 255], zz = {
  scenegraph: { type: "object", value: null, async: !0 },
  getScene: (t) => t && t.scenes ? typeof t.scene == "object" ? t.scene : t.scenes[t.scene || 0] : t,
  getAnimator: (t) => t && t.animator,
  _animations: null,
  sizeScale: { type: "number", value: 1, min: 0 },
  sizeMinPixels: { type: "number", min: 0, value: 0 },
  sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  getPosition: { type: "accessor", value: (t) => t.position },
  getColor: { type: "accessor", value: ST },
  // flat or pbr
  _lighting: "flat",
  // _lighting must be pbr for this to work
  _imageBasedLightingEnvironment: void 0,
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: { type: "accessor", value: [0, 0, 0] },
  getScale: { type: "accessor", value: [1, 1, 1] },
  getTranslation: { type: "accessor", value: [0, 0, 0] },
  // 4x4 matrix
  getTransformMatrix: { type: "accessor", value: [] },
  loaders: [Mu]
};
class Oy extends Gc {
  getShaders() {
    const e = [py, gy];
    return this.props._lighting === "pbr" && e.push(dy), super.getShaders({ vs: Lz, fs: Uz, modules: e });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: !0
      },
      instanceColors: {
        type: "unorm8",
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: ST,
        transition: !0
      },
      instanceModelMatrix: sT
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: i, oldProps: s } = e;
    i.scenegraph !== s.scenegraph ? this._updateScenegraph() : i._animations !== s._animations && this._applyAnimationsProp(this.state.animator, i._animations);
  }
  finalizeState(e) {
    var i;
    super.finalizeState(e), (i = this.state.scenegraph) == null || i.destroy();
  }
  get isLoaded() {
    var e;
    return !!((e = this.state) != null && e.scenegraph && super.isLoaded);
  }
  _updateScenegraph() {
    var c;
    const e = this.props, { device: i } = this.context;
    let s = null;
    if (e.scenegraph instanceof $f)
      s = { scenes: [e.scenegraph] };
    else if (e.scenegraph && typeof e.scenegraph == "object") {
      const x = e.scenegraph, w = x.json ? Dy(x) : x, C = wU(i, w, this._getModelOptions());
      s = { gltf: w, ...C }, kz(C).then(() => {
        this.setNeedsRedraw();
      }).catch((M) => {
        this.raiseError(M, "loading glTF");
      });
    }
    const o = { layer: this, device: this.context.device }, l = e.getScene(s, o), u = e.getAnimator(s, o);
    if (l instanceof Rc) {
      (c = this.state.scenegraph) == null || c.destroy(), this._applyAnimationsProp(u, e._animations);
      const x = [];
      l.traverse((w) => {
        w instanceof yg && x.push(w.model);
      }), this.setState({ scenegraph: l, animator: u, models: x }), this.getAttributeManager().invalidateAll();
    } else l !== null && Jt.warn("invalid scenegraph:", l)();
  }
  _applyAnimationsProp(e, i) {
    if (!e || !i)
      return;
    const s = e.getAnimations();
    Object.keys(i).sort().forEach((o) => {
      const l = i[o];
      if (o === "*")
        s.forEach((u) => {
          Object.assign(u, l);
        });
      else if (Number.isFinite(Number(o))) {
        const u = Number(o);
        u >= 0 && u < s.length ? Object.assign(s[u], l) : Jt.warn(`animation ${o} not found`)();
      } else {
        const u = s.find(({ name: c }) => c === o);
        u ? Object.assign(u, l) : Jt.warn(`animation ${o} not found`)();
      }
    });
  }
  _getModelOptions() {
    const { _imageBasedLightingEnvironment: e } = this.props;
    let i;
    return e && (typeof e == "function" ? i = e({ gl: this.context.gl, layer: this }) : i = e), {
      imageBasedLightingEnvironment: i,
      modelOptions: {
        id: this.props.id,
        isInstanced: !0,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        ...this.getShaders()
      },
      // tangents are not supported
      useTangents: !1
    };
  }
  draw({ context: e }) {
    if (!this.state.scenegraph)
      return;
    this.props._animations && this.state.animator && (this.state.animator.animate(e.timeline.getTime()), this.setNeedsRedraw());
    const { viewport: i, renderPass: s } = this.context, { sizeScale: o, sizeMinPixels: l, sizeMaxPixels: u, opacity: c, coordinateSystem: x } = this.props, w = this.getNumInstances();
    this.state.scenegraph.traverse((C, { worldMatrix: M }) => {
      if (C instanceof yg) {
        const { model: P } = C;
        P.setInstanceCount(w), P.setUniforms({
          sizeScale: o,
          opacity: c,
          sizeMinPixels: l,
          sizeMaxPixels: u,
          composeModelMatrix: rT(i, x),
          sceneModelMatrix: M,
          // Needed for PBR (TODO: find better way to get it)
          // eslint-disable-next-line camelcase
          u_Camera: P.uniforms.project_uCameraPosition
        }), P.draw(s);
      }
    });
  }
}
Oy.defaultProps = zz;
Oy.layerName = "ScenegraphLayer";
const Vz = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
uniform float sizeScale;
uniform bool composeModelMatrix;
uniform bool pickFeatureIds;
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
vec2 applyUVRegion(vec2 uv) {
#ifdef HAS_UV_REGIONS
return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
#else
return uv;
#endif
}
void main(void) {
vec2 uv = applyUVRegion(texCoords);
geometry.uv = uv;
if (pickFeatureIds) {
geometry.pickingColor = featureIdsPickingColors;
} else {
geometry.pickingColor = instancePickingColors;
}
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vTexCoord = uv;
cameraPosition = project_uCameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
vec3 pos = (instanceModelMatrix * positions) * sizeScale;
vec3 projectedPosition = project_position(positions);
position_commonspace = vec4(projectedPosition, 1.0);
gl_Position = project_common_position_to_clipspace(position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef MODULE_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, Hz = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
#ifdef MODULE_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
fragColor.a *= opacity;
#else
geometry.uv = vTexCoord;
vec3 normal;
if (flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * opacity);
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
function jz(t) {
  const e = t.positions || t.POSITION, i = e.value.length / e.size;
  t.COLOR_0 || t.colors || (t.colors = {
    size: 4,
    value: new Uint8Array(i * 4).fill(255),
    normalized: !0
  });
}
const $z = {
  pbrMaterial: { type: "object", value: null },
  featureIds: { type: "array", value: null, optional: !0 }
};
class Fy extends Cy {
  getShaders() {
    const e = super.getShaders();
    return e.modules.push(dy), { ...e, vs: Vz, fs: Hz };
  }
  initializeState() {
    const { featureIds: e } = this.props;
    super.initializeState();
    const i = this.getAttributeManager();
    e && i.add({
      featureIdsPickingColors: {
        type: "uint8",
        size: 3,
        noAlloc: !0,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateFeatureIdsPickingColors
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: i, oldProps: s } = e;
    i.pbrMaterial !== s.pbrMaterial && this.updatePbrMaterialUniforms(i.pbrMaterial);
  }
  draw(e) {
    const { featureIds: i } = this.props;
    this.state.model && (this.state.model.setUniforms({
      // Needed for PBR (TODO: find better way to get it)
      // eslint-disable-next-line camelcase
      u_Camera: this.state.model.uniforms.project_uCameraPosition,
      pickFeatureIds: !!i
    }), super.draw(e));
  }
  getModel(e) {
    const { id: i, pbrMaterial: s } = this.props, o = this.parseMaterial(s, e);
    this.setState({ parsedPBRMaterial: o });
    const l = this.getShaders();
    return jz(e.attributes), new ma(this.context.device, {
      ...this.getShaders(),
      id: i,
      geometry: e,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      defines: {
        ...l.defines,
        ...o == null ? void 0 : o.defines,
        HAS_UV_REGIONS: e.attributes.uvRegions ? 1 : 0
      },
      parameters: o == null ? void 0 : o.parameters,
      isInstanced: !0
    });
  }
  updatePbrMaterialUniforms(e) {
    const { model: i } = this.state;
    if (i) {
      const { mesh: s } = this.props, o = this.parseMaterial(e, s);
      this.setState({ parsedPBRMaterial: o }), i.setBindings(o.bindings), i.setUniforms(o.uniforms);
    }
  }
  parseMaterial(e, i) {
    const s = !!(e.pbrMetallicRoughness && e.pbrMetallicRoughness.baseColorTexture);
    return nT(this.context.device, { unlit: s, ...e }, { NORMAL: i.attributes.normals, TEXCOORD_0: i.attributes.texCoords }, {
      pbrDebug: !1,
      lights: !0,
      useTangents: !1
    });
  }
  calculateFeatureIdsPickingColors(e) {
    const i = this.props.featureIds, s = new Uint8ClampedArray(i.length * e.size), o = [];
    for (let l = 0; l < i.length; l++)
      this.encodePickingColor(i[l], o), s[l * 3] = o[0], s[l * 3 + 1] = o[1], s[l * 3 + 2] = o[2];
    e.value = s;
  }
  finalizeState(e) {
    var i;
    super.finalizeState(e), (i = this.state.parsedPBRMaterial) == null || i.generatedTextures.forEach((s) => s.destroy()), this.setState({ parsedPBRMaterial: null });
  }
}
Fy.layerName = "MeshLayer";
Fy.defaultProps = $z;
const Gz = 6378137, Xz = 6378137, Wz = 6356752314245179e-9;
function Sp(t) {
  return t;
}
new Se();
function qz(t, e = [], i = Sp) {
  return "longitude" in t ? (e[0] = i(t.longitude), e[1] = i(t.latitude), e[2] = t.height) : "x" in t ? (e[0] = i(t.x), e[1] = i(t.y), e[2] = t.z) : (e[0] = i(t[0]), e[1] = i(t[1]), e[2] = t[2]), e;
}
function Zz(t, e = []) {
  return qz(t, e, us._cartographicRadians ? Sp : RP);
}
function Kz(t, e, i = Sp) {
  return "longitude" in e ? (e.longitude = i(t[0]), e.latitude = i(t[1]), e.height = t[2]) : "x" in e ? (e.x = i(t[0]), e.y = i(t[1]), e.z = t[2]) : (e[0] = i(t[0]), e[1] = i(t[1]), e[2] = t[2]), e;
}
function Jz(t, e) {
  return Kz(t, e, us._cartographicRadians ? Sp : MP);
}
const Jx = 1e-14, Yz = new Se(), Yx = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
}, Im = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
}, iu = {
  east: new Se(),
  north: new Se(),
  up: new Se(),
  west: new Se(),
  south: new Se(),
  down: new Se()
}, Qz = new Se(), e5 = new Se(), t5 = new Se();
function Qx(t, e, i, s, o, l) {
  const u = Yx[e] && Yx[e][i];
  pn(u && (!s || s === u));
  let c, x, w;
  const C = Yz.copy(o);
  if (bn(C.x, 0, Jx) && bn(C.y, 0, Jx)) {
    const P = Math.sign(C.z);
    c = Qz.fromArray(Im[e]), e !== "east" && e !== "west" && c.scale(P), x = e5.fromArray(Im[i]), i !== "east" && i !== "west" && x.scale(P), w = t5.fromArray(Im[s]), s !== "east" && s !== "west" && w.scale(P);
  } else {
    const { up: P, east: j, north: Y } = iu;
    j.set(-C.y, C.x, 0).normalize(), t.geodeticSurfaceNormal(C, P), Y.copy(P).cross(j);
    const { down: Q, west: _e, south: me } = iu;
    Q.copy(P).scale(-1), _e.copy(j).scale(-1), me.copy(Y).scale(-1), c = iu[e], x = iu[i], w = iu[s];
  }
  return l[0] = c.x, l[1] = c.y, l[2] = c.z, l[3] = 0, l[4] = x.x, l[5] = x.y, l[6] = x.z, l[7] = 0, l[8] = w.x, l[9] = w.y, l[10] = w.z, l[11] = 0, l[12] = C.x, l[13] = C.y, l[14] = C.z, l[15] = 1, l;
}
const dc = new Se(), i5 = new Se(), s5 = new Se();
function r5(t, e, i = []) {
  const { oneOverRadii: s, oneOverRadiiSquared: o, centerToleranceSquared: l } = e;
  dc.from(t);
  const u = dc.x, c = dc.y, x = dc.z, w = s.x, C = s.y, M = s.z, P = u * u * w * w, j = c * c * C * C, Y = x * x * M * M, Q = P + j + Y, _e = Math.sqrt(1 / Q);
  if (!Number.isFinite(_e))
    return;
  const me = i5;
  if (me.copy(t).scale(_e), Q < l)
    return me.to(i);
  const we = o.x, Ee = o.y, Oe = o.z, Ne = s5;
  Ne.set(me.x * we * 2, me.y * Ee * 2, me.z * Oe * 2);
  let ze = (1 - _e) * dc.len() / (0.5 * Ne.len()), nt = 0, mt, We, at, it;
  do {
    ze -= nt, mt = 1 / (1 + ze * we), We = 1 / (1 + ze * Ee), at = 1 / (1 + ze * Oe);
    const Ut = mt * mt, Rt = We * We, yt = at * at, di = Ut * mt, Fs = Rt * We, Hi = yt * at;
    it = P * Ut + j * Rt + Y * yt - 1;
    const Js = -2 * (P * di * we + j * Fs * Ee + Y * Hi * Oe);
    nt = it / Js;
  } while (Math.abs(it) > Z3);
  return dc.scale([mt, We, at]).to(i);
}
const ff = new Se(), e1 = new Se(), n5 = new Se(), dn = new Se(), o5 = new Se(), pf = new Se();
class Ti {
  constructor(e = 0, i = 0, s = 0) {
    this.centerToleranceSquared = q3, pn(e >= 0), pn(i >= 0), pn(s >= 0), this.radii = new Se(e, i, s), this.radiiSquared = new Se(e * e, i * i, s * s), this.radiiToTheFourth = new Se(e * e * e * e, i * i * i * i, s * s * s * s), this.oneOverRadii = new Se(e === 0 ? 0 : 1 / e, i === 0 ? 0 : 1 / i, s === 0 ? 0 : 1 / s), this.oneOverRadiiSquared = new Se(e === 0 ? 0 : 1 / (e * e), i === 0 ? 0 : 1 / (i * i), s === 0 ? 0 : 1 / (s * s)), this.minimumRadius = Math.min(e, i, s), this.maximumRadius = Math.max(e, i, s), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);
  }
  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */
  equals(e) {
    return this === e || !!(e && this.radii.equals(e.radii));
  }
  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */
  toString() {
    return this.radii.toString();
  }
  cartographicToCartesian(e, i = [0, 0, 0]) {
    const s = e1, o = n5, [, , l] = e;
    this.geodeticSurfaceNormalCartographic(e, s), o.copy(this.radiiSquared).scale(s);
    const u = Math.sqrt(s.dot(o));
    return o.scale(1 / u), s.scale(l), o.add(s), o.to(i);
  }
  cartesianToCartographic(e, i = [0, 0, 0]) {
    pf.from(e);
    const s = this.scaleToGeodeticSurface(pf, dn);
    if (!s)
      return;
    const o = this.geodeticSurfaceNormal(s, e1), l = o5;
    l.copy(pf).subtract(s);
    const u = Math.atan2(o.y, o.x), c = Math.asin(o.z), x = Math.sign(ay(l, pf)) * Ww(l);
    return Jz([u, c, x], i);
  }
  eastNorthUpToFixedFrame(e, i = new Xt()) {
    return Qx(this, "east", "north", "up", e, i);
  }
  // Computes a 4x4 transformation matrix from a reference frame centered at
  // the provided origin to the ellipsoid's fixed reference frame.
  localFrameToFixedFrame(e, i, s, o, l = new Xt()) {
    return Qx(this, e, i, s, o, l);
  }
  geocentricSurfaceNormal(e, i = [0, 0, 0]) {
    return ff.from(e).normalize().to(i);
  }
  geodeticSurfaceNormalCartographic(e, i = [0, 0, 0]) {
    const s = Zz(e), o = s[0], l = s[1], u = Math.cos(l);
    return ff.set(u * Math.cos(o), u * Math.sin(o), Math.sin(l)).normalize(), ff.to(i);
  }
  geodeticSurfaceNormal(e, i = [0, 0, 0]) {
    return ff.from(e).scale(this.oneOverRadiiSquared).normalize().to(i);
  }
  /** Scales the provided Cartesian position along the geodetic surface normal
   * so that it is on the surface of this ellipsoid.  If the position is
   * at the center of the ellipsoid, this function returns undefined. */
  scaleToGeodeticSurface(e, i) {
    return r5(e, this, i);
  }
  /** Scales the provided Cartesian position along the geocentric surface normal
   * so that it is on the surface of this ellipsoid. */
  scaleToGeocentricSurface(e, i = [0, 0, 0]) {
    dn.from(e);
    const s = dn.x, o = dn.y, l = dn.z, u = this.oneOverRadiiSquared, c = 1 / Math.sqrt(s * s * u.x + o * o * u.y + l * l * u.z);
    return dn.multiplyScalar(c).to(i);
  }
  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#oneOverRadii` */
  transformPositionToScaledSpace(e, i = [0, 0, 0]) {
    return dn.from(e).scale(this.oneOverRadii).to(i);
  }
  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#radii`. */
  transformPositionFromScaledSpace(e, i = [0, 0, 0]) {
    return dn.from(e).scale(this.radii).to(i);
  }
  /** Computes a point which is the intersection of the surface normal with the z-axis. */
  getSurfaceNormalIntersectionWithZAxis(e, i = 0, s = [0, 0, 0]) {
    pn(bn(this.radii.x, this.radii.y, sA)), pn(this.radii.z > 0), dn.from(e);
    const o = dn.z * (1 - this.squaredXOverSquaredZ);
    if (!(Math.abs(o) >= this.radii.z - i))
      return dn.set(0, 0, o).to(s);
  }
}
Ti.WGS84 = new Ti(Gz, Xz, Wz);
class a5 {
  constructor(e, i, s) {
    O(this, "item");
    O(this, "previous");
    O(this, "next");
    this.item = e, this.previous = i, this.next = s;
  }
}
class l5 {
  constructor() {
    O(this, "head", null);
    O(this, "tail", null);
    O(this, "_length", 0);
  }
  get length() {
    return this._length;
  }
  /**
   * Adds the item to the end of the list
   * @param {*} [item]
   * @return {DoublyLinkedListNode}
   */
  add(e) {
    const i = new a5(e, this.tail, null);
    return this.tail ? (this.tail.next = i, this.tail = i) : (this.head = i, this.tail = i), ++this._length, i;
  }
  /**
   * Removes the given node from the list
   * @param {DoublyLinkedListNode} node
   */
  remove(e) {
    e && (e.previous && e.next ? (e.previous.next = e.next, e.next.previous = e.previous) : e.previous ? (e.previous.next = null, this.tail = e.previous) : e.next ? (e.next.previous = null, this.head = e.next) : (this.head = null, this.tail = null), e.next = null, e.previous = null, --this._length);
  }
  /**
   * Moves nextNode after node
   * @param {DoublyLinkedListNode} node
   * @param {DoublyLinkedListNode} nextNode
   */
  splice(e, i) {
    e !== i && (this.remove(i), this._insert(e, i));
  }
  _insert(e, i) {
    const s = e.next;
    e.next = i, this.tail === e ? this.tail = i : s.previous = i, i.next = s, i.previous = e, ++this._length;
  }
}
class c5 {
  constructor() {
    O(this, "_list");
    O(this, "_sentinel");
    O(this, "_trimTiles");
    this._list = new l5(), this._sentinel = this._list.add("sentinel"), this._trimTiles = !1;
  }
  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }
  touch(e) {
    const i = e._cacheNode;
    i && this._list.splice(this._sentinel, i);
  }
  add(e, i, s) {
    i._cacheNode || (i._cacheNode = this._list.add(i), s && s(e, i));
  }
  unloadTile(e, i, s) {
    const o = i._cacheNode;
    o && (this._list.remove(o), i._cacheNode = null, s && s(e, i));
  }
  unloadTiles(e, i) {
    const s = this._trimTiles;
    this._trimTiles = !1;
    const o = this._list, l = e.maximumMemoryUsage * 1024 * 1024, u = this._sentinel;
    let c = o.head;
    for (; c !== u && (e.gpuMemoryUsageInBytes > l || s); ) {
      const x = c.item;
      c = c.next, this.unloadTile(e, x, i);
    }
  }
  trim() {
    this._trimTiles = !0;
  }
}
function h5(t, e) {
  Ai(t), Ai(e);
  const { rtcCenter: i, gltfUpAxis: s } = e, { computedTransform: o, boundingVolume: { center: l } } = t;
  let u = new Xt(o);
  switch (i && u.translate(i), s) {
    case "Z":
      break;
    case "Y":
      const M = new Xt().rotateX(Math.PI / 2);
      u = u.multiplyRight(M);
      break;
    case "X":
      const P = new Xt().rotateY(-Math.PI / 2);
      u = u.multiplyRight(P);
      break;
  }
  e.isQuantized && u.translate(e.quantizedVolumeOffset).scale(e.quantizedVolumeScale);
  const c = new Se(l);
  e.cartesianModelMatrix = u, e.cartesianOrigin = c;
  const x = Ti.WGS84.cartesianToCartographic(c, new Se()), C = Ti.WGS84.eastNorthUpToFixedFrame(c).invert();
  e.cartographicModelMatrix = C.multiplyRight(u), e.cartographicOrigin = x, e.coordinateSystem || (e.modelMatrix = e.cartographicModelMatrix);
}
const t1 = new Se(), Rm = new Se(), Fg = new en([
  new $n(),
  new $n(),
  new $n(),
  new $n(),
  new $n(),
  new $n()
]);
function u5(t, e) {
  const { cameraDirection: i, cameraUp: s, height: o } = t, { metersPerUnit: l } = t.distanceScales, u = Ef(t, t.center), c = Ti.WGS84.eastNorthUpToFixedFrame(u), x = t.unprojectPosition(t.cameraPosition), w = Ti.WGS84.cartographicToCartesian(x, new Se()), C = new Se(
    // @ts-ignore
    c.transformAsVector(new Se(i).scale(l))
  ).normalize(), M = new Se(
    // @ts-ignore
    c.transformAsVector(new Se(s).scale(l))
  ).normalize();
  f5(t);
  const P = t.constructor, { longitude: j, latitude: Y, width: Q, bearing: _e, zoom: me } = t, we = new P({
    longitude: j,
    latitude: Y,
    height: o,
    width: Q,
    bearing: _e,
    zoom: me,
    pitch: 0
  });
  return {
    camera: {
      position: w,
      direction: C,
      up: M
    },
    viewport: t,
    topDownViewport: we,
    height: o,
    cullingVolume: Fg,
    frameNumber: e,
    // TODO: This can be the same between updates, what number is unique for between updates?
    sseDenominator: 1.15
    // Assumes fovy = 60 degrees
  };
}
function d5(t, e, i) {
  if (i === 0 || t.length <= i)
    return [t, []];
  const s = [], { longitude: o, latitude: l } = e.viewport;
  for (const [w, C] of t.entries()) {
    const [M, P] = C.header.mbs, j = Math.abs(o - M), Y = Math.abs(l - P), Q = Math.sqrt(Y * Y + j * j);
    s.push([w, Q]);
  }
  const u = s.sort((w, C) => w[1] - C[1]), c = [];
  for (let w = 0; w < i; w++)
    c.push(t[u[w][0]]);
  const x = [];
  for (let w = i; w < u.length; w++)
    x.push(t[u[w][0]]);
  return [c, x];
}
function f5(t) {
  const e = t.getFrustumPlanes(), i = i1(e.near, t.cameraPosition), s = Ef(t, i), o = Ef(t, t.cameraPosition, Rm);
  let l = 0;
  Fg.planes[l++].fromPointNormal(s, t1.copy(s).subtract(o));
  for (const u in e) {
    if (u === "near")
      continue;
    const c = e[u], x = i1(c, i, Rm), w = Ef(t, x, Rm);
    Fg.planes[l++].fromPointNormal(
      w,
      // Want the normal to point into the frustum since that's what culling expects
      t1.copy(s).subtract(w)
    );
  }
}
function i1(t, e, i = new Se()) {
  const s = t.normal.dot(e);
  return i.copy(t.normal).scale(t.distance - s).add(e), i;
}
function Ef(t, e, i = new Se()) {
  const s = t.unprojectPosition(e);
  return Ti.WGS84.cartographicToCartesian(s, i);
}
const p5 = 6378137, _5 = 6378137, kg = 6356752314245179e-9, wc = new Se();
function m5(t, e) {
  if (t instanceof Vu) {
    const { halfAxes: i } = t, s = y5(i);
    return Math.log2(kg / (s + e[2]));
  } else if (t instanceof zu) {
    const { radius: i } = t;
    return Math.log2(kg / (i + e[2]));
  } else if (t.width && t.height) {
    const { width: i, height: s } = t, o = Math.log2(p5 / i), l = Math.log2(_5 / s);
    return (o + l) / 2;
  }
  return 1;
}
function CT(t, e, i) {
  Ti.WGS84.cartographicToCartesian([t.xmax, t.ymax, t.zmax], wc);
  const s = Math.sqrt(Math.pow(wc[0] - i[0], 2) + Math.pow(wc[1] - i[1], 2) + Math.pow(wc[2] - i[2], 2));
  return Math.log2(kg / (s + e[2]));
}
function g5(t, e, i) {
  const [s, o, l, u] = t;
  return CT({ xmin: s, xmax: l, ymin: o, ymax: u, zmin: 0, zmax: 0 }, e, i);
}
function y5(t) {
  t.getColumn(0, wc);
  const e = t.getColumn(1), i = t.getColumn(2);
  return wc.add(e).add(i).len();
}
const Nr = {
  UNLOADED: 0,
  // Has never been requested
  LOADING: 1,
  // Is waiting on a pending request
  PROCESSING: 2,
  // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.
  READY: 3,
  // Ready to render.
  EXPIRED: 4,
  // Is expired and will be unloaded once new content is loaded.
  FAILED: 5
  // Request failed.
};
var vn;
(function(t) {
  t[t.ADD = 1] = "ADD", t[t.REPLACE = 2] = "REPLACE";
})(vn || (vn = {}));
var vo;
(function(t) {
  t.EMPTY = "empty", t.SCENEGRAPH = "scenegraph", t.POINTCLOUD = "pointcloud", t.MESH = "mesh";
})(vo || (vo = {}));
var vr;
(function(t) {
  t.I3S = "I3S", t.TILES3D = "TILES3D";
})(vr || (vr = {}));
var zc;
(function(t) {
  t.GEOMETRIC_ERROR = "geometricError", t.MAX_SCREEN_THRESHOLD = "maxScreenThreshold";
})(zc || (zc = {}));
const b5 = {
  NOT_COMPUTED: -1,
  USE_OPTIMIZATION: 1,
  SKIP_OPTIMIZATION: 0
};
function IT(t) {
  return t != null;
}
const Zs = new Se(), Sf = new Se(), v5 = new Se(), x5 = new Se(), Wa = new Se(), s1 = new Se(), r1 = new Se(), n1 = new Se();
function Mm(t, e, i) {
  if (Ai(t, "3D Tile: boundingVolume must be defined"), t.box)
    return RT(t.box, e, i);
  if (t.region)
    return T5(t.region);
  if (t.sphere)
    return A5(t.sphere, e, i);
  throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
}
function w5(t, e) {
  if (t.box)
    return E5(e);
  if (t.region) {
    const [i, s, o, l, u, c] = t.region;
    return [
      [fn(i), fn(s), u],
      [fn(o), fn(l), c]
    ];
  }
  if (t.sphere)
    return S5(e);
  throw new Error("Unkown boundingVolume type");
}
function RT(t, e, i) {
  const s = new Se(t[0], t[1], t[2]);
  e.transform(s, s);
  let o = [];
  if (t.length === 10) {
    const w = t.slice(3, 6), C = new Au();
    C.fromArray(t, 6);
    const M = new Se([1, 0, 0]), P = new Se([0, 1, 0]), j = new Se([0, 0, 1]);
    M.transformByQuaternion(C), M.scale(w[0]), P.transformByQuaternion(C), P.scale(w[1]), j.transformByQuaternion(C), j.scale(w[2]), o = [...M.toArray(), ...P.toArray(), ...j.toArray()];
  } else
    o = [...t.slice(3, 6), ...t.slice(6, 9), ...t.slice(9, 12)];
  const l = e.transformAsVector(o.slice(0, 3)), u = e.transformAsVector(o.slice(3, 6)), c = e.transformAsVector(o.slice(6, 9)), x = new qi([
    l[0],
    l[1],
    l[2],
    u[0],
    u[1],
    u[2],
    c[0],
    c[1],
    c[2]
  ]);
  return IT(i) ? (i.center = s, i.halfAxes = x, i) : new Vu(s, x);
}
function A5(t, e, i) {
  const s = new Se(t[0], t[1], t[2]);
  e.transform(s, s);
  const o = e.getScale(Sf), l = Math.max(Math.max(o[0], o[1]), o[2]), u = t[3] * l;
  return IT(i) ? (i.center = s, i.radius = u, i) : new zu(s, u);
}
function T5(t) {
  const [e, i, s, o, l, u] = t, c = Ti.WGS84.cartographicToCartesian([fn(e), fn(o), l], v5), x = Ti.WGS84.cartographicToCartesian([fn(s), fn(i), u], x5), w = new Se().addVectors(c, x).multiplyByScalar(0.5);
  return Ti.WGS84.cartesianToCartographic(w, Wa), Ti.WGS84.cartographicToCartesian([fn(s), Wa[1], Wa[2]], s1), Ti.WGS84.cartographicToCartesian([Wa[0], fn(o), Wa[2]], r1), Ti.WGS84.cartographicToCartesian([Wa[0], Wa[1], u], n1), RT([
    ...w,
    ...s1.subtract(w),
    ...r1.subtract(w),
    ...n1.subtract(w)
  ], new Xt());
}
function E5(t) {
  const e = MT(), { halfAxes: i } = t, s = new Se(i.getColumn(0)), o = new Se(i.getColumn(1)), l = new Se(i.getColumn(2));
  for (let u = 0; u < 2; u++) {
    for (let c = 0; c < 2; c++) {
      for (let x = 0; x < 2; x++)
        Zs.copy(t.center), Zs.add(s), Zs.add(o), Zs.add(l), PT(e, Zs), l.negate();
      o.negate();
    }
    s.negate();
  }
  return e;
}
function S5(t) {
  const e = MT(), { center: i, radius: s } = t, o = Ti.WGS84.scaleToGeodeticSurface(i, Zs);
  let l;
  o ? l = Ti.WGS84.geodeticSurfaceNormal(o) : l = new Se(0, 0, 1);
  let u = new Se(l[2], -l[1], 0);
  u.len() > 0 ? u.normalize() : u = new Se(0, 1, 0);
  const c = u.clone().cross(l);
  for (const x of [u, c, l]) {
    Sf.copy(x).scale(s);
    for (let w = 0; w < 2; w++)
      Zs.copy(i), Zs.add(Sf), PT(e, Zs), Sf.negate();
  }
  return e;
}
function MT() {
  return [
    [1 / 0, 1 / 0, 1 / 0],
    [-1 / 0, -1 / 0, -1 / 0]
  ];
}
function PT(t, e) {
  Ti.WGS84.cartesianToCartographic(e, Zs), t[0][0] = Math.min(t[0][0], Zs[0]), t[0][1] = Math.min(t[0][1], Zs[1]), t[0][2] = Math.min(t[0][2], Zs[2]), t[1][0] = Math.max(t[1][0], Zs[0]), t[1][1] = Math.max(t[1][1], Zs[1]), t[1][2] = Math.max(t[1][2], Zs[2]);
}
new Se();
new Se();
new Xt();
new Se();
new Se();
new Se();
function C5(t, e) {
  const i = t * e;
  return 1 - Math.exp(-(i * i));
}
function I5(t, e) {
  if (t.dynamicScreenSpaceError && t.dynamicScreenSpaceErrorComputedDensity) {
    const i = t.dynamicScreenSpaceErrorComputedDensity, s = t.dynamicScreenSpaceErrorFactor;
    return C5(e, i) * s;
  }
  return 0;
}
function R5(t, e, i) {
  const s = t.tileset, o = t.parent && t.parent.lodMetricValue || t.lodMetricValue, l = i ? o : t.lodMetricValue;
  if (l === 0)
    return 0;
  const u = Math.max(t._distanceToCamera, 1e-7), { height: c, sseDenominator: x } = e, { viewDistanceScale: w } = s.options;
  let C = l * c * (w || 1) / (u * x);
  return C -= I5(s, u), C;
}
const Pm = new Se(), o1 = new Se(), aa = new Se(), a1 = new Se(), M5 = new Se(), Bm = new Xt(), l1 = new Xt();
function P5(t, e) {
  if (t.lodMetricValue === 0 || isNaN(t.lodMetricValue))
    return "DIG";
  const i = 2 * BT(t, e);
  return i < 2 ? "OUT" : !t.header.children || i <= t.lodMetricValue ? "DRAW" : t.header.children ? "DIG" : "OUT";
}
function BT(t, e) {
  const { topDownViewport: i } = e, s = t.header.mbs[1], o = t.header.mbs[0], l = t.header.mbs[2], u = t.header.mbs[3], c = [...t.boundingVolume.center], x = i.unprojectPosition(i.cameraPosition);
  Ti.WGS84.cartographicToCartesian(x, Pm), o1.copy(Pm).subtract(c).normalize(), Ti.WGS84.eastNorthUpToFixedFrame(c, Bm), l1.copy(Bm).invert(), aa.copy(Pm).transform(l1);
  const w = Math.sqrt(aa[0] * aa[0] + aa[1] * aa[1]), C = w * w / aa[2];
  a1.copy([aa[0], aa[1], C]);
  const P = a1.transform(Bm).subtract(c).normalize(), Y = o1.cross(P).normalize().scale(u).add(c), Q = Ti.WGS84.cartesianToCartographic(Y), _e = i.project([o, s, l]), me = i.project(Q);
  return M5.copy(_e).subtract(me).magnitude();
}
function B5(t) {
  return {
    assetGltfUpAxis: t.asset && t.asset.gltfUpAxis || "Y"
  };
}
class c1 {
  constructor(e = 0) {
    O(this, "_map", /* @__PURE__ */ new Map());
    O(this, "_array");
    O(this, "_length");
    this._array = new Array(e), this._length = e;
  }
  /**
   * Gets or sets the length of the array.
   * If the set length is greater than the length of the internal array, the internal array is resized.
   *
   * @memberof ManagedArray.prototype
   * @type Number
   */
  get length() {
    return this._length;
  }
  set length(e) {
    this._length = e, e > this._array.length && (this._array.length = e);
  }
  /**
   * Gets the internal array.
   *
   * @memberof ManagedArray.prototype
   * @type Array
   * @readonly
   */
  get values() {
    return this._array;
  }
  /**
   * Gets the element at an index.
   *
   * @param {Number} index The index to get.
   */
  get(e) {
    return Ai(e < this._array.length), this._array[e];
  }
  /**
   * Sets the element at an index. Resizes the array if index is greater than the length of the array.
   *
   * @param {Number} index The index to set.
   * @param {*} element The element to set at index.
   */
  set(e, i) {
    Ai(e >= 0), e >= this.length && (this.length = e + 1), this._map.has(this._array[e]) && this._map.delete(this._array[e]), this._array[e] = i, this._map.set(i, e);
  }
  delete(e) {
    const i = this._map.get(e);
    i >= 0 && (this._array.splice(i, 1), this._map.delete(e), this.length--);
  }
  /**
   * Returns the last element in the array without modifying the array.
   *
   * @returns {*} The last element in the array.
   */
  peek() {
    return this._array[this._length - 1];
  }
  /**
   * Push an element into the array.
   *
   * @param {*} element The element to push.
   */
  push(e) {
    if (!this._map.has(e)) {
      const i = this.length++;
      this._array[i] = e, this._map.set(e, i);
    }
  }
  /**
   * Pop an element from the array.
   *
   * @returns {*} The last element in the array.
   */
  pop() {
    const e = this._array[--this.length];
    return this._map.delete(e), e;
  }
  /**
   * Resize the internal array if length > _array.length.
   *
   * @param {Number} length The length.
   */
  reserve(e) {
    Ai(e >= 0), e > this._array.length && (this._array.length = e);
  }
  /**
   * Resize the array.
   *
   * @param {Number} length The length.
   */
  resize(e) {
    Ai(e >= 0), this.length = e;
  }
  /**
   * Trim the internal array to the specified length. Defaults to the current length.
   *
   * @param {Number} [length] The length.
   */
  trim(e) {
    e == null && (e = this.length), this._array.length = e;
  }
  reset() {
    this._array = [], this._map = /* @__PURE__ */ new Map(), this._length = 0;
  }
  find(e) {
    return this._map.has(e);
  }
}
const D5 = {
  loadSiblings: !1,
  skipLevelOfDetail: !1,
  updateTransforms: !0,
  onTraversalEnd: () => {
  },
  viewportTraversersMap: {},
  basePath: ""
};
class Cp {
  // TODO nested props
  constructor(e) {
    O(this, "options");
    // fulfill in traverse call
    O(this, "root", null);
    // tiles should be rendered
    O(this, "selectedTiles", {});
    // tiles should be loaded from server
    O(this, "requestedTiles", {});
    // tiles does not have render content
    O(this, "emptyTiles", {});
    O(this, "lastUpdate", (/* @__PURE__ */ new Date()).getTime());
    O(this, "updateDebounceTime", 1e3);
    /** temporary storage to hold the traversed tiles during a traversal */
    O(this, "_traversalStack", new c1());
    O(this, "_emptyTraversalStack", new c1());
    /** set in every traverse cycle */
    O(this, "_frameNumber", null);
    this.options = { ...D5, ...e };
  }
  // RESULT
  traversalFinished(e) {
    return !0;
  }
  // tiles should be visible
  traverse(e, i, s) {
    this.root = e, this.options = { ...this.options, ...s }, this.reset(), this.updateTile(e, i), this._frameNumber = i.frameNumber, this.executeTraversal(e, i);
  }
  reset() {
    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();
  }
  /**
   * Execute traverse
   * Depth-first traversal that traverses all visible tiles and marks tiles for selection.
   * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.
   * This is the traditional replacement refinement approach and is called the base traversal.
   * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,
   * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree
   * and rendering children and parent tiles simultaneously.
   */
  /* eslint-disable-next-line complexity, max-statements */
  executeTraversal(e, i) {
    const s = this._traversalStack;
    for (e._selectionDepth = 1, s.push(e); s.length > 0; ) {
      const l = s.pop();
      let u = !1;
      this.canTraverse(l, i) && (this.updateChildTiles(l, i), u = this.updateAndPushChildren(l, i, s, l.hasRenderContent ? l._selectionDepth + 1 : l._selectionDepth));
      const c = l.parent, x = !!(!c || c._shouldRefine), w = !u;
      l.hasRenderContent ? l.refine === vn.ADD ? (this.loadTile(l, i), this.selectTile(l, i)) : l.refine === vn.REPLACE && (this.loadTile(l, i), w && this.selectTile(l, i)) : (this.emptyTiles[l.id] = l, this.loadTile(l, i), w && this.selectTile(l, i)), this.touchTile(l, i), l._shouldRefine = u && x;
    }
    const o = (/* @__PURE__ */ new Date()).getTime();
    (this.traversalFinished(i) || o - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = o, this.options.onTraversalEnd(i));
  }
  updateChildTiles(e, i) {
    const s = e.children;
    for (const o of s)
      this.updateTile(o, i);
  }
  /* eslint-disable complexity, max-statements */
  updateAndPushChildren(e, i, s, o) {
    const { loadSiblings: l, skipLevelOfDetail: u } = this.options, c = e.children;
    c.sort(this.compareDistanceToCamera.bind(this));
    const x = e.refine === vn.REPLACE && e.hasRenderContent && !u;
    let w = !1, C = !0;
    for (const M of c)
      if (M._selectionDepth = o, M.isVisibleAndInRequestVolume ? (s.find(M) && s.delete(M), s.push(M), w = !0) : (x || l) && (this.loadTile(M, i), this.touchTile(M, i)), x) {
        let P;
        if (M._inRequestVolume ? M.hasRenderContent ? P = M.contentAvailable : P = this.executeEmptyTraversal(M, i) : P = !1, C = C && P, !C)
          return !1;
      }
    return w || (C = !1), C;
  }
  /* eslint-enable complexity, max-statements */
  updateTile(e, i) {
    this.updateTileVisibility(e, i);
  }
  // tile to render in the browser
  selectTile(e, i) {
    this.shouldSelectTile(e) && (e._selectedFrame = i.frameNumber, this.selectedTiles[e.id] = e);
  }
  // tile to load from server
  loadTile(e, i) {
    this.shouldLoadTile(e) && (e._requestedFrame = i.frameNumber, e._priority = e._getPriority(), this.requestedTiles[e.id] = e);
  }
  // cache tile
  touchTile(e, i) {
    e.tileset._cache.touch(e), e._touchedFrame = i.frameNumber;
  }
  // tile should be visible
  // tile should have children
  // tile LoD (level of detail) is not sufficient under current viewport
  canTraverse(e, i) {
    return e.hasChildren ? e.hasTilesetContent ? !e.contentExpired : this.shouldRefine(e, i) : !1;
  }
  shouldLoadTile(e) {
    return e.hasUnloadedContent || e.contentExpired;
  }
  shouldSelectTile(e) {
    return e.contentAvailable && !this.options.skipLevelOfDetail;
  }
  /** Decide if tile LoD (level of detail) is not sufficient under current viewport */
  shouldRefine(e, i, s = !1) {
    let o = e._screenSpaceError;
    return s && (o = e.getScreenSpaceError(i, !0)), o > e.tileset.memoryAdjustedScreenSpaceError;
  }
  updateTileVisibility(e, i) {
    const s = [];
    if (this.options.viewportTraversersMap)
      for (const o in this.options.viewportTraversersMap)
        this.options.viewportTraversersMap[o] === i.viewport.id && s.push(o);
    else
      s.push(i.viewport.id);
    e.updateVisibility(i, s);
  }
  // UTILITIES
  compareDistanceToCamera(e, i) {
    return e._distanceToCamera - i._distanceToCamera;
  }
  anyChildrenVisible(e, i) {
    let s = !1;
    for (const o of e.children)
      o.updateVisibility(i), s = s || o.isVisibleAndInRequestVolume;
    return s;
  }
  // Depth-first traversal that checks if all nearest descendants with content are loaded.
  // Ignores visibility.
  executeEmptyTraversal(e, i) {
    let s = !0;
    const o = this._emptyTraversalStack;
    for (o.push(e); o.length > 0; ) {
      const l = o.pop(), u = !l.hasRenderContent && this.canTraverse(l, i), c = !l.hasRenderContent && l.children.length === 0;
      if (!u && !l.contentAvailable && !c && (s = !1), this.updateTile(l, i), l.isVisibleAndInRequestVolume || (this.loadTile(l, i), this.touchTile(l, i)), u) {
        const x = l.children;
        for (const w of x)
          o.push(w);
      }
    }
    return s;
  }
}
const h1 = new Se();
function O5(t) {
  return t != null;
}
class Ng {
  // TODO i3s specific, needs to remove
  /**
   * @constructs
   * Create a Tile3D instance
   * @param tileset - Tileset3D instance
   * @param header - tile header - JSON loaded from a dataset
   * @param parentHeader - parent Tile3D instance
   * @param extendedId - optional ID to separate copies of a tile for different viewports.
   *    const extendedId = `${tile.id}-${frameState.viewport.id}`;
   */
  // eslint-disable-next-line max-statements
  constructor(e, i, s, o = "") {
    O(this, "tileset");
    O(this, "header");
    O(this, "id");
    O(this, "url");
    O(this, "parent");
    /* Specifies the type of refine that is used when traversing this tile for rendering. */
    O(this, "refine");
    O(this, "type");
    O(this, "contentUrl");
    /** Different refinement algorithms used by I3S and 3D tiles */
    O(this, "lodMetricType", "geometricError");
    /** The error, in meters, introduced if this tile is rendered and its children are not. */
    O(this, "lodMetricValue", 0);
    /** @todo math.gl is not exporting BoundingVolume base type? */
    O(this, "boundingVolume", null);
    /**
     * The tile's content.  This represents the actual tile's payload,
     * not the content's metadata in the tileset JSON file.
     */
    O(this, "content", null);
    O(this, "contentState", Nr.UNLOADED);
    O(this, "gpuMemoryUsageInBytes", 0);
    /** The tile's children - an array of Tile3D objects. */
    O(this, "children", []);
    O(this, "depth", 0);
    O(this, "viewportIds", []);
    O(this, "transform", new Xt());
    O(this, "extensions", null);
    /** TODO Cesium 3d tiles specific */
    O(this, "implicitTiling", null);
    /** Container to store application specific data */
    O(this, "userData", {});
    O(this, "computedTransform");
    O(this, "hasEmptyContent", !1);
    O(this, "hasTilesetContent", !1);
    O(this, "traverser", new Cp({}));
    /** Used by TilesetCache */
    O(this, "_cacheNode", null);
    O(this, "_frameNumber", null);
    // TODO Cesium 3d tiles specific
    O(this, "_expireDate", null);
    O(this, "_expiredContent", null);
    O(this, "_boundingBox");
    /** updated every frame for tree traversal and rendering optimizations: */
    O(this, "_distanceToCamera", 0);
    O(this, "_screenSpaceError", 0);
    O(this, "_visibilityPlaneMask");
    O(this, "_visible");
    O(this, "_contentBoundingVolume");
    O(this, "_viewerRequestVolume");
    O(this, "_initialTransform", new Xt());
    // Used by traverser, cannot be marked private
    O(this, "_priority", 0);
    O(this, "_selectedFrame", 0);
    O(this, "_requestedFrame", 0);
    O(this, "_selectionDepth", 0);
    O(this, "_touchedFrame", 0);
    O(this, "_centerZDepth", 0);
    O(this, "_shouldRefine", !1);
    O(this, "_stackLength", 0);
    O(this, "_visitedFrame", 0);
    O(this, "_inRequestVolume", !1);
    O(this, "_lodJudge", null);
    this.header = i, this.tileset = e, this.id = o || i.id, this.url = i.url, this.parent = s, this.refine = this._getRefine(i.refine), this.type = i.type, this.contentUrl = i.contentUrl, this._initializeLodMetric(i), this._initializeTransforms(i), this._initializeBoundingVolumes(i), this._initializeContent(i), this._initializeRenderingState(i), Object.seal(this);
  }
  destroy() {
    this.header = null;
  }
  isDestroyed() {
    return this.header === null;
  }
  get selected() {
    return this._selectedFrame === this.tileset._frameNumber;
  }
  get isVisible() {
    return this._visible;
  }
  get isVisibleAndInRequestVolume() {
    return this._visible && this._inRequestVolume;
  }
  /** Returns true if tile is not an empty tile and not an external tileset */
  get hasRenderContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent;
  }
  /** Returns true if tile has children */
  get hasChildren() {
    return this.children.length > 0 || this.header.children && this.header.children.length > 0;
  }
  /**
   * Determines if the tile's content is ready. This is automatically `true` for
   * tiles with empty content.
   */
  get contentReady() {
    return this.contentState === Nr.READY || this.hasEmptyContent;
  }
  /**
   * Determines if the tile has available content to render.  `true` if the tile's
   * content is ready or if it has expired content this renders while new content loads; otherwise,
   */
  get contentAvailable() {
    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
  }
  /** Returns true if tile has renderable content but it's unloaded */
  get hasUnloadedContent() {
    return this.hasRenderContent && this.contentUnloaded;
  }
  /**
   * Determines if the tile's content has not be requested. `true` if tile's
   * content has not be requested; otherwise, `false`.
   */
  get contentUnloaded() {
    return this.contentState === Nr.UNLOADED;
  }
  /**
   * Determines if the tile's content is expired. `true` if tile's
   * content is expired; otherwise, `false`.
   */
  get contentExpired() {
    return this.contentState === Nr.EXPIRED;
  }
  // Determines if the tile's content failed to load.  `true` if the tile's
  // content failed to load; otherwise, `false`.
  get contentFailed() {
    return this.contentState === Nr.FAILED;
  }
  /**
   * Distance from the tile's bounding volume center to the camera
   */
  get distanceToCamera() {
    return this._distanceToCamera;
  }
  /**
   * Screen space error for LOD selection
   */
  get screenSpaceError() {
    return this._screenSpaceError;
  }
  /**
   * Get bounding box in cartographic coordinates
   * @returns [min, max] each in [longitude, latitude, altitude]
   */
  get boundingBox() {
    return this._boundingBox || (this._boundingBox = w5(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;
  }
  /** Get the tile's screen space error. */
  getScreenSpaceError(e, i) {
    switch (this.tileset.type) {
      case vr.I3S:
        return BT(this, e);
      case vr.TILES3D:
        return R5(this, e, i);
      default:
        throw new Error("Unsupported tileset type");
    }
  }
  /**
   * Make tile unselected than means it won't be shown
   * but it can be still loaded in memory
   */
  unselect() {
    this._selectedFrame = 0;
  }
  /**
   * Memory usage of tile on GPU
   */
  _getGpuMemoryUsageInBytes() {
    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
  }
  /*
   * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.
   * Tiles are prioritized by screen space error.
   */
  // eslint-disable-next-line complexity
  _getPriority() {
    const e = this.tileset._traverser, { skipLevelOfDetail: i } = e.options, s = this.refine === vn.ADD || i;
    if (s && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === Nr.UNLOADED)
      return -1;
    const o = this.parent, u = o && (!s || this._screenSpaceError === 0 || o.hasTilesetContent) ? o._screenSpaceError : this._screenSpaceError, c = e.root ? e.root._screenSpaceError : 0;
    return Math.max(c - u, 0);
  }
  /**
   *  Requests the tile's content.
   * The request may not be made if the Request Scheduler can't prioritize it.
   */
  // eslint-disable-next-line max-statements, complexity
  async loadContent() {
    if (this.hasEmptyContent)
      return !1;
    if (this.content)
      return !0;
    this.contentExpired && (this._expireDate = null), this.contentState = Nr.LOADING;
    const i = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
    if (!i)
      return this.contentState = Nr.UNLOADED, !1;
    try {
      const s = this.tileset.getTileUrl(this.contentUrl), o = this.tileset.loader, l = {
        ...this.tileset.loadOptions,
        [o.id]: {
          // @ts-expect-error
          ...this.tileset.loadOptions[o.id],
          isTileset: this.type === "json",
          ...this._getLoaderSpecificOptions(o.id)
        }
      };
      return this.content = await pa(s, o, l), this.tileset.options.contentLoader && await this.tileset.options.contentLoader(this), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = Nr.READY, this._onContentLoaded(), !0;
    } catch (s) {
      throw this.contentState = Nr.FAILED, s;
    } finally {
      i.done();
    }
  }
  // Unloads the tile's content.
  unloadContent() {
    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = Nr.UNLOADED, !0;
  }
  /**
   * Update the tile's visibility
   * @param {Object} frameState - frame state for tile culling
   * @param {string[]} viewportIds - a list of viewport ids that show this tile
   * @return {void}
   */
  updateVisibility(e, i) {
    if (this._frameNumber === e.frameNumber)
      return;
    const s = this.parent, o = s ? s._visibilityPlaneMask : en.MASK_INDETERMINATE;
    if (this.tileset._traverser.options.updateTransforms) {
      const l = s ? s.computedTransform : this.tileset.modelMatrix;
      this._updateTransform(l);
    }
    this._distanceToCamera = this.distanceToTile(e), this._screenSpaceError = this.getScreenSpaceError(e, !1), this._visibilityPlaneMask = this.visibility(e, o), this._visible = this._visibilityPlaneMask !== en.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(e), this._frameNumber = e.frameNumber, this.viewportIds = i;
  }
  // Determines whether the tile's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.
  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.
  visibility(e, i) {
    const { cullingVolume: s } = e, { boundingVolume: o } = this;
    return s.computeVisibilityWithPlaneMask(o, i);
  }
  // Assuming the tile's bounding volume intersects the culling volume, determines
  // whether the tile's content's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.
  contentVisibility() {
    return !0;
  }
  /**
   * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.
   * @param frameState The frame state.
   * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.
   */
  distanceToTile(e) {
    const i = this.boundingVolume;
    return Math.sqrt(Math.max(i.distanceSquaredTo(e.camera.position), 0));
  }
  /**
   * Computes the tile's camera-space z-depth.
   * @param frameState The frame state.
   * @returns The distance, in meters.
   */
  cameraSpaceZDepth({ camera: e }) {
    const i = this.boundingVolume;
    return h1.subVectors(i.center, e.position), e.direction.dot(h1);
  }
  /**
   * Checks if the camera is inside the viewer request volume.
   * @param {FrameState} frameState The frame state.
   * @returns {Boolean} Whether the camera is inside the volume.
   */
  insideViewerRequestVolume(e) {
    const i = this._viewerRequestVolume;
    return !i || i.distanceSquaredTo(e.camera.position) <= 0;
  }
  // TODO Cesium specific
  // Update whether the tile has expired.
  updateExpiration() {
    if (O5(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
      const e = Date.now();
      Date.lessThan(this._expireDate, e) && (this.contentState = Nr.EXPIRED, this._expiredContent = this.content);
    }
  }
  get extras() {
    return this.header.extras;
  }
  // INTERNAL METHODS
  _initializeLodMetric(e) {
    "lodMetricType" in e ? this.lodMetricType = e.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn("3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType")), "lodMetricValue" in e ? this.lodMetricValue = e.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue"));
  }
  _initializeTransforms(e) {
    this.transform = e.transform ? new Xt(e.transform) : new Xt();
    const i = this.parent, s = this.tileset, o = i && i.computedTransform ? i.computedTransform.clone() : s.modelMatrix.clone();
    this.computedTransform = new Xt(o).multiplyRight(this.transform);
    const l = i && i._initialTransform ? i._initialTransform.clone() : new Xt();
    this._initialTransform = new Xt(l).multiplyRight(this.transform);
  }
  _initializeBoundingVolumes(e) {
    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(e);
  }
  _initializeContent(e) {
    this.content = { _tileset: this.tileset, _tile: this }, this.hasEmptyContent = !0, this.contentState = Nr.UNLOADED, this.hasTilesetContent = !1, e.contentUrl && (this.content = null, this.hasEmptyContent = !1);
  }
  // TODO - remove anything not related to basic visibility detection
  _initializeRenderingState(e) {
    this.depth = e.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = en.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;
  }
  _getRefine(e) {
    return e || this.parent && this.parent.refine || vn.REPLACE;
  }
  _isTileset() {
    return this.contentUrl.indexOf(".json") !== -1;
  }
  _onContentLoaded() {
    switch (this.content && this.content.type) {
      case "vctr":
      case "geom":
        this.tileset._traverser.disableSkipLevelOfDetail = !0;
        break;
    }
    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
  }
  _updateBoundingVolume(e) {
    this.boundingVolume = Mm(e.boundingVolume, this.computedTransform, this.boundingVolume);
    const i = e.content;
    i && (i.boundingVolume && (this._contentBoundingVolume = Mm(i.boundingVolume, this.computedTransform, this._contentBoundingVolume)), e.viewerRequestVolume && (this._viewerRequestVolume = Mm(e.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));
  }
  // Update the tile's transform. The transform is applied to the tile's bounding volumes.
  _updateTransform(e = new Xt()) {
    const i = e.clone().multiplyRight(this.transform);
    i.equals(this.computedTransform) || (this.computedTransform = i, this._updateBoundingVolume(this.header));
  }
  // Get options which are applicable only for the particular loader
  _getLoaderSpecificOptions(e) {
    switch (e) {
      case "i3s":
        return {
          ...this.tileset.options.i3s,
          _tileOptions: {
            attributeUrls: this.header.attributeUrls,
            textureUrl: this.header.textureUrl,
            textureFormat: this.header.textureFormat,
            textureLoaderOptions: this.header.textureLoaderOptions,
            materialDefinition: this.header.materialDefinition,
            isDracoGeometry: this.header.isDracoGeometry,
            mbs: this.header.mbs
          },
          _tilesetOptions: {
            store: this.tileset.tileset.store,
            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
            fields: this.tileset.tileset.fields
          },
          isTileHeader: !1
        };
      case "3d-tiles":
      case "cesium-ion":
      default:
        return B5(this.tileset.tileset);
    }
  }
}
class F5 extends Cp {
  compareDistanceToCamera(e, i) {
    return i._distanceToCamera === 0 && e._distanceToCamera === 0 ? i._centerZDepth - e._centerZDepth : i._distanceToCamera - e._distanceToCamera;
  }
  updateTileVisibility(e, i) {
    if (super.updateTileVisibility(e, i), !e.isVisibleAndInRequestVolume)
      return;
    const s = e.children.length > 0;
    if (e.hasTilesetContent && s) {
      const u = e.children[0];
      this.updateTileVisibility(u, i), e._visible = u._visible;
      return;
    }
    if (this.meetsScreenSpaceErrorEarly(e, i)) {
      e._visible = !1;
      return;
    }
    const o = e.refine === vn.REPLACE, l = e._optimChildrenWithinParent === b5.USE_OPTIMIZATION;
    if (o && l && s && !this.anyChildrenVisible(e, i)) {
      e._visible = !1;
      return;
    }
  }
  meetsScreenSpaceErrorEarly(e, i) {
    const { parent: s } = e;
    return !s || s.hasTilesetContent || s.refine !== vn.ADD ? !1 : !this.shouldRefine(e, i, !0);
  }
}
class k5 {
  constructor() {
    O(this, "frameNumberMap", /* @__PURE__ */ new Map());
  }
  /**
   * Register a new pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  register(e, i) {
    const s = this.frameNumberMap.get(e) || /* @__PURE__ */ new Map(), o = s.get(i) || 0;
    s.set(i, o + 1), this.frameNumberMap.set(e, s);
  }
  /**
   * Deregister a pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  deregister(e, i) {
    const s = this.frameNumberMap.get(e);
    if (!s)
      return;
    const o = s.get(i) || 1;
    s.set(i, o - 1);
  }
  /**
   * Check is there are no pending tile headers registered for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  isZero(e, i) {
    var o;
    return (((o = this.frameNumberMap.get(e)) == null ? void 0 : o.get(i)) || 0) === 0;
  }
}
const Dm = {
  REQUESTED: "REQUESTED",
  COMPLETED: "COMPLETED",
  ERROR: "ERROR"
};
class N5 {
  constructor() {
    O(this, "_statusMap");
    O(this, "pendingTilesRegister", new k5());
    this._statusMap = {};
  }
  /**
   * Add request to map
   * @param request - node metadata request
   * @param key - unique key
   * @param callback - callback after request completed
   * @param frameState - frameState data
   */
  add(e, i, s, o) {
    if (!this._statusMap[i]) {
      const { frameNumber: l, viewport: { id: u } } = o;
      this._statusMap[i] = { request: e, callback: s, key: i, frameState: o, status: Dm.REQUESTED }, this.pendingTilesRegister.register(u, l), e().then((c) => {
        this._statusMap[i].status = Dm.COMPLETED;
        const { frameNumber: x, viewport: { id: w } } = this._statusMap[i].frameState;
        this.pendingTilesRegister.deregister(w, x), this._statusMap[i].callback(c, o);
      }).catch((c) => {
        this._statusMap[i].status = Dm.ERROR;
        const { frameNumber: x, viewport: { id: w } } = this._statusMap[i].frameState;
        this.pendingTilesRegister.deregister(w, x), s(c);
      });
    }
  }
  /**
   * Update request if it is still actual for the new frameState
   * @param key - unique key
   * @param frameState - frameState data
   */
  update(e, i) {
    if (this._statusMap[e]) {
      const { frameNumber: s, viewport: { id: o } } = this._statusMap[e].frameState;
      this.pendingTilesRegister.deregister(o, s);
      const { frameNumber: l, viewport: { id: u } } = i;
      this.pendingTilesRegister.register(u, l), this._statusMap[e].frameState = i;
    }
  }
  /**
   * Find request in the map
   * @param key - unique key
   * @returns
   */
  find(e) {
    return this._statusMap[e];
  }
  /**
   * Check it there are pending tile headers for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  hasPendingTiles(e, i) {
    return !this.pendingTilesRegister.isZero(e, i);
  }
}
class L5 extends Cp {
  constructor(i) {
    super(i);
    O(this, "_tileManager");
    this._tileManager = new N5();
  }
  /**
   * Check if there are no penging tile header requests,
   * that means the traversal is finished and we can call
   * following-up callbacks.
   */
  traversalFinished(i) {
    return !this._tileManager.hasPendingTiles(i.viewport.id, this._frameNumber || 0);
  }
  shouldRefine(i, s) {
    return i._lodJudge = P5(i, s), i._lodJudge === "DIG";
  }
  updateChildTiles(i, s) {
    const o = i.header.children || [], l = i.children, u = i.tileset;
    for (const c of o) {
      const x = `${c.id}-${s.viewport.id}`, w = l && l.find((C) => C.id === x);
      if (w)
        w && this.updateTile(w, s);
      else {
        let C = () => this._loadTile(c.id, u);
        this._tileManager.find(x) ? this._tileManager.update(x, s) : (u.tileset.nodePages && (C = () => u.tileset.nodePagesTile.formTileFromNodePages(c.id)), this._tileManager.add(C, x, (P) => this._onTileLoad(P, i, x), s));
      }
    }
    return !1;
  }
  async _loadTile(i, s) {
    const { loader: o } = s, l = s.getTileUrl(`${s.url}/nodes/${i}`), u = {
      ...s.loadOptions,
      i3s: {
        ...s.loadOptions.i3s,
        isTileHeader: !0
      }
    };
    return await pa(l, o, u);
  }
  /**
   * The callback to init Tile3D instance after loading the tile JSON
   * @param {Object} header - the tile JSON from a dataset
   * @param {Tile3D} tile - the parent Tile3D instance
   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.
   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;
   * @return {void}
   */
  _onTileLoad(i, s, o) {
    const l = new Ng(s.tileset, i, s, o);
    s.children.push(l);
    const u = this._tileManager.find(l.id).frameState;
    this.updateTile(l, u), this._frameNumber === u.frameNumber && (this.traversalFinished(u) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(l, u);
  }
}
const U5 = {
  description: "",
  ellipsoid: Ti.WGS84,
  modelMatrix: new Xt(),
  throttleRequests: !0,
  maxRequests: 64,
  /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */
  maximumMemoryUsage: 32,
  memoryCacheOverflow: 1,
  maximumTilesSelected: 0,
  debounceTime: 0,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  },
  onTraversalComplete: (t) => t,
  contentLoader: void 0,
  viewDistanceScale: 1,
  maximumScreenSpaceError: 8,
  memoryAdjustedScreenSpaceError: !1,
  loadTiles: !0,
  updateTransforms: !0,
  viewportTraversersMap: null,
  loadOptions: { fetch: {} },
  attributions: [],
  basePath: "",
  i3s: {}
}, _f = "Tiles In Tileset(s)", Om = "Tiles In Memory", u1 = "Tiles In View", d1 = "Tiles To Render", f1 = "Tiles Loaded", Fm = "Tiles Loading", p1 = "Tiles Unloaded", _1 = "Failed Tile Loads", m1 = "Points/Vertices", km = "Tile Memory Use", g1 = "Maximum Screen Space Error";
class z5 {
  /**
   * Create a new Tileset3D
   * @param json
   * @param props
   */
  // eslint-disable-next-line max-statements
  constructor(e, i) {
    // props: Tileset3DProps;
    O(this, "options");
    O(this, "loadOptions");
    O(this, "type");
    O(this, "tileset");
    O(this, "loader");
    O(this, "url");
    O(this, "basePath");
    O(this, "modelMatrix");
    O(this, "ellipsoid");
    O(this, "lodMetricType");
    O(this, "lodMetricValue");
    O(this, "refine");
    O(this, "root", null);
    O(this, "roots", {});
    /** @todo any->unknown */
    O(this, "asset", {});
    // Metadata for the entire tileset
    O(this, "description", "");
    O(this, "properties");
    O(this, "extras", null);
    O(this, "attributions", {});
    O(this, "credits", {});
    O(this, "stats");
    /** flags that contain information about data types in nested tiles */
    O(this, "contentFormats", { draco: !1, meshopt: !1, dds: !1, ktx2: !1 });
    // view props
    O(this, "cartographicCenter", null);
    O(this, "cartesianCenter", null);
    O(this, "zoom", 1);
    O(this, "boundingVolume", null);
    /** Updated based on the camera position and direction */
    O(this, "dynamicScreenSpaceErrorComputedDensity", 0);
    // METRICS
    /**
     * The maximum amount of GPU memory (in MB) that may be used to cache tiles
     * Tiles not in view are unloaded to enforce private
     */
    O(this, "maximumMemoryUsage", 32);
    /** The total amount of GPU memory in bytes used by the tileset. */
    O(this, "gpuMemoryUsageInBytes", 0);
    /**
     * If loading the level of detail required by maximumScreenSpaceError
     * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement
     * will instead use this (larger) adjusted screen space error to achieve the
     * best possible visual quality within the available memory.
     */
    O(this, "memoryAdjustedScreenSpaceError", 0);
    O(this, "_cacheBytes", 0);
    O(this, "_cacheOverflowBytes", 0);
    /** Update tracker. increase in each update cycle. */
    O(this, "_frameNumber", 0);
    O(this, "_queryParams", {});
    O(this, "_extensionsUsed", []);
    O(this, "_tiles", {});
    /** counter for tracking tiles requests */
    O(this, "_pendingCount", 0);
    /** Hold traversal results */
    O(this, "selectedTiles", []);
    // TRAVERSAL
    O(this, "traverseCounter", 0);
    O(this, "geometricError", 0);
    O(this, "lastUpdatedVieports", null);
    O(this, "_requestedTiles", []);
    O(this, "_emptyTiles", []);
    O(this, "frameStateData", {});
    O(this, "_traverser");
    O(this, "_cache", new c5());
    O(this, "_requestScheduler");
    // Promise tracking
    O(this, "updatePromise", null);
    O(this, "tilesetInitializationPromise");
    this.options = { ...U5, ...i }, this.tileset = e, this.loader = e.loader, this.type = e.type, this.url = e.url, this.basePath = e.basePath || Xg(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = e.lodMetricType, this.lodMetricValue = e.lodMetricValue, this.refine = e.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new t2({
      throttleRequests: this.options.throttleRequests,
      maxRequests: this.options.maxRequests
    }), this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError, this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024, this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024, this.stats = new jc({ id: this.url }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(e);
  }
  /** Release resources */
  destroy() {
    this._destroy();
  }
  /** Is the tileset loaded (update needs to have been called at least once) */
  isLoaded() {
    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
  }
  get tiles() {
    return Object.values(this._tiles);
  }
  get frameNumber() {
    return this._frameNumber;
  }
  get queryParams() {
    return new URLSearchParams(this._queryParams).toString();
  }
  setProps(e) {
    this.options = { ...this.options, ...e };
  }
  /** @deprecated */
  // setOptions(options: Tileset3DProps): void {
  //   this.options = {...this.options, ...options};
  // }
  /**
   * Return a loadable tile url for a specific tile subpath
   * @param tilePath a tile subpath
   */
  getTileUrl(e) {
    if (e.startsWith("data:"))
      return e;
    let s = e;
    return this.queryParams.length && (s = `${e}${e.includes("?") ? "&" : "?"}${this.queryParams}`), s;
  }
  // TODO CESIUM specific
  hasExtension(e) {
    return this._extensionsUsed.indexOf(e) > -1;
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports - list of viewports
   * @deprecated
   */
  update(e = null) {
    this.tilesetInitializationPromise.then(() => {
      !e && this.lastUpdatedVieports ? e = this.lastUpdatedVieports : this.lastUpdatedVieports = e, e && this.doUpdate(e);
    });
  }
  /**
   * Update visible tiles relying on a list of viewports.
   * Do it with debounce delay to prevent update spam
   * @param viewports viewports
   * @returns Promise of new frameNumber
   */
  async selectTiles(e = null) {
    return await this.tilesetInitializationPromise, e && (this.lastUpdatedVieports = e), this.updatePromise || (this.updatePromise = new Promise((i) => {
      setTimeout(() => {
        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), i(this._frameNumber), this.updatePromise = null;
      }, this.options.debounceTime);
    })), this.updatePromise;
  }
  adjustScreenSpaceError() {
    this.gpuMemoryUsageInBytes < this._cacheBytes ? this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError) : this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes && (this.memoryAdjustedScreenSpaceError *= 1.02);
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports viewports
   */
  // eslint-disable-next-line max-statements, complexity
  doUpdate(e) {
    if ("loadTiles" in this.options && !this.options.loadTiles || this.traverseCounter > 0)
      return;
    const i = e instanceof Array ? e : [e];
    this._cache.reset(), this._frameNumber++, this.traverseCounter = i.length;
    const s = [];
    for (const o of i) {
      const l = o.id;
      this._needTraverse(l) ? s.push(l) : this.traverseCounter--;
    }
    for (const o of i) {
      const l = o.id;
      if (this.roots[l] || (this.roots[l] = this._initializeTileHeaders(this.tileset, null)), !s.includes(l))
        continue;
      const u = u5(o, this._frameNumber);
      this._traverser.traverse(this.roots[l], u, this.options);
    }
  }
  /**
   * Check if traversal is needed for particular viewport
   * @param {string} viewportId - id of a viewport
   * @return {boolean}
   */
  _needTraverse(e) {
    let i = e;
    return this.options.viewportTraversersMap && (i = this.options.viewportTraversersMap[e]), i === e;
  }
  /**
   * The callback to post-process tiles after traversal procedure
   * @param frameState - frame state for tile culling
   */
  _onTraversalEnd(e) {
    const i = e.viewport.id;
    this.frameStateData[i] || (this.frameStateData[i] = { selectedTiles: [], _requestedTiles: [], _emptyTiles: [] });
    const s = this.frameStateData[i], o = Object.values(this._traverser.selectedTiles), [l, u] = d5(o, e, this.options.maximumTilesSelected);
    s.selectedTiles = l;
    for (const c of u)
      c.unselect();
    s._requestedTiles = Object.values(this._traverser.requestedTiles), s._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();
  }
  /**
   * Update tiles relying on data from all traversers
   */
  _updateTiles() {
    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];
    for (const e in this.frameStateData) {
      const i = this.frameStateData[e];
      this.selectedTiles = this.selectedTiles.concat(i.selectedTiles), this._requestedTiles = this._requestedTiles.concat(i._requestedTiles), this._emptyTiles = this._emptyTiles.concat(i._emptyTiles);
    }
    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
    for (const e of this.selectedTiles)
      this._tiles[e.id] = e;
    this._loadTiles(), this._unloadTiles(), this._updateStats();
  }
  _tilesChanged(e, i) {
    if (e.length !== i.length)
      return !0;
    const s = new Set(e.map((u) => u.id)), o = new Set(i.map((u) => u.id));
    let l = e.filter((u) => !o.has(u.id)).length > 0;
    return l = l || i.filter((u) => !s.has(u.id)).length > 0, l;
  }
  _loadTiles() {
    for (const e of this._requestedTiles)
      e.contentUnloaded && this._loadTile(e);
  }
  _unloadTiles() {
    this._cache.unloadTiles(this, (e, i) => e._unloadTile(i));
  }
  _updateStats() {
    let e = 0, i = 0;
    for (const s of this.selectedTiles)
      s.contentAvailable && s.content && (e++, s.content.pointCount ? i += s.content.pointCount : i += s.content.vertexCount);
    this.stats.get(u1).count = this.selectedTiles.length, this.stats.get(d1).count = e, this.stats.get(m1).count = i, this.stats.get(g1).count = this.memoryAdjustedScreenSpaceError;
  }
  async _initializeTileSet(e) {
    this.type === vr.I3S && (this.calculateViewPropsI3S(), e.root = await e.root), this.root = this._initializeTileHeaders(e, null), this.type === vr.TILES3D && (this._initializeTiles3DTileset(e), this.calculateViewPropsTiles3D()), this.type === vr.I3S && this._initializeI3STileset();
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset
   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props
   * @returns
   */
  calculateViewPropsI3S() {
    var s;
    const e = this.tileset.fullExtent;
    if (e) {
      const { xmin: o, xmax: l, ymin: u, ymax: c, zmin: x, zmax: w } = e;
      this.cartographicCenter = new Se(o + (l - o) / 2, u + (c - u) / 2, x + (w - x) / 2), this.cartesianCenter = new Se(), Ti.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = CT(e, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    const i = (s = this.tileset.store) == null ? void 0 : s.extent;
    if (i) {
      const [o, l, u, c] = i;
      this.cartographicCenter = new Se(o + (u - o) / 2, l + (c - l) / 2, 0), this.cartesianCenter = new Se(), Ti.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = g5(i, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    console.warn("Extent is not defined in the tileset header"), this.cartographicCenter = new Se(), this.zoom = 1;
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset.
   * For 3DTiles the root tile data is used to calculate view props.
   * @returns
   */
  calculateViewPropsTiles3D() {
    const e = this.root, { center: i } = e.boundingVolume;
    if (!i) {
      console.warn("center was not pre-calculated for the root tile"), this.cartographicCenter = new Se(), this.zoom = 1;
      return;
    }
    i[0] !== 0 || i[1] !== 0 || i[2] !== 0 ? (this.cartographicCenter = new Se(), Ti.WGS84.cartesianToCartographic(i, this.cartographicCenter)) : this.cartographicCenter = new Se(0, 0, -Ti.WGS84.radii[0]), this.cartesianCenter = i, this.zoom = m5(e.boundingVolume, this.cartographicCenter);
  }
  _initializeStats() {
    this.stats.get(_f), this.stats.get(Fm), this.stats.get(Om), this.stats.get(u1), this.stats.get(d1), this.stats.get(f1), this.stats.get(p1), this.stats.get(_1), this.stats.get(m1), this.stats.get(km, "memory"), this.stats.get(g1);
  }
  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.
  // eslint-disable-next-line max-statements
  _initializeTileHeaders(e, i) {
    var o;
    const s = new Ng(this, e.root, i);
    if (i && (i.children.push(s), s.depth = i.depth + 1), this.type === vr.TILES3D) {
      const l = [];
      for (l.push(s); l.length > 0; ) {
        const u = l.pop();
        this.stats.get(_f).incrementCount();
        const c = u.header.children || [];
        for (const x of c) {
          const w = new Ng(this, x, u);
          if ((o = w.contentUrl) != null && o.includes("?session=")) {
            const M = new URL(w.contentUrl).searchParams.get("session");
            M && (this._queryParams.session = M);
          }
          u.children.push(w), w.depth = u.depth + 1, l.push(w);
        }
      }
    }
    return s;
  }
  _initializeTraverser() {
    let e;
    switch (this.type) {
      case vr.TILES3D:
        e = F5;
        break;
      case vr.I3S:
        e = L5;
        break;
      default:
        e = Cp;
    }
    return new e({
      basePath: this.basePath,
      onTraversalEnd: this._onTraversalEnd.bind(this)
    });
  }
  _destroyTileHeaders(e) {
    this._destroySubtree(e);
  }
  async _loadTile(e) {
    let i;
    try {
      this._onStartTileLoading(), i = await e.loadContent();
    } catch (s) {
      this._onTileLoadError(e, s instanceof Error ? s : new Error("load failed"));
    } finally {
      this._onEndTileLoading(), this._onTileLoad(e, i);
    }
  }
  _onTileLoadError(e, i) {
    this.stats.get(_1).incrementCount();
    const s = i.message || i.toString(), o = e.url;
    console.error(`A 3D tile failed to load: ${e.url} ${s}`), this.options.onTileError(e, s, o);
  }
  _onTileLoad(e, i) {
    var s, o;
    if (i) {
      if (this.type === vr.I3S) {
        const l = ((o = (s = this.tileset) == null ? void 0 : s.nodePagesTile) == null ? void 0 : o.nodesInNodePages) || 0;
        this.stats.get(_f).reset(), this.stats.get(_f).addCount(l);
      }
      e && e.content && h5(e, e.content), this.updateContentTypes(e), this._addTileToCache(e), this.options.onTileLoad(e);
    }
  }
  /**
   * Update information about data types in nested tiles
   * @param tile instance of a nested Tile3D
   */
  updateContentTypes(e) {
    var i;
    if (this.type === vr.I3S)
      switch (e.header.isDracoGeometry && (this.contentFormats.draco = !0), e.header.textureFormat) {
        case "dds":
          this.contentFormats.dds = !0;
          break;
        case "ktx2":
          this.contentFormats.ktx2 = !0;
          break;
      }
    else if (this.type === vr.TILES3D) {
      const { extensionsRemoved: s = [] } = ((i = e.content) == null ? void 0 : i.gltf) || {};
      s.includes("KHR_draco_mesh_compression") && (this.contentFormats.draco = !0), s.includes("EXT_meshopt_compression") && (this.contentFormats.meshopt = !0), s.includes("KHR_texture_basisu") && (this.contentFormats.ktx2 = !0);
    }
  }
  _onStartTileLoading() {
    this._pendingCount++, this.stats.get(Fm).incrementCount();
  }
  _onEndTileLoading() {
    this._pendingCount--, this.stats.get(Fm).decrementCount();
  }
  _addTileToCache(e) {
    this._cache.add(this, e, (i) => i._updateCacheStats(e));
  }
  _updateCacheStats(e) {
    this.stats.get(f1).incrementCount(), this.stats.get(Om).incrementCount(), this.gpuMemoryUsageInBytes += e.gpuMemoryUsageInBytes || 0, this.stats.get(km).count = this.gpuMemoryUsageInBytes, this.options.memoryAdjustedScreenSpaceError && this.adjustScreenSpaceError();
  }
  _unloadTile(e) {
    this.gpuMemoryUsageInBytes -= e.gpuMemoryUsageInBytes || 0, this.stats.get(Om).decrementCount(), this.stats.get(p1).incrementCount(), this.stats.get(km).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(e), e.unloadContent();
  }
  // Traverse the tree and destroy all tiles
  _destroy() {
    const e = [];
    for (this.root && e.push(this.root); e.length > 0; ) {
      const i = e.pop();
      for (const s of i.children)
        e.push(s);
      this._destroyTile(i);
    }
    this.root = null;
  }
  // Traverse the tree and destroy all sub tiles
  _destroySubtree(e) {
    const i = e, s = [];
    for (s.push(i); s.length > 0; ) {
      e = s.pop();
      for (const o of e.children)
        s.push(o);
      e !== i && this._destroyTile(e);
    }
    i.children = [];
  }
  _destroyTile(e) {
    this._cache.unloadTile(this, e), this._unloadTile(e), e.destroy();
  }
  _initializeTiles3DTileset(e) {
    if (e.queryString) {
      const i = new URLSearchParams(e.queryString), s = Object.fromEntries(i.entries());
      this._queryParams = { ...this._queryParams, ...s };
    }
    if (this.asset = e.asset, !this.asset)
      throw new Error("Tileset must have an asset property.");
    if (this.asset.version !== "0.0" && this.asset.version !== "1.0" && this.asset.version !== "1.1")
      throw new Error("The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.");
    "tilesetVersion" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {
      attributions: this.options.attributions || []
    }, this.description = this.options.description || "", this.properties = e.properties, this.geometricError = e.geometricError, this._extensionsUsed = e.extensionsUsed || [], this.extras = e.extras;
  }
  _initializeI3STileset() {
    this.loadOptions.i3s && "token" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);
  }
}
const DT = "4.3.1", su = {
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  GEOMETRY: "geom",
  VECTOR: "vect",
  GLTF: "glTF"
};
function OT(t, e, i) {
  Ai(t instanceof ArrayBuffer);
  const s = new TextDecoder("utf8"), o = new Uint8Array(t, e, i);
  return s.decode(o);
}
function V5(t, e = 0) {
  const i = new DataView(t);
  return `${String.fromCharCode(i.getUint8(e + 0))}${String.fromCharCode(i.getUint8(e + 1))}${String.fromCharCode(i.getUint8(e + 2))}${String.fromCharCode(i.getUint8(e + 3))}`;
}
const H5 = {
  POINTS: 0,
  // Points. single points.
  LINES: 1,
  // Lines. Each vertex connects to the one after it.
  LINE_LOOP: 2,
  // Lines. Each set of two vertices is treated as a separate line segment.
  LINE_STRIP: 3,
  // Lines/ a connected group of line segments from the first vertex to the last
  TRIANGLES: 4,
  // Triangles. Each set of three vertices creates a separate triangle.
  TRIANGLE_STRIP: 5,
  // Triangles. A connected group of triangles.
  TRIANGLE_FAN: 6
  // Triangles. A connected group of triangles.
  // Each vertex connects to the previous and the first vertex in the fan.
}, rs = {
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DOUBLE: 5130
}, Kt = {
  ...H5,
  ...rs
}, Nm = {
  [rs.DOUBLE]: Float64Array,
  [rs.FLOAT]: Float32Array,
  [rs.UNSIGNED_SHORT]: Uint16Array,
  [rs.UNSIGNED_INT]: Uint32Array,
  [rs.UNSIGNED_BYTE]: Uint8Array,
  [rs.BYTE]: Int8Array,
  [rs.SHORT]: Int16Array,
  [rs.INT]: Int32Array
}, j5 = {
  DOUBLE: rs.DOUBLE,
  FLOAT: rs.FLOAT,
  UNSIGNED_SHORT: rs.UNSIGNED_SHORT,
  UNSIGNED_INT: rs.UNSIGNED_INT,
  UNSIGNED_BYTE: rs.UNSIGNED_BYTE,
  BYTE: rs.BYTE,
  SHORT: rs.SHORT,
  INT: rs.INT
}, Lm = "Failed to convert GL type";
class Zn {
  // Signature: fromTypedArray(new Uint8Array())
  // Signature: fromTypedArray(Uint8Array)
  /**
   * Returns the size, in bytes, of the corresponding datatype
   * @param arrayOrType
   * @returns glType a a string
   */
  static fromTypedArray(e) {
    e = ArrayBuffer.isView(e) ? e.constructor : e;
    for (const i in Nm)
      if (Nm[i] === e)
        return i;
    throw new Error(Lm);
  }
  /**
   * Extracts name for glType from array NAME_TO_GL_TYPE
   * @param name
   * @returns glType as a number
   */
  static fromName(e) {
    const i = j5[e];
    if (!i)
      throw new Error(Lm);
    return i;
  }
  // Converts GL constant to corresponding typed array type
  // eslint-disable-next-line complexity
  static getArrayType(e) {
    switch (e) {
      case rs.UNSIGNED_SHORT_5_6_5:
      case rs.UNSIGNED_SHORT_4_4_4_4:
      case rs.UNSIGNED_SHORT_5_5_5_1:
        return Uint16Array;
      default:
        const i = Nm[e];
        if (!i)
          throw new Error(Lm);
        return i;
    }
  }
  /**
   * Returns the size in bytes of one element of the provided WebGL type
   * @param glType
   * @returns size of glType
   */
  static getByteSize(e) {
    return Zn.getArrayType(e).BYTES_PER_ELEMENT;
  }
  /**
   * Returns `true` if `glType` is a valid WebGL data type.
   * @param glType
   * @returns boolean
   */
  static validate(e) {
    return !!Zn.getArrayType(e);
  }
  /**
   * Creates a typed view of an array of bytes
   * @param glType The type of typed array (ArrayBuffer view) to create
   * @param buffer The buffer storage to use for the view.
   * @param byteOffset The offset, in bytes, to the first element in the view
   * @param length The number of elements in the view. Defaults to buffer length
   * @returns A typed array view of the buffer
   */
  static createTypedArray(e, i, s = 0, o) {
    o === void 0 && (o = (i.byteLength - s) / Zn.getByteSize(e));
    const l = Zn.getArrayType(e);
    return new l(i, s, o);
  }
}
function $5(t, e) {
  if (!t)
    throw new Error(`math.gl assertion failed. ${e}`);
}
function G5(t, e = [0, 0, 0]) {
  const i = t >> 11 & 31, s = t >> 5 & 63, o = t & 31;
  return e[0] = i << 3, e[1] = s << 2, e[2] = o << 3, e;
}
new oy();
new Se();
new oy();
new oy();
function y1(t, e = 255) {
  return bo(t, 0, e) / e * 2 - 1;
}
function b1(t) {
  return t < 0 ? -1 : 1;
}
function X5(t, e, i, s) {
  if ($5(s), t < 0 || t > i || e < 0 || e > i)
    throw new Error(`x and y must be unsigned normalized integers between 0 and ${i}`);
  if (s.x = y1(t, i), s.y = y1(e, i), s.z = 1 - (Math.abs(s.x) + Math.abs(s.y)), s.z < 0) {
    const o = s.x;
    s.x = (1 - Math.abs(s.y)) * b1(o), s.y = (1 - Math.abs(o)) * b1(s.y);
  }
  return s.normalize();
}
function W5(t, e, i) {
  return X5(t, e, 255, i);
}
class ky {
  constructor(e, i) {
    O(this, "json");
    O(this, "buffer");
    O(this, "featuresLength", 0);
    O(this, "_cachedTypedArrays", {});
    this.json = e, this.buffer = i;
  }
  getExtension(e) {
    return this.json.extensions && this.json.extensions[e];
  }
  hasProperty(e) {
    return !!this.json[e];
  }
  getGlobalProperty(e, i = Kt.UNSIGNED_INT, s = 1) {
    const o = this.json[e];
    return o && Number.isFinite(o.byteOffset) ? this._getTypedArrayFromBinary(e, i, s, 1, o.byteOffset) : o;
  }
  getPropertyArray(e, i, s) {
    const o = this.json[e];
    return o && Number.isFinite(o.byteOffset) ? ("componentType" in o && (i = Zn.fromName(o.componentType)), this._getTypedArrayFromBinary(e, i, s, this.featuresLength, o.byteOffset)) : this._getTypedArrayFromArray(e, i, o);
  }
  getProperty(e, i, s, o, l) {
    const u = this.json[e];
    if (!u)
      return u;
    const c = this.getPropertyArray(e, i, s);
    if (s === 1)
      return c[o];
    for (let x = 0; x < s; ++x)
      l[x] = c[s * o + x];
    return l;
  }
  // HELPERS
  _getTypedArrayFromBinary(e, i, s, o, l) {
    const u = this._cachedTypedArrays;
    let c = u[e];
    return c || (c = Zn.createTypedArray(i, this.buffer.buffer, this.buffer.byteOffset + l, o * s), u[e] = c), c;
  }
  _getTypedArrayFromArray(e, i, s) {
    const o = this._cachedTypedArrays;
    let l = o[e];
    return l || (l = Zn.createTypedArray(i, s), o[e] = l), l;
  }
}
const q5 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Z5 = {
  SCALAR: (t, e) => t[e],
  VEC2: (t, e) => [t[2 * e + 0], t[2 * e + 1]],
  VEC3: (t, e) => [t[3 * e + 0], t[3 * e + 1], t[3 * e + 2]],
  VEC4: (t, e) => [t[4 * e + 0], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]],
  // TODO: check column major
  MAT2: (t, e) => [
    t[4 * e + 0],
    t[4 * e + 1],
    t[4 * e + 2],
    t[4 * e + 3]
  ],
  MAT3: (t, e) => [
    t[9 * e + 0],
    t[9 * e + 1],
    t[9 * e + 2],
    t[9 * e + 3],
    t[9 * e + 4],
    t[9 * e + 5],
    t[9 * e + 6],
    t[9 * e + 7],
    t[9 * e + 8]
  ],
  MAT4: (t, e) => [
    t[16 * e + 0],
    t[16 * e + 1],
    t[16 * e + 2],
    t[16 * e + 3],
    t[16 * e + 4],
    t[16 * e + 5],
    t[16 * e + 6],
    t[16 * e + 7],
    t[16 * e + 8],
    t[16 * e + 9],
    t[16 * e + 10],
    t[16 * e + 11],
    t[16 * e + 12],
    t[16 * e + 13],
    t[16 * e + 14],
    t[16 * e + 15]
  ]
}, K5 = {
  SCALAR: (t, e, i) => {
    e[i] = t;
  },
  VEC2: (t, e, i) => {
    e[2 * i + 0] = t[0], e[2 * i + 1] = t[1];
  },
  VEC3: (t, e, i) => {
    e[3 * i + 0] = t[0], e[3 * i + 1] = t[1], e[3 * i + 2] = t[2];
  },
  VEC4: (t, e, i) => {
    e[4 * i + 0] = t[0], e[4 * i + 1] = t[1], e[4 * i + 2] = t[2], e[4 * i + 3] = t[3];
  },
  // TODO: check column major correctness
  MAT2: (t, e, i) => {
    e[4 * i + 0] = t[0], e[4 * i + 1] = t[1], e[4 * i + 2] = t[2], e[4 * i + 3] = t[3];
  },
  MAT3: (t, e, i) => {
    e[9 * i + 0] = t[0], e[9 * i + 1] = t[1], e[9 * i + 2] = t[2], e[9 * i + 3] = t[3], e[9 * i + 4] = t[4], e[9 * i + 5] = t[5], e[9 * i + 6] = t[6], e[9 * i + 7] = t[7], e[9 * i + 8] = t[8], e[9 * i + 9] = t[9];
  },
  MAT4: (t, e, i) => {
    e[16 * i + 0] = t[0], e[16 * i + 1] = t[1], e[16 * i + 2] = t[2], e[16 * i + 3] = t[3], e[16 * i + 4] = t[4], e[16 * i + 5] = t[5], e[16 * i + 6] = t[6], e[16 * i + 7] = t[7], e[16 * i + 8] = t[8], e[16 * i + 9] = t[9], e[16 * i + 10] = t[10], e[16 * i + 11] = t[11], e[16 * i + 12] = t[12], e[16 * i + 13] = t[13], e[16 * i + 14] = t[14], e[16 * i + 15] = t[15];
  }
};
function J5(t, e, i, s) {
  const { componentType: o } = t;
  Ai(t.componentType);
  const l = typeof o == "string" ? Zn.fromName(o) : o, u = q5[t.type], c = Z5[t.type], x = K5[t.type];
  return i += t.byteOffset, {
    values: Zn.createTypedArray(l, e, i, u * s),
    type: l,
    size: u,
    unpacker: c,
    packer: x
  };
}
const Xn = (t) => t !== void 0;
function Y5(t, e, i) {
  if (!e)
    return null;
  let s = t.getExtension("3DTILES_batch_table_hierarchy");
  const o = e.HIERARCHY;
  return o && (console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy."), e.extensions = e.extensions || {}, e.extensions["3DTILES_batch_table_hierarchy"] = o, s = o), s ? Q5(s, i) : null;
}
function Q5(t, e) {
  let i, s, o;
  const l = t.instancesLength, u = t.classes;
  let c = t.classIds, x = t.parentCounts, w = t.parentIds, C = l;
  Xn(c.byteOffset) && (c.componentType = defaultValue(c.componentType, GL.UNSIGNED_SHORT), c.type = AttributeType.SCALAR, o = getBinaryAccessor(c), c = o.createArrayBufferView(e.buffer, e.byteOffset + c.byteOffset, l));
  let M;
  if (Xn(x))
    for (Xn(x.byteOffset) && (x.componentType = defaultValue(x.componentType, GL.UNSIGNED_SHORT), x.type = AttributeType.SCALAR, o = getBinaryAccessor(x), x = o.createArrayBufferView(e.buffer, e.byteOffset + x.byteOffset, l)), M = new Uint16Array(l), C = 0, i = 0; i < l; ++i)
      M[i] = C, C += x[i];
  Xn(w) && Xn(w.byteOffset) && (w.componentType = defaultValue(w.componentType, GL.UNSIGNED_SHORT), w.type = AttributeType.SCALAR, o = getBinaryAccessor(w), w = o.createArrayBufferView(e.buffer, e.byteOffset + w.byteOffset, C));
  const P = u.length;
  for (i = 0; i < P; ++i) {
    const _e = u[i].length, me = u[i].instances, we = getBinaryProperties(_e, me, e);
    u[i].instances = combine(we, me);
  }
  const j = new Array(P).fill(0), Y = new Uint16Array(l);
  for (i = 0; i < l; ++i)
    s = c[i], Y[i] = j[s], ++j[s];
  const Q = {
    classes: u,
    classIds: c,
    classIndexes: Y,
    parentCounts: x,
    parentIndexes: M,
    parentIds: w
  };
  return i8(Q), Q;
}
function ru(t, e, i) {
  if (!t)
    return;
  const s = t.parentCounts;
  return t.parentIds ? i(t, e) : s > 0 ? e8(t, e, i) : t8(t, e, i);
}
function e8(t, e, i) {
  const s = t.classIds, o = t.parentCounts, l = t.parentIds, u = t.parentIndexes, c = s.length, x = scratchVisited;
  x.length = Math.max(x.length, c);
  const w = ++marker, C = scratchStack;
  for (C.length = 0, C.push(e); C.length > 0; ) {
    if (e = C.pop(), x[e] === w)
      continue;
    x[e] = w;
    const M = i(t, e);
    if (Xn(M))
      return M;
    const P = o[e], j = u[e];
    for (let Y = 0; Y < P; ++Y) {
      const Q = l[j + Y];
      Q !== e && C.push(Q);
    }
  }
  return null;
}
function t8(t, e, i) {
  let s = !0;
  for (; s; ) {
    const o = i(t, e);
    if (Xn(o))
      return o;
    const l = t.parentIds[e];
    s = l !== e, e = l;
  }
  throw new Error("traverseHierarchySingleParent");
}
function i8(t) {
  const i = t.classIds.length;
  for (let s = 0; s < i; ++s)
    FT(t, s, stack);
}
function FT(t, e, i) {
  const s = t.parentCounts, o = t.parentIds, l = t.parentIndexes, c = t.classIds.length;
  if (!Xn(o))
    return;
  assert(e < c, `Parent index ${e} exceeds the total number of instances: ${c}`), assert(i.indexOf(e) === -1, "Circular dependency detected in the batch table hierarchy."), i.push(e);
  const x = Xn(s) ? s[e] : 1, w = Xn(s) ? l[e] : e;
  for (let C = 0; C < x; ++C) {
    const M = o[w + C];
    M !== e && FT(t, M, i);
  }
  i.pop(e);
}
function br(t) {
  return t != null;
}
const mf = (t, e) => t, s8 = {
  HIERARCHY: !0,
  // Deprecated HIERARCHY property
  extensions: !0,
  extras: !0
};
class kT {
  constructor(e, i, s, o = {}) {
    O(this, "json");
    O(this, "binary");
    O(this, "featureCount");
    O(this, "_extensions");
    // Copy all top-level property fields from the json object, ignoring special fields
    O(this, "_properties");
    O(this, "_binaryProperties");
    // TODO: hierarchy support is only partially implemented and not tested
    O(this, "_hierarchy");
    var l;
    Ai(s >= 0), this.json = e || {}, this.binary = i, this.featureCount = s, this._extensions = ((l = this.json) == null ? void 0 : l.extensions) || {}, this._properties = {};
    for (const u in this.json)
      s8[u] || (this._properties[u] = this.json[u]);
    this._binaryProperties = this._initializeBinaryProperties(), o["3DTILES_batch_table_hierarchy"] && (this._hierarchy = Y5(this, this.json, this.binary));
  }
  getExtension(e) {
    return this.json && this.json.extensions && this.json.extensions[e];
  }
  memorySizeInBytes() {
    return 0;
  }
  isClass(e, i) {
    if (this._checkBatchId(e), Ai(typeof i == "string", i), this._hierarchy) {
      const s = ru(this._hierarchy, e, (o, l) => {
        const u = o.classIds[l];
        return o.classes[u].name === i;
      });
      return br(s);
    }
    return !1;
  }
  isExactClass(e, i) {
    return Ai(typeof i == "string", i), this.getExactClassName(e) === i;
  }
  getExactClassName(e) {
    if (this._checkBatchId(e), this._hierarchy) {
      const i = this._hierarchy.classIds[e];
      return this._hierarchy.classes[i].name;
    }
  }
  hasProperty(e, i) {
    return this._checkBatchId(e), Ai(typeof i == "string", i), br(this._properties[i]) || this._hasPropertyInHierarchy(e, i);
  }
  getPropertyNames(e, i) {
    this._checkBatchId(e), i = br(i) ? i : [], i.length = 0;
    const s = Object.keys(this._properties);
    return i.push(...s), this._hierarchy && this._getPropertyNamesInHierarchy(e, i), i;
  }
  getProperty(e, i) {
    if (this._checkBatchId(e), Ai(typeof i == "string", i), this._binaryProperties) {
      const o = this._binaryProperties[i];
      if (br(o))
        return this._getBinaryProperty(o, e);
    }
    const s = this._properties[i];
    if (br(s))
      return mf(s[e]);
    if (this._hierarchy) {
      const o = this._getHierarchyProperty(e, i);
      if (br(o))
        return o;
    }
  }
  setProperty(e, i, s) {
    const o = this.featureCount;
    if (this._checkBatchId(e), Ai(typeof i == "string", i), this._binaryProperties) {
      const u = this._binaryProperties[i];
      if (u) {
        this._setBinaryProperty(u, e, s);
        return;
      }
    }
    if (this._hierarchy && this._setHierarchyProperty(this, e, i, s))
      return;
    let l = this._properties[i];
    br(l) || (this._properties[i] = new Array(o), l = this._properties[i]), l[e] = mf(s);
  }
  // PRIVATE METHODS
  _checkBatchId(e) {
    if (!(e >= 0 && e < this.featureCount))
      throw new Error("batchId not in range [0, featureCount - 1].");
  }
  _getBinaryProperty(e, i) {
    return e.unpack(e.typedArray, i);
  }
  _setBinaryProperty(e, i, s) {
    e.pack(s, e.typedArray, i);
  }
  _initializeBinaryProperties() {
    let e = null;
    for (const i in this._properties) {
      const s = this._properties[i], o = this._initializeBinaryProperty(i, s);
      o && (e = e || {}, e[i] = o);
    }
    return e;
  }
  _initializeBinaryProperty(e, i) {
    if ("byteOffset" in i) {
      const s = i;
      Ai(this.binary, `Property ${e} requires a batch table binary.`), Ai(s.type, `Property ${e} requires a type.`);
      const o = J5(s, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
      return {
        typedArray: o.values,
        componentCount: o.size,
        unpack: o.unpacker,
        pack: o.packer
      };
    }
    return null;
  }
  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy
  _hasPropertyInHierarchy(e, i) {
    if (!this._hierarchy)
      return !1;
    const s = ru(this._hierarchy, e, (o, l) => {
      const u = o.classIds[l], c = o.classes[u].instances;
      return br(c[i]);
    });
    return br(s);
  }
  _getPropertyNamesInHierarchy(e, i) {
    ru(this._hierarchy, e, (s, o) => {
      const l = s.classIds[o], u = s.classes[l].instances;
      for (const c in u)
        u.hasOwnProperty(c) && i.indexOf(c) === -1 && i.push(c);
    });
  }
  _getHierarchyProperty(e, i) {
    return ru(this._hierarchy, e, (s, o) => {
      const l = s.classIds[o], u = s.classes[l], c = s.classIndexes[o], x = u.instances[i];
      return br(x) ? br(x.typedArray) ? this._getBinaryProperty(x, c) : mf(x[c]) : null;
    });
  }
  _setHierarchyProperty(e, i, s, o) {
    const l = ru(this._hierarchy, i, (u, c) => {
      const x = u.classIds[c], w = u.classes[x], C = u.classIndexes[c], M = w.instances[s];
      return br(M) ? (Ai(c === i, `Inherited property "${s}" is read-only.`), br(M.typedArray) ? this._setBinaryProperty(M, C, o) : M[C] = mf(o), !0) : !1;
    });
    return br(l);
  }
}
const Um = 4;
function Ip(t, e, i = 0) {
  const s = new DataView(e);
  if (t.magic = s.getUint32(i, !0), i += Um, t.version = s.getUint32(i, !0), i += Um, t.byteLength = s.getUint32(i, !0), i += Um, t.version !== 1)
    throw new Error(`3D Tile Version ${t.version} not supported`);
  return i;
}
const fc = 4, v1 = "b3dm tile in legacy format.";
function Ny(t, e, i) {
  const s = new DataView(e);
  let o;
  t.header = t.header || {};
  let l = s.getUint32(i, !0);
  i += fc;
  let u = s.getUint32(i, !0);
  i += fc;
  let c = s.getUint32(i, !0);
  i += fc;
  let x = s.getUint32(i, !0);
  return i += fc, c >= 570425344 ? (i -= fc * 2, o = l, c = u, x = 0, l = 0, u = 0, console.warn(v1)) : x >= 570425344 && (i -= fc, o = c, c = l, x = u, l = 0, u = 0, console.warn(v1)), t.header.featureTableJsonByteLength = l, t.header.featureTableBinaryByteLength = u, t.header.batchTableJsonByteLength = c, t.header.batchTableBinaryByteLength = x, t.header.batchLength = o, i;
}
function Ly(t, e, i, s) {
  return i = r8(t, e, i), i = n8(t, e, i), i;
}
function r8(t, e, i, s) {
  const { featureTableJsonByteLength: o, featureTableBinaryByteLength: l, batchLength: u } = t.header || {};
  if (t.featureTableJson = {
    BATCH_LENGTH: u || 0
  }, o && o > 0) {
    const c = OT(e, i, o);
    t.featureTableJson = JSON.parse(c);
  }
  return i += o || 0, t.featureTableBinary = new Uint8Array(e, i, l), i += l || 0, i;
}
function n8(t, e, i, s) {
  const { batchTableJsonByteLength: o, batchTableBinaryByteLength: l } = t.header || {};
  if (o && o > 0) {
    const u = OT(e, i, o);
    t.batchTableJson = JSON.parse(u), i += o, l && l > 0 && (t.batchTableBinary = new Uint8Array(e, i, l), t.batchTableBinary = new Uint8Array(t.batchTableBinary), i += l);
  }
  return i;
}
function NT(t, e, i) {
  if (!e && (!t || !t.batchIds || !i))
    return null;
  const { batchIds: s, isRGB565: o, pointCount: l = 0 } = t;
  if (s && i) {
    const u = new Uint8ClampedArray(l * 3);
    for (let c = 0; c < l; c++) {
      const x = s[c], C = i.getProperty(x, "dimensions").map((M) => M * 255);
      u[c * 3] = C[0], u[c * 3 + 1] = C[1], u[c * 3 + 2] = C[2];
    }
    return {
      type: Kt.UNSIGNED_BYTE,
      value: u,
      size: 3,
      normalized: !0
    };
  }
  if (e && o) {
    const u = new Uint8ClampedArray(l * 3);
    for (let c = 0; c < l; c++) {
      const x = G5(e[c]);
      u[c * 3] = x[0], u[c * 3 + 1] = x[1], u[c * 3 + 2] = x[2];
    }
    return {
      type: Kt.UNSIGNED_BYTE,
      value: u,
      size: 3,
      normalized: !0
    };
  }
  return e && e.length === l * 3 ? {
    type: Kt.UNSIGNED_BYTE,
    value: e,
    size: 3,
    normalized: !0
  } : {
    type: Kt.UNSIGNED_BYTE,
    value: e || new Uint8ClampedArray(),
    size: 4,
    normalized: !0
  };
}
const x1 = new Se();
function o8(t, e) {
  if (!e)
    return null;
  if (t.isOctEncoded16P) {
    const i = new Float32Array((t.pointsLength || 0) * 3);
    for (let s = 0; s < (t.pointsLength || 0); s++)
      W5(e[s * 2], e[s * 2 + 1], x1), x1.toArray(i, s * 3);
    return {
      type: Kt.FLOAT,
      size: 2,
      value: i
    };
  }
  return {
    type: Kt.FLOAT,
    size: 2,
    value: e
  };
}
function a8(t, e, i) {
  return t.isQuantized ? i["3d-tiles"] && i["3d-tiles"].decodeQuantizedPositions ? (t.isQuantized = !1, l8(t, e)) : {
    type: Kt.UNSIGNED_SHORT,
    value: e,
    size: 3,
    normalized: !0
  } : e;
}
function l8(t, e) {
  const i = new Se(), s = new Float32Array(t.pointCount * 3);
  for (let o = 0; o < t.pointCount; o++)
    i.set(e[o * 3], e[o * 3 + 1], e[o * 3 + 2]).scale(1 / t.quantizedRange).multiply(t.quantizedVolumeScale).add(t.quantizedVolumeOffset).toArray(s, o * 3);
  return s;
}
async function c8(t, e, i, s, o) {
  i = Ip(t, e, i), i = Ny(t, e, i), i = Ly(t, e, i), h8(t);
  const { featureTable: l, batchTable: u } = u8(t);
  return await m8(t, l, u, s, o), d8(t, l, s), f8(t, l, u), p8(t, l), i;
}
function h8(t) {
  t.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, t.isQuantized = !1, t.isTranslucent = !1, t.isRGB565 = !1, t.isOctEncoded16P = !1;
}
function u8(t) {
  const e = new ky(t.featureTableJson, t.featureTableBinary), i = e.getGlobalProperty("POINTS_LENGTH");
  if (!Number.isFinite(i))
    throw new Error("POINTS_LENGTH must be defined");
  e.featuresLength = i, t.featuresLength = i, t.pointsLength = i, t.pointCount = i, t.rtcCenter = e.getGlobalProperty("RTC_CENTER", Kt.FLOAT, 3);
  const s = _8(t, e);
  return { featureTable: e, batchTable: s };
}
function d8(t, e, i) {
  if (t.attributes = t.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !t.attributes.positions) {
    if (e.hasProperty("POSITION"))
      t.attributes.positions = e.getPropertyArray("POSITION", Kt.FLOAT, 3);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      const s = e.getPropertyArray("POSITION_QUANTIZED", Kt.UNSIGNED_SHORT, 3);
      if (t.isQuantized = !0, t.quantizedRange = 65535, t.quantizedVolumeScale = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", Kt.FLOAT, 3), !t.quantizedVolumeScale)
        throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      if (t.quantizedVolumeOffset = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", Kt.FLOAT, 3), !t.quantizedVolumeOffset)
        throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      t.attributes.positions = a8(t, s, i);
    }
  }
  if (!t.attributes.positions)
    throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
}
function f8(t, e, i) {
  if (t.attributes = t.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !t.attributes.colors) {
    let s = null;
    e.hasProperty("RGBA") ? (s = e.getPropertyArray("RGBA", Kt.UNSIGNED_BYTE, 4), t.isTranslucent = !0) : e.hasProperty("RGB") ? s = e.getPropertyArray("RGB", Kt.UNSIGNED_BYTE, 3) : e.hasProperty("RGB565") && (s = e.getPropertyArray("RGB565", Kt.UNSIGNED_SHORT, 1), t.isRGB565 = !0), t.attributes.colors = NT(t, s, i);
  }
  e.hasProperty("CONSTANT_RGBA") && (t.constantRGBA = e.getGlobalProperty("CONSTANT_RGBA", Kt.UNSIGNED_BYTE, 4));
}
function p8(t, e) {
  if (t.attributes = t.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !t.attributes.normals) {
    let i = null;
    e.hasProperty("NORMAL") ? i = e.getPropertyArray("NORMAL", Kt.FLOAT, 3) : e.hasProperty("NORMAL_OCT16P") && (i = e.getPropertyArray("NORMAL_OCT16P", Kt.UNSIGNED_BYTE, 2), t.isOctEncoded16P = !0), t.attributes.normals = o8(t, i);
  }
}
function _8(t, e) {
  let i = null;
  if (!t.batchIds && e.hasProperty("BATCH_ID") && (t.batchIds = e.getPropertyArray("BATCH_ID", Kt.UNSIGNED_SHORT, 1), t.batchIds)) {
    const s = e.getGlobalProperty("BATCH_LENGTH");
    if (!s)
      throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
    const { batchTableJson: o, batchTableBinary: l } = t;
    i = new kT(o, l, s);
  }
  return i;
}
async function m8(t, e, i, s, o) {
  let l, u, c;
  const x = t.batchTableJson && t.batchTableJson.extensions && t.batchTableJson.extensions["3DTILES_draco_point_compression"];
  x && (c = x.properties);
  const w = e.getExtension("3DTILES_draco_point_compression");
  if (w) {
    u = w.properties;
    const M = w.byteOffset, P = w.byteLength;
    if (!u || !Number.isFinite(M) || !P)
      throw new Error("Draco properties, byteOffset, and byteLength must be defined");
    l = (t.featureTableBinary || []).slice(M, M + P), t.hasPositions = Number.isFinite(u.POSITION), t.hasColors = Number.isFinite(u.RGB) || Number.isFinite(u.RGBA), t.hasNormals = Number.isFinite(u.NORMAL), t.hasBatchIds = Number.isFinite(u.BATCH_ID), t.isTranslucent = Number.isFinite(u.RGBA);
  }
  if (!l)
    return !0;
  const C = {
    buffer: l,
    properties: { ...u, ...c },
    featureTableProperties: u,
    batchTableProperties: c,
    dequantizeInShader: !1
  };
  return await g8(t, C, s, o);
}
async function g8(t, e, i, s) {
  if (!s)
    return;
  const o = {
    ...i,
    draco: {
      ...i == null ? void 0 : i.draco,
      extraAttributes: e.batchTableProperties || {}
    }
  };
  delete o["3d-tiles"];
  const l = await Bu(e.buffer, xT, o, s), u = l.attributes.POSITION && l.attributes.POSITION.value, c = l.attributes.COLOR_0 && l.attributes.COLOR_0.value, x = l.attributes.NORMAL && l.attributes.NORMAL.value, w = l.attributes.BATCH_ID && l.attributes.BATCH_ID.value, C = u && l.attributes.POSITION.value.quantization, M = x && l.attributes.NORMAL.value.quantization;
  if (C) {
    const j = l.POSITION.data.quantization, Y = j.range;
    t.quantizedVolumeScale = new Se(Y, Y, Y), t.quantizedVolumeOffset = new Se(j.minValues), t.quantizedRange = (1 << j.quantizationBits) - 1, t.isQuantizedDraco = !0;
  }
  M && (t.octEncodedRange = (1 << l.NORMAL.data.quantization.quantizationBits) - 1, t.isOctEncodedDraco = !0);
  const P = {};
  if (e.batchTableProperties)
    for (const j of Object.keys(e.batchTableProperties))
      l.attributes[j] && l.attributes[j].value && (P[j.toLowerCase()] = l.attributes[j].value);
  t.attributes = {
    // @ts-expect-error
    positions: u,
    // @ts-expect-error
    colors: NT(t, c, void 0),
    // @ts-expect-error
    normals: x,
    // @ts-expect-error
    batchIds: w,
    ...P
  };
}
const Lg = {
  URI: 0,
  EMBEDDED: 1
};
function LT(t, e, i, s) {
  t.rotateYtoZ = !0;
  const o = (t.byteOffset || 0) + (t.byteLength || 0) - i;
  if (o === 0)
    throw new Error("glTF byte length must be greater than 0.");
  return t.gltfUpAxis = s != null && s["3d-tiles"] && s["3d-tiles"].assetGltfUpAxis ? s["3d-tiles"].assetGltfUpAxis : "Y", t.gltfArrayBuffer = Gg(e, i, o), t.gltfByteOffset = 0, t.gltfByteLength = o, i % 4 === 0 || console.warn(`${t.type}: embedded glb is not aligned to a 4-byte boundary.`), (t.byteOffset || 0) + (t.byteLength || 0);
}
async function UT(t, e, i, s) {
  const o = (i == null ? void 0 : i["3d-tiles"]) || {};
  if (y8(t, e), o.loadGLTF) {
    if (!s)
      return;
    if (t.gltfUrl) {
      const { fetch: l } = s, u = await l(t.gltfUrl, i);
      t.gltfArrayBuffer = await u.arrayBuffer(), t.gltfByteOffset = 0;
    }
    if (t.gltfArrayBuffer) {
      const l = await Bu(t.gltfArrayBuffer, Mu, i, s);
      t.gltf = Dy(l), t.gpuMemoryUsageInBytes = uT(t.gltf), delete t.gltfArrayBuffer, delete t.gltfByteOffset, delete t.gltfByteLength;
    }
  }
}
function y8(t, e, i) {
  switch (e) {
    case Lg.URI:
      if (t.gltfArrayBuffer) {
        const s = new Uint8Array(t.gltfArrayBuffer, t.gltfByteOffset), l = new TextDecoder().decode(s);
        t.gltfUrl = l.replace(/[\s\0]+$/, "");
      }
      delete t.gltfArrayBuffer, delete t.gltfByteOffset, delete t.gltfByteLength;
      break;
    case Lg.EMBEDDED:
      break;
    default:
      throw new Error("b3dm: Illegal glTF format field");
  }
}
async function b8(t, e, i, s, o) {
  var u;
  i = v8(t, e, i, s), await UT(t, Lg.EMBEDDED, s, o);
  const l = (u = t == null ? void 0 : t.gltf) == null ? void 0 : u.extensions;
  return l && l.CESIUM_RTC && (t.rtcCenter = l.CESIUM_RTC.center), i;
}
function v8(t, e, i, s, o) {
  i = Ip(t, e, i), i = Ny(t, e, i), i = Ly(t, e, i), i = LT(t, e, i, s);
  const l = new ky(t.featureTableJson, t.featureTableBinary);
  return t.rtcCenter = l.getGlobalProperty("RTC_CENTER", Kt.FLOAT, 3), i;
}
async function x8(t, e, i, s, o) {
  return i = w8(t, e, i, s), await UT(t, t.gltfFormat || 0, s, o), i;
}
function w8(t, e, i, s, o) {
  var w;
  if (i = Ip(t, e, i), t.version !== 1)
    throw new Error(`Instanced 3D Model version ${t.version} is not supported`);
  i = Ny(t, e, i);
  const l = new DataView(e);
  if (t.gltfFormat = l.getUint32(i, !0), i += 4, i = Ly(t, e, i), i = LT(t, e, i, s), !((w = t == null ? void 0 : t.header) != null && w.featureTableJsonByteLength) || t.header.featureTableJsonByteLength === 0)
    throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
  const u = new ky(t.featureTableJson, t.featureTableBinary), c = u.getGlobalProperty("INSTANCES_LENGTH");
  if (u.featuresLength = c, !Number.isFinite(c))
    throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
  t.eastNorthUp = u.getGlobalProperty("EAST_NORTH_UP"), t.rtcCenter = u.getGlobalProperty("RTC_CENTER", Kt.FLOAT, 3);
  const x = new kT(t.batchTableJson, t.batchTableBinary, c);
  return A8(t, u, x, c), i;
}
function A8(t, e, i, s) {
  const o = new Array(s), l = new Se();
  new Se(), new Se(), new Se();
  const u = new qi(), c = new Au(), x = new Se(), w = {}, C = new Xt(), M = [], P = [], j = [], Y = [];
  for (let Q = 0; Q < s; Q++) {
    let _e;
    if (e.hasProperty("POSITION"))
      _e = e.getProperty("POSITION", Kt.FLOAT, 3, Q, l);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      _e = e.getProperty("POSITION_QUANTIZED", Kt.UNSIGNED_SHORT, 3, Q, l);
      const ze = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", Kt.FLOAT, 3);
      if (!ze)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      const nt = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", Kt.FLOAT, 3);
      if (!nt)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      const mt = 65535;
      for (let We = 0; We < 3; We++)
        _e[We] = _e[We] / mt * nt[We] + ze[We];
    }
    if (!_e)
      throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
    if (l.copy(_e), w.translation = l, t.normalUp = e.getProperty("NORMAL_UP", Kt.FLOAT, 3, Q, M), t.normalRight = e.getProperty("NORMAL_RIGHT", Kt.FLOAT, 3, Q, P), t.normalUp) {
      if (!t.normalRight)
        throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
      t.hasCustomOrientation = !0;
    } else {
      if (t.octNormalUp = e.getProperty("NORMAL_UP_OCT32P", Kt.UNSIGNED_SHORT, 2, Q, M), t.octNormalRight = e.getProperty("NORMAL_RIGHT_OCT32P", Kt.UNSIGNED_SHORT, 2, Q, P), t.octNormalUp)
        throw t.octNormalRight ? new Error("i3dm: oct-encoded orientation not implemented") : new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
      t.eastNorthUp ? (Ti.WGS84.eastNorthUpToFixedFrame(l, C), C.getRotationMatrix3(u)) : u.identity();
    }
    c.fromMatrix3(u), w.rotation = c, x.set(1, 1, 1);
    const me = e.getProperty("SCALE", Kt.FLOAT, 1, Q, j);
    Number.isFinite(me) && x.multiplyByScalar(me);
    const we = e.getProperty("SCALE_NON_UNIFORM", Kt.FLOAT, 3, Q, M);
    we && x.scale(we), w.scale = x;
    let Ee = e.getProperty("BATCH_ID", Kt.UNSIGNED_SHORT, 1, Q, Y);
    Ee === void 0 && (Ee = Q);
    const Oe = new Xt().fromQuaternion(w.rotation);
    C.identity(), C.translate(w.translation), C.multiplyRight(Oe), C.scale(w.scale);
    const Ne = C.clone();
    o[Q] = {
      modelMatrix: Ne,
      batchId: Ee
    };
  }
  t.instances = o;
}
async function T8(t, e, i, s, o, l) {
  i = Ip(t, e, i);
  const u = new DataView(e);
  for (t.tilesLength = u.getUint32(i, !0), i += 4, t.tiles = []; t.tiles.length < t.tilesLength && (t.byteLength || 0) - i > 12; ) {
    const c = { shape: "tile3d" };
    t.tiles.push(c), i = await l(e, i, s, o, c);
  }
  return i;
}
async function E8(t, e, i, s) {
  var o, l;
  if (t.rotateYtoZ = !0, t.gltfUpAxis = (o = i == null ? void 0 : i["3d-tiles"]) != null && o.assetGltfUpAxis ? i["3d-tiles"].assetGltfUpAxis : "Y", (l = i == null ? void 0 : i["3d-tiles"]) != null && l.loadGLTF) {
    if (!s)
      return e.byteLength;
    const u = await Bu(e, Mu, i, s);
    t.gltf = Dy(u), t.gpuMemoryUsageInBytes = uT(t.gltf);
  } else
    t.gltfArrayBuffer = e;
  return e.byteLength;
}
async function zT(t, e = 0, i, s, o = { shape: "tile3d" }) {
  switch (o.byteOffset = e, o.type = V5(t, e), o.type) {
    case su.COMPOSITE:
      return await T8(o, t, e, i, s, zT);
    case su.BATCHED_3D_MODEL:
      return await b8(o, t, e, i, s);
    case su.GLTF:
      return await E8(o, t, i, s);
    case su.INSTANCED_3D_MODEL:
      return await x8(o, t, e, i, s);
    case su.POINT_CLOUD:
      return await c8(o, t, e, i, s);
    default:
      throw new Error(`3DTileLoader: unknown type ${o.type}`);
  }
}
const S8 = 1952609651, C8 = 1;
async function I8(t, e, i) {
  if (new Uint32Array(t.slice(0, 4))[0] !== S8)
    throw new Error("Wrong subtree file magic number");
  if (new Uint32Array(t.slice(4, 8))[0] !== C8)
    throw new Error("Wrong subtree file verson, must be 1");
  const l = w1(t.slice(8, 16)), u = new Uint8Array(t, 24, l), x = new TextDecoder("utf8").decode(u), w = JSON.parse(x), C = w1(t.slice(16, 24));
  let M = new ArrayBuffer(0);
  if (C && (M = t.slice(24 + l)), await gf(w, w.tileAvailability, M, i), Array.isArray(w.contentAvailability))
    for (const P of w.contentAvailability)
      await gf(w, P, M, i);
  else
    await gf(w, w.contentAvailability, M, i);
  return await gf(w, w.childSubtreeAvailability, M, i), w;
}
async function gf(t, e, i, s) {
  const o = Number.isFinite(e.bitstream) ? e.bitstream : e.bufferView;
  if (typeof o != "number")
    return;
  const l = t.bufferViews[o], u = t.buffers[l.buffer];
  if (!(s != null && s.baseUrl))
    throw new Error("Url is not provided");
  if (!s.fetch)
    throw new Error("fetch is not provided");
  if (u.uri) {
    const x = `${(s == null ? void 0 : s.baseUrl) || ""}/${u.uri}`, C = await (await s.fetch(x)).arrayBuffer();
    e.explicitBitstream = new Uint8Array(C, l.byteOffset, l.byteLength);
    return;
  }
  const c = t.buffers.slice(0, l.buffer).reduce((x, w) => x + w.byteLength, 0);
  e.explicitBitstream = new Uint8Array(i.slice(c, c + u.byteLength), l.byteOffset, l.byteLength);
}
function w1(t) {
  const e = new DataView(t), i = e.getUint32(0, !0), s = e.getUint32(4, !0);
  return i + 2 ** 32 * s;
}
const VT = {
  dataType: null,
  batchType: null,
  id: "3d-tiles-subtree",
  name: "3D Tiles Subtree",
  module: "3d-tiles",
  version: DT,
  extensions: ["subtree"],
  mimeTypes: ["application/octet-stream"],
  tests: ["subtree"],
  parse: I8,
  options: {}
};
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var tn = null;
try {
  tn = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch {
}
function ui(t, e, i) {
  this.low = t | 0, this.high = e | 0, this.unsigned = !!i;
}
ui.prototype.__isLong__;
Object.defineProperty(ui.prototype, "__isLong__", { value: !0 });
function Ks(t) {
  return (t && t.__isLong__) === !0;
}
function A1(t) {
  var e = Math.clz32(t & -t);
  return t ? 31 - e : e;
}
ui.isLong = Ks;
var T1 = {}, E1 = {};
function fl(t, e) {
  var i, s, o;
  return e ? (t >>>= 0, (o = 0 <= t && t < 256) && (s = E1[t], s) ? s : (i = Yt(t, 0, !0), o && (E1[t] = i), i)) : (t |= 0, (o = -128 <= t && t < 128) && (s = T1[t], s) ? s : (i = Yt(t, t < 0 ? -1 : 0, !1), o && (T1[t] = i), i));
}
ui.fromInt = fl;
function sn(t, e) {
  if (isNaN(t))
    return e ? xo : yn;
  if (e) {
    if (t < 0)
      return xo;
    if (t >= HT)
      return GT;
  } else {
    if (t <= -C1)
      return wr;
    if (t + 1 >= C1)
      return $T;
  }
  return t < 0 ? sn(-t, e).neg() : Yt(t % Vc | 0, t / Vc | 0, e);
}
ui.fromNumber = sn;
function Yt(t, e, i) {
  return new ui(t, e, i);
}
ui.fromBits = Yt;
var Jf = Math.pow;
function Uy(t, e, i) {
  if (t.length === 0)
    throw Error("empty string");
  if (typeof e == "number" ? (i = e, e = !1) : e = !!e, t === "NaN" || t === "Infinity" || t === "+Infinity" || t === "-Infinity")
    return e ? xo : yn;
  if (i = i || 10, i < 2 || 36 < i)
    throw RangeError("radix");
  var s;
  if ((s = t.indexOf("-")) > 0)
    throw Error("interior hyphen");
  if (s === 0)
    return Uy(t.substring(1), e, i).neg();
  for (var o = sn(Jf(i, 8)), l = yn, u = 0; u < t.length; u += 8) {
    var c = Math.min(8, t.length - u), x = parseInt(t.substring(u, u + c), i);
    if (c < 8) {
      var w = sn(Jf(i, c));
      l = l.mul(w).add(sn(x));
    } else
      l = l.mul(o), l = l.add(sn(x));
  }
  return l.unsigned = e, l;
}
ui.fromString = Uy;
function wn(t, e) {
  return typeof t == "number" ? sn(t, e) : typeof t == "string" ? Uy(t, e) : Yt(t.low, t.high, typeof e == "boolean" ? e : t.unsigned);
}
ui.fromValue = wn;
var S1 = 65536, R8 = 1 << 24, Vc = S1 * S1, HT = Vc * Vc, C1 = HT / 2, I1 = fl(R8), yn = fl(0);
ui.ZERO = yn;
var xo = fl(0, !0);
ui.UZERO = xo;
var Ac = fl(1);
ui.ONE = Ac;
var jT = fl(1, !0);
ui.UONE = jT;
var Ug = fl(-1);
ui.NEG_ONE = Ug;
var $T = Yt(-1, 2147483647, !1);
ui.MAX_VALUE = $T;
var GT = Yt(-1, -1, !0);
ui.MAX_UNSIGNED_VALUE = GT;
var wr = Yt(0, -2147483648, !1);
ui.MIN_VALUE = wr;
var Xe = ui.prototype;
Xe.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
Xe.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * Vc + (this.low >>> 0) : this.high * Vc + (this.low >>> 0);
};
Xe.toString = function(e) {
  if (e = e || 10, e < 2 || 36 < e)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative())
    if (this.eq(wr)) {
      var i = sn(e), s = this.div(i), o = s.mul(i).sub(this);
      return s.toString(e) + o.toInt().toString(e);
    } else
      return "-" + this.neg().toString(e);
  for (var l = sn(Jf(e, 6), this.unsigned), u = this, c = ""; ; ) {
    var x = u.div(l), w = u.sub(x.mul(l)).toInt() >>> 0, C = w.toString(e);
    if (u = x, u.isZero())
      return C + c;
    for (; C.length < 6; )
      C = "0" + C;
    c = "" + C + c;
  }
};
Xe.getHighBits = function() {
  return this.high;
};
Xe.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
Xe.getLowBits = function() {
  return this.low;
};
Xe.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
Xe.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(wr) ? 64 : this.neg().getNumBitsAbs();
  for (var e = this.high != 0 ? this.high : this.low, i = 31; i > 0 && !(e & 1 << i); i--)
    ;
  return this.high != 0 ? i + 33 : i + 1;
};
Xe.isZero = function() {
  return this.high === 0 && this.low === 0;
};
Xe.eqz = Xe.isZero;
Xe.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
Xe.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
Xe.isOdd = function() {
  return (this.low & 1) === 1;
};
Xe.isEven = function() {
  return (this.low & 1) === 0;
};
Xe.equals = function(e) {
  return Ks(e) || (e = wn(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? !1 : this.high === e.high && this.low === e.low;
};
Xe.eq = Xe.equals;
Xe.notEquals = function(e) {
  return !this.eq(
    /* validates */
    e
  );
};
Xe.neq = Xe.notEquals;
Xe.ne = Xe.notEquals;
Xe.lessThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) < 0;
};
Xe.lt = Xe.lessThan;
Xe.lessThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) <= 0;
};
Xe.lte = Xe.lessThanOrEqual;
Xe.le = Xe.lessThanOrEqual;
Xe.greaterThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) > 0;
};
Xe.gt = Xe.greaterThan;
Xe.greaterThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) >= 0;
};
Xe.gte = Xe.greaterThanOrEqual;
Xe.ge = Xe.greaterThanOrEqual;
Xe.compare = function(e) {
  if (Ks(e) || (e = wn(e)), this.eq(e))
    return 0;
  var i = this.isNegative(), s = e.isNegative();
  return i && !s ? -1 : !i && s ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
};
Xe.comp = Xe.compare;
Xe.negate = function() {
  return !this.unsigned && this.eq(wr) ? wr : this.not().add(Ac);
};
Xe.neg = Xe.negate;
Xe.add = function(e) {
  Ks(e) || (e = wn(e));
  var i = this.high >>> 16, s = this.high & 65535, o = this.low >>> 16, l = this.low & 65535, u = e.high >>> 16, c = e.high & 65535, x = e.low >>> 16, w = e.low & 65535, C = 0, M = 0, P = 0, j = 0;
  return j += l + w, P += j >>> 16, j &= 65535, P += o + x, M += P >>> 16, P &= 65535, M += s + c, C += M >>> 16, M &= 65535, C += i + u, C &= 65535, Yt(P << 16 | j, C << 16 | M, this.unsigned);
};
Xe.subtract = function(e) {
  return Ks(e) || (e = wn(e)), this.add(e.neg());
};
Xe.sub = Xe.subtract;
Xe.multiply = function(e) {
  if (this.isZero())
    return this;
  if (Ks(e) || (e = wn(e)), tn) {
    var i = tn.mul(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return Yt(i, tn.get_high(), this.unsigned);
  }
  if (e.isZero())
    return this.unsigned ? xo : yn;
  if (this.eq(wr))
    return e.isOdd() ? wr : yn;
  if (e.eq(wr))
    return this.isOdd() ? wr : yn;
  if (this.isNegative())
    return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative())
    return this.mul(e.neg()).neg();
  if (this.lt(I1) && e.lt(I1))
    return sn(this.toNumber() * e.toNumber(), this.unsigned);
  var s = this.high >>> 16, o = this.high & 65535, l = this.low >>> 16, u = this.low & 65535, c = e.high >>> 16, x = e.high & 65535, w = e.low >>> 16, C = e.low & 65535, M = 0, P = 0, j = 0, Y = 0;
  return Y += u * C, j += Y >>> 16, Y &= 65535, j += l * C, P += j >>> 16, j &= 65535, j += u * w, P += j >>> 16, j &= 65535, P += o * C, M += P >>> 16, P &= 65535, P += l * w, M += P >>> 16, P &= 65535, P += u * x, M += P >>> 16, P &= 65535, M += s * C + o * w + l * x + u * c, M &= 65535, Yt(j << 16 | Y, M << 16 | P, this.unsigned);
};
Xe.mul = Xe.multiply;
Xe.divide = function(e) {
  if (Ks(e) || (e = wn(e)), e.isZero())
    throw Error("division by zero");
  if (tn) {
    if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1)
      return this;
    var i = (this.unsigned ? tn.div_u : tn.div_s)(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return Yt(i, tn.get_high(), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? xo : yn;
  var s, o, l;
  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this))
      return xo;
    if (e.gt(this.shru(1)))
      return jT;
    l = xo;
  } else {
    if (this.eq(wr)) {
      if (e.eq(Ac) || e.eq(Ug))
        return wr;
      if (e.eq(wr))
        return Ac;
      var u = this.shr(1);
      return s = u.div(e).shl(1), s.eq(yn) ? e.isNegative() ? Ac : Ug : (o = this.sub(e.mul(s)), l = s.add(o.div(e)), l);
    } else if (e.eq(wr))
      return this.unsigned ? xo : yn;
    if (this.isNegative())
      return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative())
      return this.div(e.neg()).neg();
    l = yn;
  }
  for (o = this; o.gte(e); ) {
    s = Math.max(1, Math.floor(o.toNumber() / e.toNumber()));
    for (var c = Math.ceil(Math.log(s) / Math.LN2), x = c <= 48 ? 1 : Jf(2, c - 48), w = sn(s), C = w.mul(e); C.isNegative() || C.gt(o); )
      s -= x, w = sn(s, this.unsigned), C = w.mul(e);
    w.isZero() && (w = Ac), l = l.add(w), o = o.sub(C);
  }
  return l;
};
Xe.div = Xe.divide;
Xe.modulo = function(e) {
  if (Ks(e) || (e = wn(e)), tn) {
    var i = (this.unsigned ? tn.rem_u : tn.rem_s)(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return Yt(i, tn.get_high(), this.unsigned);
  }
  return this.sub(this.div(e).mul(e));
};
Xe.mod = Xe.modulo;
Xe.rem = Xe.modulo;
Xe.not = function() {
  return Yt(~this.low, ~this.high, this.unsigned);
};
Xe.countLeadingZeros = function() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
Xe.clz = Xe.countLeadingZeros;
Xe.countTrailingZeros = function() {
  return this.low ? A1(this.low) : A1(this.high) + 32;
};
Xe.ctz = Xe.countTrailingZeros;
Xe.and = function(e) {
  return Ks(e) || (e = wn(e)), Yt(this.low & e.low, this.high & e.high, this.unsigned);
};
Xe.or = function(e) {
  return Ks(e) || (e = wn(e)), Yt(this.low | e.low, this.high | e.high, this.unsigned);
};
Xe.xor = function(e) {
  return Ks(e) || (e = wn(e)), Yt(this.low ^ e.low, this.high ^ e.high, this.unsigned);
};
Xe.shiftLeft = function(e) {
  return Ks(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Yt(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : Yt(0, this.low << e - 32, this.unsigned);
};
Xe.shl = Xe.shiftLeft;
Xe.shiftRight = function(e) {
  return Ks(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Yt(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : Yt(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
Xe.shr = Xe.shiftRight;
Xe.shiftRightUnsigned = function(e) {
  return Ks(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Yt(this.low >>> e | this.high << 32 - e, this.high >>> e, this.unsigned) : e === 32 ? Yt(this.high, 0, this.unsigned) : Yt(this.high >>> e - 32, 0, this.unsigned);
};
Xe.shru = Xe.shiftRightUnsigned;
Xe.shr_u = Xe.shiftRightUnsigned;
Xe.rotateLeft = function(e) {
  var i;
  return Ks(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? Yt(this.high, this.low, this.unsigned) : e < 32 ? (i = 32 - e, Yt(this.low << e | this.high >>> i, this.high << e | this.low >>> i, this.unsigned)) : (e -= 32, i = 32 - e, Yt(this.high << e | this.low >>> i, this.low << e | this.high >>> i, this.unsigned));
};
Xe.rotl = Xe.rotateLeft;
Xe.rotateRight = function(e) {
  var i;
  return Ks(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? Yt(this.high, this.low, this.unsigned) : e < 32 ? (i = 32 - e, Yt(this.high << i | this.low >>> e, this.low << i | this.high >>> e, this.unsigned)) : (e -= 32, i = 32 - e, Yt(this.low << i | this.high >>> e, this.high << i | this.low >>> e, this.unsigned));
};
Xe.rotr = Xe.rotateRight;
Xe.toSigned = function() {
  return this.unsigned ? Yt(this.low, this.high, !1) : this;
};
Xe.toUnsigned = function() {
  return this.unsigned ? this : Yt(this.low, this.high, !0);
};
Xe.toBytes = function(e) {
  return e ? this.toBytesLE() : this.toBytesBE();
};
Xe.toBytesLE = function() {
  var e = this.high, i = this.low;
  return [
    i & 255,
    i >>> 8 & 255,
    i >>> 16 & 255,
    i >>> 24,
    e & 255,
    e >>> 8 & 255,
    e >>> 16 & 255,
    e >>> 24
  ];
};
Xe.toBytesBE = function() {
  var e = this.high, i = this.low;
  return [
    e >>> 24,
    e >>> 16 & 255,
    e >>> 8 & 255,
    e & 255,
    i >>> 24,
    i >>> 16 & 255,
    i >>> 8 & 255,
    i & 255
  ];
};
ui.fromBytes = function(e, i, s) {
  return s ? ui.fromBytesLE(e, i) : ui.fromBytesBE(e, i);
};
ui.fromBytesLE = function(e, i) {
  return new ui(
    e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24,
    e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24,
    i
  );
};
ui.fromBytesBE = function(e, i) {
  return new ui(
    e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7],
    e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3],
    i
  );
};
const M8 = 16;
function XT(t) {
  t === "X" && (t = "");
  const e = t.padEnd(M8, "0");
  return ui.fromString(e, !0, 16);
}
function P8(t) {
  if (t.isZero())
    return "X";
  let e = t.countTrailingZeros();
  const i = e % 4;
  e = (e - i) / 4;
  const s = e;
  e *= 4;
  const l = t.shiftRightUnsigned(e).toString(16).replace(/0+$/, "");
  return Array(17 - s - l.length).join("0") + l;
}
function B8(t, e) {
  const i = D8(t).shiftRightUnsigned(2);
  return t.add(ui.fromNumber(2 * e + 1 - 4).multiply(i));
}
function D8(t) {
  return t.and(t.not().add(1));
}
const O8 = 3, F8 = 30, k8 = 2 * F8 + 1, R1 = 180 / Math.PI;
function N8(t) {
  if (t.length === 0)
    throw new Error(`Invalid Hilbert quad key ${t}`);
  const e = t.split("/"), i = parseInt(e[0], 10), s = e[1], o = s.length;
  let l = 0;
  const u = [0, 0];
  for (let c = o - 1; c >= 0; c--) {
    l = o - c;
    const x = s[c];
    let w = 0, C = 0;
    x === "1" ? C = 1 : x === "2" ? (w = 1, C = 1) : x === "3" && (w = 1);
    const M = Math.pow(2, l - 1);
    U8(M, u, w, C), u[0] += M * w, u[1] += M * C;
  }
  if (i % 2 === 1) {
    const c = u[0];
    u[0] = u[1], u[1] = c;
  }
  return { face: i, ij: u, level: l };
}
function L8(t) {
  if (t.isZero())
    return "";
  let e = t.toString(2);
  for (; e.length < O8 + k8; )
    e = "0" + e;
  const i = e.lastIndexOf("1"), s = e.substring(0, 3), o = e.substring(3, i), l = o.length / 2, u = ui.fromString(s, !0, 2).toString(10);
  let c = "";
  if (l !== 0)
    for (c = ui.fromString(o, !0, 2).toString(4); c.length < l; )
      c = "0" + c;
  return `${u}/${c}`;
}
function WT(t, e, i) {
  const s = 1 << e;
  return [(t[0] + i[0]) / s, (t[1] + i[1]) / s];
}
function M1(t) {
  return t >= 0.5 ? 1 / 3 * (4 * t * t - 1) : 1 / 3 * (1 - 4 * (1 - t) * (1 - t));
}
function qT(t) {
  return [M1(t[0]), M1(t[1])];
}
function ZT(t, [e, i]) {
  switch (t) {
    case 0:
      return [1, e, i];
    case 1:
      return [-e, 1, i];
    case 2:
      return [-e, -i, 1];
    case 3:
      return [-1, -i, -e];
    case 4:
      return [i, -1, -e];
    case 5:
      return [i, e, -1];
    default:
      throw new Error("Invalid face");
  }
}
function KT([t, e, i]) {
  const s = Math.atan2(i, Math.sqrt(t * t + e * e));
  return [Math.atan2(e, t) * R1, s * R1];
}
function U8(t, e, i, s) {
  if (s === 0) {
    i === 1 && (e[0] = t - 1 - e[0], e[1] = t - 1 - e[1]);
    const o = e[0];
    e[0] = e[1], e[1] = o;
  }
}
function z8(t) {
  const e = WT(t.ij, t.level, [0.5, 0.5]), i = qT(e), s = ZT(t.face, i);
  return KT(s);
}
const V8 = 100;
function P1(t) {
  const { face: e, ij: i, level: s } = t, o = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0],
    [0, 0]
  ], l = Math.max(1, Math.ceil(V8 * Math.pow(2, -s))), u = new Float64Array(4 * l * 2 + 2);
  let c = 0, x = 0;
  for (let w = 0; w < 4; w++) {
    const C = o[w].slice(0), M = o[w + 1], P = (M[0] - C[0]) / l, j = (M[1] - C[1]) / l;
    for (let Y = 0; Y < l; Y++) {
      C[0] += P, C[1] += j;
      const Q = WT(i, s, C), _e = qT(Q), me = ZT(e, _e), we = KT(me);
      Math.abs(we[1]) > 89.999 && (we[0] = x);
      const Ee = we[0] - x;
      we[0] += Ee > 180 ? -360 : Ee < -180 ? 360 : 0, u[c++] = we[0], u[c++] = we[1], x = we[0];
    }
  }
  return u[c++] = u[0], u[c++] = u[1], u;
}
function zy(t) {
  const e = H8(t);
  return N8(e);
}
function H8(t) {
  if (t.indexOf("/") > 0)
    return t;
  const e = XT(t);
  return L8(e);
}
function j8(t) {
  const e = zy(t);
  return z8(e);
}
function $8(t) {
  let e;
  if (t.face === 2 || t.face === 5) {
    let i = null, s = 0;
    for (let o = 0; o < 4; o++) {
      const l = `${t.face}/${o}`, u = zy(l), c = P1(u);
      (typeof i > "u" || i === null) && (i = new Float64Array(4 * c.length)), i.set(c, s), s += c.length;
    }
    e = B1(i);
  } else {
    const i = P1(t);
    e = B1(i);
  }
  return e;
}
function B1(t) {
  if (t.length % 2 !== 0)
    throw new Error("Invalid corners");
  const e = [], i = [];
  for (let s = 0; s < t.length; s += 2)
    e.push(t[s]), i.push(t[s + 1]);
  return e.sort((s, o) => s - o), i.sort((s, o) => s - o), {
    west: e[0],
    east: e[e.length - 1],
    north: i[i.length - 1],
    south: i[0]
  };
}
function G8(t, e) {
  const i = (e == null ? void 0 : e.minimumHeight) || 0, s = (e == null ? void 0 : e.maximumHeight) || 0, o = zy(t), l = $8(o), u = l.west, c = l.south, x = l.east, w = l.north, C = [];
  return C.push(new Se(u, w, i)), C.push(new Se(x, w, i)), C.push(new Se(x, c, i)), C.push(new Se(u, c, i)), C.push(new Se(u, w, s)), C.push(new Se(x, w, s)), C.push(new Se(x, c, s)), C.push(new Se(u, c, s)), C;
}
function JT(t) {
  const e = t.token, i = {
    minimumHeight: t.minimumHeight,
    maximumHeight: t.maximumHeight
  }, s = G8(e, i), o = j8(e), l = o[0], u = o[1], c = Ti.WGS84.cartographicToCartesian([
    l,
    u,
    i.maximumHeight
  ]), x = new Se(c[0], c[1], c[2]);
  s.push(x);
  const w = NL(s);
  return [...w.center, ...w.halfAxes];
}
const X8 = 4, W8 = 8, q8 = {
  QUADTREE: X8,
  OCTREE: W8
};
function Z8(t, e, i) {
  if (t != null && t.box) {
    const s = XT(t.s2VolumeInfo.token), o = B8(s, e), l = P8(o), u = { ...t.s2VolumeInfo };
    switch (u.token = l, i) {
      case "OCTREE":
        const w = t.s2VolumeInfo, C = w.maximumHeight - w.minimumHeight, M = C / 2, P = w.minimumHeight + C / 2;
        w.minimumHeight = P - M, w.maximumHeight = P + M;
        break;
    }
    return {
      box: JT(u),
      s2VolumeInfo: u
    };
  }
}
async function YT(t) {
  const { subtree: e, subtreeData: i = {
    level: 0,
    x: 0,
    y: 0,
    z: 0
  }, parentData: s = {
    mortonIndex: 0,
    localLevel: -1,
    localX: 0,
    localY: 0,
    localZ: 0
  }, childIndex: o = 0, implicitOptions: l, loaderOptions: u, s2VolumeBox: c } = t, { subdivisionScheme: x, subtreeLevels: w, maximumLevel: C, contentUrlTemplate: M, subtreesUriTemplate: P, basePath: j } = l, Y = { children: [], lodMetricValue: 0, contentUrl: "" };
  if (!C)
    return X1.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${M} won't be loaded...`), Y;
  const Q = s.localLevel + 1, _e = i.level + Q;
  if (_e > C)
    return Y;
  const me = q8[x], we = Math.log2(me), Ee = o & 1, Oe = o >> 1 & 1, Ne = o >> 2 & 1, ze = qa(s.localX, Ee, 1), nt = qa(s.localY, Oe, 1), mt = qa(s.localZ, Ne, 1), We = qa(i.x, ze, Q), at = qa(i.y, nt, Q), it = qa(i.z, mt, Q), Ut = qa(s.mortonIndex, o, we), Rt = Q === w && zm(e.childSubtreeAvailability, Ut);
  let yt, di, Fs, Hi;
  if (Rt) {
    const ji = `${j}/${P}`, Li = zg(ji, _e, We, at, it);
    yt = await pa(Li, VT, u), Hi = 0, di = { level: _e, x: We, y: at, z: it }, Fs = { mortonIndex: 0, localLevel: 0, localX: 0, localY: 0, localZ: 0 };
  } else
    yt = e, Hi = (me ** Q - 1) / (me - 1) + Ut, di = i, Fs = { mortonIndex: Ut, localLevel: Q, localX: ze, localY: nt, localZ: mt };
  if (!zm(yt.tileAvailability, Hi))
    return Y;
  zm(yt.contentAvailability, Hi) && (Y.contentUrl = zg(M, _e, We, at, it));
  for (let ji = 0; ji < me; ji++) {
    const Li = Z8(c, ji, x), Pi = await YT({
      subtree: yt,
      subtreeData: di,
      parentData: Fs,
      childIndex: ji,
      implicitOptions: l,
      loaderOptions: u,
      s2VolumeBox: Li
    });
    (Pi.contentUrl || Pi.children.length) && Y.children.push(Pi);
  }
  return Y.contentUrl || Y.children.length ? K8(Y, { level: _e, x: We, y: at, z: it }, l, c) : Y;
}
function zm(t, e) {
  let i;
  return Array.isArray(t) ? (i = t[0], t.length > 1 && X1.once('Not supported extension "3DTILES_multiple_contents" has been detected')) : i = t, "constant" in i ? !!i.constant : i.explicitBitstream ? Q8(e, i.explicitBitstream) : !1;
}
function K8(t, e, i, s) {
  const { basePath: o, refine: l, getRefine: u, lodMetricType: c, getTileType: x, rootLodMetricValue: w, rootBoundingVolume: C } = i, M = t.contentUrl && t.contentUrl.replace(`${o}/`, ""), P = w / 2 ** e.level, j = s != null && s.box ? { box: s.box } : C, Y = J8(j, e, i.subdivisionScheme);
  return {
    children: t.children,
    contentUrl: t.contentUrl,
    content: { uri: M },
    id: t.contentUrl,
    refine: u(l),
    type: x(t),
    lodMetricType: c,
    lodMetricValue: P,
    geometricError: P,
    transform: t.transform,
    boundingVolume: Y
  };
}
function J8(t, e, i) {
  if (t.region) {
    const { level: s, x: o, y: l, z: u } = e, [c, x, w, C, M, P] = t.region, j = 2 ** s, Y = (w - c) / j, [Q, _e] = [c + Y * o, c + Y * (o + 1)], me = (C - x) / j, [we, Ee] = [x + me * l, x + me * (l + 1)];
    let Oe, Ne;
    if (i === "OCTREE") {
      const ze = (P - M) / j;
      [Oe, Ne] = [
        M + ze * u,
        M + ze * (u + 1)
      ];
    } else
      [Oe, Ne] = [M, P];
    return {
      region: [Q, we, _e, Ee, Oe, Ne]
    };
  }
  if (t.box)
    return t;
  throw new Error(`Unsupported bounding volume type ${JSON.stringify(t)}`);
}
function qa(t, e, i) {
  return (t << i) + e;
}
function zg(t, e, i, s, o) {
  const l = Y8({ level: e, x: i, y: s, z: o });
  return t.replace(/{level}|{x}|{y}|{z}/gi, (u) => l[u]);
}
function Y8(t) {
  const e = {};
  for (const i in t)
    e[`{${i}}`] = t[i];
  return e;
}
function Q8(t, e) {
  const i = Math.floor(t / 8), s = t % 8;
  return (e[i] >> s & 1) === 1;
}
function Vy(t, e = "") {
  if (!e)
    return vo.EMPTY;
  const s = e.split("?")[0].split(".").pop();
  switch (s) {
    case "pnts":
      return vo.POINTCLOUD;
    case "i3dm":
    case "b3dm":
    case "glb":
    case "gltf":
      return vo.SCENEGRAPH;
    default:
      return s || vo.EMPTY;
  }
}
function Hy(t) {
  switch (t) {
    case "REPLACE":
    case "replace":
      return vn.REPLACE;
    case "ADD":
    case "add":
      return vn.ADD;
    default:
      return t;
  }
}
function Vg(t, e) {
  if (/^[a-z][0-9a-z+.-]*:/i.test(e)) {
    const s = new URL(t, `${e}/`);
    return decodeURI(s.toString());
  } else if (t.startsWith("/"))
    return t;
  return o2(e, t);
}
function D1(t, e) {
  var o;
  if (!t)
    return null;
  let i;
  if (t.content) {
    const l = t.content.uri || ((o = t.content) == null ? void 0 : o.url);
    typeof l < "u" && (i = Vg(l, e));
  }
  return {
    ...t,
    id: i,
    contentUrl: i,
    lodMetricType: zc.GEOMETRIC_ERROR,
    lodMetricValue: t.geometricError,
    transformMatrix: t.transform,
    type: Vy(t, i),
    refine: Hy(t.refine)
  };
}
async function eV(t, e, i) {
  let s = null;
  const o = F1(t.root);
  o && t.root ? s = await O1(t.root, t, e, o, i) : s = D1(t.root, e);
  const l = [];
  for (l.push(s); l.length > 0; ) {
    const u = l.pop() || {}, c = u.children || [], x = [];
    for (const w of c) {
      const C = F1(w);
      let M;
      C ? M = await O1(w, t, e, C, i) : M = D1(w, e), M && (x.push(M), l.push(M));
    }
    u.children = x;
  }
  return s;
}
async function O1(t, e, i, s, o) {
  var Oe, Ne, ze;
  const { subdivisionScheme: l, maximumLevel: u, availableLevels: c, subtreeLevels: x, subtrees: { uri: w } } = s, C = zg(w, 0, 0, 0, 0), M = Vg(C, i), P = await pa(M, VT, o), j = (Oe = t.content) == null ? void 0 : Oe.uri, Y = j ? Vg(j, i) : "", Q = (Ne = e == null ? void 0 : e.root) == null ? void 0 : Ne.refine, _e = t.geometricError, me = (ze = t.boundingVolume.extensions) == null ? void 0 : ze["3DTILES_bounding_volume_S2"];
  if (me) {
    const mt = { box: JT(me), s2VolumeInfo: me };
    t.boundingVolume = mt;
  }
  const we = t.boundingVolume, Ee = {
    contentUrlTemplate: Y,
    subtreesUriTemplate: w,
    subdivisionScheme: l,
    subtreeLevels: x,
    maximumLevel: Number.isFinite(c) ? c - 1 : u,
    refine: Q,
    basePath: i,
    lodMetricType: zc.GEOMETRIC_ERROR,
    rootLodMetricValue: _e,
    rootBoundingVolume: we,
    getTileType: Vy,
    getRefine: Hy
  };
  return await tV(t, i, P, Ee, o);
}
async function tV(t, e, i, s, o) {
  if (!t)
    return null;
  const { children: l, contentUrl: u } = await YT({
    subtree: i,
    implicitOptions: s,
    loaderOptions: o
  });
  let c, x = null;
  return u && (c = u, x = { uri: u.replace(`${e}/`, "") }), {
    ...t,
    id: c,
    contentUrl: c,
    lodMetricType: zc.GEOMETRIC_ERROR,
    lodMetricValue: t.geometricError,
    transformMatrix: t.transform,
    type: Vy(t, c),
    refine: Hy(t.refine),
    content: x || t.content,
    children: l
  };
}
function F1(t) {
  var e;
  return ((e = t == null ? void 0 : t.extensions) == null ? void 0 : e["3DTILES_implicit_tiling"]) || (t == null ? void 0 : t.implicitTiling);
}
const QT = {
  dataType: null,
  batchType: null,
  id: "3d-tiles",
  name: "3D Tiles",
  module: "3d-tiles",
  version: DT,
  extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
  mimeTypes: ["application/octet-stream"],
  tests: ["cmpt", "pnts", "b3dm", "i3dm"],
  parse: iV,
  options: {
    "3d-tiles": {
      loadGLTF: !0,
      decodeQuantizedPositions: !1,
      isTileset: "auto",
      assetGltfUpAxis: null
    }
  }
};
async function iV(t, e = {}, i) {
  const s = e["3d-tiles"] || {};
  let o;
  return s.isTileset === "auto" ? o = (i == null ? void 0 : i.url) && i.url.indexOf(".json") !== -1 : o = s.isTileset, o ? sV(t, e, i) : rV(t, e, i);
}
async function sV(t, e, i) {
  var x;
  const s = JSON.parse(new TextDecoder().decode(t)), o = (i == null ? void 0 : i.url) || "", l = nV(o), u = await eV(s, l, e || {});
  return {
    ...s,
    shape: "tileset3d",
    loader: QT,
    url: o,
    queryString: (i == null ? void 0 : i.queryString) || "",
    basePath: l,
    root: u || s.root,
    type: vr.TILES3D,
    lodMetricType: zc.GEOMETRIC_ERROR,
    lodMetricValue: ((x = s.root) == null ? void 0 : x.geometricError) || 0
  };
}
async function rV(t, e, i) {
  const s = {
    content: {
      shape: "tile3d",
      featureIds: null
    }
  };
  return await zT(t, 0, e, i, s.content), s.content;
}
function nV(t) {
  return Xg(t);
}
const k1 = [0], oV = {
  getPointColor: { type: "accessor", value: [0, 0, 0, 255] },
  pointSize: 1,
  // Disable async data loading (handling it in _loadTileSet)
  data: "",
  loader: QT,
  onTilesetLoad: { type: "function", value: (t) => {
  } },
  onTileLoad: { type: "function", value: (t) => {
  } },
  onTileUnload: { type: "function", value: (t) => {
  } },
  onTileError: { type: "function", value: (t, e, i) => {
  } },
  _getMeshColor: { type: "function", value: (t) => [255, 255, 255] }
};
class jy extends eT {
  initializeState() {
    "onTileLoadFail" in this.props && Jt.removed("onTileLoadFail", "onTileError")(), this.state = {
      layerMap: {},
      tileset3d: null,
      activeViewports: {},
      lastUpdatedViewports: null
    };
  }
  get isLoaded() {
    var e, i;
    return !!((i = (e = this.state) == null ? void 0 : e.tileset3d) != null && i.isLoaded() && super.isLoaded);
  }
  shouldUpdateState({ changeFlags: e }) {
    return e.somethingChanged;
  }
  updateState({ props: e, oldProps: i, changeFlags: s }) {
    if (e.data && e.data !== i.data && this._loadTileset(e.data), s.viewportChanged) {
      const { activeViewports: o } = this.state;
      Object.keys(o).length && (this._updateTileset(o), this.state.lastUpdatedViewports = o, this.state.activeViewports = {});
    }
    if (s.propsChanged) {
      const { layerMap: o } = this.state;
      for (const l in o)
        o[l].needsUpdate = !0;
    }
  }
  activateViewport(e) {
    const { activeViewports: i, lastUpdatedViewports: s } = this.state;
    this.internalState.viewport = e, i[e.id] = e;
    const o = s == null ? void 0 : s[e.id];
    (!o || !e.equals(o)) && (this.setChangeFlags({ viewportChanged: !0 }), this.setNeedsUpdate());
  }
  getPickingInfo({ info: e, sourceLayer: i }) {
    const s = i && i.props.tile;
    return e.picked && (e.object = s), e.sourceTile = s, e;
  }
  filterSubLayer({ layer: e, viewport: i }) {
    const { tile: s } = e.props, { id: o } = i;
    return s.selected && s.viewportIds.includes(o);
  }
  _updateAutoHighlight(e) {
    const i = e.sourceTile, s = this.state.layerMap[i == null ? void 0 : i.id];
    s && s.layer && s.layer.updateAutoHighlight(e);
  }
  async _loadTileset(e) {
    const { loadOptions: i = {} } = this.props, s = this.props.loader || this.props.loaders, o = Array.isArray(s) ? s[0] : s, l = { loadOptions: { ...i } };
    let u = e;
    if (o.preload) {
      const w = await o.preload(e, i);
      w.url && (u = w.url), w.headers && (l.loadOptions.fetch = {
        ...l.loadOptions.fetch,
        headers: w.headers
      }), Object.assign(l, w);
    }
    const c = await pa(u, o, l.loadOptions), x = new z5(c, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: this._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      ...l
    });
    this.setState({
      tileset3d: x,
      layerMap: {}
    }), this._updateTileset(this.state.activeViewports), this.props.onTilesetLoad(x);
  }
  _onTileLoad(e) {
    const { lastUpdatedViewports: i } = this.state;
    this.props.onTileLoad(e), this._updateTileset(i), this.setNeedsUpdate();
  }
  _onTileUnload(e) {
    delete this.state.layerMap[e.id], this.props.onTileUnload(e);
  }
  _updateTileset(e) {
    if (!e)
      return;
    const { tileset3d: i } = this.state, { timeline: s } = this.context, o = Object.keys(e).length;
    !s || !o || !i || i.selectTiles(Object.values(e)).then((l) => {
      this.state.frameNumber !== l && this.setState({ frameNumber: l });
    });
  }
  _getSubLayer(e, i) {
    if (!e.content)
      return null;
    switch (e.type) {
      case vo.POINTCLOUD:
        return this._makePointCloudLayer(e, i);
      case vo.SCENEGRAPH:
        return this._make3DModelLayer(e);
      case vo.MESH:
        return this._makeSimpleMeshLayer(e, i);
      default:
        throw new Error(`Tile3DLayer: Failed to render layer of type ${e.content.type}`);
    }
  }
  _makePointCloudLayer(e, i) {
    const { attributes: s, pointCount: o, constantRGBA: l, cartographicOrigin: u, modelMatrix: c } = e.content, { positions: x, normals: w, colors: C } = s;
    if (!x)
      return null;
    const M = i && i.props.data || {
      header: {
        vertexCount: o
      },
      attributes: {
        POSITION: x,
        NORMAL: w,
        COLOR_0: C
      }
    }, { pointSize: P, getPointColor: j } = this.props, Y = this.getSubLayerClass("pointcloud", Sy);
    return new Y({
      pointSize: P
    }, this.getSubLayerProps({
      id: "pointcloud"
    }), {
      id: `${this.id}-pointcloud-${e.id}`,
      tile: e,
      data: M,
      coordinateSystem: Wt.METER_OFFSETS,
      coordinateOrigin: u,
      modelMatrix: c,
      getColor: l || j,
      _offset: 0
    });
  }
  _make3DModelLayer(e) {
    const { gltf: i, instances: s, cartographicOrigin: o, modelMatrix: l } = e.content, u = this.getSubLayerClass("scenegraph", Oy);
    return new u({
      _lighting: "pbr"
    }, this.getSubLayerProps({
      id: "scenegraph"
    }), {
      id: `${this.id}-scenegraph-${e.id}`,
      tile: e,
      data: s || k1,
      scenegraph: i,
      coordinateSystem: Wt.METER_OFFSETS,
      coordinateOrigin: o,
      modelMatrix: l,
      getTransformMatrix: (c) => c.modelMatrix,
      getPosition: [0, 0, 0],
      _offset: 0
    });
  }
  _makeSimpleMeshLayer(e, i) {
    const s = e.content, { attributes: o, indices: l, modelMatrix: u, cartographicOrigin: c, coordinateSystem: x = Wt.METER_OFFSETS, material: w, featureIds: C } = s, { _getMeshColor: M } = this.props, P = i && i.props.mesh || new Ic({
      topology: "triangle-list",
      attributes: aV(o),
      indices: l
    }), j = this.getSubLayerClass("mesh", Fy);
    return new j(this.getSubLayerProps({
      id: "mesh"
    }), {
      id: `${this.id}-mesh-${e.id}`,
      tile: e,
      mesh: P,
      data: k1,
      getColor: M(e),
      pbrMaterial: w,
      modelMatrix: u,
      coordinateOrigin: c,
      coordinateSystem: x,
      featureIds: C,
      _offset: 0
    });
  }
  renderLayers() {
    const { tileset3d: e, layerMap: i } = this.state;
    return e ? e.tiles.map((s) => {
      const o = i[s.id] = i[s.id] || { tile: s };
      let { layer: l } = o;
      return s.selected && (l ? o.needsUpdate && (l = this._getSubLayer(s, l), o.needsUpdate = !1) : l = this._getSubLayer(s)), o.layer = l, l;
    }).filter(Boolean) : null;
  }
}
jy.defaultProps = oV;
jy.layerName = "Tile3DLayer";
function aV(t) {
  const e = {};
  return e.positions = {
    ...t.positions,
    value: new Float32Array(t.positions.value)
  }, t.normals && (e.normals = t.normals), t.texCoords && (e.texCoords = t.texCoords), t.colors && (e.colors = t.colors), t.uvRegions && (e.uvRegions = t.uvRegions), e;
}
const Vm = 512, lV = Math.PI / 180;
function eE({ map: t, gl: e, deck: i }) {
  if (t.__deck)
    return t.__deck;
  const s = i == null ? void 0 : i.props._customRender, o = i == null ? void 0 : i.props.onLoad, l = iE({
    ...i == null ? void 0 : i.props,
    _customRender: () => {
      t.triggerRepaint(), s == null || s("");
    }
  });
  let u;
  return (!i || i.props.gl === e) && (Object.assign(l, {
    gl: e,
    width: null,
    height: null,
    touchAction: "unset",
    viewState: Pu(t)
  }), i != null && i.isInitialized ? N1(i, t) : l.onLoad = () => {
    o == null || o(), N1(u, t);
  }), i ? (u = i, i.setProps(l), i.userData.isExternal = !0) : (u = new Iu(l), t.on("remove", () => {
    tE(t);
  })), u.userData.mapboxLayers = /* @__PURE__ */ new Set(), t.__deck = u, t.on("render", () => {
    u.isInitialized && pV(u, t);
  }), u;
}
function N1(t, e) {
  const i = () => {
    t.isInitialized ? _V(t, e) : e.off("move", i);
  };
  e.on("move", i);
}
function tE(t) {
  var e;
  (e = t.__deck) == null || e.finalize(), t.__deck = null;
}
function iE(t) {
  return {
    ...t,
    // TODO: remove with withParametersWebGL
    parameters: {
      depthMask: !0,
      depthTest: !0,
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthFunc: 515,
      blendEquation: 32774,
      ...t.parameters
    },
    // @ts-ignore views prop is hidden by the types because it is not expected to work the same way as in standalone Deck, see documentation
    views: t.views || [new by({ id: "mapbox" })]
  };
}
function cV(t, e) {
  t.userData.mapboxLayers.add(e), $y(t);
}
function hV(t, e) {
  t.userData.mapboxLayers.delete(e), $y(t);
}
function uV(t, e) {
  $y(t);
}
function dV(t, e, i) {
  let { currentViewport: s } = t.userData, o = !1;
  s || (s = sE(t, e, !0), t.userData.currentViewport = s, o = !0), t.isInitialized && t._drawLayers("mapbox-repaint", {
    viewports: [s],
    layerFilter: ({ layer: l }) => i.id === l.id || l.props.operation.includes("terrain"),
    clearStack: o,
    clearCanvas: !1
  });
}
function Pu(t) {
  var o;
  const { lng: e, lat: i } = t.getCenter(), s = {
    // Longitude returned by getCenter can be outside of [-180, 180] when zooming near the anti meridian
    // https://github.com/visgl/deck.gl/issues/6894
    longitude: (e + 540) % 360 - 180,
    latitude: i,
    zoom: t.getZoom(),
    bearing: t.getBearing(),
    pitch: t.getPitch(),
    padding: t.getPadding(),
    repeat: t.getRenderWorldCopies()
  };
  return (o = t.getTerrain) != null && o.call(t) && fV(t, s), s;
}
function fV(t, e) {
  if (t.getFreeCameraOptions) {
    const { position: i } = t.getFreeCameraOptions();
    if (!i || i.z === void 0)
      return;
    const s = t.transform.height, { longitude: o, latitude: l, pitch: u } = e, c = i.x * Vm, x = (1 - i.y) * Vm, w = i.z * Vm, C = Tu([o, l]), M = c - C[0], P = x - C[1], j = Math.sqrt(M * M + P * P), Y = u * lV, Q = 1.5 * s, _e = Y < 1e-3 ? (
      // Pitch angle too small to deduce the look at point, assume elevation is 0
      Q * Math.cos(Y) / w
    ) : Q * Math.sin(Y) / j;
    e.zoom = Math.log2(_e);
    const me = Q * Math.cos(Y) / _e, we = w - me;
    e.position = [0, 0, we / wf(l)];
  } else typeof t.transform.elevation == "number" && (e.position = [0, 0, t.transform.elevation]);
}
function sE(t, e, i = !0) {
  return new ol({
    id: "mapbox",
    x: 0,
    y: 0,
    width: t.width,
    height: t.height,
    ...Pu(e),
    nearZMultiplier: i ? (
      // match mapbox-gl@>=1.3.0's projection matrix
      0.02
    ) : (
      // use deck.gl's own default
      0.1
    ),
    nearZ: e.transform._nearZ / e.transform.height,
    farZ: e.transform._farZ / e.transform.height
  });
}
function pV(t, e) {
  const { mapboxLayers: i, isExternal: s } = t.userData;
  if (s) {
    const o = Array.from(i, (C) => C.id), u = Nc(t.props.layers, Boolean).some((C) => C && !o.includes(C.id));
    let c = t.getViewports();
    const x = c.findIndex((C) => C.id === "mapbox"), w = c.length > 1 || x < 0;
    (u || w) && (x >= 0 && (c = c.slice(), c[x] = sE(t, e, !1)), t._drawLayers("mapbox-repaint", {
      viewports: c,
      layerFilter: (C) => (!t.props.layerFilter || t.props.layerFilter(C)) && (C.viewport.id !== "mapbox" || !o.includes(C.layer.id)),
      clearCanvas: !1
    }));
  }
  t.userData.currentViewport = null;
}
function _V(t, e) {
  t.setProps({
    viewState: Pu(e)
  }), t.needsRedraw({ clearRedrawFlags: !0 });
}
function $y(t) {
  if (t.userData.isExternal)
    return;
  const e = [];
  t.userData.mapboxLayers.forEach((i) => {
    const s = i.props.type, o = new s(i.props);
    e.push(o);
  }), t.setProps({ layers: e });
}
class mV {
  /* eslint-disable no-this-before-super */
  constructor(e) {
    if (!e.id)
      throw new Error("Layer must have an unique id");
    this.id = e.id, this.type = "custom", this.renderingMode = e.renderingMode || "3d", this.map = null, this.deck = null, this.props = e;
  }
  /* Mapbox custom layer methods */
  onAdd(e, i) {
    this.map = e, this.deck = eE({ map: e, gl: i, deck: this.props.deck }), cV(this.deck, this);
  }
  onRemove() {
    this.deck && hV(this.deck, this);
  }
  setProps(e) {
    Object.assign(this.props, e, { id: this.id }), this.deck && uV(this.deck);
  }
  render() {
    dV(this.deck, this.map, this);
  }
}
const Hm = "__UNDEFINED__";
function yf(t, e, i, s) {
  if (!t || !e || !t.style || !t.style._loaded)
    return;
  const o = Nc(s, Boolean);
  if (i !== s) {
    const c = Nc(i, Boolean), x = new Set(c.map((w) => w.id));
    for (const w of o)
      x.delete(w.id);
    for (const w of x)
      t.getLayer(w) && t.removeLayer(w);
  }
  for (const c of o) {
    const x = t.getLayer(c.id);
    x ? (x.implementation || x).setProps(c.props) : t.addLayer(
      new mV({ id: c.id, deck: e }),
      // @ts-expect-error beforeId is not defined in LayerProps
      c.props.beforeId
    );
  }
  const l = t.style._order, u = {};
  for (const c of o) {
    let { beforeId: x } = c.props;
    (!x || !l.includes(x)) && (x = Hm), u[x] = u[x] || [], u[x].push(c.id);
  }
  for (const c in u) {
    const x = u[c];
    let w = c === Hm ? l.length : l.indexOf(c), C = c === Hm ? void 0 : c;
    for (let M = x.length - 1; M >= 0; M--) {
      const P = x[M], j = l.indexOf(P);
      j !== w - 1 && (t.moveLayer(P, C), j > w && w++), w--, C = P;
    }
  }
}
class gV {
  constructor(e) {
    this._handleStyleChange = () => {
      yf(this._map, this._deck, this._props.layers, this._props.layers);
    }, this._updateContainerSize = () => {
      if (this._map && this._container) {
        const { clientWidth: o, clientHeight: l } = this._map.getContainer();
        Object.assign(this._container.style, {
          width: `${o}px`,
          height: `${l}px`
        });
      }
    }, this._updateViewState = () => {
      const o = this._deck;
      o && (o.setProps({ viewState: Pu(this._map) }), o.isInitialized && o.redraw());
    }, this._handleMouseEvent = (o) => {
      const l = this._deck;
      if (!l || !l.isInitialized)
        return;
      const u = {
        type: o.type,
        offsetCenter: o.point,
        srcEvent: o
      }, c = this._lastMouseDownPoint;
      switch (!o.point && c && (u.deltaX = o.originalEvent.clientX - c.clientX, u.deltaY = o.originalEvent.clientY - c.clientY, u.offsetCenter = {
        x: c.x + u.deltaX,
        y: c.y + u.deltaY
      }), u.type) {
        case "mousedown":
          l._onPointerDown(u), this._lastMouseDownPoint = {
            ...o.point,
            clientX: o.originalEvent.clientX,
            clientY: o.originalEvent.clientY
          };
          break;
        case "dragstart":
          u.type = "panstart", l._onEvent(u);
          break;
        case "drag":
          u.type = "panmove", l._onEvent(u);
          break;
        case "dragend":
          u.type = "panend", l._onEvent(u);
          break;
        case "click":
          u.tapCount = 1, l._onEvent(u);
          break;
        case "dblclick":
          u.type = "click", u.tapCount = 2, l._onEvent(u);
          break;
        case "mousemove":
          u.type = "pointermove", l._onPointerMove(u);
          break;
        case "mouseout":
          u.type = "pointerleave", l._onPointerMove(u);
          break;
        default:
          return;
      }
    };
    const { interleaved: i = !1, ...s } = e;
    this._interleaved = i, this._props = s;
  }
  /** Update (partial) props of the underlying Deck instance. */
  setProps(e) {
    this._interleaved && e.layers && yf(this._map, this._deck, this._props.layers, e.layers), Object.assign(this._props, e), this._deck && this._deck.setProps(this._interleaved ? iE(this._props) : this._props);
  }
  /** Called when the control is added to a map */
  onAdd(e) {
    return this._map = e, this._interleaved ? this._onAddInterleaved(e) : this._onAddOverlaid(e);
  }
  _onAddOverlaid(e) {
    const i = document.createElement("div");
    return Object.assign(i.style, {
      position: "absolute",
      left: 0,
      top: 0,
      textAlign: "initial",
      pointerEvents: "none"
    }), this._container = i, this._deck = new Iu({
      ...this._props,
      parent: i,
      viewState: Pu(e)
    }), e.on("resize", this._updateContainerSize), e.on("render", this._updateViewState), e.on("mousedown", this._handleMouseEvent), e.on("dragstart", this._handleMouseEvent), e.on("drag", this._handleMouseEvent), e.on("dragend", this._handleMouseEvent), e.on("mousemove", this._handleMouseEvent), e.on("mouseout", this._handleMouseEvent), e.on("click", this._handleMouseEvent), e.on("dblclick", this._handleMouseEvent), this._updateContainerSize(), i;
  }
  _onAddInterleaved(e) {
    const i = e.painter.context.gl;
    return i instanceof WebGLRenderingContext && Jt.warn("Incompatible basemap library. See: https://deck.gl/docs/api-reference/mapbox/overview#compatibility")(), this._deck = eE({
      map: e,
      gl: i,
      deck: new Iu({
        ...this._props,
        gl: i
      })
    }), e.on("styledata", this._handleStyleChange), yf(e, this._deck, [], this._props.layers), document.createElement("div");
  }
  /** Called when the control is removed from a map */
  onRemove() {
    const e = this._map;
    e && (this._interleaved ? this._onRemoveInterleaved(e) : this._onRemoveOverlaid(e)), this._deck = void 0, this._map = void 0, this._container = void 0;
  }
  _onRemoveOverlaid(e) {
    var i;
    e.off("resize", this._updateContainerSize), e.off("render", this._updateViewState), e.off("mousedown", this._handleMouseEvent), e.off("dragstart", this._handleMouseEvent), e.off("drag", this._handleMouseEvent), e.off("dragend", this._handleMouseEvent), e.off("mousemove", this._handleMouseEvent), e.off("mouseout", this._handleMouseEvent), e.off("click", this._handleMouseEvent), e.off("dblclick", this._handleMouseEvent), (i = this._deck) == null || i.finalize();
  }
  _onRemoveInterleaved(e) {
    e.off("styledata", this._handleStyleChange), yf(e, this._deck, this._props.layers, []), tE(e);
  }
  getDefaultPosition() {
    return "top-left";
  }
  /** Forwards the Deck.pickObject method */
  pickObject(e) {
    return hs(this._deck), this._deck.pickObject(e);
  }
  /** Forwards the Deck.pickMultipleObjects method */
  pickMultipleObjects(e) {
    return hs(this._deck), this._deck.pickMultipleObjects(e);
  }
  /** Forwards the Deck.pickObjects method */
  pickObjects(e) {
    return hs(this._deck), this._deck.pickObjects(e);
  }
  /** Remove from map and releases all resources */
  finalize() {
    this._map && this._map.removeControl(this);
  }
  /** If interleaved: true, returns base map's canvas, otherwise forwards the Deck.getCanvas method. */
  getCanvas() {
    return this._map ? this._interleaved ? this._map.getCanvas() : this._deck.getCanvas() : null;
  }
}
class yV {
  constructor({ apiKey: e, mode: i = "2d", threedTileset: s = sC }) {
    O(this, "mapInstance");
    O(this, "olaMaps");
    O(this, "apiKey");
    O(this, "mode");
    O(this, "threedTileset");
    this.apiKey = e, this.mode = i, this.threedTileset = s;
  }
  addOlaLogo(e) {
    var o;
    if (typeof window > "u") return;
    const i = document.getElementsByClassName("maplibregl-ctrl-bottom-left");
    let s = "#000";
    (o = e.style) != null && o.includes("dark") && (s = "#FFF");
    for (let l = 0; l < i.length; l++) {
      const u = document.createElement("div");
      u.style.position = "absolute", u.style.bottom = "4px", u.style.left = "10px", u.style.zIndex = "1000", u.innerHTML = rC(s), i[l].appendChild(u);
    }
  }
  addAttribution() {
    const e = document.querySelectorAll(".maplibregl-ctrl-bottom-right .maplibregl-ctrl-attrib-inner");
    e == null || e.forEach((i) => {
      const s = i.querySelector("a");
      s && (s.style.display = "none");
      const o = "ola-maps-link";
      if (!i.querySelector(`#${o}`)) {
        const u = document.createElement("a");
        u.id = o, u.href = "https://maps.olakrutrim.com/", u.target = "_blank", u.textContent = "Ola Maps ", i.appendChild(u);
      }
      const l = "osm-link";
      if (!i.querySelector(`#${l}`)) {
        const u = document.createElement("a");
        u.id = l, u.href = "https://www.openstreetmap.org/copyright", u.target = "_blank", u.textContent = "|  OpenStreetMap contributors", i.appendChild(u);
      }
    });
  }
  fetchStaticMap(e) {
    try {
      return fetch(e).then((i) => i.blob());
    } catch (i) {
      console.log(i);
    }
  }
  async add3dLayer() {
    if (!this.threedTileset)
      throw new Error("3d Tileset is not initialized");
    const e = new jy({
      id: "tile-3d-layer",
      data: `${this.threedTileset}?api_key=${this.apiKey}`,
      beforeId: "poi_railway"
    }), i = new gV({
      interleaved: !0,
      layers: [e]
    });
    i && this.olaMaps.on("style.load", () => {
      this.olaMaps.setFilter("building-3d", [
        "all",
        [
          "!has",
          "hide_3d"
        ],
        [
          "!=",
          "render_as_3d",
          !0
        ]
      ]), this.olaMaps.addControl(i);
    });
  }
  init(e) {
    return this.mapInstance = tC.getInstance(), this.olaMaps = new this.mapInstance.Map({
      container: (e == null ? void 0 : e.container) || "map",
      center: (e == null ? void 0 : e.center) || [0, 0],
      zoom: (e == null ? void 0 : e.zoom) || 9,
      hash: (e == null ? void 0 : e.hash) || !1,
      style: (e == null ? void 0 : e.style) || iC,
      transformRequest: (i, s) => {
        const o = new URL(i);
        return s !== "Image" && o.searchParams.append("api_key", this.apiKey), {
          url: o.toString()
        };
      },
      ...e
    }), this.mode === "3d" && this.add3dLayer(), this.addOlaLogo(e), this.addAttribution(), this.olaMaps;
  }
  addNavigationControls(e) {
    return new this.mapInstance.NavigationControl(e);
  }
  addGeolocateControls(e) {
    return new this.mapInstance.GeolocateControl(e);
  }
  getMercatorCoordinate() {
    return Hg.MercatorCoordinate;
  }
  addMarker(e) {
    return new this.mapInstance.Marker(e);
  }
  addPopup(e) {
    return new this.mapInstance.Popup(e);
  }
  getStaticMap(e, i) {
    const s = this.fetchStaticMap(e);
    s == null || s.then((o) => {
      const l = URL.createObjectURL(o), u = document.createElement("img");
      u.src = l;
      const c = document.getElementById(i);
      c && !c.querySelector("img") ? c == null || c.appendChild(u) : console.log("An image already exists in the element.");
    }).catch((o) => console.error(o));
  }
}
typeof window < "u" && (window.OlaMaps = yV);
export {
  yV as OlaMaps
};
